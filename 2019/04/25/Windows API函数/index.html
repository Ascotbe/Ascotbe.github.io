<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>Windows API函数 | Asc0t6e</title><meta name="description" content="Windows API函数"><meta name="author" content="Asc0t6e"><meta name="copyright" content="Asc0t6e"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Windows API函数"><meta name="twitter:description" content="Windows API函数"><meta name="twitter:image" content="https://gitee.com/asc0t6e/Random-img/raw/master/BlogCover/4.jpg"><meta property="og:type" content="article"><meta property="og:title" content="Windows API函数"><meta property="og:url" content="https://www.ascotbe.com/2019/04/25/Windows%20API%E5%87%BD%E6%95%B0/"><meta property="og:site_name" content="Asc0t6e"><meta property="og:description" content="Windows API函数"><meta property="og:image" content="https://gitee.com/asc0t6e/Random-img/raw/master/BlogCover/4.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = '2'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://www.ascotbe.com/2019/04/25/Windows%20API%E5%87%BD%E6%95%B0/"><link rel="prev" title="使用爬虫爆破海康监控" href="https://www.ascotbe.com/2019/05/21/%E4%BD%BF%E7%94%A8%E7%88%AC%E8%99%AB%E7%88%86%E7%A0%B4%E6%B5%B7%E5%BA%B7%E7%9B%91%E6%8E%A7/"><link rel="next" title="C++this" href="https://www.ascotbe.com/2019/04/05/C++this/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://www.ascotbe.com/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.1"></head><body><canvas class="fireworks"></canvas><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Asc0t6e</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/Loophole"><i class="fa-fw fa fa-link"></i><span> Loophole</span></a></div><div class="menus_item"><a class="site-page" href="/Taylor_Swift"><i class="fa-fw fa fa-link"></i><span> Taylor_Swift</span></a></div><div class="menus_item"><a class="site-page" href="/Links/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">98</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/Loophole"><i class="fa-fw fa fa-link"></i><span> Loophole</span></a></div><div class="menus_item"><a class="site-page" href="/Taylor_Swift"><i class="fa-fw fa fa-link"></i><span> Taylor_Swift</span></a></div><div class="menus_item"><a class="site-page" href="/Links/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">1. API之网络函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">2. API之消息函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">3. API之文件处理函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">4. API之打印函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">5. API之文本和字体函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">6. API之菜单函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text">7. API之位图、图标和光栅运算函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#"><span class="toc_mobile_items-number">8.</span> <span class="toc_mobile_items-text">8. API之绘图函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#"><span class="toc_mobile_items-number">9.</span> <span class="toc_mobile_items-text">再补一点消息详解</span></a></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#"><span class="toc-number">1.</span> <span class="toc-text">1. API之网络函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#"><span class="toc-number">2.</span> <span class="toc-text">2. API之消息函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#"><span class="toc-number">3.</span> <span class="toc-text">3. API之文件处理函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#"><span class="toc-number">4.</span> <span class="toc-text">4. API之打印函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#"><span class="toc-number">5.</span> <span class="toc-text">5. API之文本和字体函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#"><span class="toc-number">6.</span> <span class="toc-text">6. API之菜单函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#"><span class="toc-number">7.</span> <span class="toc-text">7. API之位图、图标和光栅运算函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#"><span class="toc-number">8.</span> <span class="toc-text">8. API之绘图函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#"><span class="toc-number">9.</span> <span class="toc-text">再补一点消息详解</span></a></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://gitee.com/asc0t6e/Random-img/raw/master/Blog/4.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">Windows API函数</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2019-04-25<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2020-03-09</time><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1>1. API之网络函数</h1>
<p>WNetAddConnection 创建同一个网络资源的永久性连接<br>
WNetAddConnection2 创建同一个网络资源的连接<br>
WNetAddConnection3 创建同一个网络资源的连接<br>
WNetCancelConnection 结束一个网络连接<br>
WNetCancelConnection2 结束一个网络连接<br>
WNetCloseEnum 结束一次枚举操作<br>
WNetConnectionDialog 启动一个标准对话框，以便建立同网络资源的连接<br>
WNetDisconnectDialog 启动一个标准对话框，以便断开同网络资源的连接<br>
WNetEnumResource 枚举网络资源<br>
WNetGetConnection 获取本地或已连接的一个资源的网络名称<br>
WNetGetLastError 获取网络错误的扩展错误信息<br>
WNetGetUniversalName 获取网络中一个文件的远程名称以及/或者UNC（统一命名规范）名称<br>
WNetGetUser 获取一个网络资源用以连接的名字<br>
WNetOpenEnum 启动对网络资源进行枚举的过程</p>
<h1>2. API之消息函数</h1>
<p>BroadcastSystemMessage 将一条系统消息广播给系统中所有的顶级窗口<br>
GetMessagePos 取得消息队列中上一条消息处理完毕时的鼠标指针屏幕位置<br>
GetMessageTime 取得消息队列中上一条消息处理完毕时的时间<br>
PostMessage 将一条消息投递到指定窗口的消息队列<br>
PostThreadMessage 将一条消息投递给应用程序<br>
RegisterWindowMessage 获取分配给一个字串标识符的消息编号<br>
ReplyMessage 答复一个消息<br>
SendMessage 调用一个窗口的窗口函数，将一条消息发给那个窗口<br>
SendMessageCallback 将一条消息发给窗口<br>
SendMessageTimeout 向窗口发送一条消息<br>
SendNotifyMessage 向窗口发送一条消息</p>
<h1>3. API之文件处理函数</h1>
<p>CloseHandle 关闭一个内核对象。其中包括文件、文件映射、进程、线程、安全和同步对象等<br>
CompareFileTime 对比两个文件的时间<br>
CopyFile 复制文件<br>
CreateDirectory 创建一个新目录<br>
CreateFile 打开和创建文件、管道、邮槽、通信服务、设备以及控制台<br>
CreateFileMapping 创建一个新的文件映射对象<br>
DeleteFile 删除指定文件<br>
DeviceIoControl 对设备执行指定的操作<br>
DosDateTimeToFileTime 将DOS日期和时间值转换成一个 win32 FILETIME 值<br>
FileTimeToDosDateTime 将一个 win32 FILETIME 值转换成DOS日期和时间值<br>
FileTimeToLocalFileTime 将一个FILETIME结构转换成本地时间<br>
FileTimeToSystemTime 根据一个FILETIME结构的内容，装载一个SYSTEMTIME结构<br>
FindClose 关闭由FindFirstFile函数创建的一个搜索句柄<br>
FindFirstFile 根据文件名查找文件<br>
FindNextFile 根据调用FindFirstFile函数时指定的一个文件名查找下一个文件<br>
FlushFileBuffers 针对指定的文件句柄，刷新内部文件缓冲区<br>
FlushViewOfFile 将写入文件映射缓冲区的所有数据都刷新到磁盘<br>
GetBinaryType 判断文件是否可以执行<br>
GetCompressedFileSize 判断一个压缩文件在磁盘上实际占据的字节数<br>
GetCurrentDirectory 在一个缓冲区中装载当前目录<br>
GetDiskFreeSpace 获取与一个磁盘的组织有关的信息，以及了解剩余空间的容量<br>
GetDiskFreeSpaceEx 获取与一个磁盘的组织以及剩余空间容量有关的信息<br>
GetDriveType 判断一个磁盘驱动器的类型<br>
GetExpandedName 取得一个压缩文件的全名<br>
GetFileAttributes 判断指定文件的属性<br>
GetFileInformationByHandle 这个函数提供了获取文件信息的一种机制<br>
GetFileSize 判断文件长度<br>
GetFileTime 取得指定文件的时间信息<br>
GetFileType 在给出文件句柄的前提下，判断文件类型<br>
GetFileVersionInfo 从支持版本标记的一个模块里获取文件版本信息<br>
GetFileVersionInfoSize 针对包含了版本资源的一个文件，判断容纳文件版本信息需要一个多大的缓冲区<br>
GetFullPathName 获取指定文件的完整路径名<br>
GetLogicalDrives 判断系统中存在哪些逻辑驱动器字母<br>
GetLogicalDriveStrings 获取一个字串，其中包含了当前所有逻辑驱动器的根驱动器路径<br>
GetOverlappedResult 判断一个重叠操作当前的状态<br>
GetPrivateProfileInt 为初始化文件（.ini文件）中指定的条目获取一个整数值<br>
GetPrivateProfileSection 获取指定小节（在.ini文件中）所有项名和值的一个列表<br>
GetPrivateProfileString 为初始化文件中指定的条目取得字串<br>
GetProfileInt 取得win.ini初始化文件中指定条目的一个整数值<br>
GetProfileSection 获取指定小节（在win.ini文件中）所有项名和值的一个列表<br>
GetProfileString 为win.ini初始化文件中指定的条目取得字串<br>
GetShortPathName 获取指定文件的短路径名<br>
GetSystemDirectory 取得Windows系统目录（即System目录）的完整路径名<br>
GetTempFileName 这个函数包含了一个临时文件的名字，它可由应用程序使用<br>
GetTempPath 获取为临时文件指定的路径<br>
GetVolumeInformation 获取与一个磁盘卷有关的信息<br>
GetWindowsDirectory 获取Windows目录的完整路径名<br>
hread 参考lread<br>
hwrite 参考lwrite函数<br>
lclose 关闭指定的文件<br>
lcreat 创建一个文件<br>
llseek 设置文件中进行读写的当前位置<br>
LockFile 锁定文件的某一部分，使其不与其他应用程序共享<br>
LockFileEx 与LockFile相似，只是它提供了更多的功能<br>
lopen 以二进制模式打开指定的文件<br>
lread 将文件中的数据读入内存缓冲区<br>
lwrite 将数据从内存缓冲区写入一个文件<br>
LZClose 关闭由LZOpenFile 或 LZInit函数打开的一个文件<br>
LZCopy 复制一个文件<br>
LZInit 这个函数用于初始化内部缓冲区<br>
LZOpenFile 该函数能执行大量不同的文件处理，而且兼容于压缩文件<br>
LZRead 将数据从文件读入内存缓冲区<br>
LZSeek 设置一个文件中进行读写的当前位置<br>
MapViewOfFile 将一个文件映射对象映射到当前应用程序的地址空间<br>
MoveFile 移动文件<br>
OpenFile 这个函数能执行大量不同的文件操作<br>
OpenFileMapping 打开一个现成的文件映射对象<br>
QueryDosDevice 在Windows NT中，DOS设备名会映射成NT系统设备名。该函数可判断当前的设备映射情况<br>
ReadFile 从文件中读出数据<br>
ReadFileEx 与ReadFile相似，只是它只能用于异步读操作，并包含了一个完整的回调<br>
RegCloseKey 关闭系统注册表中的一个项（或键）<br>
RegConnectRegistry 访问远程系统的部分注册表<br>
RegCreateKey 在指定的项下创建或打开一个项<br>
RegCreateKeyEx 在指定项下创建新项的更复杂的方式。在Win32环境中建议使用这个函数<br>
RegDeleteKey 删除现有项下方一个指定的子项<br>
RegDeletevalue 删除指定项下方的一个值<br>
RegEnumKey 枚举指定项的子项。在Win32环境中应使用RegEnumKeyEx<br>
RegEnumKeyEx 枚举指定项下方的子项<br>
RegEnumvalue 枚举指定项的值<br>
RegFlushKey 将对项和它的子项作出的改动实际写入磁盘<br>
RegGetKeySecurity 获取与一个注册表项有关的安全信息<br>
RegLoadKey 从以前用RegSaveKey函数创建的一个文件里装载注册表信息<br>
RegNotifyChangeKeyvalue 注册表项或它的任何一个子项发生变化时，用这个函数提供一种通知机制<br>
RegOpenKey 打开一个现有的注册表项<br>
RegOpenKeyEx 打开一个现有的项。在win32下推荐使用这个函数<br>
RegQueryInfoKey 获取与一个项有关的信息<br>
RegQueryvalue 取得指定项或子项的默认（未命名）值<br>
RegQueryvalueEx 获取一个项的设置值<br>
RegReplaceKey 用一个磁盘文件保存的信息替换注册表信息；并创建一个备份，在其中包含当前注册表信息<br>
RegRestoreKey 从一个磁盘文件恢复注册表信息<br>
RegSaveKey 将一个项以及它的所有子项都保存到一个磁盘文件<br>
RegSetKeySecurity 设置指定项的安全特性<br>
RegSetvalue 设置指定项或子项的默认值<br>
RegSetvalueEx 设置指定项的值<br>
RegUnLoadKey 卸载指定的项以及它的所有子项<br>
RemoveDirectory 删除指定目录<br>
SearchPath 查找指定文件<br>
SetCurrentDirectory 设置当前目录<br>
SetEndOfFile 针对一个打开的文件，将当前文件位置设为文件末尾<br>
SetFileAttributes 设置文件属性<br>
SetFilePointer 在一个文件中设置当前的读写位置<br>
SetFileTime 设置文件的创建、访问及上次修改时间<br>
SetHandleCount 这个函数不必在win32下使用；即使使用，也不会有任何效果<br>
SetVolumeLabel 设置一个磁盘的卷标（Label）<br>
SystemTimeToFileTime 根据一个FILETIME结构的内容，载入一个SYSTEMTIME结构<br>
UnlockFile 解除对一个文件的锁定<br>
UnlockFileEx 解除对一个文件的锁定<br>
UnmapViewOfFile 在当前应用程序的内存地址空间解除对一个文件映射对象的映射<br>
VerFindFile 用这个函数决定一个文件应安装到哪里<br>
VerInstallFile 用这个函数安装一个文件<br>
VerLanguageName 这个函数能根据16位语言代码获取一种语言的名称<br>
VerQueryvalue 这个函数用于从版本资源中获取信息<br>
WriteFile 将数据写入一个文件<br>
WriteFileEx 与WriteFile类似，只是它只能用于异步写操作，并包括了一个完整的回调<br>
WritePrivateProfileSection 为一个初始化文件（.ini）中指定的小节设置所有项名和值<br>
WritePrivateProfileString 在初始化文件指定小节内设置一个字串<br>
WriteProfileSection 为Win.ini初始化文件中一个指定的小节设置所有项名和值<br>
WriteProfileString 在Win.ini初始化文件指定小节内设置一个字串</p>
<h1>4. API之打印函数</h1>
AbortDoc 取消一份文档的打印<br>
AbortPrinter 删除与一台打印机关联在一起的缓冲文件<br>
AddForm 为打印机的表单列表添加一个新表单<br>
AddJob 用于获取一个有效的路径名，以便用它为作业创建一个后台打印文件。它也会为作业分配一个作业编号<br>
AddMonitor 为系统添加一个打印机监视器<br>
AddPort 启动“添加端口”对话框，允许用户在系统可用端口列表中加入一个新端口<br>
AddPrinter 在系统中添加一台新打印机<br>
AddPrinterConnection 连接指定的打印机<br>
AddPrinterDriver 为指定的系统添加一个打印驱动程序<br>
AddPrintProcessor 为指定的系统添加一个打印处理器<br>
AddPrintProvidor 为系统添加一个打印供应商<br>
AdvancedDocumentProperties 启动打印机文档设置对话框<br>
ClosePrinter 关闭一个打开的打印机对象<br>
ConfigurePort 针对指定的端口，启动一个端口配置对话框<br>
ConnectToPrinterDlg 启动连接打印机对话框，用它同访问网络的打印机连接<br>
DeleteForm 从打印机可用表单列表中删除一个表单<br>
DeleteMonitor 删除指定的打印监视器<br>
DeletePort 启动“删除端口”对话框，允许用户从当前系统删除一个端口<br>
DeletePrinter 将指定的打印机标志为从系统中删除<br>
DeletePrinterConnection 删除与指定打印机的连接<br>
DeletePrinterDriver 从系统删除一个打印机驱动程序<br>
DeletePrintProcessor 从指定系统删除一个打印处理器<br>
DeletePrintProvidor 从系统中删除一个打印供应商<br>
DeviceCapabilities 利用这个函数可获得与一个设备的能力有关的信息<br>
DocumentProperties 打印机配置控制函数<br>
EndDocAPI 结束一个成功的打印作业<br>
EndDocPrinter 在后台打印程序的级别指定一个文档的结束<br>
EndPage 用这个函数完成一个页面的打印，并准备设备场景，以便打印下一个页<br>
EndPagePrinter 指定一个页在打印作业中的结尾<br>
EnumForms 枚举一台打印机可用的表单<br>
EnumJobs 枚举打印队列中的作业<br>
EnumMonitors 枚举可用的打印监视器<br>
EnumPorts 枚举一个系统可用的端口<br>
EnumPrinterDrivers 枚举指定系统中已安装的打印机驱动程序<br>
EnumPrinters 枚举系统中安装的打印机<br>
EnumPrintProcessorDatatypes 枚举由一个打印处理器支持的数据类型<br>
EnumPrintProcessors 枚举系统中可用的打印处理器<br>
Escape 设备控制函数<br>
FindClosePrinterChangeNotification 关闭用FindFirstPrinterChangeNotification函数获取的一个打印机通告对象<br>
FindFirstPrinterChangeNotification 创建一个新的改变通告对象，以便我们注意打印机状态的各种变化<br>
FindNextPrinterChangeNotification 用这个函数判断触发一次打印机改变通告信号的原因<br>
FreePrinterNotifyInfo 释放由FindNextPrinterChangeNotification函数分配的一个缓冲区<br>
GetForm 取得与指定表单有关的信息<br>
GetJob 获取与指定作业有关的信息<br>
GetPrinter 取得与指定打印机有关的信息<br>
GetPrinterData 为打印机设置注册表配置信息<br>
GetPrinterDriver 针对指定的打印机，获取与打印机驱动程序有关的信息<br>
GetPrinterDriverDirectory 判断指定系统中包含了打印机驱动程序的目录是什么<br>
GetPrintProcessorDirectory 判断指定系统中包含了打印机处理器驱动程序及文件的目录<br>
OpenPrinter 打开指定的打印机，并获取打印机的句柄<br>
PrinterMessageBox 在拥有指定打印作业的系统上显示一个打印机出错消息框<br>
PrinterProperties 启动打印机属性对话框，以便对打印机进行配置<br>
ReadPrinter 从打印机读入数据<br>
ResetDC 重设一个设备场景<br>
ResetPrinter 改变指定打印机的默认数据类型及文档设置<br>
ScheduleJob 提交一个要打印的作业<br>
SetAbortProc 为Windows指定取消函数的地址<br>
SetForm 为指定的表单设置信息<br>
SetJob 对一个打印作业的状态进行控制<br>
SetPrinter 对一台打印机的状态进行控制<br>
SetPrinterData 设置打印机的注册表配置信息<br>
StartDoc 开始一个打印作业<br>
StartDocPrinter 在后台打印的级别启动一个新文档<br>
StartPage 打印一个新页前要先调用这个函数<br>
StartPagePrinter 在打印作业中指定一个新页的开始<br>
WritePrinter 将发送目录中的数据写入打印机<p></p>
<h1>5. API之文本和字体函数</h1>
<p>AddFontResource 在Windows系统中添加一种字体资源<br>
CreateFont 用指定的属性创建一种逻辑字体<br>
CreateFontIndirect 用指定的属性创建一种逻辑字体<br>
CreateScalableFontResource 为一种TureType字体创建一个资源文件，以便能用API函数AddFontResource将其加入Windows系统<br>
DrawText 将文本描绘到指定的矩形中<br>
DrawTextEx 与DrawText相似，只是加入了更多的功能<br>
EnumFontFamilies 列举指定设备可用的字体<br>
EnumFontFamiliesEx 列举指定设备可用的字体<br>
EnumFonts 列举指定设备可用的字体<br>
ExtTextOut 经过扩展的文本描绘函数。也请参考SetTextAlign函数<br>
GetAspectRatioFilterEx 用SetMapperFlags要求Windows只选择与设备当前纵横比相符的光栅字体时，本函数可判断纵横比大小<br>
GetCharABCWidths 判断TureType字体中一个或多个字符的A-B-C大小<br>
GetCharABCWidthsFloat 查询一种字体中一个或多个字符的A-B-C尺寸<br>
GetCharacterPlacement 该函数用于了解如何用一个给定的字符显示一个字串<br>
GetCharWidth 调查字体中一个或多个字符的宽度<br>
GetFontData 接收一种可缩放字体文件的数据<br>
GetFontLanguageInfo 返回目前选入指定设备场景中的字体的信息<br>
GetGlyphOutline 取得TureType字体中构成一个字符的曲线信息<br>
GetKerningPairs 取得指定字体的字距信息<br>
GetOutlineTextMetrics 接收与TureType字体内部特征有关的详细信息<br>
GetRasterizerCaps 了解系统是否有能力支持可缩放的字体<br>
GetTabbedTextExtent 判断一个字串占据的范围，同时考虑制表站扩充的因素<br>
GetTextAlign 接收一个设备场景当前的文本对齐标志<br>
GetTextCharacterExtra 判断额外字符间距的当前值<br>
GetTextCharset 接收当前选入指定设备场景的字体的字符集标识符<br>
GetTextCharsetInfo 获取与当前选定字体的字符集有关的详细信息<br>
GetTextColor 判断当前字体颜色。通常也称为“前景色”<br>
GetTextExtentExPoint 判断要填入指定区域的字符数量。也用一个数组装载每个字符的范围信息<br>
GetTextExtentPoint 判断一个字串的大小（范围）<br>
GetTextFace 获取一种字体的字样名<br>
GetTextMetrics 获取与选入一种设备场景的物理字体有关的信息<br>
GrayString 描绘一个以灰色显示的字串。通常由Windows用于标识禁止状态<br>
PolyTextOut 描绘一系列字串<br>
RemoveFontResource 从Windows系统中删除一种字体资源<br>
SetMapperFlags Windows对字体进行映射时，可用该函数选择与目标设备的纵横比相符的光栅字体<br>
SetTextAlign 设置文本对齐方式，并指定在文本输出过程中使用设备场景的当前位置<br>
SetTextCharacterExtra 描绘文本的时候，指定要在字符间插入的额外间距<br>
SetTextColor 设置当前文本颜色。这种颜色也称为“前景色”<br>
SetTextJustification 通过指定一个文本行应占据的额外空间，可用这个函数对文本进行两端对齐处理<br>
TabbedTextOut 支持制表站的一个文本描绘函数<br>
TextOut 文本绘图函数</p>
<h1>6. API之菜单函数</h1>
<p>AppendMenu 在指定的菜单里添加一个菜单项<br>
CheckMenuItem 复选或撤消复选指定的菜单条目<br>
CheckMenuRadioItem 指定一个菜单条目被复选成“单选”项目<br>
CreateMenu 创建新菜单<br>
CreatePopupMenu 创建一个空的弹出式菜单<br>
DeleteMenu 删除指定的菜单条目<br>
DestroyMenu 删除指定的菜单<br>
DrawMenuBar 为指定的窗口重画菜单<br>
EnableMenuItem 允许或禁止指定的菜单条目<br>
GetMenu 取得窗口中一个菜单的句柄<br>
GetMenuCheckMarkDimensions 返回一个菜单复选符的大小<br>
GetMenuContextHelpId 取得一个菜单的帮助场景ID<br>
GetMenuDefaultItem 判断菜单中的哪个条目是默认条目<br>
GetMenuItemCount 返回菜单中条目（菜单项）的数量<br>
GetMenuItemID 返回位于菜单中指定位置处的条目的菜单ID<br>
GetMenuItemInfo 取得（接收）与一个菜单条目有关的特定信息<br>
GetMenuItemRect 在一个矩形中装载指定菜单条目的屏幕坐标信息<br>
GetMenuState 取得与指定菜单条目状态有关的信息<br>
GetMenuString 取得指定菜单条目的字串<br>
GetSubMenu 取得一个弹出式菜单的句柄，它位于菜单中指定的位置<br>
GetSystemMenu 取得指定窗口的系统菜单的句柄<br>
HiliteMenuItem 控制顶级菜单条目的加亮显示状态<br>
InsertMenu 在菜单的指定位置处插入一个菜单条目，并根据需要将其他条目向下移动<br>
InsertMenuItem 插入一个新菜单条目<br>
IsMenu 判断指定的句柄是否为一个菜单的句柄<br>
LoadMenu 从指定的模块或应用程序实例中载入一个菜单<br>
LoadMenuIndirect 载入一个菜单<br>
MenuItemFromPoint 判断哪个菜单条目包含了屏幕上一个指定的点<br>
ModifyMenu 改变菜单条目<br>
RemoveMenu 删除指定的菜单条目<br>
SetMenu 设置窗口菜单<br>
SetMenuContextHelpId 设置一个菜单的帮助场景ID<br>
SetMenuDefaultItem 将一个菜单条目设为默认条目<br>
SetMenuItemBitmaps 设置一幅特定位图，令其在指定的菜单条目中使用，代替标准的复选符号（√）<br>
SetMenuItemInfo 为一个菜单条目设置指定的信息<br>
TrackPopupMenu 在屏幕的任意地方显示一个弹出式菜单<br>
TrackPopupMenuEx 与TrackPopupMenu相似，只是它提供了额外的功能</p>
<h1>7. API之位图、图标和光栅运算函数</h1>
BitBlt 将一幅位图从一个设备场景复制到另一个<br>
CopyIcon 制作指定图标或鼠标指针的一个副本。这个副本从属于发出调用的应用程序<br>
CopyImage 复制位图、图标或指针，同时在复制过程中进行一些转换工作<br>
CreateBitmap 按照规定的格式创建一幅与设备有关位图<br>
CreateBitmapIndirect 创建一幅与设备有关位图<br>
CreateCompatibleBitmap 创建一幅与设备有关位图，它与指定的设备场景兼容<br>
CreateCursor 创建一个鼠标指针<br>
CreateDIBitmap 根据一幅与设备无关的位图创建一幅与设备有关的位图<br>
CreateDIBSection 创建一个DIBSection<br>
CreateIcon 创建一个图标<br>
CreateIconIndirect 创建一个图标<br>
DestroyCursor 清除指定的鼠标指针，并释放它占用的所有系统资源<br>
DestroyIcon 清除图标<br>
DrawIcon 在指定的位置画一个图标<br>
DrawIconEx 描绘一个图标或鼠标指针。与DrawIcon相比，这个函数提供了更多的功能<br>
ExtractAssociatedIcon 判断一个可执行程序或DLL中是否存在图标，或是否有图标与系统注册表中指定的文件存在关联并提取之<br>
ExtractIcon 判断一个可执行文件或DLL中是否有图标存在，并将其提取出来<br>
GetBitmapBits 将来自位图的二进制位复制到一个缓冲区<br>
GetBitmapDimensionEx 取得一幅位图的宽度和高度<br>
GetDIBColorTable 从选入设备场景的DIBSection中取得颜色表信息<br>
GetDIBits 将来自一幅位图的二进制位复制到一幅与设备无关的位图里<br>
GetIconInfo 取得与图标有关的信息<br>
GetStretchBltMode 判断StretchBlt 和 StretchDIBits函数采用的伸缩模式<br>
LoadBitmap 从指定的模块或应用程序实例中载入一幅位图<br>
LoadCursor 从指定的模块或应用程序实例中载入一个鼠标指针<br>
LoadCursorFromFile 在一个指针文件或一个动画指针文件的基础上创建一个指针<br>
LoadIcon 从指定的模块或应用程序实例中载入一个图标<br>
LoadImage 载入一个位图、图标或指针<br>
MaskBlt 执行复杂的图象传输，同时进行掩模（MASK）处理<br>
PatBlt 在当前选定的刷子的基础上，用一个图案填充指定的设备场景<br>
PlgBlt 复制一幅位图，同时将其转换成一个平行四边形。利用它可对位图进行旋转处理<br>
SetBitmapBits 将来自缓冲区的二进制位复制到一幅位图<br>
SetBitmapDimensionEx 设置一幅位图的宽度。以一毫米的十分之一为单位<br>
SetDIBColorTable 设置选入设备场景的一个DIBSection的颜色表信息<br>
SetDIBits 将来自与设备无关位图的二进制位复制到一幅与设备有关的位图里<br>
SetDIBitsToDevice 将一幅与设备无关位图的全部或部分数据直接复制到一个设备<br>
SetStretchBltMode 指定StretchBlt 和 StretchDIBits函数的伸缩模式<br>
StretchBlt 将一幅位图从一个设备场景复制到另一个<br>
StretchDIBits 将一幅与设备无关位图的全部或部分数据直接复制到指定的设备场景<p></p>
<h1>8. API之绘图函数</h1>
<p>AbortPath 抛弃选入指定设备场景中的所有路径。也取消目前正在进行的任何路径的创建工作<br>
AngleArc 用一个连接弧画一条线<br>
Arc 画一个圆弧<br>
BeginPath 启动一个路径分支<br>
CancelDC 取消另一个线程里的长时间绘图操作<br>
Chord 画一个弦<br>
CloseEnhMetaFile 关闭指定的增强型图元文件设备场景，并将新建的图元文件返回一个句柄<br>
CloseFigure 描绘到一个路径时，关闭当前打开的图形<br>
CloseMetaFile 关闭指定的图元文件设备场景，并向新建的图元文件返回一个句柄<br>
CopyEnhMetaFile 制作指定增强型图元文件的一个副本（拷贝）<br>
CopyMetaFile 制作指定（标准）图元文件的一个副本<br>
CreateBrushIndirect 在一个LOGBRUSH数据结构的基础上创建一个刷子<br>
CreateDIBPatternBrush 用一幅与设备无关的位图创建一个刷子，以便指定刷子样式（图案）<br>
CreateEnhMetaFile 创建一个增强型的图元文件设备场景<br>
CreateHatchBrush 创建带有阴影图案的一个刷子<br>
CreateMetaFile 创建一个图元文件设备场景<br>
CreatePatternBrush 用指定了刷子图案的一幅位图创建一个刷子<br>
CreatePen 用指定的样式、宽度和颜色创建一个画笔<br>
CreatePenIndirect 根据指定的LOGPEN结构创建一个画笔<br>
CreateSolidBrush 用纯色创建一个刷子<br>
DeleteEnhMetaFile 删除指定的增强型图元文件<br>
DeleteMetaFile 删除指定的图元文件<br>
DeleteObject 删除GDI对象，对象使用的所有系统资源都会被释放<br>
DrawEdge 用指定的样式描绘一个矩形的边框<br>
DrawEscape 换码（Escape）函数将数据直接发至显示设备驱动程序<br>
DrawFocusRect 画一个焦点矩形<br>
DrawFrameControl 描绘一个标准控件<br>
DrawState 为一幅图象或绘图操作应用各式各样的效果<br>
Ellipse 描绘一个椭圆，由指定的矩形围绕<br>
EndPath 停止定义一个路径<br>
EnumEnhMetaFile 针对一个增强型图元文件，列举其中单独的图元文件记录<br>
EnumMetaFile 为一个标准的windows图元文件枚举单独的图元文件记录<br>
EnumObjects 枚举可随同指定设备场景使用的画笔和刷子<br>
ExtCreatePen 创建一个扩展画笔（装饰或几何）<br>
ExtFloodFill 在指定的设备场景里，用当前选择的刷子填充一个区域<br>
FillPath 关闭路径中任何打开的图形，并用当前刷子填充<br>
FillRect 用指定的刷子填充一个矩形<br>
FlattenPath 将一个路径中的所有曲线都转换成线段<br>
FloodFill 用当前选定的刷子在指定的设备场景中填充一个区域<br>
FrameRect 用指定的刷子围绕一个矩形画一个边框<br>
GdiComment 为指定的增强型图元文件设备场景添加一条注释信息<br>
GdiFlush 执行任何未决的绘图操作<br>
GdiGetBatchLimit 判断有多少个GDI绘图命令位于队列中<br>
GdiSetBatchLimit 指定有多少个GDI绘图命令能够进入队列<br>
GetArcDirection 画圆弧的时候，判断当前采用的绘图方向<br>
GetBkColor 取得指定设备场景当前的背景颜色<br>
GetBkMode 针对指定的设备场景，取得当前的背景填充模式<br>
GetBrushOrgEx 判断指定设备场景中当前选定刷子起点<br>
GetCurrentObject 获得指定类型的当前选定对象<br>
GetCurrentPositionEx 在指定的设备场景中取得当前的画笔位置<br>
GetEnhMetaFile 取得磁盘文件中包含的一个增强型图元文件的图元文件句柄<br>
GetEnhMetaFileBits 将指定的增强型图元文件复制到一个内存缓冲区里<br>
GetEnhMetaFileDescription 返回对一个增强型图元文件的说明<br>
GetEnhMetaFileHeader 取得增强型图元文件的图元文件头<br>
GetEnhMetaFilePaletteEntries 取得增强型图元文件的全部或部分调色板<br>
GetMetaFile 取得包含在一个磁盘文件中的图元文件的图元文件句柄<br>
GetMetaFileBitsEx 将指定的图元文件复制到一个内存缓冲区<br>
GetMiterLimit 取得设备场景的斜率限制（Miter）设置<br>
GetNearestColor 根据设备的显示能力，取得与指定颜色最接近的一种纯色<br>
GetObjectAPI 取得对指定对象进行说明的一个结构<br>
GetObjectType 判断由指定句柄引用的GDI对象的类型<br>
GetPath 取得对当前路径进行定义的一系列数据<br>
GetPixel 在指定的设备场景中取得一个像素的RGB值<br>
GetPolyFillMode 针对指定的设备场景，获得多边形填充模式<br>
GetROP2 针对指定的设备场景，取得当前的绘图模式<br>
GetStockObject 取得一个固有对象（Stock）<br>
GetSysColorBrush 为任何一种标准系统颜色取得一个刷子<br>
GetWinMetaFileBits 通过在一个缓冲区中填充用于标准图元文件的数据，将一个增强型图元文件转换成标准windows图元文件<br>
InvertRect 通过反转每个像素的值，从而反转一个设备场景中指定的矩形<br>
LineDDA 枚举指定线段中的所有点<br>
LineTo 用当前画笔画一条线，从当前位置连到一个指定的点<br>
MoveToEx 为指定的设备场景指定一个新的当前画笔位置<br>
PaintDesk 在指定的设备场景中描绘桌面墙纸图案<br>
PathToRegion 将当前选定的路径转换到一个区域里<br>
Pie 画一个饼图<br>
PlayEnhMetaFile 在指定的设备场景中画一个增强型图元文件<br>
PlayEnhMetaFileRecord 回放单独一条增强型图元文件记录<br>
PlayMetaFile 在指定的设备场景中回放一个图元文件<br>
PlayMetaFileRecord 回放来自图元文件的单条记录<br>
PolyBezier 描绘一条或多条贝塞尔（Bezier）曲线<br>
PolyDraw 描绘一条复杂的曲线，由线段及贝塞尔曲线组成<br>
Polygon 描绘一个多边形<br>
Polyline 用当前画笔描绘一系列线段<br>
PolyPolygon 用当前选定画笔描绘两个或多个多边形<br>
PolyPolyline 用当前选定画笔描绘两个或多个多边形<br>
Rectangle 用当前选定的画笔描绘矩形，并用当前选定的刷子填充<br>
RoundRect 用当前选定的画笔画一个圆角矩形，并用当前选定的刷子在其中填充<br>
SelectClipPath 将设备场景当前的路径合并到剪切区域里<br>
SelectObject 为当前设备场景选择图形对象<br>
SetArcDirection 设置圆弧的描绘方向<br>
SetBkColor 为指定的设备场景设置背景颜色<br>
SetBkMode 指定阴影刷子、虚线画笔以及字符中的空隙的填充方式<br>
SetBrushOrgEx 为指定的设备场景设置当前选定刷子的起点<br>
SetEnhMetaFileBits 用指定内存缓冲区内包含的数据创建一个增强型图元文件<br>
SetMetaFileBitsEx 用包含在指定内存缓冲区内的数据结构创建一个图元文件<br>
SetMiterLimit 设置设备场景当前的斜率限制<br>
SetPixel 在指定的设备场景中设置一个像素的RGB值<br>
SetPixelV 在指定的设备场景中设置一个像素的RGB值<br>
SetPolyFillMode 设置多边形的填充模式<br>
SetROP2 设置指定设备场景的绘图模式。与vb的DrawMode属性完全一致<br>
SetWinMetaFileBits 将一个标准Windows图元文件转换成增强型图元文件<br>
StrokeAndFillPath 针对指定的设备场景，关闭路径上打开的所有区域<br>
StrokePath 用当前画笔描绘一个路径的轮廓。打开的图形不会被这个函数关闭<br>
UnrealizeObject 将一个刷子对象选入设备场景之前，如刷子的起点准备用SetBrushOrgEx修改，则必须先调用本函数<br>
WidenPath 根据选定画笔的宽度，重新定义当前选定的路径</p>
<p>9. API之设备场景函数</p>
<p>CombineRgn 将两个区域组合为一个新区域<br>
CombineTransform 驱动世界转换。它相当于依顺序进行两次转换<br>
CreateCompatibleDC 创建一个与特定设备场景一致的内存设备场景<br>
CreateDC 为专门设备创建设备场景<br>
CreateEllipticRgn 创建一个椭圆<br>
CreateEllipticRgnIndirect 创建一个内切于特定矩形的椭圆区域<br>
CreateIC 为专用设备创建一个信息场景<br>
CreatePolygonRgn 创建一个由一系列点围成的区域<br>
CreatePolyPolygonRgn 创建由多个多边形构成的区域。每个多边形都应是封闭的<br>
CreateRectRgn 创建一个矩形区域<br>
CreateRectRgnIndirect 创建一个矩形区域<br>
CreateRoundRectRgn 创建一个圆角矩形<br>
DeleteDC 删除专用设备场景或信息场景，释放所有相关窗口资源<br>
DPtoLP 将点阵从设备坐标转换到专用设备场景逻辑坐标<br>
EqualRgn 确定两个区域是否相等<br>
ExcludeClipRect 从专用设备场景的剪裁区中去掉一个矩形区。矩形内不能进行绘图<br>
ExcludeUpdateRgn 从专用设备场景剪裁区去掉指定窗口的刷新区域<br>
ExtCreateRegion 根据世界转换修改区域<br>
ExtSelectClipRgn 将指定区域组合到设备场景的当前剪裁区<br>
FillRgn 用指定刷子填充指定区域<br>
FrameRgn 用指定刷子围绕指定区域画一个外框<br>
GetBoundsRect 获取指定设备场景的边界矩形<br>
GetClipBox 获取完全包含指定设备场景剪裁区的最小矩形<br>
GetClipRgn 获取设备场景当前剪裁区<br>
GetDC 获取指定窗口的设备场景<br>
GetDCEx 为指定窗口获取设备场景。相比GetDC，本函数提供了更多的选项<br>
GetDCOrgEx 获取指定设备场景起点位置（以屏幕坐标表示）<br>
GetDeviceCaps 根据指定设备场景代表的设备的功能返回信息<br>
GetGraphicsMode 确定是否允许增强图形模式（世界转换）<br>
GetMapMode 为特定设备场景调入映象模式<br>
GetRegionData 装入描述一个区域信息的RgnData结构或缓冲区<br>
GetRgnBox 获取完全包含指定区域的最小矩形<br>
GetUpdateRgn 确定指定窗口的刷新区域。该区域当前无效，需要刷新<br>
GetViewportExtEx 获取设备场景视口（viewport）范围<br>
GetViewportOrgEx 获取设备场景视口起点<br>
GetWindowDC 获取整个窗口（包括边框、滚动条、标题栏、菜单等）的设备场景<br>
GetWindowExtEx 获取指定设备场景的窗口范围<br>
GetWindowOrgEx 获取指定设备场景的逻辑窗口的起点<br>
GetWindowRgn 获取窗口区域<br>
GetWorldTransform 如果有世界转换，为设备场景获取当前世界转换<br>
IntersectClipRect 为指定设备定义一个新的剪裁区<br>
InvalidateRgn 使窗口指定区域不活动，并将它加入窗口刷新区，使之可随后被重画<br>
InvertRgn 通过颠倒每个像素值反转设备场景指定区域<br>
LPtoDP 将点阵从指定设备场景逻辑坐标转换为设备坐标<br>
ModifyWorldTransform 根据指定的模式修改世界转换<br>
OffsetClipRgn 按指定量平移设备场景剪裁区<br>
OffsetRgn 按指定偏移量平移指定区域<br>
OffsetViewportOrgEx 平移设备场景视口区域<br>
OffsetWindowOrgEx 平移指定设备场景窗口起点<br>
PaintRgn 用当前刷子背景色填充指定区域<br>
PtInRegion 确定点是否在指定区域内<br>
PtVisible 确定指定点是否可见（即，点是否在设备场景剪裁区内）<br>
RectInRegion 确定矩形是否有部分在指定区域内<br>
RectVisible 确定指定矩形是否有部分可见（是否在设备场景剪裁区内）<br>
ReleaseDC 释放由调用GetDC或GetWindowDC函数获取的指定设备场景<br>
RestoreDC 从设备场景堆栈恢复一个原先保存的设备场景<br>
SaveDC 将指定设备场景状态保存到Windows设备场景堆栈<br>
ScaleViewportExtEx 缩放设备场景视口的范围<br>
ScaleWindowExtEx 缩放指定设备场景窗口范围<br>
ScrollDC 在窗口（由设备场景代表）中水平和（或）垂直滚动矩形<br>
SelectClipRgn 为指定设备场景选择新的剪裁区<br>
SetBoundsRect 设置指定设备场景的边界矩形<br>
SetGraphicsMode 允许或禁止增强图形模式，以提供某些支持（包括世界转换）<br>
SetMapMode 设置指定设备场景的映射模式<br>
SetRectRgn 设置区域为指定的矩形<br>
SetViewportExtEx 设置设备场景视口范围<br>
SetViewportOrgEx 设置设备场景视口起点<br>
SetWindowExtEx 设置指定设备场景窗口范围<br>
SetWindowOrgEx 设置指定设备场景窗口起点<br>
SetWindowRgn 设置窗口区域<br>
SetWorldTransform 设置世界转换<br>
ValidateRgn 激活窗口中指定区域，把它从刷新区移走<br>
WindowFromDC 取回与某一设备场景相关的窗口的句柄</p>
<p>10. API之硬件与系统函数<br>
ActivateKeyboardLayout 激活一个新的键盘布局。键盘布局定义了按键在一种物理性键盘上的位置与含义<br>
Beep 用于生成简单的声音<br>
CharToOem 将一个字串从ANSI字符集转换到OEM字符集<br>
ClipCursor 将指针限制到指定区域<br>
ConvertDefaultLocale 将一个特殊的地方标识符转换成真实的地方ID<br>
CreateCaret 根据指定的信息创建一个插入符（光标），并将它选定为指定窗口的默认插入符<br>
DestroyCaret 清除（破坏）一个插入符<br>
EnumCalendarInfo 枚举在指定“地方”环境中可用的日历信息<br>
EnumDateFormats 列举指定的“当地”设置中可用的长、短日期格式<br>
EnumSystemCodePages 枚举系统中已安装或支持的代码页<br>
EnumSystemLocales 枚举系统已经安装或提供支持的“地方”设置<br>
EnumTimeFormats 枚举一个指定的地方适用的时间格式<br>
ExitWindowsEx 退出windows，并用特定的选项重新启动<br>
ExpandEnvironmentStrings 扩充环境字串<br>
FreeEnvironmentStrings 翻译指定的环境字串块<br>
GetACP 判断目前正在生效的ANSI代码页<br>
GetAsyncKeyState 判断函数调用时指定虚拟键的状态<br>
GetCaretBlinkTime 判断插入符光标的闪烁频率<br>
GetCaretPos 判断插入符的当前位置<br>
GetClipCursor 取得一个矩形，用于描述目前为鼠标指针规定的剪切区域<br>
GetCommandLine 获得指向当前命令行缓冲区的一个指针<br>
GetComputerName 取得这台计算机的名称<br>
GetCPInfo 取得与指定代码页有关的信息<br>
GetCurrencyFormat 针对指定的“地方”设置，根据货币格式格式化一个数字<br>
GetCursor 获取目前选择的鼠标指针的句柄<br>
GetCursorPos 获取鼠标指针的当前位置<br>
GetDateFormat 针对指定的“当地”格式，对一个系统日期进行格式化<br>
GetDoubleClickTime 判断连续两次鼠标单击之间会被处理成双击事件的间隔时间<br>
GetEnvironmentStrings 为包含了当前环境字串设置的一个内存块分配和返回一个句柄<br>
GetEnvironmentVariable 取得一个环境变量的值<br>
GetInputState 判断是否存在任何待决（等待处理）的鼠标或键盘事件<br>
GetKBCodePage 由GetOEMCP取代，两者功能完全相同<br>
GetKeyboardLayout 取得一个句柄，描述指定应用程序的键盘布局<br>
GetKeyboardLayoutList 获得系统适用的所有键盘布局的一个列表<br>
GetKeyboardLayoutName 取得当前活动键盘布局的名称<br>
GetKeyboardState 取得键盘上每个虚拟键当前的状态<br>
GetKeyboardType 了解与正在使用的键盘有关的信息<br>
GetKeyNameText 在给出扫描码的前提下，判断键名<br>
GetKeyState 针对已处理过的按键，在最近一次输入信息时，判断指定虚拟键的状态<br>
GetLastError 针对之前调用的api函数，用这个函数取得扩展错误信息<br>
GetLocaleInfo 取得与指定“地方”有关的信息<br>
GetLocalTime 取得本地日期和时间<br>
GetNumberFormat 针对指定的“地方”，按特定的格式格式化一个数字<br>
GetOEMCP 判断在OEM和ANSI字符集间转换的windows代码页<br>
GetQueueStatus 判断应用程序消息队列中待决（等待处理）的消息类型<br>
GetSysColor 判断指定windows显示对象的颜色<br>
GetSystemDefaultLangID 取得系统的默认语言ID<br>
GetSystemDefaultLCID 取得当前的默认系统“地方”<br>
GetSystemInfo 取得与底层硬件平台有关的信息<br>
GetSystemMetrics 返回与windows环境有关的信息<br>
GetSystemPowerStatus 获得与当前系统电源状态有关的信息<br>
GetSystemTime 取得当前系统时间，这个时间采用的是“协同世界时间”（即UTC，也叫做GMT）格式<br>
GetSystemTimeAdjustment 使内部系统时钟与一个外部的时钟信号源同步<br>
GetThreadLocale 取得当前线程的地方ID<br>
GetTickCount 用于获取自windows启动以来经历的时间长度（毫秒）<br>
GetTimeFormat 针对当前指定的“地方”，按特定的格式格式化一个系统时间<br>
GetTimeZoneInformation 取得与系统时区设置有关的信息<br>
GetUserDefaultLangID 为当前用户取得默认语言ID<br>
GetUserDefaultLCID 取得当前用户的默认“地方”设置<br>
GetUserName 取得当前用户的名字<br>
GetVersion 判断当前运行的Windows和DOS版本<br>
GetVersionEx 取得与平台和操作系统有关的版本信息<br>
HideCaret 在指定的窗口隐藏插入符（光标）<br>
IsValidCodePage 判断一个代码页是否有效<br>
IsValidLocale 判断地方标识符是否有效<br>
keybd_event 这个函数模拟了键盘行动<br>
LoadKeyboardLayout 载入一个键盘布局<br>
MapVirtualKey 根据指定的映射类型，执行不同的扫描码和字符转换<br>
MapVirtualKeyEx 根据指定的映射类型，执行不同的扫描码和字符转换<br>
MessageBeep 播放一个系统声音。系统声音的分配方案是在控制面板里决定的<br>
mouse_event 模拟一次鼠标事件<br>
OemKeyScan 判断OEM字符集中的一个ASCII字符的扫描码和Shift键状态<br>
OemToChar 将OEM字符集的一个字串转换到ANSI字符集<br>
SetCaretBlinkTime 指定插入符（光标）的闪烁频率<br>
SetCaretPos 指定插入符的位置<br>
SetComputerName 设置新的计算机名<br>
SetCursor 将指定的鼠标指针设为当前指针<br>
SetCursorPos 设置指针的位置<br>
SetDoubleClickTime 设置连续两次鼠标单击之间能使系统认为是双击事件的间隔时间<br>
SetEnvironmentVariable 将一个环境变量设为指定的值<br>
SetKeyboardState 设置每个虚拟键当前在键盘上的状态<br>
SetLocaleInfo 改变用户“地方”设置信息<br>
SetLocalTime 设置当前地方时间<br>
SetSysColors 设置指定窗口显示对象的颜色<br>
SetSystemCursor 改变任何一个标准系统指针<br>
SetSystemTime 设置当前系统时间<br>
SetSystemTimeAdjustment 定时添加一个校准值使内部系统时钟与一个外部的时钟信号源同步<br>
SetThreadLocale 为当前线程设置地方<br>
SetTimeZoneInformation 设置系统时区信息<br>
ShowCaret 在指定的窗口里显示插入符（光标）<br>
ShowCursor 控制鼠标指针的可视性<br>
SwapMouseButton 决定是否互换鼠标左右键的功能<br>
SystemParametersInfo 获取和设置数量众多的windows系统参数<br>
SystemTimeToTzSpecificLocalTime 将系统时间转换成地方时间<br>
ToAscii 根据当前的扫描码和键盘信息，将一个虚拟键转换成ASCII字符<br>
ToUnicode 根据当前的扫描码和键盘信息，将一个虚拟键转换成Unicode字符<br>
UnloadKeyboardLayout 卸载指定的键盘布局<br>
VkKeyScan 针对Windows字符集中一个ASCII字符，判断虚拟键码和Shift键的状态</p>
<p>11. API之进程和线程函数</p>
<p>CancelWaitableTimer 这个函数用于取消一个可以等待下去的计时器操作<br>
CallNamedPipe 这个函数由一个希望通过管道通信的一个客户进程调用<br>
ConnectNamedPipe 指示一台服务器等待下去，直至客户机同一个命名管道连接<br>
CreateEvent 创建一个事件对象<br>
CreateMailslot 创建一个邮路。返回的句柄由邮路服务器使用（收件人）<br>
CreateMutex 创建一个互斥体（MUTEX）<br>
CreateNamedPipe 创建一个命名管道。返回的句柄由管道的服务器端使用<br>
CreatePipe 创建一个匿名管道<br>
CreateProcess 创建一个新进程（比如执行一个程序）<br>
CreateSemaphore 创建一个新的信号机<br>
CreateWaitableTimer 创建一个可等待的计时器对象<br>
DisconnectNamedPipe 断开一个客户与一个命名管道的连接<br>
DuplicateHandle 在指出一个现有系统对象当前句柄的情况下，为那个对象创建一个新句柄<br>
ExitProcess 中止一个进程<br>
FindCloseChangeNotification 关闭一个改动通知对象<br>
FindExecutable 查找与一个指定文件关联在一起的程序的文件名<br>
FindFirstChangeNotification 创建一个文件通知对象。该对象用于监视文件系统发生的变化<br>
FindNextChangeNotification 重设一个文件改变通知对象，令其继续监视下一次变化<br>
FreeLibrary 释放指定的动态链接库<br>
GetCurrentProcess 获取当前进程的一个伪句柄<br>
GetCurrentProcessId 获取当前进程一个唯一的标识符<br>
GetCurrentThread 获取当前线程的一个伪句柄<br>
GetCurrentThreadId 获取当前线程一个唯一的线程标识符<br>
GetExitCodeProces 获取一个已中断进程的退出代码<br>
GetExitCodeThread 获取一个已中止线程的退出代码<br>
GetHandleInformation 获取与一个系统对象句柄有关的信息<br>
GetMailslotInfo 获取与一个邮路有关的信息<br>
GetModuleFileName 获取一个已装载模板的完整路径名称<br>
GetModuleHandle 获取一个应用程序或动态链接库的模块句柄<br>
GetPriorityClass 获取特定进程的优先级别<br>
GetProcessShutdownParameters 调查系统关闭时一个指定的进程相对于其它进程的关闭早迟情况<br>
GetProcessTimes 获取与一个进程的经过时间有关的信息<br>
GetProcessWorkingSetSize 了解一个应用程序在运行过程中实际向它交付了多大容量的内存<br>
GetSartupInfo 获取一个进程的启动信息<br>
GetThreadPriority 获取特定线程的优先级别<br>
GetTheardTimes 获取与一个线程的经过时间有关的信息<br>
GetWindowThreadProcessId 获取与指定窗口关联在一起的一个进程和线程标识符<br>
LoadLibrary 载入指定的动态链接库，并将它映射到当前进程使用的地址空间<br>
LoadLibraryEx 装载指定的动态链接库，并为当前进程把它映射到地址空间<br>
LoadModule 载入一个Windows应用程序，并在指定的环境中运行<br>
MsgWaitForMultipleObjects 等侯单个对象或一系列对象发出信号。如返回条件已经满足，则立即返回<br>
SetPriorityClass 设置一个进程的优先级别<br>
SetProcessShutdownParameters 在系统关闭期间，为指定进程设置他相对于其它程序的关闭顺序<br>
SetProcessWorkingSetSize 设置操作系统实际划分给进程使用的内存容量<br>
SetThreadPriority 设定线程的优先级别<br>
ShellExecute 查找与指定文件关联在一起的程序的文件名<br>
TerminateProcess 结束一个进程<br>
WinExec 运行指定的程序</p>
<p>12. API之控件与消息函数</p>
<p>AdjustWindowRect 给定一种窗口样式，计算获得目标客户区矩形所需的窗口大小<br>
AnyPopup 判断屏幕上是否存在任何弹出式窗口<br>
ArrangeIconicWindows 排列一个父窗口的最小化子窗口<br>
AttachThreadInput 连接线程输入函数<br>
BeginDeferWindowPos 启动构建一系列新窗口位置的过程<br>
BringWindowToTop 将指定的窗口带至窗口列表顶部<br>
CascadeWindows 以层叠方式排列窗口<br>
ChildWindowFromPoint 返回父窗口中包含了指定点的第一个子窗口的句柄<br>
ClientToScreen 判断窗口内以客户区坐标表示的一个点的屏幕坐标<br>
CloseWindow 最小化指定的窗口<br>
CopyRect 矩形内容复制<br>
DeferWindowPos 该函数为特定的窗口指定一个新窗口位置<br>
DestroyWindow 清除指定的窗口以及它的所有子窗口<br>
DrawAnimatedRects 描绘一系列动态矩形<br>
EnableWindow 指定的窗口里允许或禁止所有鼠标及键盘输入<br>
EndDeferWindowPos 同时更新DeferWindowPos调用时指定的所有窗口的位置及状态<br>
EnumChildWindows 为指定的父窗口枚举子窗口<br>
EnumThreadWindows 枚举与指定任务相关的窗口<br>
EnumWindows 枚举窗口列表中的所有父窗口<br>
EqualRect 判断两个矩形结构是否相同<br>
FindWindow 寻找窗口列表中第一个符合指定条件的顶级窗口<br>
FindWindowEx 在窗口列表中寻找与指定条件相符的第一个子窗口<br>
FlashWindow 闪烁显示指定窗口<br>
GetActiveWindow 获得活动窗口的句柄<br>
GetCapture 获得一个窗口的句柄，这个窗口位于当前输入线程，且拥有鼠标捕获（鼠标活动由它接收）<br>
GetClassInfo 取得WNDCLASS结构（或WNDCLASSEX结构）的一个副本，结构中包含了与指定类有关的信息<br>
GetClassLong 取得窗口类的一个Long变量条目<br>
GetClassName 为指定的窗口取得类名<br>
GetClassWord 为窗口类取得一个整数变量<br>
GetClientRect 返回指定窗口客户区矩形的大小<br>
GetDesktopWindow 获得代表整个屏幕的一个窗口（桌面窗口）句柄<br>
GetFocus 获得拥有输入焦点的窗口的句柄<br>
GetForegroundWindow 获得前台窗口的句柄<br>
GetLastActivePopup 获得在一个给定父窗口中最近激活过的弹出式窗口的句柄<br>
GetParent 判断指定窗口的父窗口<br>
GetTopWindow 搜索内部窗口列表，寻找隶属于指定窗口的头一个窗口的句柄<br>
GetUpdateRect 获得一个矩形，它描叙了指定窗口中需要更新的那一部分<br>
GetWindow 获得一个窗口的句柄，该窗口与某源窗口有特定的关系<br>
GetWindowContextHelpId 取得与窗口关联在一起的帮助场景ID<br>
GetWindowLong 从指定窗口的结构中取得信息<br>
GetWindowPlacement 获得指定窗口的状态及位置信息<br>
GetWindowRect 获得整个窗口的范围矩形，窗口的边框、标题栏、滚动条及菜单等都在这个矩形内<br>
GetWindowText 取得一个窗体的标题（caption）文字，或者一个控件的内容<br>
GetWindowTextLength 调查窗口标题文字或控件内容的长短<br>
GetWindowWord 获得指定窗口结构的信息<br>
InflateRect 增大或减小一个矩形的大小<br>
IntersectRect 这个函数在lpDestRect里载入一个矩形，它是lpSrc1Rect与lpSrc2Rect两个矩形的交集<br>
InvalidateRect 屏蔽一个窗口客户区的全部或部分区域<br>
IsChild 判断一个窗口是否为另一窗口的子或隶属窗口<br>
IsIconic 判断窗口是否已最小化<br>
IsRectEmpty 判断一个矩形是否为空<br>
IsWindow 判断一个窗口句柄是否有效<br>
IsWindowEnabled 判断窗口是否处于活动状态<br>
IsWindowUnicode 判断一个窗口是否为Unicode窗口。这意味着窗口为所有基于文本的消息都接收Unicode文字<br>
IsWindowVisible 判断窗口是否可见<br>
IsZoomed 判断窗口是否最大化<br>
LockWindowUpdate 锁定指定窗口，禁止它更新<br>
MapWindowPoints 将一个窗口客户区坐标的点转换到另一窗口的客户区坐标系统<br>
MoveWindow 改变指定窗口的位置和大小<br>
OffsetRect 通过应用一个指定的偏移，从而让矩形移动起来<br>
OpenIcon 恢复一个最小化的程序，并将其激活<br>
PtInRect 判断指定的点是否位于矩形内部<br>
RedrawWindow 重画全部或部分窗口<br>
ReleaseCapture 为当前的应用程序释放鼠标捕获<br>
ScreenToClient 判断屏幕上一个指定点的客户区坐标<br>
ScrollWindow 滚动窗口客户区的全部或一部分<br>
ScrollWindowEx 根据附加的选项，滚动窗口客户区的全部或部分<br>
SetActiveWindow 激活指定的窗口<br>
SetCapture 将鼠标捕获设置到指定的窗口<br>
SetClassLong 为窗口类设置一个Long变量条目<br>
SetClassWord 为窗口类设置一个条目<br>
SetFocusAPI 将输入焦点设到指定的窗口。如有必要，会激活窗口<br>
SetForegroundWindow 将窗口设为系统的前台窗口<br>
SetParent 指定一个窗口的新父<br>
SetRect 设置指定矩形的内容<br>
SetRectEmpty 将矩形设为一个空矩形<br>
SetWindowContextHelpId 为指定的窗口设置帮助场景（上下文）ID<br>
SetWindowLong 在窗口结构中为指定的窗口设置信息<br>
SetWindowPlacement 设置窗口状态和位置信息<br>
SetWindowPos 为窗口指定一个新位置和状态<br>
SetWindowText 设置窗口的标题文字或控件的内容<br>
SetWindowWord 在窗口结构中为指定的窗口设置信息<br>
ShowOwnedPopups 显示或隐藏由指定窗口所有的全部弹出式窗口<br>
ShowWindow 控制窗口的可见性<br>
ShowWindowAsync 与ShowWindow相似<br>
SubtractRect 装载矩形lprcDst，它是在矩形lprcSrc1中减去lprcSrc2得到的结果<br>
TileWindows 以平铺顺序排列窗口<br>
UnionRect 装载一个lpDestRect目标矩形，它是lpSrc1Rect和lpSrc2Rect联合起来的结果<br>
UpdateWindow 强制立即更新窗口<br>
ValidateRect 校验窗口的全部或部分客户区<br>
WindowFromPoint 返回包含了指定点的窗口的句柄。忽略屏蔽、隐藏以及透明窗口</p>
<p>消息，就是指Windows发出的一个通知，告诉应用程序某个事情发生了。例如，单击鼠标、改变窗口尺寸、按下键盘上的一个键都会使Windows 发送一个消息给应用程序。消息本身是作为一个记录传递给应用程序的，这个记录中包含了消息的类型以及其他信息。例如，对于单击鼠标所产生的消息来说，这个 记录中包含了单击鼠标时的坐标。这个记录类型叫做TMsg，</p>
<p>它在Windows单元中是这样声明的：<br>
type<br>
TMsg = packed record<br>
hwnd: HWND; / /窗口句柄<br>
message: UINT; / /消息常量标识符<br>
wParam: WPARAM ; // 32位消息的特定附加信息<br>
lParam: LPARAM ; // 32位消息的特定附加信息<br>
time: DWORD; / /消息创建时的时间<br>
pt: TPoint; / /消息创建时的鼠标位置<br>
end;</p>
<h1>再补一点消息详解</h1>
消息中有什么？<br>
是否觉得一个消息记录中的信息像希腊语一样？如果是这样，那么看一看下面的解释：<br>
hwnd 32位的窗口句柄。窗口可以是任何类型的屏幕对象，因为Win32能够维护大多数可视对象的句柄(窗口、对话框、按钮、编辑框等)。<br>
message 用于区别其他消息的常量值，这些常量可以是Windows单元中预定义的常量，也可以是自定义的常量。<br>
wParam 通常是一个与消息有关的常量值，也可能是窗口或控件的句柄。<br>
lParam 通常是一个指向内存中数据的指针。由于W P a r a m、l P a r a m和P o i n t e r都是3 2位的，<br>
因此，它们之间可以相互转换。<p></p>
<p>WM_NULL = $0000;<br>
WM_CREATE = $0001;<br>
应用程序创建一个窗口<br>
WM_DESTROY = $0002;<br>
一个窗口被销毁<br>
WM_MOVE = $0003;<br>
移动一个窗口<br>
WM_SIZE = $0005;<br>
改变一个窗口的大小<br>
WM_ACTIVATE = $0006;<br>
一个窗口被激活或失去激活状态；<br>
WM_SETFOCUS = $0007;<br>
获得焦点后<br>
WM_KILLFOCUS = $0008;<br>
失去焦点<br>
WM_ENABLE = $000A;<br>
改变enable状态<br>
WM_SETREDRAW = $000B;<br>
设置窗口是否能重画 <br>
WM_SETTEXT = $000C;<br>
应用程序发送此消息来设置一个窗口的文本<br>
WM_GETTEXT = $000D;<br>
应用程序发送此消息来复制对应窗口的文本到缓冲区<br>
WM_GETTEXTLENGTH = $000E;<br>
得到与一个窗口有关的文本的长度（不包含空字符）<br>
WM_PAINT = $000F;<br>
要求一个窗口重画自己<br>
WM_CLOSE = $0010;<br>
当一个窗口或应用程序要关闭时发送一个信号<br>
WM_QUERYENDSESSION = $0011;<br>
当用户选择结束对话框或程序自己调用ExitWindows函数<br>
WM_QUIT = $0012;<br>
用来结束程序运行或当程序调用postquitmessage函数 <br>
WM_QUERYOPEN = $0013;<br>
当用户窗口恢复以前的大小位置时，把此消息发送给某个图标<br>
WM_ERASEBKGND = $0014;<br>
当窗口背景必须被擦除时（例在窗口改变大小时）<br>
WM_SYSCOLORCHANGE = $0015;<br>
当系统颜色改变时，发送此消息给所有顶级窗口<br>
WM_ENDSESSION = $0016;<br>
当系统进程发出WM_QUERYENDSESSION消息后，此消息发送给应用程序，<br>
通知它对话是否结束<br>
WM_SYSTEMERROR = $0017;<br>
WM_SHOWWINDOW = $0018;<br>
当隐藏或显示窗口是发送此消息给这个窗口<br>
WM_ACTIVATEAPP = $001C;<br>
发此消息给应用程序哪个窗口是激活的，哪个是非激活的；<br>
WM_FONTCHANGE = $001D;<br>
当系统的字体资源库变化时发送此消息给所有顶级窗口<br>
WM_TIMECHANGE = $001E;<br>
当系统的时间变化时发送此消息给所有顶级窗口<br>
WM_CANCELMODE = $001F;<br>
发送此消息来取消某种正在进行的摸态（操作）<br>
WM_SETCURSOR = $0020;<br>
如果鼠标引起光标在某个窗口中移动且鼠标输入没有被捕获时，就发消息给某个窗口<br>
WM_MOUSEACTIVATE = $0021;<br>
当光标在某个非激活的窗口中而用户正按着鼠标的某个键发送此消息给当前窗口<br>
WM_CHILDACTIVATE = $0022;<br>
发送此消息给MDI子窗口当用户点击此窗口的标题栏，或当窗口被激活，移动，改变大小<br>
WM_QUEUESYNC = $0023;<br>
此消息由基于计算机的训练程序发送，通过WH_JOURNALPALYBACK的hook程序<br>
分离出用户输入消息<br>
WM_GETMINMAXINFO = $0024;<br>
此消息发送给窗口当它将要改变大小或位置；<br>
WM_PAINTICON = $0026;<br>
发送给最小化窗口当它图标将要被重画<br>
WM_ICONERASEBKGND = $0027;<br>
此消息发送给某个最小化窗口，仅当它在画图标前它的背景必须被重画<br>
WM_NEXTDLGCTL = $0028;<br>
发送此消息给一个对话框程序去更改焦点位置<br>
WM_SPOOLERSTATUS = $002A;<br>
每当打印管理列队增加或减少一条作业时发出此消息 <br>
WM_DRAWITEM = $002B;<br>
当button，combobox，listbox，menu的可视外观改变时发送<br>
此消息给这些空件的所有者<br>
WM_MEASUREITEM = $002C;<br>
当button, combo box, list box, list view control, or menu item 被创建时<br>
发送此消息给控件的所有者<br>
WM_DELETEITEM = $002D;<br>
当the list box 或 combo box 被销毁 或 当 某些项被删除通过LB_DELETESTRING, LB_RESETCONTENT, CB_DELETESTRING, or CB_RESETCONTENT 消息<br>
WM_VKEYTOITEM = $002E;<br>
此消息有一个LBS_WANTKEYBOARDINPUT风格的发出给它的所有者来响应WM_KEYDOWN消息 <br>
WM_CHARTOITEM = $002F;<br>
此消息由一个LBS_WANTKEYBOARDINPUT风格的列表框发送给他的所有者来响应WM_CHAR消息 <br>
WM_SETFONT = $0030;<br>
当绘制文本时程序发送此消息得到控件要用的颜色 <br>
WM_GETFONT = $0031;<br>
应用程序发送此消息得到当前控件绘制文本的字体<br>
WM_SETHOTKEY = $0032;<br>
应用程序发送此消息让一个窗口与一个热键相关连<br>
WM_GETHOTKEY = $0033;<br>
应用程序发送此消息来判断热键与某个窗口是否有关联<br>
WM_QUERYDRAGICON = $0037;<br>
此消息发送给最小化窗口，当此窗口将要被拖放而它的类中没有定义图标，应用程序能返回一个图标或光标的句柄，当用户拖放图标时系统显示这个图标或光标<br>
WM_COMPAREITEM = $0039;<br>
发送此消息来判定combobox或listbox新增加的项的相对位置<br>
WM_GETOBJECT = $003D;<br>
WM_COMPACTING = $0041;<br>
显示内存已经很少了<br>
WM_WINDOWPOSCHANGING = $0046;<br>
发送此消息给那个窗口的大小和位置将要被改变时，来调用setwindowpos函数或其它窗口管理函数<br>
WM_WINDOWPOSCHANGED = $0047;<br>
发送此消息给那个窗口的大小和位置已经被改变时，来调用setwindowpos函数或其它窗口管理函数<br>
WM_POWER = $0048;（适用于16位的windows）<br>
当系统将要进入暂停状态时发送此消息<br>
WM_COPYDATA = $004A;<br>
当一个应用程序传递数据给另一个应用程序时发送此消息<br>
WM_CANCELJOURNAL = $004B;<br>
当某个用户取消程序日志激活状态，提交此消息给程序<br>
WM_NOTIFY = $004E;<br>
当某个控件的某个事件已经发生或这个控件需要得到一些信息时，发送此消息给它的父窗口<br>
WM_INPUTLANGCHANGEREQUEST = $0050;<br>
当用户选择某种输入语言，或输入语言的热键改变<br>
WM_INPUTLANGCHANGE = $0051;<br>
当平台现场已经被改变后发送此消息给受影响的最顶级窗口<br>
WM_TCARD = $0052;<br>
当程序已经初始化windows帮助例程时发送此消息给应用程序<br>
WM_HELP = $0053;<br>
此消息显示用户按下了F1，如果某个菜单是激活的，就发送此消息个此窗口关联的菜单，否则就<br>
发送给有焦点的窗口，如果当前都没有焦点，就把此消息发送给当前激活的窗口<br>
WM_USERCHANGED = $0054;<br>
当用户已经登入或退出后发送此消息给所有的窗口，当用户登入或退出时系统更新用户的具体<br>
设置信息，在用户更新设置时系统马上发送此消息；<br>
WM_NOTIFYFORMAT = $0055;<br>
公用控件，自定义控件和他们的父窗口通过此消息来判断控件是使用ANSI还是UNICODE结构<br>
在WM_NOTIFY消息，使用此控件能使某个控件与它的父控件之间进行相互通信<br>
WM_CONTEXTMENU = $007B;<br>
当用户某个窗口中点击了一下右键就发送此消息给这个窗口<br>
WM_STYLECHANGING = $007C;<br>
当调用SETWINDOWLONG函数将要改变一个或多个 窗口的风格时发送此消息给那个窗口<br>
WM_STYLECHANGED = $007D;<br>
当调用SETWINDOWLONG函数一个或多个 窗口的风格后发送此消息给那个窗口<br>
WM_DISPLAYCHANGE = $007E;<br>
当显示器的分辨率改变后发送此消息给所有的窗口<br>
WM_GETICON = $007F;<br>
此消息发送给某个窗口来返回与某个窗口有关连的大图标或小图标的句柄；<br>
WM_SETICON = $0080;<br>
程序发送此消息让一个新的大图标或小图标与某个窗口关联；<br>
WM_NCCREATE = $0081;<br>
当某个窗口第一次被创建时，此消息在WM_CREATE消息发送前发送；<br>
WM_NCDESTROY = $0082;<br>
此消息通知某个窗口，非客户区正在销毁<br>
WM_NCCALCSIZE = $0083;<br>
当某个窗口的客户区域必须被核算时发送此消息<br>
WM_NCHITTEST = $0084;//移动鼠标，按住或释放鼠标时发生<br>
WM_NCPAINT = $0085;<br>
程序发送此消息给某个窗口当它（窗口）的框架必须被绘制时；<br>
WM_NCACTIVATE = $0086;<br>
此消息发送给某个窗口 仅当它的非客户区需要被改变来显示是激活还是非激活状态；<br>
WM_GETDLGCODE = $0087;<br>
发送此消息给某个与对话框程序关联的控件，widdows控制方位键和TAB键使输入进入此控件<br>
通过响应WM_GETDLGCODE消息，应用程序可以把他当成一个特殊的输入控件并能处理它<br>
WM_NCMOUSEMOVE = $00A0;<br>
当光标在一个窗口的非客户区内移动时发送此消息给这个窗口 //非客户区为：窗体的标题栏及窗 <br>
的边框体<br>
WM_NCLBUTTONDOWN = $00A1;<br>
当光标在一个窗口的非客户区同时按下鼠标左键时提交此消息<br>
WM_NCLBUTTONUP = $00A2;<br>
当用户释放鼠标左键同时光标某个窗口在非客户区十发送此消息；<br>
WM_NCLBUTTONDBLCLK = $00A3;<br>
当用户双击鼠标左键同时光标某个窗口在非客户区十发送此消息<br>
WM_NCRBUTTONDOWN = $00A4;<br>
当用户按下鼠标右键同时光标又在窗口的非客户区时发送此消息<br>
WM_NCRBUTTONUP = $00A5;<br>
当用户释放鼠标右键同时光标又在窗口的非客户区时发送此消息<br>
WM_NCRBUTTONDBLCLK = $00A6;<br>
当用户双击鼠标右键同时光标某个窗口在非客户区十发送此消息<br>
WM_NCMBUTTONDOWN = $00A7;<br>
当用户按下鼠标中键同时光标又在窗口的非客户区时发送此消息<br>
WM_NCMBUTTONUP = $00A8;<br>
当用户释放鼠标中键同时光标又在窗口的非客户区时发送此消息<br>
WM_NCMBUTTONDBLCLK = $00A9;<br>
当用户双击鼠标中键同时光标又在窗口的非客户区时发送此消息<br>
WM_KEYFIRST = $0100;<br>
WM_KEYDOWN = $0100; <br>
//按下一个键<br>
WM_KEYUP = $0101; <br>
//释放一个键<br>
WM_CHAR = $0102; <br>
//按下某键，并已发出WM_KEYDOWN， WM_KEYUP消息<br>
WM_DEADCHAR = $0103;<br>
当用translatemessage函数翻译WM_KEYUP消息时发送此消息给拥有焦点的窗口<br>
WM_SYSKEYDOWN = $0104;<br>
当用户按住ALT键同时按下其它键时提交此消息给拥有焦点的窗口；<br>
WM_SYSKEYUP = $0105;<br>
当用户释放一个键同时ALT 键还按着时提交此消息给拥有焦点的窗口<br>
WM_SYSCHAR = $0106;<br>
当WM_SYSKEYDOWN消息被TRANSLATEMESSAGE函数翻译后提交此消息给拥有焦点的窗口<br>
WM_SYSDEADCHAR = $0107;<br>
当WM_SYSKEYDOWN消息被TRANSLATEMESSAGE函数翻译后发送此消息给拥有焦点的窗口<br>
WM_KEYLAST = $0108;<br>
WM_INITDIALOG = $0110;<br>
在一个对话框程序被显示前发送此消息给它，通常用此消息初始化控件和执行其它任务<br>
WM_COMMAND = $0111;<br>
当用户选择一条菜单命令项或当某个控件发送一条消息给它的父窗口，一个快捷键被翻译<br>
WM_SYSCOMMAND = $0112;<br>
当用户选择窗口菜单的一条命令或当用户选择最大化或最小化时那个窗口会收到此消息<br>
WM_TIMER = $0113; //发生了定时器事件<br>
WM_HSCROLL = $0114;<br>
当一个窗口标准水平滚动条产生一个滚动事件时发送此消息给那个窗口，也发送给拥有它的控件<br>
WM_VSCROLL = $0115;<br>
当一个窗口标准垂直滚动条产生一个滚动事件时发送此消息给那个窗口也，发送给拥有它的控件 WM_INITMENU = $0116;<br>
当一个菜单将要被激活时发送此消息，它发生在用户菜单条中的某项或按下某个菜单键，它允许程序在显示前更改菜单<br>
WM_INITMENUPOPUP = $0117;<br>
当一个下拉菜单或子菜单将要被激活时发送此消息，它允许程序在它显示前更改菜单，而不要改变全部 <br>
WM_MENUSELECT = $011F;<br>
当用户选择一条菜单项时发送此消息给菜单的所有者（一般是窗口）<br>
WM_MENUCHAR = $0120;<br>
当菜单已被激活用户按下了某个键（不同于加速键），发送此消息给菜单的所有者；<br>
WM_ENTERIDLE = $0121;<br>
当一个模态对话框或菜单进入空载状态时发送此消息给它的所有者，一个模态对话框或菜单进入空载状态就是在处理完一条或几条先前的消息后没有消息它的列队中等待<br>
WM_MENURBUTTONUP = $0122;<br>
WM_MENUDRAG = $0123;<br>
WM_MENUGETOBJECT = $0124;<br>
WM_UNINITMENUPOPUP = $0125;<br>
WM_MENUCOMMAND = $0126;<br>
WM_CHANGEUISTATE = $0127;<br>
WM_UPDATEUISTATE = $0128;<br>
WM_QUERYUISTATE = $0129; <br>
WM_CTLCOLORMSGBOX = $0132;<br>
在windows绘制消息框前发送此消息给消息框的所有者窗口，通过响应这条消息，所有者窗口可以通过使用给定的相关显示设备的句柄来设置消息框的文本和背景颜色<br>
WM_CTLCOLOREDIT = $0133;<br>
当一个编辑型控件将要被绘制时发送此消息给它的父窗口；通过响应这条消息，所有者窗口可以通过使用给定的相关显示设备的句柄来设置编辑框的文本和背景颜色<br>
WM_CTLCOLORLISTBOX = $0134;<br>
当一个列表框控件将要被绘制前发送此消息给它的父窗口；通过响应这条消息，所有者窗口可以通过使用给定的相关显示设备的句柄来设置列表框的文本和背景颜色 <br>
WM_CTLCOLORBTN = $0135;<br>
当一个按钮控件将要被绘制时发送此消息给它的父窗口；通过响应这条消息，所有者窗口可以通过使用给定的相关显示设备的句柄来设置按纽的文本和背景颜色<br>
WM_CTLCOLORDLG = $0136;<br>
当一个对话框控件将要被绘制前发送此消息给它的父窗口；通过响应这条消息，所有者窗口可以通过使用给定的相关显示设备的句柄来设置对话框的文本背景颜色<br>
WM_CTLCOLORSCROLLBAR= $0137;<br>
当一个滚动条控件将要被绘制时发送此消息给它的父窗口；通过响应这条消息，所有者窗口可以通过使用给定的相关显示设备的句柄来设置滚动条的背景颜色<br>
WM_CTLCOLORSTATIC = $0138; <br>
当一个静态控件将要被绘制时发送此消息给它的父窗口；通过响应这条消息，所有者窗口可以通过使用给定的相关显示设备的句柄来设置静态控件的文本和背景颜色<br>
WM_MOUSEFIRST = $0200;<br>
WM_MOUSEMOVE = $0200; <br>
// 移动鼠标<br>
WM_LBUTTONDOWN = $0201; <br>
//按下鼠标左键<br>
WM_LBUTTONUP = $0202; <br>
//释放鼠标左键<br>
WM_LBUTTONDBLCLK = $0203;<br>
//双击鼠标左键<br>
WM_RBUTTONDOWN = $0204;<br>
//按下鼠标右键<br>
WM_RBUTTONUP = $0205;<br>
//释放鼠标右键<br>
WM_RBUTTONDBLCLK = $0206; <br>
//双击鼠标右键<br>
WM_MBUTTONDOWN = $0207; <br>
//按下鼠标中键 <br>
WM_MBUTTONUP = $0208; <br>
//释放鼠标中键<br>
WM_MBUTTONDBLCLK = $0209; <br>
//双击鼠标中键<br>
WM_MOUSEWHEEL = $020A;<br>
当鼠标轮子转动时发送此消息个当前有焦点的控件<br>
WM_MOUSELAST = $020A;<br>
WM_PARENTNOTIFY = $0210;<br>
当MDI子窗口被创建或被销毁，或用户按了一下鼠标键而光标在子窗口上时发送此消息给它的父窗口<br>
WM_ENTERMENULOOP = $0211;<br>
发送此消息通知应用程序的主窗口that已经进入了菜单循环模式<br>
WM_EXITMENULOOP = $0212;<br>
发送此消息通知应用程序的主窗口that已退出了菜单循环模式<br>
WM_NEXTMENU = $0213;<br>
WM_SIZING = 532;<br>
当用户正在调整窗口大小时发送此消息给窗口；通过此消息应用程序可以监视窗口大小和位置也可以修改他们<br>
WM_CAPTURECHANGED = 533;<br>
发送此消息 给窗口当它失去捕获的鼠标时；<br>
WM_MOVING = 534;<br>
当用户在移动窗口时发送此消息，通过此消息应用程序可以监视窗口大小和位置也可以修改他们；<br>
WM_POWERBROADCAST = 536;<br>
此消息发送给应用程序来通知它有关电源管理事件；<br>
WM_DEVICECHANGE = 537;<br>
当设备的硬件配置改变时发送此消息给应用程序或设备驱动程序<br>
WM_IME_STARTCOMPOSITION = $010D;<br>
WM_IME_ENDCOMPOSITION = $010E;<br>
WM_IME_COMPOSITION = $010F;<br>
WM_IME_KEYLAST = $010F;<br>
WM_IME_SETCONTEXT = $0281;<br>
WM_IME_NOTIFY = $0282;<br>
WM_IME_CONTROL = $0283;<br>
WM_IME_COMPOSITIONFULL = $0284;<br>
WM_IME_SELECT = $0285;<br>
WM_IME_CHAR = $0286;<br>
WM_IME_REQUEST = $0288;<br>
WM_IME_KEYDOWN = $0290;<br>
WM_IME_KEYUP = $0291;<br>
WM_MDICREATE = $0220;<br>
应用程序发送此消息给多文档的客户窗口来创建一个MDI 子窗口<br>
WM_MDIDESTROY = $0221;<br>
应用程序发送此消息给多文档的客户窗口来关闭一个MDI 子窗口<br>
WM_MDIACTIVATE = $0222;<br>
应用程序发送此消息给多文档的客户窗口通知客户窗口激活另一个MDI子窗口，当客户窗口收到此消息后，它发出WM_MDIACTIVE消息给MDI子窗口（未激活）激活它；<br>
WM_MDIRESTORE = $0223;<br>
程序 发送此消息给MDI客户窗口让子窗口从最大最小化恢复到原来大小<br>
WM_MDINEXT = $0224;<br>
程序 发送此消息给MDI客户窗口激活下一个或前一个窗口<br>
WM_MDIMAXIMIZE = $0225;<br>
程序发送此消息给MDI客户窗口来最大化一个MDI子窗口；<br>
WM_MDITILE = $0226;<br>
程序 发送此消息给MDI客户窗口以平铺方式重新排列所有MDI子窗口<br>
WM_MDICASCADE = $0227;<br>
程序 发送此消息给MDI客户窗口以层叠方式重新排列所有MDI子窗口<br>
WM_MDIICONARRANGE = $0228;<br>
程序 发送此消息给MDI客户窗口重新排列所有最小化的MDI子窗口<br>
WM_MDIGETACTIVE = $0229;<br>
程序 发送此消息给MDI客户窗口来找到激活的子窗口的句柄<br>
WM_MDISETMENU = $0230;<br>
程序 发送此消息给MDI客户窗口用MDI菜单代替子窗口的菜单<br>
WM_ENTERSIZEMOVE = $0231;<br>
WM_EXITSIZEMOVE = $0232;<br>
WM_DROPFILES = $0233;<br>
WM_MDIREFRESHMENU = $0234;<br>
WM_MOUSEHOVER = $02A1;<br>
WM_MOUSELEAVE = $02A3;<br>
WM_CUT = $0300;<br>
程序发送此消息给一个编辑框或combobox来删除当前选择的文本<br>
WM_COPY = $0301;<br>
程序发送此消息给一个编辑框或combobox来复制当前选择的文本到剪贴板<br>
WM_PASTE = $0302;<br>
程序发送此消息给editcontrol或combobox从剪贴板中得到数据<br>
WM_CLEAR = $0303;<br>
程序发送此消息给editcontrol或combobox清除当前选择的内容；<br>
WM_UNDO = $0304;<br>
程序发送此消息给editcontrol或combobox撤消最后一次操作<br>
WM_RENDERFORMAT = $0305；</p>
<p>WM_RENDERALLFORMATS = $0306;<br>
WM_DESTROYCLIPBOARD = $0307;<br>
当调用ENPTYCLIPBOARD函数时 发送此消息给剪贴板的所有者<br>
WM_DRAWCLIPBOARD = $0308;<br>
当剪贴板的内容变化时发送此消息给剪贴板观察链的第一个窗口；它允许用剪贴板观察窗口来<br>
显示剪贴板的新内容；<br>
WM_PAINTCLIPBOARD = $0309;<br>
当剪贴板包含CF_OWNERDIPLAY格式的数据并且剪贴板观察窗口的客户区需要重画；<br>
WM_VSCROLLCLIPBOARD = $030A;<br>
WM_SIZECLIPBOARD = $030B;<br>
当剪贴板包含CF_OWNERDIPLAY格式的数据并且剪贴板观察窗口的客户区域的大小已经改变是此消息通过剪贴板观察窗口发送给剪贴板的所有者；<br>
WM_ASKCBFORMATNAME = $030C;<br>
通过剪贴板观察窗口发送此消息给剪贴板的所有者来请求一个CF_OWNERDISPLAY格式的剪贴板的名字<br>
WM_CHANGECBCHAIN = $030D;<br>
当一个窗口从剪贴板观察链中移去时发送此消息给剪贴板观察链的第一个窗口；<br>
WM_HSCROLLCLIPBOARD = $030E; <br>
此消息通过一个剪贴板观察窗口发送给剪贴板的所有者 ；它发生在当剪贴板包含CFOWNERDISPALY格式的数据并且有个事件在剪贴板观察窗的水平滚动条上；所有者应滚动剪贴板图象并更新滚动条的值；<br>
WM_QUERYNEWPALETTE = $030F;<br>
此消息发送给将要收到焦点的窗口，此消息能使窗口在收到焦点时同时有机会实现他的逻辑调色板<br>
WM_PALETTEISCHANGING= $0310;<br>
当一个应用程序正要实现它的逻辑调色板时发此消息通知所有的应用程序<br>
WM_PALETTECHANGED = $0311;<br>
此消息在一个拥有焦点的窗口实现它的逻辑调色板后发送此消息给所有顶级并重叠的窗口，以此来改变系统调色板 <br>
WM_HOTKEY = $0312;<br>
当用户按下由REGISTERHOTKEY函数注册的热键时提交此消息<br>
WM_PRINT = 791;<br>
应用程序发送此消息仅当WINDOWS或其它应用程序发出一个请求要求绘制一个应用程序的一部分；<br>
WM_PRINTCLIENT = 792;<br>
WM_HANDHELDFIRST = 856;<br>
WM_HANDHELDLAST = 863;<br>
WM_PENWINFIRST = $0380;<br>
WM_PENWINLAST = $038F;<br>
WM_COALESCE_FIRST = $0390;<br>
WM_COALESCE_LAST = $039F;<br>
WM_DDE_FIRST = $03E0;<br>
WM_DDE_INITIATE = WM_DDE_FIRST + 0;<br>
一个DDE客户程序提交此消息开始一个与服务器程序的会话来响应那个指定的程序和主题名；<br>
WM_DDE_TERMINATE = WM_DDE_FIRST + 1;<br>
一个DDE应用程序（无论是客户还是服务器）提交此消息来终止一个会话；<br>
WM_DDE_ADVISE = WM_DDE_FIRST + 2;<br>
一个DDE客户程序提交此消息给一个DDE服务程序来请求服务器每当数据项改变时更新它<br>
WM_DDE_UNADVISE = WM_DDE_FIRST + 3;<br>
一个DDE客户程序通过此消息通知一个DDE服务程序不更新指定的项或一个特殊的剪贴板格式的项<br>
WM_DDE_ACK = WM_DDE_FIRST + 4;<br>
此消息通知一个DDE（动态数据交换）程序已收到并正在处理WM_DDE_POKE, WM_DDE_EXECUTE, WM_DDE_DATA, WM_DDE_ADVISE, WM_DDE_UNADVISE, or WM_DDE_INITIAT消息<br>
WM_DDE_DATA = WM_DDE_FIRST + 5;<br>
一个DDE服务程序提交此消息给DDE客户程序来传递个一数据项给客户或通知客户的一条可用数据项<br>
WM_DDE_REQUEST = WM_DDE_FIRST + 6;<br>
一个DDE客户程序提交此消息给一个DDE服务程序来请求一个数据项的值；<br>
WM_DDE_POKE = WM_DDE_FIRST + 7;<br>
一个DDE客户程序提交此消息给一个DDE服务程序，客户使用此消息来请求服务器接收一个未经同意的数据项；服务器通过答复WM_DDE_ACK消息提示是否它接收这个数据项；<br>
WM_DDE_EXECUTE = WM_DDE_FIRST + 8;<br>
一个DDE客户程序提交此消息给一个DDE服务程序来发送一个字符串给服务器让它象串行命令一样被处理，服务器通过提交WM_DDE_ACK消息来作回应；<br>
WM_DDE_LAST = WM_DDE_FIRST + 8;<br>
WM_APP = $8000;<br>
WM_USER = $0400;<br>
此消息能帮助应用程序自定义私有消息；<br>
/////////////////////////////////////////////////////////////////////<br>
通 知消息(Notification message)是指这样一种消息，一个窗口内的子控件发生了一些事情，需要通知父窗口。通知消息只适用于标准的窗口控件如按钮、列表框、组合框、编辑 框，以及Windows 95公共控件如树状视图、列表视图等。例如，单击或双击一个控件、在控件中选择部分文本、操作控件的滚动条都会产生通知消息。<br>
按扭<br>
B N _ C L I C K E D //用户单击了按钮<br>
B N _ D I S A B L E //按钮被禁止<br>
B N _ D O U B L E C L I C K E D //用户双击了按钮<br>
B N _ H I L I T E //用户加亮了按钮<br>
B N _ PA I N T按钮应当重画<br>
B N _ U N H I L I T E加亮应当去掉<br>
组合框<br>
C B N _ C L O S E U P组合框的列表框被关闭<br>
C B N _ D B L C L K用户双击了一个字符串<br>
C B N _ D R O P D O W N组合框的列表框被拉出<br>
C B N _ E D I T C H A N G E用户修改了编辑框中的文本<br>
C B N _ E D I T U P D AT E编辑框内的文本即将更新<br>
C B N _ E R R S PA C E组合框内存不足<br>
C B N _ K I L L F O C U S组合框失去输入焦点<br>
C B N _ S E L C H A N G E在组合框中选择了一项<br>
C B N _ S E L E N D C A N C E L用户的选择应当被取消<br>
C B N _ S E L E N D O K用户的选择是合法的<br>
C B N _ S E T F O C U S组合框获得输入焦点<br>
编辑框<br>
E N _ C H A N G E编辑框中的文本己更新<br>
E N _ E R R S PA C E编辑框内存不足<br>
E N _ H S C R O L L用户点击了水平滚动条<br>
E N _ K I L L F O C U S编辑框正在失去输入焦点<br>
E N _ M A X T E X T插入的内容被截断<br>
E N _ S E T F O C U S编辑框获得输入焦点<br>
E N _ U P D AT E编辑框中的文本将要更新<br>
E N _ V S C R O L L用户点击了垂直滚动条消息含义<br>
列表框<br>
L B N _ D B L C L K用户双击了一项<br>
L B N _ E R R S PA C E列表框内存不够<br>
L B N _ K I L L F O C U S列表框正在失去输入焦点<br>
L B N _ S E L C A N C E L选择被取消<br>
L B N _ S E L C H A N G E选择了另一项<br>
L B N _ S E T F O C U S列表框获得输入焦点</p>
原文出处：来自百度用户
            </div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Asc0t6e</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.ascotbe.com/2019/04/25/Windows%20API%E5%87%BD%E6%95%B0/">https://www.ascotbe.com/2019/04/25/Windows%20API%E5%87%BD%E6%95%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.ascotbe.com">Asc0t6e</a>！</span></div></div><div class="tag_share"><div class="post_share"><div class="social-share" data-image="https://gitee.com/asc0t6e/Random-img/raw/master/BlogCover/4.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2019/05/21/%E4%BD%BF%E7%94%A8%E7%88%AC%E8%99%AB%E7%88%86%E7%A0%B4%E6%B5%B7%E5%BA%B7%E7%9B%91%E6%8E%A7/"><img class="prev_cover lazyload" data-src="https://gitee.com/asc0t6e/Random-img/raw/master/BlogCover/3.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>使用爬虫爆破海康监控</span></div></a></div><div class="next-post pull_right"><a href="/2019/04/05/C++this/"><img class="next_cover lazyload" data-src="https://gitee.com/asc0t6e/Random-img/raw/master/BlogCover/25.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>C++this</span></div></a></div></nav></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2017 - 2020 By Asc0t6e</div><span>呐呐呐ฅ(๑*д*๑)ฅ到底啦~</span><div class="icp"><a href="http://www.beian.miit.gov.cn/state/outPortal/loginPortal.action" target="_blank" rel="noopener"><img class="icp-icon" src="/img/icp.png"><span>闽ICP备20002178号-1</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/fireworks.js"></script><script id="ribbon_piao" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/click_heart.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/Bronya.model.json"},"display":{"position":"right","width":400,"height":500,"hOffset":-110,"vOffset":-40},"mobile":{"show":false},"log":false});</script></body></html>