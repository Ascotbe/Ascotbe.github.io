<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Linux堆溢出总结（0x01） | ascotbe</title><meta name="author" content="ascotbe"><meta name="copyright" content="ascotbe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！   前言  HVV结束，终于能闲下来学习了，开新坑啦~好耶~   记个小知识点    libc是Linux下的ANSI C函数库。   glibc是Linux下的GUN C函数库。   Linux下原来的标准c库Linux libc逐渐不再被">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux堆溢出总结（0x01）">
<meta property="og:url" content="https://www.ascotbe.com/2021/05/04/HeapOverflow_Linux_0x01/index.html">
<meta property="og:site_name" content="ascotbe">
<meta property="og:description" content="郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！   前言  HVV结束，终于能闲下来学习了，开新坑啦~好耶~   记个小知识点    libc是Linux下的ANSI C函数库。   glibc是Linux下的GUN C函数库。   Linux下原来的标准c库Linux libc逐渐不再被">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/123.jpg">
<meta property="article:published_time" content="2021-05-04T15:45:42.000Z">
<meta property="article:modified_time" content="2023-01-05T06:17:01.848Z">
<meta property="article:author" content="ascotbe">
<meta property="article:tag" content="堆">
<meta property="article:tag" content="溢出">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/123.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://www.ascotbe.com/2021/05/04/HeapOverflow_Linux_0x01/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"本篇文章距最近一次更新已过去","messageNext":"天，文章内容有可能过时."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: ascotbe","link":"链接: ","source":"来源: ascotbe","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux堆溢出总结（0x01）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-01-05 14:17:01'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="//at.alicdn.com/t/c/font_3133731_25dh7dx5bg4.css"><link rel="stylesheet" href="/css/beating_icon.css"><link rel="stylesheet" href="/css/mouse.css"><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="ascotbe" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "/img/loading.gif" data-lazy-src="/img/avatar.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">102</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">78</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">28</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-dongwu"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 内容</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-danger-full"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-zhiwu"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-tubiaozhizuomoban-"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/Loophole"><i class="fa-fw iconfont icon-godot-assets1"></i><span> 漏洞</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery"><i class="fa-fw iconfont icon-forms_dota_dragon_big"></i><span> 图片</span></a></div><div class="menus_item"><a class="site-page" href="/Link/"><i class="fa-fw iconfont icon-FaceID"></i><span> 友联</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-maomi_touxiang"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://raw.githubusercontent.com/Ascotbe/Image/master/Blog/123.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ascotbe</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-dongwu"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 内容</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-danger-full"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-zhiwu"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-tubiaozhizuomoban-"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/Loophole"><i class="fa-fw iconfont icon-godot-assets1"></i><span> 漏洞</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery"><i class="fa-fw iconfont icon-forms_dota_dragon_big"></i><span> 图片</span></a></div><div class="menus_item"><a class="site-page" href="/Link/"><i class="fa-fw iconfont icon-FaceID"></i><span> 友联</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-maomi_touxiang"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Linux堆溢出总结（0x01）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-05-04T15:45:42.000Z" title="发表于 2021-05-04 23:45:42">2021-05-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.848Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%80%86%E5%90%91/">逆向</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%80%86%E5%90%91/%E5%A0%86%E6%A0%88/">堆栈</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>23分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Linux堆溢出总结（0x01）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><div class="note danger modern"><p>郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！</p>
</div>
<blockquote>
<p>前言</p>
</blockquote>
<p>HVV结束，终于能闲下来学习了，开新坑啦~好耶~</p>
<img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/HeapOverflow/1.gif" alt="4E2FEA9B95DD08A1A4A30E8A3E4B9C63" style="zoom:33%;" />
<blockquote>
<p>记个小知识点</p>
</blockquote>
<ul>
<li>
<p>libc是Linux下的ANSI C函数库。</p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="http://www.gnu.org/software/libc/">glibc</a>是Linux下的GUN C函数库。</p>
</li>
</ul>
<p>Linux下原来的标准c库Linux libc逐渐不再被维护。Linux下面的标准c库不仅有这一个，如uclibc、klibc，以及上面被提到的Linux libc，但是glibc无疑是用得最多的。glibc在/lib目录下的.so文件为libc.so.6。</p>
<h2 id="堆内存管理机制介绍">堆内存管理机制介绍</h2>
<p>不同平台的堆内存管理机制不相同，下面是几个常见平台的堆内存管理机制：</p>
<table>
<thead>
<tr>
<th style="text-align:center">平台</th>
<th style="text-align:center">堆内存分配机制</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">General purpose allocator</td>
<td style="text-align:center">dlmalloc</td>
</tr>
<tr>
<td style="text-align:center">glibc</td>
<td style="text-align:center">ptmalloc2</td>
</tr>
<tr>
<td style="text-align:center">free BSD and Firefox</td>
<td style="text-align:center">jemalloc</td>
</tr>
<tr>
<td style="text-align:center">Google</td>
<td style="text-align:center">tcmalloc</td>
</tr>
<tr>
<td style="text-align:center">Solaris</td>
<td style="text-align:center">libumem</td>
</tr>
</tbody>
</table>
<p>在 Linux 的 <code>glibc</code> 使用的 <code>ptmalloc2</code> 实现原理。本来 Linux 默认的是 <code>dlmalloc</code>，但是由于其不支持多线程堆管理，所以后来被支持多线程的 <code>prmalloc2</code> 代替了。当然在 Linux 平台上的 <code>malloc</code> 函数本质上都是通过系统调用 <code>brk</code> 或者 <code>mmap</code> 实现的。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/HeapOverflow/2.png" alt="img"></p>
<p>进程的虚拟内存分布示意图(32位系统的进程虚拟内存分布)：</p>
<ul>
<li>在Linux 2.6.7之前的布局</li>
<li>堆只有1G虚拟空间</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/HeapOverflow/3.png" alt="img"></p>
<p>任何应用都可以调用 Linux 的 <code>mmap</code> 系统调用，或者 Windows 的 <code>CreateFileMapping</code>/<code>MapViewOfFile</code>，向操作系统申请内存映射。内存映射是一个很方便、高效的做文件 IO 的方式, 所以一般用来加载动态链接库（dynamic libraries），也可以创建一块匿名的映射内存，不对应任何文件，在程序中使用。</p>
<p>进程的虚拟内存分布示意图(64位系统的进程虚拟内存分布)：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/HeapOverflow/19.png" alt="2"></p>
<h2 id="堆内存分配实验">堆内存分配实验</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//test_malloc.cpp</span></span><br><span class="line"><span class="comment">//clang++ -std=c++11 test_malloc.cpp -lpthread</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">ThreadFunc</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Before malloc in thread 1\n&quot;</span>);</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="type">char</span>* addr = (<span class="type">char</span>*) <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After malloc and before free in thread 1\n&quot;</span>);</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="built_in">free</span>(addr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After free in thread 1\n&quot;</span>);</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">pthread_t</span> t1;</span><br><span class="line">        <span class="type">void</span>* s;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        <span class="type">char</span>* addr;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Welcome to per thread arena example::%d\n&quot;</span>,<span class="built_in">getpid</span>());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Before malloc in main thread\n&quot;</span>);</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        addr = (<span class="type">char</span>*) <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After malloc and before free in main thread\n&quot;</span>);</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="built_in">free</span>(addr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After free in main thread\n&quot;</span>);</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        ret = <span class="built_in">pthread_create</span>(&amp;t1, <span class="literal">NULL</span>, ThreadFunc, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Thread creation error\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = <span class="built_in">pthread_join</span>(t1, &amp;s);</span><br><span class="line">        <span class="keyword">if</span>(ret)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Thread join error\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="主线程-malloc-之前">主线程 malloc 之前</h3>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/HeapOverflow/4.png" alt="image-20210505225640027"></p>
<p>可以看到，在本机上（Ubuntu16.04，x64），在主线程调用 <code>malloc</code> 之前，就已经给主线程分配了一块堆内存，这块<strong>默认大小的内存是 200 KB</strong>。</p>
<p>堆区内存位置是紧接着数据段的，并且<strong>offset</strong>的值为<strong>00000000</strong>，说明这个系统是通过 <code>brk</code> 进行内存分配的。</p>
<h3 id="主线程-malloc-之后">主线程 malloc 之后</h3>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/HeapOverflow/5.png" alt="image-20210505231259039"></p>
<p>在主线程中调用 <code>malloc</code> 之后，发现 <strong>堆的大小仍然是 200K</strong>，因此 <code>malloc</code> 并没有引起堆区总容量的自增长。</p>
<div class="note info modern"><p>作者原文中有一种解释（32位）：还可以看出虽然我们只申请了1000bytes的数据，但是系统却分配了132KB大小的堆，这是为什么呢？原来这132KB的堆空间叫做<strong>arena</strong>，此时因为是主线程分配的，所以叫做<strong>main arena</strong>（每个<strong>arena</strong>中含有多个<strong>chunk</strong>，这些<strong>chunk</strong>以链表的形式加以组织)。由于132KB比1000bytes大很多，所以主线程后续再申请堆空间的话，就会先从这132KB的剩余部分中申请，直到用完或不够用的时候，再通过增加<strong>program break location</strong>的方式来增加<strong>main arena</strong>的大小。同理，当<strong>main arena</strong>中有过多空闲内存的时候，也会通过减小<strong>program break location</strong>的方式来缩小<strong>main arena</strong>的大小。</p>
</div>
<h3 id="主线程-free-之后">主线程 free 之后</h3>
<p>主线程调用 <code>free</code> 之后，堆内存分布未发生改变</p>
<div class="note info modern"><p>原文也给出了解释（32位）：在主线程调用<code>free</code>之后，从内存布局可以看出程序的堆空间并没有被释放掉，因为调用<code>free</code>函数释放已经分配了的空间并非直接“返还”给系统，而是由<code>glibc</code>的<code>malloc</code>库函数加以管理。它会将释放的<strong>chunk</strong>（称为<strong>free chunk</strong>）添加到 <strong>main arena</strong> 的 <strong>bin</strong>（这是一种用于存储同类型<strong>free chunk</strong> 的双链表数据结构，后面会加以详细介绍）中。在这里，记录空闲空间的 <strong>free list</strong> 数据结构称之为 <strong>bins</strong>。之后当用户再次调用 <code>malloc</code> 申请堆空间的时候，<code>glibc</code>的 <code>malloc</code> 会先尝试从 <strong>bin</strong> 中找到一个满足要求的 <strong>chunk</strong> ，如果没有才会向操作系统申请新的堆空间。</p>
</div>
<h3 id="子线程-malloc-之前">子线程 malloc 之前</h3>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/HeapOverflow/6.png" alt="image-20210506110331027"></p>
<p>红色框这一部分地址可以看出，<strong>在子线程 <code>malloc</code> 之前，已经创建了子线程的栈，或者说子线程创建时就在内存映射区上创建了该线程的栈空间，其默认大小是 8MB</strong>。</p>
<div class="note info modern"><p><strong>Linux 子线程是由 mmap 创建的，所以其栈是位于内存映射区区域</strong></p>
</div>
<h3 id="子线程-malloc-之后">子线程 malloc 之后</h3>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/HeapOverflow/7.png" alt="image-20210506135215497"></p>
<p>在 <code>malloc</code> 之后，为子线程分配了堆区，这个大小是 132K，并且同样是位于内存映射区，这部分区域就是 thread1 的堆空间，即 thread1 的 <strong>arena</strong>。同时还要注意，子线程分配的空间是内存映射区向下增长的，也就是向堆区增长。</p>
<p>所以可以确定的是，<strong>子线程的堆栈都是分配在内存映射区和堆区之间的区域</strong>（也可以理解为就是分配在内存映射区，因为内存映射区和堆区都是动态增长的，内存映射区向下增长，堆区向上增长）。从虚拟内存的分布图中我们可以看到，在 3GB 的用户进程空间中，地址最高处的栈所占用的比较少（主线程的栈一般是 16MB 或者 8MB），然后内存映射区也不大，而初始化的堆区也很小。所以内存映射区和堆之间的区域是非常大的。</p>
<h3 id="子线程-free-之后">子线程 free 之后</h3>
<p>同主线程类似，并没有立即回收。</p>
<h2 id="brk和mmap的区别">brk和mmap的区别</h2>
<p>从操作系统角度来看，进程分配内存有两种方式，分别由两个系统调用完成：brk和mmap（不考虑共享内存）。</p>
<ul>
<li>
<p>brk是将数据段(.data)的最高地址指针_edata往高地址推；</p>
</li>
<li>
<p>mmap是在进程的虚拟地址空间中（堆和栈中间，称为<strong>文件映射区域</strong>的地方）找一块空闲的虚拟内存。</p>
</li>
</ul>
<p>这两种方式分配的都是<strong>虚拟内存</strong>，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。</p>
<p>在标准C库中，提供了malloc/free函数分配释放内存，这两个函数底层是由brk，mmap，munmap这些系统调用实现的。</p>
<h2 id="arena">arena</h2>
<h3 id="介绍">介绍</h3>
<p><strong>arena</strong>原本的翻译是竞技场，这个词非常巧妙的表现了堆中内存的管理的思路。前文提到，每个线程都有一个自己的<strong>arena</strong>用于堆内存的分配，这个区域是调用<code>malloc</code>的时候从操作系统获得的，一般情况下比实际<code>malloc</code>要大一些，当下次再次调用<code>malloc</code>，可以直接从<strong>arena</strong>中进行堆内存分配。</p>
<blockquote>
<p><strong>arena</strong>分为<strong>thread arena</strong>（可以包含多个 <strong>heap</strong>）和<strong>main arena</strong>（只包含一个可以自增长的 <strong>heap</strong>），每个<strong>heap</strong> 被分为多个 <strong>chunk</strong></p>
</blockquote>
<h3 id="arena-数量">arena 数量</h3>
<p>对于不同系统，arena 数量的<a target="_blank" rel="noopener" href="https://github.com/lattera/glibc/blob/master/malloc/arena.c#L888">约束</a>如下</p>
<table>
<thead>
<tr>
<th style="text-align:center">systems</th>
<th style="text-align:center">number of arena</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">32bits</td>
<td style="text-align:center">2 x number of cpu cores + 1</td>
</tr>
<tr>
<td style="text-align:center">64bits</td>
<td style="text-align:center">8 x number of cpu cores + 1</td>
</tr>
</tbody>
</table>
<h3 id="arena-管理">arena 管理</h3>
<p>假设有如下情景：一台只含有一个处理器核心的机器安装有 32 位操作系统，其上运行了一个多线程应用程序，共含有 4 个线程——主线程和三个子线程。显然线程个数大于系统能维护的最大 <strong>arena</strong> 个数（2 x 核心数 + 1= 3），那么此时 <code>glibc</code> 的 <code>malloc</code> 就需要确保这 4 个线程能够正确地共享这 3 个 <strong>arena</strong>，那么它是如何实现的呢？</p>
<p>当主线程首次调用 <code>malloc</code> 的时候会直接为它分配一个 <strong>main arena</strong>，而不需要任何附加条件。</p>
<p>当子线程 1 和子线程 2 首次调用 <code>malloc</code> 的时候，<code>glibc</code> 实现的 <code>malloc</code> 会分别为每个子线程创建一个新的 <strong>thread arena</strong>。此时，各个线程与 <strong>arena</strong> 是一一对应的。但是，当用户线程 3 调用 <code>malloc</code> 的时候就出现问题了。因为此时 <code>glibc</code> 的 <code>malloc</code> 能维护的 <strong>arena</strong> 个数已经达到上限，无法再为子线程 3 分配新的 <strong>arena</strong> 了，那么就需要重复使用已经分配好的 3 个 <strong>arena</strong> 中的一个（<strong>main arena</strong>, <strong>arena1</strong> 或者 <strong>arena2</strong>）。那么该选择哪个 <strong>arena</strong> 进行重复利用呢？<code>glibc</code> 的 <code>malloc</code> 遵循以下规则：</p>
<ol>
<li>首先循环遍历所有可用的 <strong>arena</strong>，在遍历的过程中，它会尝试加锁该 <strong>arena</strong>。如果成功加锁（该 <strong>arena</strong> 当前对应的线程并未使用堆内存则表示可加锁），比如将 <strong>main arena</strong> 成功锁住，那么就将 <strong>main arena</strong> 返回给用户，即表示该 <strong>arena</strong> 被子线程 3 共享使用。</li>
<li>如果没能找到可用的 <strong>arena</strong>，那么就将子线程 3 的 <code>malloc</code> 操作阻塞，直到有可用的 <strong>arena</strong> 为止。</li>
<li>如果子线程 3 再次调用 <code>malloc</code> 的话（第二次使用arena），<code>glibc</code> 的 <code>malloc</code> 就会先尝试使用最近访问的 <strong>arena</strong>（此时为 <strong>main arena</strong>）。如果此时 <strong>main arena</strong> 可用的话，就直接使用，否则就将子线程 3 阻塞，直到 <strong>main arena</strong> 再次可用为止（为了防止开销过大问题）。</li>
</ol>
<h2 id="堆的数据结构">堆的数据结构</h2>
<p>在 <code>glibc</code> 的 <code>malloc</code> 中针对堆管理，主要涉及到以下 3 种数据结构</p>
<h3 id="heap-info">heap_info</h3>
<p>我们把从操作系统申请的一块内存称为一个 <strong>heap</strong>，这个 <strong>heap</strong> 的信息就是用 <code>heap_info</code> 表示，也称为 <strong>heap header</strong>，因为一个 <strong>thread arena</strong>（注意：不包含主线程）可以包含多个 <strong>heap</strong>，所以为了便于管理，就给每个 <strong>heap</strong> 用一个 <code>heap_info</code> 表示。</p>
<blockquote>
<p>此处的 <strong>heap</strong> 并非广义上的进程的虚拟内存空间中的堆，而是子线程通过系统调用 <code>mmap</code> 从操作系统申请的一块内存空间，后面 <strong>heap</strong> 不做声明，均是这个意思。同时我们把主线程的 <strong>main arena</strong> 的那个区域也成为 <strong>heap</strong>，这种称呼也是对的，二者功能相同，只不过位置不同，但是 <strong>main arena</strong> 中只包含一个可以自增长的 <strong>heap</strong>。</p>
</blockquote>
<p>那么在什么情况下一个 <strong>thread arena</strong> 会包含多个 <strong>heap</strong> 呢？在当前 <strong>heap</strong> 不够用的时候，<code>malloc</code> 会通过系统调用 <code>mmap</code> 申请新的 <strong>heap</strong>（这部分空间本来是位于内存映射区区域），新的 <strong>heap</strong> 会被添加到当前 <strong>thread arena</strong> 中，便于管理。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_heap_info</span></span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;                <span class="comment">/* arena for this heap. */</span> <span class="comment">/*这堆的竞技场。*/</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_heap_info</span> *prev;      <span class="comment">/* Previous heap. */</span> <span class="comment">/*以前的堆。*/</span></span><br><span class="line">  <span class="type">size_t</span> size;                  <span class="comment">/* Current size in bytes. */</span> <span class="comment">/*当前大小以字节为单位。*/</span></span><br><span class="line">  <span class="type">size_t</span> mprotect_size;         <span class="comment">/* Size in bytes that has been mprotected</span></span><br><span class="line"><span class="comment">                                   PROT_READ|PROT_WRITE.  */</span> <span class="comment">/*以mprotectated的字节的大小*/</span></span><br><span class="line">   <span class="comment">/* Make sure the following data is properly aligned, particularly</span></span><br><span class="line"><span class="comment">      that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</span></span><br><span class="line"><span class="comment">      MALLOC_ALIGNMENT. */</span> <span class="comment">/*确保以下数据正确对齐*/</span></span><br><span class="line">  <span class="type">char</span> pad[<span class="number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK];</span><br><span class="line">&#125; heap_info;</span><br></pre></td></tr></table></figure>
<h3 id="malloc-state">malloc_state</h3>
<p><code>malloc_state</code> 用于表示 <strong>arena</strong> 的信息，因此也被称为 <strong>arena header</strong>，每个线程只含有一个 <strong>arena header</strong>。<strong>arena header</strong> 包含 <strong>bin</strong>、<strong>top chunk</strong> 以及 <strong>last remainder chunk</strong> 等信息，这些概念会在后文详细介绍。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">malloc_state</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Serialize access.  */</span> <span class="comment">/*序列化访问。*/</span></span><br><span class="line">  <span class="type">mutex_t</span> mutex;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span> <span class="comment">/*标志（以前在max_fast）。*/</span></span><br><span class="line">  <span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span> <span class="comment">/*快速的bins*/</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span>  <span class="comment">/*最顶层块的基础 - 没有以其他方式保存在垃圾箱里*/</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span> <span class="comment">/*剩余的来自小型请求的最新分裂*/</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span> <span class="comment">/*如上所述包装正常箱*/</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span> <span class="comment">/*bins的位图*/</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span> <span class="comment">/*链接名单*/</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">malloc_state</span> *next;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  */</span> <span class="comment">/*免费竞技场的链表。*/</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">malloc_state</span> *next_free;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span> <span class="comment">/*在此竞技场中分配的内存。*/</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="malloc-chunk">malloc_chunk</h3>
<p>为了便于管理和更加高效的利用内存，一个 <strong>heap</strong> 被分为多个 <strong>chunk</strong>，每个 <strong>chunk</strong> 的大小不是固定，是根据用户的请求决定的，也就是说用户调用 <code>malloc(size_t size)</code> 传递的 <code>size</code> 参数就是 <strong>chunk</strong> 的大小（这种表示并不准确，但是为了方便理解就暂时这么描述了，详细说明见后文）。每个 <strong>chunk</strong> 都由一个结构体 <code>malloc_chunk</code> 表示，也成为 <strong>chunk header</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">malloc_chunk</span> &#123;</span><br><span class="line">  <span class="comment">/* #define INTERNAL_SIZE_T size_t */</span></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span> <span class="comment">/*之前块的大小*/</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span> <span class="comment">/*大小以字节为单位，包括开销*/</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">malloc_chunk</span>* fd;         <span class="comment">/* double links -- used only if free. 这两个指针只在free chunk中存在*/</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">malloc_chunk</span>* bk;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="comment">/*仅用于大块：指向下一个更大的尺寸*/</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">malloc_chunk</span>* fd_nextsize; <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">malloc_chunk</span>* bk_nextsize;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>关于上述的三种结构，基本都是针对子线程的，主线程和子线程有一些不同：</p>
<ol>
<li>主线程的堆不是分配在内存映射区，而是进程的虚拟内存堆区，因此不含有多个 <strong>heap</strong> 所以也就不含有 <code>heap_info</code> 结构体。当需要更多堆空间的时候，直接通过增长 <code>brk</code> 指针来获取更多的空间，直到它碰到内存映射区域为止。</li>
<li>不同于 <strong>thread arena</strong>，主线程的 <strong>main arena</strong> 的 <strong>arena header</strong> 并不在堆区中，而是一个全局变量，因此它属于 <code>libc.so</code> 的 data segment 区域。</li>
<li><strong>heap</strong>的结构体<code>heap_info</code>，<strong>arena</strong>的结构体<code>malloc_state</code>，<strong>chunk</strong>的结构体<code>malloc_chunk</code></li>
</ol>
<h2 id="heap-与-arena-的关系">heap 与 arena 的关系</h2>
<p>首先，通过内存分布图理清 <code>malloc_state</code> 与 <code>heap_info</code> 之间的组织关系。</p>
<blockquote>
<p>下图是<strong>main arena</strong> 和 <strong>thread arena</strong>（只有一个heap的时候） 的内存分布图：</p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/HeapOverflow/8.png" alt="single heap"></p>
<p>关于Main Arena的几个点：</p>
<ul>
<li>Main Arena中的malloc_state结构是不在Heap中的，并且是存在于libc.so的data段的</li>
<li>Main Arena是没有heap_info结构的（因为只有一个Heap）</li>
<li>malloc_state结构中的top成员是指向malloc_chunk结构和Allocated Chunk中间的</li>
<li>Top Chunk、Allocated Chunk、Free Chunk其中的任何一个和malloc_chunk结构进行组合才是一个完整的chunk块</li>
</ul>
<p>关于Thread Arena（单Heap）的几个点：</p>
<ul>
<li>Thread Arena中的malloc_state是分配在Heap中的</li>
<li>heap_info结构中的ar_ptr成员是指向malloc_state结构中的开头，而malloc_state结构中的top成员是指向malloc_chunk和Allocated Chunk中间的（这个是和Main Arena一样的）</li>
</ul>
<blockquote>
<p>下图是一个 <strong>thread arena</strong> 中含有多个 <strong>heap</strong> 的情况：</p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/HeapOverflow/9.png" alt="multi-heap"></p>
<p>由于两个 <strong>heap</strong> 是通过 <code>mmap</code> 从操作系统申请的内存，两者在内存布局上并不相邻而是分属于不同的内存区间，所以为了便于管理，<code>glibc</code> 的 <code>malloc</code> 将第二个 <code>heap_info</code> 结构体的 <code>prev</code> 成员指向了第一个 <code>heap_info</code> 结构体的起始位置（即 <code>ar_ptr</code> 成员），而第一个 <code>heap_info</code> 结构体的 <code>ar_ptr</code> 成员指向了 <code>malloc_state</code>，这样就构成了一个单链表，方便后续管理。</p>
<h2 id="bin">bin</h2>
<h3 id="介绍">介绍</h3>
<p>用户释放掉的 <strong>chunk</strong> 不会马上归还给系统，<strong>ptmalloc</strong> 会统一管理 <strong>heap</strong> 和 <strong>mmap</strong> 映射区域中的空闲的 <strong>chunk</strong>。当用户再一次请求分配内存时，<strong>ptmalloc</strong> 分配器会试图在空闲的 <strong>chunk</strong> 中挑选一块合适的给用户。这样可以避免频繁的系统调用，降低内存分配的开销。</p>
<p>在具体的实现中，<strong>ptmalloc</strong> 采用分箱式方法对空闲的 <strong>chunk</strong> 进行管理。首先，它会根据空闲的 <strong>chunk</strong> 的大小以及使用状态将 <strong>chunk</strong> 初步分为 4 类：<strong>fast bins</strong>，<strong>small bins</strong>，<strong>large bins</strong>，<strong>unsorted bin</strong>。每类中仍然有更细的划分，相似大小的<strong>chunk</strong> 会用双向链表链接起来。也就是说，在每类<strong>bin</strong> 的内部仍然会有多个互不相关的链表来保存不同大小的 <strong>chunk</strong>。</p>
<p>对于 <strong>small bins</strong>，<strong>large bins</strong>，<strong>unsorted bin</strong> 来说，<code>ptmalloc</code> 将它们维护在同一个数组中。这些 <strong>bin</strong> 对应的数据结构在<code>malloc_state</code> 中，如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NBINS 128</span></span><br><span class="line"><span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">mchunkptr bins[ NBINS * <span class="number">2</span> - <span class="number">2</span> ];</span><br></pre></td></tr></table></figure>
<p><strong>bin</strong> 作为一种记录 <strong>free chunk</strong> 的链表数据结构。系统针对不同大小的 <strong>free chunk</strong> ，将 <strong>bin</strong> 分为了 4 类：</p>
<ul>
<li>fast bin（总共有10个）</li>
<li>unsorted bin（只有一个）</li>
<li>small bin（总共有 62 个）</li>
<li>large bin（总共有63个）</li>
</ul>
<p>同时，在 <code>glibc</code> 中用于记录 <strong>bin</strong> 的数据结构有两种，分别为：</p>
<ul>
<li><code>fastbinsY</code>: 这是一个数组，用于记录所有的 <strong>fast bin</strong></li>
<li><code>bins</code> 数组: 这也是一个数组，用于记录除 <strong>fast bin</strong> 之外的所有 <strong>bin</strong> 。事实上这个数组共有 126 个<strong>bin</strong>，分别是：
<ul>
<li>bin [1] : <strong>unsorted bin</strong></li>
<li>bin [2~63] : <strong>small bin</strong></li>
<li>bin [64~126] : <strong>large bin</strong></li>
</ul>
</li>
</ul>
<h3 id="fast-bin">fast bin</h3>
<p>对于size较小的<strong>chunk</strong>，释放之后单独处理，被放入<strong>fast bin</strong>中。</p>
<ul>
<li>32位系统，<strong>fast bin</strong>中的<strong>chunk</strong>大小范围在16字节到64字节；</li>
<li>64位系统，<strong>fast bin</strong>中的<strong>chunk</strong>大小范围在32字节到128字节。</li>
</ul>
<p>下图是32位系统分布图：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/HeapOverflow/12.png" alt="fast bin"></p>
<p>下图为64位系统的：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/HeapOverflow/14.png" alt="img"></p>
<p>在内存分配和释放过程中，<strong>fast bin</strong> 是所有 <strong>bin</strong> 中操作速度最快的。下面详细介绍 <strong>fast bin</strong> 的一些特性：</p>
<ol>
<li><strong>fast bin</strong> 的个数为10个，并且为了速度，<strong>fast bin</strong>永远不会进行合并，里面<strong>chunk</strong>中的P标志位永远为1</li>
<li>这类<strong>bin</strong>通常申请和释放的堆块都比较小，所以使用单链表结构，LIFO（后进先出）分配策略。</li>
<li>在<strong>fastbinsY</strong>数组里按照从小到大的顺序排列。</li>
</ol>
<h3 id="unsorted-bin">unsorted bin</h3>
<p><strong>unsorted bin</strong> 可以视为空闲 <strong>chunk</strong> 回归其所属 <strong>bin</strong> 之前的缓冲区。</p>
<p>其在 <code>glibc</code> 中具体的说明如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Unsorted chunks</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    All remainders from chunk splits, as well as all returned chunks,</span></span><br><span class="line"><span class="comment">    are first placed in the &quot;unsorted&quot; bin. They are then placed</span></span><br><span class="line"><span class="comment">    in regular bins after malloc gives them ONE chance to be used before</span></span><br><span class="line"><span class="comment">    binning. So, basically, the unsorted_chunks list acts as a queue,</span></span><br><span class="line"><span class="comment">    with chunks being placed on it in free (and malloc_consolidate),</span></span><br><span class="line"><span class="comment">    and taken off (to be either used or placed in bins) in malloc.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The NON_MAIN_ARENA flag is never set for unsorted chunks, so it</span></span><br><span class="line"><span class="comment">    does not have to be taken into account in size comparisons.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>从下面的宏我们可以看出</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The otherwise unindexable 1-bin is used to hold unsorted chunks. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unsorted_chunks(M) (bin_at(M, 1))</span></span><br></pre></td></tr></table></figure>
<p><strong>unsorted bin</strong> 处于我们之前所说的 <strong>bin</strong> 数组下标 1 处。故而 <strong>unsorted bin</strong> 只有一个链表。unsorted bin 中的空闲 <strong>chunk</strong> 处于乱序状态，主要有两个来源</p>
<ul>
<li>当一个较大的 <strong>chunk</strong> 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中。</li>
<li>释放一个不属于 <strong>fast bin</strong> 的 <strong>chunk</strong>，并且该 <strong>chunk</strong> 不和 <strong>top chunk</strong> 紧邻时，该 <strong>chunk</strong> 会被首先放到 <strong>unsorted bin</strong> 中可以加快分配速度。使用双链表结构，FIFO（先进先出）分配策略。</li>
</ul>
<p>以64位为例，<strong>unsorted bin</strong>结构如下（非连续内存，大小无限制）：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/HeapOverflow/15.png" alt="img"></p>
<h3 id="small-bin">small bin</h3>
<p>同一个<strong>small bin</strong>里chunk的大小相同，采用双链表结构，使用频率介于<strong>fast bin</strong>和<strong>large bin</strong>之间。每个链表都有链表头结点，这样可以方便对于链表内部结点的管理。此外，<strong>small bins</strong> 中每个 <strong>bin</strong> 对应的链表采用 FIFO（先进先出） 的规则，所以同一个链表中先被释放的 <strong>chunk</strong> 会先被分配出去。<strong>small bin</strong>在<strong>bins</strong>中居第2到第63位，共62个。<strong>small bins</strong> 中每个 <strong>chunk</strong> 的大小与其所在的 <strong>bin</strong> 的 <strong>index</strong> 的关系为：<code>chunk_size = 2 * SIZE_SZ * index</code>，具体如下</p>
<table>
<thead>
<tr>
<th style="text-align:left">下标</th>
<th style="text-align:left">SIZE_SZ=4（32 位）</th>
<th style="text-align:left">SIZE_SZ=8（64 位）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">16</td>
<td style="text-align:left">32</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">24</td>
<td style="text-align:left">48</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">32</td>
<td style="text-align:left">64</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">40</td>
<td style="text-align:left">80</td>
</tr>
<tr>
<td style="text-align:left">x</td>
<td style="text-align:left">2*4*x</td>
<td style="text-align:left">2*8*x</td>
</tr>
<tr>
<td style="text-align:left">63</td>
<td style="text-align:left">504</td>
<td style="text-align:left">1008</td>
</tr>
</tbody>
</table>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/HeapOverflow/16.png" alt="img"></p>
<h3 id="large-bin">large bin</h3>
<p><strong>large bins</strong> 中一共包括 63 个 <strong>bin</strong>，每个 <strong>bin</strong> 中的 <strong>chunk</strong> 的大小不一致，而是处于一定区间范围内。此外，这 63 个 <strong>bin</strong> 被分成了 6 组，每组 <strong>bin</strong> 中的 <strong>chunk</strong> 大小之间的公差一致，具体如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">组</th>
<th style="text-align:left">数量</th>
<th style="text-align:left">公差</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">32</td>
<td style="text-align:left">64</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">16</td>
<td style="text-align:left">512</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">8</td>
<td style="text-align:left">4096</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">4</td>
<td style="text-align:left">32768</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">2</td>
<td style="text-align:left">262144</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">1</td>
<td style="text-align:left">不限制</td>
</tr>
</tbody>
</table>
<p>这里我们以 32 位平台的 <strong>large bin</strong> 为例，第一个 <strong>large bin</strong> 的起始 <strong>chunk</strong> 大小为 512 字节，第二个<strong>large bin</strong>的<strong>chunk</strong>最小为512+64字节（处于<code>[512,512+64)</code>之间的<strong>chunk</strong>都属于第一个<strong>large bin</strong>），以此类推，直到第一组结束。64位平台也是一样的，第一个<strong>large bin</strong>的<strong>chunk</strong>最小为1024字节，第二个<strong>large bin</strong>的<strong>chunk</strong>最小为1024+64字节（处于<code>[1024,1024+64)</code>之间的<strong>chunk</strong>都属于第一个large bin）</p>
<p>下面附上各类上述三类 <strong>bin</strong> 的逻辑：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/HeapOverflow/13.jpg" alt="img"></p>
<h2 id="chunk">chunk</h2>
<h3 id="介绍">介绍</h3>
<p>在 <code>glibc</code> 的 <code>malloc</code> 中将整个堆内存空间分成了连续的、大小不一的 <strong>chunk</strong>，即对于堆内存管理而言 <strong>chunk</strong> 就是最小操作单位。<strong>chunk</strong> 总共分为4类：</p>
<ul>
<li>allocated chunk</li>
<li>free chunk</li>
<li>top chunk</li>
<li>last remainder chunk</li>
</ul>
<p>所有类型的 <strong>chunk</strong> 都是内存中一块连续的区域，只是通过该区域中特定位置的某些标识符加以区分。</p>
<h3 id="allocated-chunk">allocated chunk</h3>
<p>顾名思义就是已经被分配使用的 <strong>chunk</strong> ，区域内容表示如下：</p>
<ul>
<li><code>prev_size</code>:
<ul>
<li>如果前一个 <strong>chunk</strong> 是 <strong>free chunk</strong>，则这个内容保存的是前一个 <strong>chunk</strong> 的大小。并且这个字段是归属于当前的chunk的</li>
<li>如果前一个 <strong>chunk</strong> 是 <strong>allocated chunk</strong>，则这个区域保存的是前一个 <strong>chunk</strong> 的用户数据（也有可能为填充值）。并且这个字段就不属于当前的chunk了</li>
</ul>
</li>
<li><code>size</code>: 保存的是当前这个chunk的大小。总共是 32 位，并且最后的 3 位作为标志位：
<ul>
<li><code>PREV_INUSE (P)</code>: 表示前一个 <strong>chunk</strong> 是否为 <strong>allocated chunk</strong>，而当前是不是 <strong>chunk allocated</strong> 可以通过查询下一个 <strong>chunk</strong> 的这个标志位来得知）</li>
<li><code>IS_MMAPPED (M)</code>: 表示当前 <strong>chunk</strong> 是否是通过 <code>mmap</code> 系统调用产生的，子线程是 <code>mmap</code>，主线程则是通过 <code>brk</code>。</li>
<li><code>NON_MAIN_arena (N)</code>: 表示当前 <strong>chunk</strong> 是否属于 <strong>main arena</strong>，也就是主线程的 <strong>arena</strong>。（主线程和子线程的堆区不一样，前文已经做了详细说明）。</li>
</ul>
</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/HeapOverflow/10.png" alt="allocated chunk"></p>
<p>几个注意点：</p>
<ol>
<li>每个 <strong>chunk</strong> 的大小怎么确定？<br>
用户程序调用 <code>malloc(size_t size)</code> 就会创建一个<strong>chunk</strong>，传入的大小就是当前分配的 <strong>chunk</strong> 大小，这个是非常重要的。</li>
<li>我们为什么要知道前一个 <strong>chunk</strong> 的信息？<br>
为了方便合并不同的 <strong>chunk</strong> ，减少内存的碎片化。如果不这么做， <strong>chunk</strong> 的合并只能向下合并，必须从头遍历整个堆，然后加以合并，这就意味着每次进行 <strong>chunk</strong> 释放操作消耗的时间与堆的大小成线性关系。</li>
<li><strong>chunk</strong> 的链表是如何构成的？<br>
<strong>chunk</strong> 在堆内存上是连续的，并不是直接由指针构成的链表，而是通过 <code>prev_size</code> 和 <code>size</code> 块构成了隐式的链表。在进行分配操作的时候，堆内存管理器可以通过遍历整个堆内存的 <strong>chunk</strong> ，分析每个 <strong>chunk</strong> 的 <code>size</code> 字段，进而找到合适的 <strong>chunk</strong>。</li>
</ol>
<h3 id="free-chunk">free chunk</h3>
<ul>
<li><code>prev_size</code>: 为了防止碎片化，堆中不存在两个相邻的 <strong>free chunk</strong> （如果存在，则被堆管理器合并了）。因此对于一个 <strong>free chunk</strong> ，这个 <code>prev_size</code> 区域中一定包含的上一个 <strong>chunk</strong> 的部分有效数据或者为了地址对齐所做的填充对齐。</li>
<li><code>size</code>: 同 <strong>allocated chunk</strong> ，表示当前 <strong>chunk</strong> 的大小，其标志位<code>N</code>，<code>M</code>，<code>P</code> 也同 <strong>allocated chunk</strong> 一样。</li>
<li><code>fd</code>: 前向指针——指向当前 <strong>chunk</strong> 在同一个 <strong>bin</strong>（一种用于加快内存分配和释放效率的显示链表）的下一个（线性中的前一个） <strong>chunk</strong></li>
<li><code>bk</code>: 后向指针——指向当前 <strong>chunk</strong> 在同一个 <strong>bin</strong> 的上一个（线性中的后一个） <strong>chunk</strong></li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/HeapOverflow/11.png" alt="free chunk"></p>
<h3 id="top-chunk">top chunk</h3>
<p>当一个 <strong>chunk</strong> 处于一个<strong>arena</strong>的最顶部（即最高内存地址处）的时候，就称之为 <strong>top chunk</strong>。该 <strong>chunk</strong> 并不属于任何 <strong>bin</strong> ，而是在当前的 <strong>heap</strong> 所有的 <strong>free chunk</strong> （无论那种 <strong>bin</strong>）都无法满足用户请求的内存大小的时候，将此 <strong>chunk</strong> 当做一个应急消防员，分配给用户使用。如果 <strong>top chunk</strong> 的大小比用户请求的大小要大的话，就将该 <strong>top chunk</strong> 分作两部分：用户请求的 <strong>chunk</strong> 和剩余的部分（成为新的 <strong>top chunk</strong>）。否则，就需要扩展 <strong>heap</strong> 或分配新的 <strong>heap</strong> 了，在 <strong>main arena</strong> 中通过 <code>sbrk</code> 扩展 <strong>heap</strong>，而在<strong>thread arena</strong> 中通过 <code>mmap</code> 分配新的 <strong>heap</strong>。注意，至此我们已经多次强调，主线程和子线程的堆管理方式的差异。</p>
<h3 id="last-remainder-chunk">last remainder chunk</h3>
<p>它是如何产生的：当用户请求的是一个 <strong>small chunk</strong>，且该请求无法被 <strong>small bin</strong>、<strong>unsorted bin</strong> 满足的时候，就通过 <code>binmaps</code> 遍历 <strong>bin</strong> 查找最合适的 <strong>chunk</strong> ，如果该 <strong>chunk</strong> 有剩余部分的话，就将该剩余部分变成一个新的 <strong>chunk</strong> 加入到 <strong>unsorted bin</strong> 中，另外，再将该新的 <strong>chunk</strong> 变成新的 <strong>last remainder chunk</strong> 。</p>
<p>它的作用是：此类型的 <strong>chunk</strong> 用于提高连续 <code>malloc</code>（产生大量 <strong>small chunk</strong>）的效率，主要是提高内存分配的局部性。那么具体是怎么提高局部性的呢？举例说明。当用户请求一个 <strong>small chunk</strong> ，且该请求无法被 <strong>small bin</strong> 满足，那么就转而交由 <strong>unsorted bin</strong> 处理。同时，假设当前 <strong>unsorted bin</strong> 中只有一个 <strong>chunk</strong> 的话，也就是 <strong>last remainder chunk</strong> ，那么就将该 <strong>chunk</strong> 分成两部分：前者分配给用户，剩下的部分放到 <strong>unsorted bin</strong> 中，并成为新的 <strong>last remainder chunk</strong> 。这样就保证了连续 <code>malloc</code> 产生的各个 <strong>small chunk</strong> 在内存分布中是相邻的，即提高了内存分配的局部性。</p>
<h2 id="glibc内存管理流程图">Glibc内存管理流程图</h2>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/HeapOverflow/17.png" alt="img"></p>
<h2 id="参考文章">参考文章</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://introspelliam.github.io/2017/09/10/Linux%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89/</span><br><span class="line">https://murphypei.github.io/blog/2019/01/linux-heap</span><br><span class="line">https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/comment-page-1/</span><br><span class="line">http://abcdxyzk.github.io/blog/2015/08/05/kernel-mm-malloc/</span><br><span class="line">https://www.cnblogs.com/unr4v31/p/14446412.html</span><br><span class="line">https://ctf-wiki.org/pwn/linux/glibc-heap/heap_structure/#fast-bin</span><br><span class="line">https://www.bilibili.com/video/BV1N441147K2?p=18</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://www.ascotbe.com">ascotbe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.ascotbe.com/2021/05/04/HeapOverflow_Linux_0x01/">https://www.ascotbe.com/2021/05/04/HeapOverflow_Linux_0x01/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.ascotbe.com" target="_blank">ascotbe</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%A0%86/">堆</a><a class="post-meta__tags" href="/tags/%E6%BA%A2%E5%87%BA/">溢出</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/123.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/05/18/SampleAnalysis/0b2a794bac4bf650b6ba537137504162520b67266449be979679afbb14e8e5c0/"><img class="prev-cover" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/126.jpg" onerror="onerror=null;src='/img/404.gif'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">蔓灵花APT组织针对巴基斯坦定向攻击的样本分析</div></div></a></div><div class="next-post pull-right"><a href="/2021/03/26/StackOverflow_Linux_0x03/"><img class="next-cover" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/122.jpg" onerror="onerror=null;src='/img/404.gif'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Linux栈溢出总结（0x03）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/1021/07/31/HeapOverflow_Linux_0x02/" title="Linux堆溢出总结（0x02）"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/125.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 1021-07-31</div><div class="title">Linux堆溢出总结（0x02）</div></div></a></div><div><a href="/2018/12/05/HardwareRelatedKnowledge/" title="硬件相关知识"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/39.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2018-12-05</div><div class="title">硬件相关知识</div></div></a></div><div><a href="/2022/02/22/StackOverflow_Linux_0x00/" title="Linux栈溢出总结（0x00）"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/139.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-22</div><div class="title">Linux栈溢出总结（0x00）</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="utterances-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "/img/loading.gif" data-lazy-src="/img/avatar.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ascotbe</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">102</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">78</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">28</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ascotbe"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:ascotbe@gmail.com" target="_blank" title=""><i class="fa fa-envelope"></i></a><a class="social-icon" href="https://steamcommunity.com/id/ascotbe" target="_blank" title=""><i class="iconfont icon-steam"></i></a><a class="social-icon" href="https://twitter.com/asc0t6e" target="_blank" title=""><i class="iconfont icon-twitter"></i></a><a class="social-icon" href="https://t.me/ascotbe" target="_blank" title=""><i class="iconfont icon-telegram"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title=""><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">所有文章都是本人学习笔记仅限交流探讨，禁止利用文章思路进行违法操作，否则与作者无关，如果您不同意请关闭本站<img src= "/img/loading.gif" data-lazy-src="/img/announcement2.gif" style="zoom:25%;" ></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">堆内存管理机制介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%AE%9E%E9%AA%8C"><span class="toc-number">2.</span> <span class="toc-text">堆内存分配实验</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E7%BA%BF%E7%A8%8B-malloc-%E4%B9%8B%E5%89%8D"><span class="toc-number">2.1.</span> <span class="toc-text">主线程 malloc 之前</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E7%BA%BF%E7%A8%8B-malloc-%E4%B9%8B%E5%90%8E"><span class="toc-number">2.2.</span> <span class="toc-text">主线程 malloc 之后</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E7%BA%BF%E7%A8%8B-free-%E4%B9%8B%E5%90%8E"><span class="toc-number">2.3.</span> <span class="toc-text">主线程 free 之后</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E7%BA%BF%E7%A8%8B-malloc-%E4%B9%8B%E5%89%8D"><span class="toc-number">2.4.</span> <span class="toc-text">子线程 malloc 之前</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E7%BA%BF%E7%A8%8B-malloc-%E4%B9%8B%E5%90%8E"><span class="toc-number">2.5.</span> <span class="toc-text">子线程 malloc 之后</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E7%BA%BF%E7%A8%8B-free-%E4%B9%8B%E5%90%8E"><span class="toc-number">2.6.</span> <span class="toc-text">子线程 free 之后</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#brk%E5%92%8Cmmap%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.</span> <span class="toc-text">brk和mmap的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#arena"><span class="toc-number">4.</span> <span class="toc-text">arena</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">4.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#arena-%E6%95%B0%E9%87%8F"><span class="toc-number">4.2.</span> <span class="toc-text">arena 数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#arena-%E7%AE%A1%E7%90%86"><span class="toc-number">4.3.</span> <span class="toc-text">arena 管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">5.</span> <span class="toc-text">堆的数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#heap-info"><span class="toc-number">5.1.</span> <span class="toc-text">heap_info</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#malloc-state"><span class="toc-number">5.2.</span> <span class="toc-text">malloc_state</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#malloc-chunk"><span class="toc-number">5.3.</span> <span class="toc-text">malloc_chunk</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#heap-%E4%B8%8E-arena-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">6.</span> <span class="toc-text">heap 与 arena 的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bin"><span class="toc-number">7.</span> <span class="toc-text">bin</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">7.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fast-bin"><span class="toc-number">7.2.</span> <span class="toc-text">fast bin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unsorted-bin"><span class="toc-number">7.3.</span> <span class="toc-text">unsorted bin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#small-bin"><span class="toc-number">7.4.</span> <span class="toc-text">small bin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#large-bin"><span class="toc-number">7.5.</span> <span class="toc-text">large bin</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chunk"><span class="toc-number">8.</span> <span class="toc-text">chunk</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">8.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#allocated-chunk"><span class="toc-number">8.2.</span> <span class="toc-text">allocated chunk</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#free-chunk"><span class="toc-number">8.3.</span> <span class="toc-text">free chunk</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#top-chunk"><span class="toc-number">8.4.</span> <span class="toc-text">top chunk</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#last-remainder-chunk"><span class="toc-number">8.5.</span> <span class="toc-text">last remainder chunk</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#glibc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">9.</span> <span class="toc-text">Glibc内存管理流程图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="toc-number">10.</span> <span class="toc-text">参考文章</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/05/10/LinearRegression/" title="线性回归实现"><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/189.png" onerror="this.onerror=null;this.src='/img/404.gif'" alt="线性回归实现"/></a><div class="content"><a class="title" href="/2024/05/10/LinearRegression/" title="线性回归实现">线性回归实现</a><time datetime="2024-05-10T15:58:53.000Z" title="发表于 2024-05-10 23:58:53">2024-05-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/06/HowToUnderstandGradientDescent/" title="如何理解梯度下降法？"><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/187.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="如何理解梯度下降法？"/></a><div class="content"><a class="title" href="/2024/05/06/HowToUnderstandGradientDescent/" title="如何理解梯度下降法？">如何理解梯度下降法？</a><time datetime="2024-05-06T15:58:53.000Z" title="发表于 2024-05-06 23:58:53">2024-05-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/04/HowToUnderstandTheLeastSquaresMethod/" title="如何理解最小二乘法？"><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/188.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="如何理解最小二乘法？"/></a><div class="content"><a class="title" href="/2024/05/04/HowToUnderstandTheLeastSquaresMethod/" title="如何理解最小二乘法？">如何理解最小二乘法？</a><time datetime="2024-05-04T15:58:53.000Z" title="发表于 2024-05-04 23:58:53">2024-05-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/01/HowToUnderstandLinearRegression/" title="如何理解线性回归？"><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/186.png" onerror="this.onerror=null;this.src='/img/404.gif'" alt="如何理解线性回归？"/></a><div class="content"><a class="title" href="/2024/05/01/HowToUnderstandLinearRegression/" title="如何理解线性回归？">如何理解线性回归？</a><time datetime="2024-05-01T15:58:53.000Z" title="发表于 2024-05-01 23:58:53">2024-05-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/22/PortableExecutableFileMemoryLoading/" title="PE文件内存加载"><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/185.png" onerror="this.onerror=null;this.src='/img/404.gif'" alt="PE文件内存加载"/></a><div class="content"><a class="title" href="/2024/04/22/PortableExecutableFileMemoryLoading/" title="PE文件内存加载">PE文件内存加载</a><time datetime="2024-04-22T15:58:53.000Z" title="发表于 2024-04-22 23:58:53">2024-04-22</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://raw.githubusercontent.com/Ascotbe/Image/master/Blog/123.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 <i id="heartbeat" class="fa fas fa-heartbeat"></i> By ascotbe</div><div class="footer_custom_text">Hi, welcome to my <a href="https://www.ascotbe.com/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>function loadUtterances () {
  let ele = document.createElement('script')
  ele.setAttribute('id', 'utterances_comment')
  ele.setAttribute('src', 'https://utteranc.es/client.js')
  ele.setAttribute('repo', 'Ascotbe/Ascotbe.github.io')
  ele.setAttribute('issue-term', 'pathname')
  let nowTheme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'photon-dark' : 'github-light'
  ele.setAttribute('theme', nowTheme)
  ele.setAttribute('crossorigin', 'anonymous')
  ele.setAttribute('async', 'true')
  document.getElementById('utterances-wrap').insertAdjacentElement('afterbegin',ele)
}

function utterancesTheme () {
  const iframe = document.querySelector('.utterances-frame')
  if (iframe) {
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'photon-dark' : 'github-light'
    const message = {
      type: 'set-theme',
      theme: theme
    };
    iframe.contentWindow.postMessage(message, 'https://utteranc.es');
  }
}

if ('Utterances' === 'Utterances' || !true) {
  if (true) btf.loadComment(document.getElementById('utterances-wrap'), loadUtterances)
  else loadUtterances()
} else {
  function loadOtherComment () {
    loadUtterances()
  }
}</script></div><script src="/js/snowflake.js"></script><div class="aplayer no-destroy" data-id="2276118625" data-server="netease" data-type="playlist" data-fixed="true"  data-mini="playlist" data-autoplay="true"> </div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["link[rel=\"canonical\"]","meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":true,"model":{"jsonPath":"/live2dw/assets/ots14_3001.model.json"},"display":{"position":"right","width":350,"height":400,"hOffset":-50,"vOffset":0},"mobile":{"show":false},"log":false});</script></body></html>